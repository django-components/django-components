{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Django Components","text":"<p><code>django-components</code> combines Django's templating system with the modularity seen in modern frontend frameworks like Vue or React.</p> <p>With <code>django-components</code> you can support Django projects small and large without leaving the Django ecosystem.</p>"},{"location":"#sponsors","title":"Sponsors","text":""},{"location":"#quickstart","title":"Quickstart","text":"<p>A component in django-components can be as simple as a Django template and Python code to declare the component:</p> components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n</code></pre> <p>Or a combination of Django template, Python, CSS, and Javascript:</p> components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> components/calendar/calendar.css<pre><code>.calendar {\n  width: 200px;\n  background: pink;\n}\n</code></pre> components/calendar/calendar.js<pre><code>document.querySelector(\".calendar\").onclick = () =&gt; {\n  alert(\"Clicked calendar!\");\n};\n</code></pre> components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"date\": kwargs[\"date\"]}\n</code></pre> <p>Use the component like this:</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}{% endcomponent %}\n</code></pre> <p>And this is what gets rendered:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n  Today's date is &lt;span&gt;2024-11-06&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>Read on to learn about all the exciting details and configuration possibilities!</p> <p>(If you instead prefer to jump right into the code, check out the example project)</p>"},{"location":"#features","title":"Features","text":""},{"location":"#modern-and-modular-ui","title":"Modern and modular UI","text":"<ul> <li>Create self-contained, reusable UI elements.</li> <li>Each component can include its own HTML, CSS, and JS, or additional third-party JS and CSS.</li> <li>HTML, CSS, and JS can be defined on the component class, or loaded from files.</li> </ul> <pre><code>from django_components import Component\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar\"&gt;\n            Today's date is\n            &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n        .calendar {\n            width: 200px;\n            background: pink;\n        }\n    \"\"\"\n\n    js = \"\"\"\n        document.querySelector(\".calendar\")\n            .addEventListener(\"click\", () =&gt; {\n                alert(\"Clicked calendar!\");\n            });\n    \"\"\"\n\n    # Additional JS and CSS\n    class Media:\n        js = [\"https://cdn.jsdelivr.net/npm/htmx.org@2/dist/htmx.min.js\"]\n        css = [\"bootstrap/dist/css/bootstrap.min.css\"]\n\n    # Variables available in the template\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"]\n        }\n</code></pre>"},{"location":"#composition-with-slots","title":"Composition with slots","text":"<ul> <li>Render components inside templates with   <code>{% component %}</code> tag.</li> <li>Compose them with <code>{% slot %}</code>   and <code>{% fill %}</code> tags.</li> <li>Vue-like slot system, including scoped slots.</li> </ul> <pre><code>{% component \"Layout\"\n    bookmarks=bookmarks\n    breadcrumbs=breadcrumbs\n%}\n    {% fill \"header\" %}\n        &lt;div class=\"flex justify-between gap-x-12\"&gt;\n            &lt;div class=\"prose\"&gt;\n                &lt;h3&gt;{{ project.name }}&lt;/h3&gt;\n            &lt;/div&gt;\n            &lt;div class=\"font-semibold text-gray-500\"&gt;\n                {{ project.start_date }} - {{ project.end_date }}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    {% endfill %}\n\n    {# Access data passed to `{% slot %}` with `data` #}\n    {% fill \"tabs\" data=\"tabs_data\" %}\n        {% component \"TabItem\" header=\"Project Info\" %}\n            {% component \"ProjectInfo\"\n                project=project\n                project_tags=project_tags\n                attrs:class=\"py-5\"\n                attrs:width=tabs_data.width\n            / %}\n        {% endcomponent %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"#extended-template-tags","title":"Extended template tags","text":"<p><code>django-components</code> is designed for flexibility, making working with templates a breeze.</p> <p>It extends Django's template tags syntax with:</p> <ul> <li>Literal lists and dictionaries in the template</li> <li>Self-closing tags <code>{% mytag / %}</code></li> <li>Multi-line template tags</li> <li>Spread operator <code>...</code> to dynamically pass args or kwargs into the template tag</li> <li>Template tags inside literal strings like <code>\"{{ first_name }} {{ last_name }}\"</code></li> <li>Pass dictonaries by their key-value pairs <code>attr:key=val</code></li> </ul> <pre><code>{% component \"table\"\n    ...default_attrs\n    title=\"Friend list for {{ user.name }}\"\n    headers=[\"Name\", \"Age\", \"Email\"]\n    data=[\n        {\n            \"name\": \"John\"|upper,\n            \"age\": 30|add:1,\n            \"email\": \"john@example.com\",\n            \"hobbies\": [\"reading\"],\n        },\n        {\n            \"name\": \"Jane\"|upper,\n            \"age\": 25|add:1,\n            \"email\": \"jane@example.com\",\n            \"hobbies\": [\"reading\", \"coding\"],\n        },\n    ],\n    attrs:class=\"py-4 ma-2 border-2 border-gray-300 rounded-md\"\n/ %}\n</code></pre> <p>You too can define template tags with these features by using <code>@template_tag()</code> or <code>BaseNode</code>.</p> <p>Read more on Custom template tags.</p>"},{"location":"#full-programmatic-access","title":"Full programmatic access","text":"<p>When you render a component, you can access everything about the component:</p> <ul> <li>Component input: args, kwargs, slots and context</li> <li>Component's template, CSS and JS</li> <li>Django's context processors</li> <li>Unique render ID</li> </ul> <pre><code>class Table(Component):\n    js_file = \"table.js\"\n    css_file = \"table.css\"\n\n    template = \"\"\"\n        &lt;div class=\"table\"&gt;\n            &lt;span&gt;{{ variable }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's ID\n        assert self.id == \"djc1A2b3c\"\n\n        # Access component's inputs and slots\n        assert self.args == [123, \"str\"]\n        assert self.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.slots[\"footer\"]\n        some_var = self.context[\"some_var\"]\n\n        # Access the request object and Django's context processors, if available\n        assert self.request.GET == {\"query\": \"something\"}\n        assert self.context_processors_data['user'].username == \"admin\"\n\n        return {\n            \"variable\": kwargs[\"variable\"],\n        }\n\n# Access component's HTML / JS / CSS\nTable.template\nTable.js\nTable.css\n\n# Render the component\nrendered = Table.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"footer\": \"MY_FOOTER\"},\n)\n</code></pre>"},{"location":"#granular-html-attributes","title":"Granular HTML attributes","text":"<p>Use the <code>{% html_attrs %}</code> template tag to render HTML attributes.</p> <p>It supports:</p> <ul> <li>Defining attributes as whole dictionaries or keyword arguments</li> <li>Merging attributes from multiple sources</li> <li>Boolean attributes</li> <li>Appending attributes</li> <li>Removing attributes</li> <li>Defining default attributes</li> </ul> <pre><code>&lt;div\n    {% html_attrs\n        attrs\n        defaults:class=\"default-class\"\n        class=\"extra-class\"\n    %}\n&gt;\n</code></pre> <p><code>{% html_attrs %}</code> offers a Vue-like granular control for <code>class</code> and <code>style</code> HTML attributes, where you can use a dictionary to manage each class name or style property separately.</p> <pre><code>{% html_attrs\n    class=\"foo bar\"\n    class={\n        \"baz\": True,\n        \"foo\": False,\n    }\n    class=\"extra\"\n%}\n</code></pre> <pre><code>{% html_attrs\n    style=\"text-align: center; background-color: blue;\"\n    style={\n        \"background-color\": \"green\",\n        \"color\": None,\n        \"width\": False,\n    }\n    style=\"position: absolute; height: 12px;\"\n%}\n</code></pre> <p>Read more about HTML attributes.</p>"},{"location":"#html-fragment-support","title":"HTML fragment support","text":"<p><code>django-components</code> makes integration with HTMX, AlpineJS or jQuery easy by allowing components to be rendered as HTML fragments:</p> <ul> <li> <p>Components's JS and CSS files are loaded automatically when the fragment is inserted into the DOM.</p> </li> <li> <p>Components can be exposed as Django Views with <code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code> methods</p> </li> <li> <p>Automatically create an endpoint for a component with <code>Component.View.public</code></p> </li> </ul> <pre><code># components/calendar/calendar.py\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n\n    class View:\n        # Register Component with `urlpatterns`\n        public = True\n\n        # Define handlers\n        def get(self, request, *args, **kwargs):\n            page = request.GET.get(\"page\", 1)\n            return self.component.render_to_response(\n                request=request,\n                kwargs={\n                    \"page\": page,\n                },\n            )\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"page\": kwargs[\"page\"],\n        }\n\n# Get auto-generated URL for the component\nurl = get_component_url(Calendar)\n\n# Or define explicit URL in urls.py\npath(\"calendar/\", Calendar.as_view())\n</code></pre>"},{"location":"#provide-inject","title":"Provide / Inject","text":"<p><code>django-components</code> supports the provide / inject pattern, similarly to React's Context Providers or Vue's provide / inject:</p> <ul> <li>Use the <code>{% provide %}</code> tag to provide data to the component tree</li> <li>Use the <code>Component.inject()</code> method to inject data into the component</li> </ul> <p>Read more about Provide / Inject.</p> <pre><code>&lt;body&gt;\n    {% provide \"theme\" variant=\"light\" %}\n        {% component \"header\" / %}\n    {% endprovide %}\n&lt;/body&gt;\n</code></pre> <pre><code>@register(\"header\")\nclass Header(Component):\n    template = \"...\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        theme = self.inject(\"theme\").variant\n        return {\n            \"theme\": theme,\n        }\n</code></pre>"},{"location":"#input-validation-and-static-type-hints","title":"Input validation and static type hints","text":"<p>Avoid needless errors with type hints and runtime input validation.</p> <p>To opt-in to input validation, define types for component's args, kwargs, slots:</p> <pre><code>from typing import NamedTuple, Optional\nfrom django.template import Context\nfrom django_components import Component, Slot, SlotInput\n\nclass Button(Component):\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        variable: str\n        another: int\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        another_slot: SlotInput\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        args.size  # int\n        kwargs.variable  # str\n        slots.my_slot  # Slot[MySlotData]\n</code></pre> <p>To have type hints when calling <code>Button.render()</code> or <code>Button.render_to_response()</code>, wrap the inputs in their respective <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes:</p> <pre><code>Button.render(\n    # Error: First arg must be `int`, got `float`\n    args=Button.Args(\n        size=1.25,\n        text=\"abc\",\n    ),\n    # Error: Key \"another\" is missing\n    kwargs=Button.Kwargs(\n        variable=\"text\",\n    ),\n)\n</code></pre>"},{"location":"#extensions","title":"Extensions","text":"<p>Django-components functionality can be extended with Extensions. Extensions allow for powerful customization and integrations. They can:</p> <ul> <li>Tap into lifecycle events, such as when a component is created, deleted, or registered</li> <li>Add new attributes and methods to the components</li> <li>Add custom CLI commands</li> <li>Add custom URLs</li> </ul> <p>Some of the extensions include:</p> <ul> <li>Component caching</li> <li>Django View integration</li> <li>Component defaults</li> <li>Pydantic integration (input validation)</li> </ul> <p>Some of the planned extensions include:</p> <ul> <li>AlpineJS integration</li> <li>Storybook integration</li> <li>Component-level benchmarking with asv</li> </ul>"},{"location":"#caching","title":"Caching","text":"<ul> <li>Components can be cached using Django's cache framework.</li> <li>Caching rules can be configured on a per-component basis.</li> <li>Components are cached based on their input. Or you can write custom caching logic.</li> </ul> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n\n        def hash(self, *args, **kwargs):\n            return hash(f\"{json.dumps(args)}:{json.dumps(kwargs)}\")\n</code></pre>"},{"location":"#simple-testing","title":"Simple testing","text":"<ul> <li>Write tests for components with <code>@djc_test</code> decorator.</li> <li>The decorator manages global state, ensuring that tests don't leak.</li> <li>If using <code>pytest</code>, the decorator allows you to parametrize Django or Components settings.</li> <li>The decorator also serves as a stand-in for Django's <code>@override_settings</code>.</li> </ul> <pre><code>from django_components.testing import djc_test\n\nfrom components.my_table import MyTable\n\n@djc_test\ndef test_my_table():\n    rendered = MyTable.render(\n        kwargs={\n            \"title\": \"My table\",\n        },\n    )\n    assert rendered == \"&lt;table&gt;My table&lt;/table&gt;\"\n</code></pre>"},{"location":"#debugging-features","title":"Debugging features","text":"<ul> <li>Visual component inspection: Highlight components and slots directly in your browser.</li> <li>Detailed tracing logs to supply AI-agents with context: The logs include component and slot names and IDs, and their position in the tree.</li> </ul>"},{"location":"#sharing-components","title":"Sharing components","text":"<ul> <li>Install and use third-party components from PyPI</li> <li>Or publish your own \"component registry\"</li> <li> <p>Highly customizable - Choose how the components are called in the template (and more):</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}\n{% endcomponent %}\n\n{% calendar date=\"2024-11-06\" %}\n{% endcalendar %}\n</code></pre> </li> </ul>"},{"location":"migrating_from_safer_staticfiles/","title":"Migrating from safer_staticfiles","text":"<p>This guide is for you if you're upgrating django_components to v0.100 or later from older versions.</p> <p>In version 0.100, we changed how components' static JS and CSS files are handled. See more in the \"Static files\" section.</p> <p>Migration steps:</p> <ol> <li>Remove <code>django_components.safer_staticfiles</code> from <code>INSTALLED_APPS</code> in your <code>settings.py</code>,    and replace it with <code>django.contrib.staticfiles</code>.</li> </ol> <p>Before:</p> <pre><code>INSTALLED_APPS = [\n   \"django.contrib.admin\",\n   ...\n   # \"django.contrib.staticfiles\",  # &lt;-- ADD\n   \"django_components\",\n   \"django_components.safer_staticfiles\",  # &lt;-- REMOVE\n]\n</code></pre> <p>After:</p> <pre><code>INSTALLED_APPS = [\n   \"django.contrib.admin\",\n   ...\n   \"django.contrib.staticfiles\",\n   \"django_components\",\n]\n</code></pre> <ol> <li>Add <code>STATICFILES_FINDERS</code> to <code>settings.py</code>, and add <code>django_components.finders.ComponentsFileSystemFinder</code>:</li> </ol> <pre><code>STATICFILES_FINDERS = [\n   # Default finders\n   \"django.contrib.staticfiles.finders.FileSystemFinder\",\n   \"django.contrib.staticfiles.finders.AppDirectoriesFinder\",\n   # Django components\n   \"django_components.finders.ComponentsFileSystemFinder\",  # &lt;-- ADDED\n]\n</code></pre> <ol> <li>Add <code>COMPONENTS.dirs</code> to <code>settings.py</code>.</li> </ol> <p>If you previously defined <code>STATICFILES_DIRS</code>, move    only those directories from <code>STATICFILES_DIRS</code> that point to components directories, and keep the rest.</p> <p>E.g. if you have <code>STATICFILES_DIRS</code> like this:</p> <pre><code>STATICFILES_DIRS = [\n   BASE_DIR / \"components\",  # &lt;-- MOVE\n   BASE_DIR / \"myapp\" / \"components\",  # &lt;-- MOVE\n   BASE_DIR / \"assets\",\n]\n</code></pre> <p>Then first two entries point to components dirs, whereas <code>/assets</code> points to non-component static files.    In this case move only the first two paths:</p> <pre><code>COMPONENTS = {\n   \"dirs\": [\n      BASE_DIR / \"components\",  # &lt;-- MOVED\n      BASE_DIR / \"myapp\" / \"components\",  # &lt;-- MOVED\n   ],\n}\n\nSTATICFILES_DIRS = [\n   BASE_DIR / \"assets\",\n]\n</code></pre> <p>Moreover, if you defined app-level component directories in <code>STATICFILES_DIRS</code> before,    you can now define as a RELATIVE path in <code>app_dirs</code>:</p> <pre><code>COMPONENTS = {\n   \"dirs\": [\n      # Search top-level \"/components/\" dir\n      BASE_DIR / \"components\",\n   ],\n   \"app_dirs\": [\n      # Search \"/[app]/components/\" dirs\n      \"components\",\n   ],\n}\n\nSTATICFILES_DIRS = [\n   BASE_DIR / \"assets\",\n]\n</code></pre>"},{"location":"community/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"community/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or  advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic  address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a  professional setting</li> </ul>"},{"location":"community/code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"community/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"community/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at emil@emilstenstrom.se. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"community/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"community/contributing/","title":"Contributing","text":"<p>Hey there! \ud83d\udc4b</p> <p>django-components is what it is today because of awesome people like you who've jumped in to help out. We appreciate everyone who's taken the time to make this thing better.</p> <p>Want to get involved? Here's how:</p>"},{"location":"community/contributing/#found-a-bug","title":"Found a bug?","text":"<p>Just drop us an issue with the details of what went wrong. The more info, the better!</p>"},{"location":"community/contributing/#got-a-fix","title":"Got a fix?","text":"<p>Found a bug or typo and know how to fix it? Sweet! Open up a PR and we'll help you get it across the finish line.</p>"},{"location":"community/contributing/#have-an-idea","title":"Have an idea?","text":"<p>Feature requests and suggestions are always welcome. Toss them in a discussion or issue - we'd love to hear what you're thinking.</p>"},{"location":"community/contributing/#feeling-generous","title":"Feeling generous?","text":"<p>You can also support the project by sponsoring us. Every bit helps keep the lights on!</p>"},{"location":"community/contributing/#help-others","title":"Help others","text":"<p>Help others by answering questions in:</p> <ul> <li>Discussions</li> <li>Issues</li> <li>Discord</li> <li>Reddit</li> <li>Stack Overflow</li> </ul>"},{"location":"community/contributing/#get-coding","title":"Get coding","text":"<p>django-components is still growing and there's tons of cool stuff to build.</p> <p>Getting started is easy - pick an issue from our project's Kanban board and start coding.</p> <p>First time contributing? See the development guide.</p> <p>See here for how we manage the project board.</p>"},{"location":"community/development/","title":"Development","text":""},{"location":"community/development/#local-installation","title":"Local installation","text":"<p>Start by forking the project by clicking the Fork button up in the right corner in the GitHub. This makes a copy of the repository in your own name. Now you can clone this repository locally and start adding features:</p> <pre><code>git clone https://github.com/&lt;your GitHub username&gt;/django-components.git\ncd django-components\n</code></pre> <p>To quickly run the tests install the local dependencies by running:</p> <pre><code>pip install -r requirements-dev.txt\n</code></pre> <p>You also have to install this local django-components version. Use <code>-e</code> for editable mode so you don't have to re-install after every change:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"community/development/#running-tests","title":"Running tests","text":"<p>Now you can run the tests to make sure everything works as expected:</p> <pre><code>pytest\n</code></pre> <p>The library is also tested across many versions of Python and Django. To run tests that way:</p> <pre><code>pyenv install -s 3.8\npyenv install -s 3.9\npyenv install -s 3.10\npyenv install -s 3.11\npyenv install -s 3.12\npyenv install -s 3.13\npyenv local 3.8 3.9 3.10 3.11 3.12 3.13\ntox -p\n</code></pre> <p>To run tests for a specific Python version, use:</p> <pre><code>tox -e py38\n</code></pre> <p>NOTE: See the available environments in <code>tox.ini</code>.</p>"},{"location":"community/development/#linting-and-formatting","title":"Linting and formatting","text":"<p>To check linting rules, run:</p> <pre><code>ruff check .\n# Or to fix errors automatically:\nruff check --fix .\n</code></pre> <p>To format the code, run:</p> <pre><code>ruff format --check .\n# Or to fix errors automatically:\nruff format .\n</code></pre> <p>To validate with Mypy, run:</p> <pre><code>mypy .\n</code></pre> <p>You can run these through <code>tox</code> as well:</p> <pre><code>tox -e mypy,ruff\n</code></pre>"},{"location":"community/development/#playwright-tests","title":"Playwright tests","text":"<p>We use Playwright for end-to-end tests. You will need to install Playwright to run these tests.</p> <p>Luckily, Playwright makes it very easy:</p> <pre><code>pip install -r requirements-dev.txt\nplaywright install chromium --with-deps\n</code></pre> <p>After Playwright is ready, run the tests the same way as before:</p> <pre><code>pytest\n# Or for specific Python version\ntox -e py38\n</code></pre>"},{"location":"community/development/#snapshot-tests","title":"Snapshot tests","text":"<p>Some tests rely on snapshot testing with syrupy to test the HTML output of the components.</p> <p>If you need to update the snapshot tests, add <code>--snapshot-update</code> to the pytest command:</p> <pre><code>pytest --snapshot-update\n</code></pre> <p>Or with tox:</p> <pre><code>tox -e py39 -- --snapshot-update\n</code></pre>"},{"location":"community/development/#dev-server","title":"Dev server","text":"<p>How do you check that your changes to django-components project will work in an actual Django project?</p> <p>Use the sampleproject demo project to validate the changes:</p> <ol> <li> <p>Navigate to sampleproject directory:</p> <pre><code>cd sampleproject\n</code></pre> </li> <li> <p>Install dependencies from the requirements.txt file:</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Link to your local version of django-components:</p> <pre><code>pip install -e ..\n</code></pre> <p>Note</p> <p>The path to the local version (in this case <code>..</code>) must point to the directory that has the <code>pyproject.toml</code> file.</p> </li> <li> <p>Start Django server:</p> <pre><code>python manage.py runserver\n</code></pre> </li> </ol> <p>Once the server is up, it should be available at http://127.0.0.1:8000.</p> <p>To display individual components, add them to the <code>urls.py</code>, like in the case of http://127.0.0.1:8000/greeting</p>"},{"location":"community/development/#building-js-code","title":"Building JS code","text":"<p>django_components uses a bit of JS code to:</p> <ul> <li>Manage the loading of JS and CSS files used by the components</li> <li>Allow to pass data from Python to JS</li> </ul> <p>When you make changes to this JS code, you also need to compile it:</p> <ol> <li> <p>Navigate to <code>src/django_components_js</code>:</p> <pre><code>cd src/django_components_js\n</code></pre> </li> <li> <p>Install the JS dependencies</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Compile the JS/TS code:</p> <pre><code>python build.py\n</code></pre> <p>The script will combine all JS/TS code into a single <code>.js</code> file, minify it, and copy it to <code>django_components/static/django_components/django_components.min.js</code>.</p> </li> </ol>"},{"location":"community/development/#documentation-website","title":"Documentation website","text":"<p>The documentation website is built using MkDocs and Material for MkDocs.</p> <p>First install dependencies needed for the documentation:</p> <pre><code>pip install -r requirements-docs.txt\n</code></pre> <p>Then install this local django-components version. Use <code>-e</code> for editable mode so you don't have to re-install after every change:</p> <pre><code>pip install -e .\n</code></pre> <p>To run the documentation server locally, run:</p> <pre><code>mkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:9000/django-components/ in your browser.</p> <p>To just build the documentation, run:</p> <pre><code>mkdocs build\n</code></pre> <p>The documentation site is deployed automatically with Github actions (see <code>.github/workflows/docs.yml</code>).</p> <p>The CI workflow runs when:</p> <ul> <li>A new commit is pushed to the <code>master</code> branch - This updates the <code>dev</code> version</li> <li>A new tag is pushed - This updates the <code>latest</code> version and the version specified in the tag name</li> </ul>"},{"location":"community/development/#publishing","title":"Publishing","text":"<p>We use Github actions to automatically publish new versions of django-components to PyPI when a new tag is pushed. See the full workflow here.</p>"},{"location":"community/development/#commands","title":"Commands","text":"<p>We do not manually release new versions of django-components. Commands below are shown for reference only.</p> <p>To package django-components into a distribution that can be published to PyPI, run <code>build</code>:</p> <pre><code># Install pypa/build\npython -m pip install build --user\n# Build a binary wheel and a source tarball\npython -m build --sdist --wheel --outdir dist/ .\n</code></pre> <p>To then publish the contents of <code>dist/</code> to PyPI, use <code>twine</code> (See Python user guide):</p> <pre><code>twine upload --repository pypi dist/* -u __token__ -p &lt;PyPI_TOKEN&gt;\n</code></pre>"},{"location":"community/development/#release-new-version","title":"Release new version","text":"<p>Let's say we want to release a new version <code>0.141.6</code>. We need to:</p> <ol> <li> <p>Bump the <code>version</code> in <code>pyproject.toml</code> to the desired version.</p> <pre><code>[project]\nversion = \"0.141.6\"\n</code></pre> </li> <li> <p>Create a summary of the changes in <code>CHANGELOG.md</code> at the top of the file.</p> <p>When writing release notes for individual changes, it's useful to write them like mini announcements:</p> <ul> <li>Explain the context</li> <li>Then the change itself</li> <li>Then include an example</li> </ul> <pre><code># Release notes\n\n## v0.141.6\n\n_2025-09-24_\n\n#### Fix\n\n- Tests - Fix bug when using `@djc_test` decorator and the `COMPONENTS`\n  settings are set with `ComponentsSettings`\n  See [#1369](https://github.com/django-components/django-components/issues/1369)\n</code></pre> <p>Note</p> <p>When you include the release date in the format <code>_YYYY-MM-DD_</code>, it will be displayed in the release notes.</p> <p>See <code>docs/scripts/gen_release_notes.py</code> for more details.</p> <p></p> </li> <li> <p>Create a new PR to merge the changes above into the <code>master</code> branch.</p> </li> <li> <p>Create new release in Github UI.</p> <p> </p> </li> </ol>"},{"location":"community/development/#semantic-versioning","title":"Semantic versioning","text":"<p>We use Semantic Versioning for django-components.</p> <p>The version number is in the format <code>MAJOR.MINOR.PATCH</code> (e.g. <code>0.141.6</code>).</p> <ul> <li><code>MAJOR</code> (e.g. <code>1.0.0</code>) is reserved for significant architectural changes and breaking changes.</li> <li><code>MINOR</code> (e.g. <code>0.1.0</code>) is incremented for new features.</li> <li><code>PATCH</code> (e.g. <code>0.0.1</code>) is incremented for bug fixes or documentation changes.</li> </ul>"},{"location":"community/development/#development-guides","title":"Development guides","text":"<p>Head over to Dev guides for a deep dive into how django_components' features are implemented.</p>"},{"location":"community/development/#maintenance","title":"Maintenance","text":""},{"location":"community/development/#updating-supported-versions","title":"Updating supported versions","text":"<p>The <code>scripts/supported_versions.py</code> script manages the supported Python and Django versions for the project.</p> <p>The script runs automatically via GitHub Actions once a week to check for version updates. If changes are detected, it creates a GitHub issue with the necessary updates. See the <code>maint-supported-versions.yml</code> workflow.</p> <p>You can also run the script manually:</p> <pre><code># Check if versions need updating\npython scripts/supported_versions.py check\n\n# Generate configuration snippets for manual updates\npython scripts/supported_versions.py generate\n</code></pre> <p>The <code>generate</code> command will print to the terminal all the places that need updating and what to set them to.</p>"},{"location":"community/development/#updating-link-references","title":"Updating link references","text":"<p>The <code>scripts/validate_links.py</code> script can be used to update the link references.</p> <pre><code>python scripts/validate_links.py\n</code></pre> <p>When new version of Django is released, you can use the script to update the URLs pointing to the Django documentation.</p> <p>First, you need to update the <code>URL_REWRITE_MAP</code> in the script to point to the new version of Django.</p> <p>Then, you can run the script to update the URLs in the codebase.</p> <pre><code>python scripts/validate_links.py --rewrite\n</code></pre>"},{"location":"community/development/#integrations","title":"Integrations","text":""},{"location":"community/development/#discord","title":"Discord","text":"<p>We integrate with our Discord server to notify about new releases, issues, PRs, and discussions.</p> <p>See: - <code>issue-discord.yml</code> - <code>release-discord.yml</code> - <code>pr-discord.yml</code> - <code>discussion-discord.yml</code></p> <p>See this tutorial on how to set up the Discord webhooks.</p> <p>The Discord webhook URLs are stored as secrets in the GitHub repository.</p> <ul> <li><code>DISCORD_WEBHOOK_DEVELOPMENT</code> - For new issues</li> <li><code>DISCORD_WEBHOOK_ANNOUNCEMENTS</code> - For new releases</li> </ul>"},{"location":"community/development/#project-management","title":"Project management","text":""},{"location":"community/development/#project-board","title":"Project board","text":"<p>We use the GitHub project board to manage the project.</p> <p>Quick overview of the columns:</p> <ul> <li>No status - Issues that are not planned yet and need more discussion</li> <li>\ud83d\udd35 Backlog - Planned but not ready to be picked up</li> <li>\ud83d\udfe2 Ready - Ready to be picked up</li> <li>\ud83d\udfe1 In Progress - Someone is already working on it</li> <li>\ud83d\udfe3 Ready for release - Completed, but not released yet</li> <li>\ud83d\udfe0 Done - Completed and released</li> </ul> <p>New issues are automatically added to the No status column.</p> <p>To pick up an issue, assign it to yourself and move it to the \ud83d\udfe1 In Progress column.</p> <p></p> <p>Use the sidebar to filter the issues by different labels, milestones, and issue types:</p> <p></p>"},{"location":"community/development/#priority","title":"Priority","text":"<p>Which issues should be picked up first?</p> <p>We suggest the following guideline:</p> <ol> <li>Bugs - First fix bugs and documentation errors.</li> <li>V1 release - Then pick up issues that are part of the v1 release milestone.</li> </ol> <p>After that, pick what you like!</p>"},{"location":"community/development/#labels","title":"Labels","text":"<p>Labels help keep our project organized. See the list of all labels here.</p>"},{"location":"community/development/#milestones","title":"Milestones","text":"<ul> <li><code>milestone--v1</code> - Work to be done for the V1 release.</li> </ul>"},{"location":"community/development/#issue-types","title":"Issue types","text":"<ul> <li><code>type--bug</code> - Bugs.</li> <li><code>type--documentation</code> - Documentation changes.</li> <li><code>type--enhancement</code> - New features and improvements.</li> <li><code>type--integration</code> - Integrating with other libraries or systems.</li> <li><code>type--operations</code> - Relating to \"operations\" - Github Actions, processes, etc.</li> <li><code>type--optimisation</code> - Optimizing the code for performance.</li> </ul>"},{"location":"community/help/","title":"Questions & Help","text":"<p>The best place to ask questions is in our Github Discussion board or Discord Server</p> <p>Please, before opening a new discussion, check if similar discussion wasn't opened already.</p>"},{"location":"community/devguides/dependency_mgmt/","title":"JS and CSS rendering","text":"<p>Aim of this doc is to share the intuition on how we manage the JS and CSS (\"dependencies\") associated with components, and how we render them.</p>"},{"location":"community/devguides/dependency_mgmt/#starting-conditions","title":"Starting conditions","text":"<ol> <li> <p>First of all, when we consider a component, it has two kind of dependencies - the \"inlined\" JS and CSS, and additional linked JS and CSS via <code>Media.js/css</code>:</p> <pre><code>from django_components import Component, types\n\nclass MyTable(Component):\n    # Inlined JS\n    js: types.js = \"\"\"\n      console.log(123);\n    \"\"\"\n\n    # Inlined CSS\n    css: types.css = \"\"\"\n      .my-table {\n        color: red;\n      }\n    \"\"\"\n\n    # Linked JS / CSS\n    class Media:\n        js = [\n            \"script-one.js\",  # STATIC file relative to component file\n            \"/script-two.js\", # URL path\n            \"https://example.com/script-three.js\", # URL\n        ]\n\n        css = [\n            \"style-one.css\",  # STATIC file relative to component file\n            \"/style-two.css\", # URL path\n            \"https://example.com/style-three.css\", # URL\n        ]\n</code></pre> </li> <li> <p>Second thing to keep in mind is that all component's are eventually rendered into a string. And so, if we want to associate extra info with a rendered component, it has to be serialized to a string.</p> <p>This is because a component may be embedded in a Django Template with the <code>{% component %}</code> tag, which, when rendered, is turned into a string:</p> <pre><code>template = Template(\"\"\"\n  {% load component_tags %}\n  &lt;div&gt;\n    {% component \"my_table\" / %}\n  &lt;/div&gt;\n\"\"\")\n\nhtml_str = template.render(Context({}))\n</code></pre> <p>And for this reason, we take the same approach also when we render a component with <code>Component.render()</code> - It returns a string.</p> </li> <li> <p>Thirdly, we also want to add support for JS / CSS variables. That is, that a variable defined on the component would be somehow accessible from within the JS script / CSS style.</p> <p>A simple approach to this would be to modify the inlined JS / CSS directly, and insert them for each component. But if you had extremely large JS / CSS, and e.g. only a single JS / CSS variable that you want to insert, it would be wasteful to create a copy of the JS / CSS scripts for each component instance.</p> <p>So instead, a preferred approach here is to defined and insert the inlined JS / CSS only once, and have some kind of mechanism on how we make correct the JS / CSS variables available only to the correct components.</p> </li> <li> <p>Last important thing is that we want the JS / CSS dependencies to work also with HTML fragments.</p> <p>So normally, e.g. when a user hits URL of a web page, the server renders full HTML document, with <code>&lt;!doctype&gt;</code>, <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code>. In such case, we know about ALL JS and CSS dependencies at render time, so we can e.g. insert them into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> ourselves.</p> <p>However this renders only the initial state. HTML fragments is a common pattern where interactivity is added to the web page by fetching and replacing bits of HTML on the main HTML document after some user action.</p> <p>In the case of HTML fragments, the HTML is NOT a proper document, but only the HTML that will be inserted somewhere into the DOM.</p> <p>The challenge here is that Django template for the HTML fragment MAY contain components, and these components MAY have inlined or linked JS and CSS.</p> <pre><code>def fragment_view(request):\n    template = Template(\"\"\"\n      {% load component_tags %}\n      &lt;div&gt;\n        {% component \"my_table\" / %}\n      &lt;/div&gt;\n    \"\"\")\n\n    fragment_str = template.render(Context({}))\n    return HttpResponse(fragment_str, status=200)\n</code></pre> <p>User may use different libraries to fetch and insert the HTML fragments (e.g. HTMX, AlpineJS, ...). From our perspective, the only thing that we can reliably say is that we expect that the HTML fragment WILL be eventually inserted into the DOM.</p> <p>So to include the corresponding JS and CSS, a simple approach could be to append them to the HTML as <code>&lt;style&gt;</code> and <code>&lt;script&gt;</code>, e.g.:</p> <pre><code>&lt;!-- Original content --&gt;\n&lt;div&gt;...&lt;/div&gt;\n&lt;!-- Associated CSS files --&gt;\n&lt;link href=\"http://...\" /&gt;\n&lt;style&gt;\n  .my-class {\n    color: red;\n  }\n&lt;/style&gt;\n&lt;!-- Associated JS files --&gt;\n&lt;script src=\"http://...\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  console.log(123);\n&lt;/script&gt;\n</code></pre> <p>But this has a number of issues:</p> <ul> <li>The JS scripts would run for each instance of the component.</li> <li>Bloating of the HTML file, as each inlined JS or CSS would be included fully for each component.</li> <li>While this sound OK, this could really bloat the HTML files if we used a UI component library for the basic building blocks like buttons, lists, cards, etc.</li> </ul> </li> </ol>"},{"location":"community/devguides/dependency_mgmt/#flow","title":"Flow","text":"<p>So the solution should address all the points above. To achieve that, we manage the JS / CSS dependencies ourselves in the browser. So when a full HTML document is loaded, we keep track of which JS and CSS have been loaded. And when an HTML fragment is inserted, we check which JS / CSS dependencies it has, and load only those that have NOT been loaded yet.</p> <p>This is how we achieve that:</p> <ol> <li> <p>When a component is rendered, it inserts an HTML comment containing metadata about the rendered component.</p> <p>So a template like this</p> <pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"my_table\" / %}\n&lt;/div&gt;\n{% component \"button\" %}\n  Click me!\n{% endcomponent %}\n</code></pre> <p>May actually render:</p> <pre><code>&lt;div&gt;\n  &lt;!-- _RENDERED \"my_table_10bc2c,c020ad\" --&gt;\n  &lt;table&gt;\n    ...\n  &lt;/table&gt;\n&lt;/div&gt;\n&lt;!-- _RENDERED \"button_309dcf,31c0da\" --&gt;\n&lt;button&gt;Click me!&lt;/button&gt;\n</code></pre> <p>Each <code>&lt;!-- _RENDERED --&gt;</code> comment includes comma-separated data - a unique hash for the component class, e.g. <code>my_table_10bc2c</code>, and the component ID, e.g. <code>c020ad</code>.</p> <p>This way, we or the user can freely pass the rendered around or transform it, treating it as a string to add / remove / replace bits. As long as the <code>&lt;!-- _RENDERED --&gt;</code> comments remain in the rendered string, we will be able to deduce which JS and CSS dependencies the component needs.</p> </li> <li> <p>Post-process the rendered HTML, extracting the <code>&lt;!-- _RENDERED --&gt;</code> comments, and instead inserting the corresponding JS and CSS dependencies.</p> <p>If we dealt only with JS, then we could get away with processing the <code>&lt;!-- _RENDERED --&gt;</code> comments on the client (browser). However, the CSS needs to be processed still on the server, so the browser receives CSS styles already inserted as <code>&lt;style&gt;</code> or <code>&lt;link&gt;</code> HTML tags. Because if we do not do that, we get a flash of unstyled content, as there will be a delay between when the HTML page loaded and when the CSS was fetched and loaded.</p> <p>So, assuming that a user has already rendered their template, which still contains <code>&lt;!-- _RENDERED --&gt;</code> comments, we need to extract and process these comments.</p> <p>There's multiple ways to achieve this:</p> <ul> <li> <p>If users are using <code>Component.render()</code> or <code>Component.render_to_response()</code>, these post-process the <code>&lt;!-- _RENDERED --&gt;</code> comments by default.</p> </li> <li> <p>NOTE: Users are able to opt out of the post-processing by setting <code>deps_strategy=\"ignore\"</code>.</p> </li> <li> <p>If one renders a Template directly, the <code>&lt;!-- _RENDERED --&gt;</code> will be processed too. We achieve this by   modifying Django's <code>Template.render()</code> method.</p> </li> <li> <p>For advanced use cases, users may use <code>render_dependencies()</code> directly. This is the function that   <code>Component.render()</code> calls internally.</p> </li> </ul> <p><code>render_dependencies()</code>, whether called directly, or other way, does the following:</p> <ol> <li> <p>Find all <code>&lt;!-- _RENDERED --&gt;</code> comments, and for each comment:</p> </li> <li> <p>Look up the corresponding component class.</p> </li> <li> <p>Get the component's inlined JS / CSS from <code>Component.js/css</code>, and linked JS / CSS from <code>Component.Media.js/css</code>.</p> </li> <li> <p>Generate JS script that loads the JS / CSS dependencies.</p> </li> <li> <p>Insert the JS scripts either at the end of <code>&lt;body&gt;</code>, or in place of <code>{% component_dependencies %}</code> / <code>{% component_js_dependencies %}</code> tags.</p> </li> <li> <p>To avoid the flash of unstyled content, we need place the styles into the HTML instead of dynamically loading them from within a JS script. The CSS is placed either at the end of <code>&lt;head&gt;</code>, or in place of <code>{% component_dependencies %}</code> / <code>{% component_css_dependencies %}</code></p> </li> <li> <p>We cache the component's inlined JS and CSS, so they can be fetched via an URL, so the inlined JS / CSS an be treated the same way as the JS / CSS dependencies set in <code>Component.Media.js/css</code>.</p> <ul> <li>NOTE: While this is currently not entirely necessary, it opens up the doors for allowing plugins to post-process the inlined JS and CSS. Because after it has been post-processed, we need to store it somewhere.</li> </ul> </li> </ol> </li> <li> <p>Server returns the post-processed HTML.</p> </li> <li> <p>In the browser, the generated JS script from step 2.4 is executed. It goes through all JS and CSS dependencies it was given. If some JS / CSS was already loaded, it is NOT fetched again. Otherwise it generates the corresponding <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> HTML tags to load the JS / CSS dependencies.</p> <p>In the browser, the \"dependency manager JS\" may look like this:</p> <pre><code>// Load JS or CSS script if not loaded already\nComponents.loadJs('&lt;script src=\"/abc/xyz/script.js\"&gt;');\nComponents.loadCss('&lt;link href=\"/abc/xyz/style.css\"&gt;');\n\n// Or mark one as already-loaded, so it is ignored when\n// we call `loadJs`\nComponents.markScriptLoaded(\"js\", \"/abc/def\");\n</code></pre> <p>Note that <code>loadJs() / loadCss()</code> receive whole <code>&lt;script&gt; / &lt;link&gt;</code> tags, not just the URL. This is because when Django's <code>Media</code> class renders JS and CSS, it formats it as <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags. And we allow users to modify how the JS and CSS should be rendered into the <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags.</p> <p>So, if users decided to add an extra attribute to their <code>&lt;script&gt;</code> tags, e.g. <code>&lt;script defer src=\"http://...\"&gt;&lt;/script&gt;</code>, then this way we make sure that the <code>defer</code> attribute will be present on the <code>&lt;script&gt;</code> tag when it is inserted into the DOM at the time of loading the JS script.</p> </li> <li> <p>To be able to fetch component's inlined JS and CSS, django-components adds a URL path under:</p> <p><code>/components/cache/&lt;str:comp_cls_id&gt;.&lt;str:script_type&gt;/</code></p> <p>E.g. <code>/components/cache/MyTable_10bc2c.js/</code></p> <p>This endpoint takes the component's unique ID, e.g. <code>MyTable_10bc2c</code>, and looks up the component's inlined JS or CSS.</p> </li> </ol> <p>Thus, with this approach, we ensure that:</p> <ol> <li>All JS / CSS dependencies are loaded / executed only once.</li> <li>The approach is compatible with HTML fragments</li> <li>The approach is compatible with JS / CSS variables.</li> <li>Inlined JS / CSS may be post-processed by plugins</li> </ol>"},{"location":"community/devguides/slot_rendering/","title":"Slot rendering","text":"<p>This doc serves as a primer on how component slots and fills are resolved.</p>"},{"location":"community/devguides/slot_rendering/#flow","title":"Flow","text":"<ol> <li> <p>Imagine you have a template. Some kind of text, maybe HTML:    <pre><code>| ------\n| ---------\n| ----\n| -------\n</code></pre></p> </li> <li> <p>The template may contain some vars, tags, etc    <pre><code>| -- {{ my_var }} --\n| ---------\n| ----\n| -------\n</code></pre></p> </li> <li> <p>The template also contains some slots, etc    <pre><code>| -- {{ my_var }} --\n| ---------\n| -- {% slot \"myslot\" %} ---\n| -- {% endslot %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>Slots may be nested    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %} ---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- JKL {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>Some slots may be inside fills for other components    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %}---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ------\n| -- {% component \"mycomp\" %} ---\n| ---- {% slot \"myslot\" %} ---\n| ------- JKL {{ my_var }}\n| ------- {% slot \"myslot_inner\" %}\n| ---------- MNO {{ my_var }}\n| ------- {% endslot %}\n| ---- {% endslot %} ---\n| -- {% endcomponent %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- PQR {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>The names of the slots and fills may be defined using variables    <pre><code>| -- {% slot slot_name %} ---\n| ---- STU {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>The slot and fill names may be defined using for loops or other variables defined within the template (e.g. <code>{% with %}</code> tag or <code>{% ... as var %}</code> syntax)    <pre><code>| -- {% for slot_name in slots %} ---\n| ---- {% slot slot_name %} ---\n| ------ STU {{ slot_name }}\n| ---- {% endslot %} ---\n| -- {% endfor %} ---\n| -------\n</code></pre></p> </li> <li> <p>Variables for names and for loops allow us implement \"passthrough slots\" - that is, taking all slots that our component received, and passing them to a child component, dynamically.    <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- {% for slot_name in slots %} ---\n| ------ {% fill slot_name %} ---\n| -------- {% slot slot_name %} ---\n| ---------- XYZ {{ slot_name }}\n| --------- {% endslot %}\n| ------- {% endfill %}\n| ---- {% endfor %} ---\n| -- {% endcomponent %} ---\n| ----\n</code></pre></p> </li> <li> <p>Putting that all together, a document may look like this:    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %}---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ------\n| -- {% component \"mycomp\" %} ---\n| ---- {% slot \"myslot\" %} ---\n| ------- JKL {{ my_var }}\n| ------- {% slot \"myslot_inner\" %}\n| ---------- MNO {{ my_var }}\n| ------- {% endslot %}\n| ---- {% endslot %} ---\n| -- {% endcomponent %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- PQR {{ my_var }}\n| -- {% endslot %} ---\n| -------\n| -- {% for slot_name in slots %} ---\n| ---- {% component \"mycomp\" %} ---\n| ------- {% slot slot_name %}\n| ---------- STU {{ slot_name }}\n| ------- {% endslot %}\n| ---- {% endcomponent %} ---\n| -- {% endfor %} ---\n| ----\n| -- {% component \"mycomp\" %} ---\n| ---- {% for slot_name in slots %} ---\n| ------ {% fill slot_name %} ---\n| -------- {% slot slot_name %} ---\n| ---------- XYZ {{ slot_name }}\n| --------- {% endslot %}\n| ------- {% endfill %}\n| ---- {% endfor %} ---\n| -- {% endcomponent %} ---\n| -------\n</code></pre></p> </li> <li> <p>Given the above, we want to render the slots with <code>{% fill %}</code> tag that were defined OUTSIDE of this template. How do I do that?</p> <p>NOTE: Before v0.110, slots were resolved statically, by walking down the Django Template and Nodes. However, this did not allow for using for loops or other variables defined in the template.</p> <p>Currently, this consists of 2 steps:</p> <ol> <li> <p>If a component is rendered within a template using <code>{% component %}</code> tag, determine the given <code>{% fill %}</code> tags in the component's body (the content in between <code>{% component %}</code> and <code>{% endcomponent %}</code>).</p> <p>After this step, we know about all the fills that were passed to the component.</p> </li> <li> <p>Then we simply render the template as usual. And then we reach the <code>{% slot %}</code> tag, we search the context for the available fills.</p> <ul> <li>If there IS a fill with the same name as the slot, we render the fill.</li> <li>If the slot is marked <code>default</code>, and there is a fill named <code>default</code>, then we render that.</li> <li>Otherwise, we render the slot's default content.</li> </ul> </li> </ol> </li> <li> <p>Obtaining the fills from <code>{% fill %}</code>.</p> <p>When a component is rendered with <code>{% component %}</code> tag, and it has some content in between <code>{% component %}</code> and <code>{% endcomponent %}</code>, we want to figure out if that content is a default slot (no <code>{% fill %}</code> used), or if there is a collection of named <code>{% fill %}</code> tags:</p> <p>Default slot:</p> <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- STU {{ slot_name }}\n| -- {% endcomponent %} ---\n</code></pre> <p>Named slots:</p> <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- {% fill \"slot_a\" %}\n| ------ STU\n| ---- {% endslot %}\n| ---- {% fill \"slot_b\" %}\n| ------ XYZ\n| ---- {% endslot %}\n| -- {% endcomponent %} ---\n</code></pre> <p>To respect any forloops or other variables defined within the template to which the fills may have access, we:</p> <ol> <li>Render the content between <code>{% component %}</code> and <code>{% endcomponent %}</code> using the context    outside of the component.</li> <li>When we reach a <code>{% fill %}</code> tag, we capture any variables that were created between    the <code>{% component %}</code> and <code>{% fill %}</code> tags.</li> <li>When we reach <code>{% fill %}</code> tag, we do not continue rendering deeper. Instead we    make a record that we found the fill tag with given name, kwargs, etc.</li> <li>After the rendering is done, we check if we've encountered any fills.    If yes, we expect only named fills. If no, we assume that the the component's body    is a default slot.</li> <li>Lastly we process the found fills, and make them available to the context, so any    slots inside the component may access these fills.</li> </ol> </li> <li> <p>Rendering slots</p> <p>Slot rendering works similarly to collecting fills, in a sense that we do not search for the slots ahead of the time, but instead let Django handle the rendering of the template, and we step in only when Django come across as <code>{% slot %}</code> tag.</p> <p>When we reach a slot tag, we search the context for the available fills.</p> <ul> <li>If there IS a fill with the same name as the slot, we render the fill.</li> <li>If the slot is marked <code>default</code>, and there is a fill named <code>default</code>, then we render that.</li> <li>Otherwise, we render the slot's default content.</li> </ul> </li> </ol>"},{"location":"community/devguides/slot_rendering/#using-the-correct-context-in-slotfill-tags","title":"Using the correct context in {% slot/fill %} tags","text":"<p>In previous section, we said that the <code>{% fill %}</code> tags should be already rendered by the time they are inserted into the <code>{% slot %}</code> tags.</p> <p>This is not quite true. To help you understand, consider this complex case:</p> <pre><code>| -- {% for var in [1, 2, 3] %} ---\n| ---- {% component \"mycomp2\" %} ---\n| ------ {% fill \"first\" %}\n| ------- STU {{ my_var }}\n| -------     {{ var }}\n| ------ {% endfill %}\n| ------ {% fill \"second\" %}\n| -------- {% component var=var my_var=my_var %}\n| ---------- VWX {{ my_var }}\n| -------- {% endcomponent %}\n| ------ {% endfill %}\n| ---- {% endcomponent %} ---\n| -- {% endfor %} ---\n| -------\n</code></pre> <p>We want the forloop variables to be available inside the <code>{% fill %}</code> tags. Because of that, however, we CANNOT render the fills/slots in advance.</p> <p>Instead, our solution is closer to how Vue handles slots. In Vue, slots are effectively functions that accept a context variables and render some content.</p> <p>While we do not wrap the logic in a function, we do PREPARE IN ADVANCE: 1. The content that should be rendered for each slot 2. The context variables from <code>get_template_data()</code></p> <p>Thus, once we reach the <code>{% slot %}</code> node, in it's <code>render()</code> method, we access the data above, and, depending on the <code>context_behavior</code> setting, include the current context or not. For more info, see <code>SlotNode.render()</code>.</p>"},{"location":"community/devguides/slots_and_blocks/","title":"Using slot and block tags","text":"<ol> <li> <p>First let's clarify how <code>include</code> and <code>extends</code> tags work inside components.</p> <p>When component template includes <code>include</code> or <code>extends</code> tags, it's as if the \"included\" template was inlined. So if the \"included\" template contains <code>slot</code> tags, then the component uses those slots.</p> <p>If you have a template <code>abc.html</code>: <pre><code>&lt;div&gt;\n  hello\n  {% slot \"body\" %}{% endslot %}\n&lt;/div&gt;\n</code></pre></p> <p>And components that make use of <code>abc.html</code> via <code>include</code> or <code>extends</code>: <pre><code>from django_components import Component, register\n\n@register(\"my_comp_extends\")\nclass MyCompWithExtends(Component):\n    template = \"\"\"{% extends \"abc.html\" %}\"\"\"\n\n@register(\"my_comp_include\")\nclass MyCompWithInclude(Component):\n    template = \"\"\"{% include \"abc.html\" %}\"\"\"\n</code></pre></p> <p>Then you can set slot fill for the slot imported via <code>include/extends</code>:</p> <pre><code>{% component \"my_comp_extends\" %}\n    {% fill \"body\" %}\n        123\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>And it will render: <pre><code>&lt;div&gt;\n  hello\n  123\n&lt;/div&gt;\n</code></pre></p> </li> <li> <p>Slot and block</p> <p>If you have a template <code>abc.html</code> like so:</p> <pre><code>&lt;div&gt;\n  hello\n  {% block inner %}\n    1\n    {% slot \"body\" %}\n      2\n    {% endslot %}\n  {% endblock %}\n&lt;/div&gt;\n</code></pre> <p>and component <code>my_comp</code>:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template_file = \"abc.html\"\n</code></pre> <p>Then:</p> <ol> <li> <p>Since the <code>block</code> wasn't overriden, you can use the <code>body</code> slot:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"body\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>And we get:</p> <pre><code>&lt;div&gt;hello 1 XYZ&lt;/div&gt;\n</code></pre> </li> <li> <p><code>blocks</code> CANNOT be overriden through the <code>component</code> tag, so something like this:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"body\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n{% block \"inner\" %}\n    456\n{% endblock %}\n</code></pre> <p>Will still render the component content just the same:</p> <pre><code>&lt;div&gt;hello 1 XYZ&lt;/div&gt;\n</code></pre> </li> <li> <p>You CAN override the <code>block</code> tags of <code>abc.html</code> if the component template     uses <code>extends</code>. In that case, just as you would expect, the <code>block inner</code> inside     <code>abc.html</code> will render <code>OVERRIDEN</code>:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        {% extends \"abc.html\" %}\n        {% block inner %}\n          OVERRIDEN\n        {% endblock %}\n    \"\"\"\n</code></pre> </li> <li> <p>This is where it gets interesting (but still intuitive). You can insert even     new <code>slots</code> inside these \"overriding\" blocks:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n      {% extends \"abc.html\" %}\n\n      {% load component_tags %}\n      {% block \"inner\" %}\n        OVERRIDEN\n        {% slot \"new_slot\" %}\n          hello\n        {% endslot %}\n      {% endblock %}\n    \"\"\"\n</code></pre> <p>And you can then pass fill for this <code>new_slot</code> when rendering the component:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"new_slot\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>NOTE: Currently you can supply fills for both <code>new_slot</code> and <code>body</code> slots, and you will not get an error for an invalid/unknown slot name. But since <code>body</code> slot is not rendered, it just won't do anything. So this renders the same as above:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"new_slot\" %}\n        XYZ\n    {% endfill %}\n    {% fill \"body\" %}\n        www\n    {% endfill %}\n{% endcomponent %}\n</code></pre> </li> </ol> </li> </ol>"},{"location":"concepts/advanced/component_caching/","title":"Component caching","text":"<p>Component caching allows you to store the rendered output of a component. Next time the component is rendered with the same input, the cached output is returned instead of re-rendering the component.</p> <p>This is particularly useful for components that are expensive to render or do not change frequently.</p> <p>Info</p> <p>Component caching uses Django's cache framework, so you can use any cache backend that is supported by Django.</p>"},{"location":"concepts/advanced/component_caching/#enabling-caching","title":"Enabling caching","text":"<p>Caching is disabled by default.</p> <p>To enable caching for a component, set <code>Component.Cache.enabled</code> to <code>True</code>:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n</code></pre>"},{"location":"concepts/advanced/component_caching/#time-to-live-ttl","title":"Time-to-live (TTL)","text":"<p>You can specify a time-to-live (TTL) for the cache entry with <code>Component.Cache.ttl</code>, which determines how long the entry remains valid. The TTL is specified in seconds.</p> <pre><code>class MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n</code></pre> <ul> <li>If <code>ttl &gt; 0</code>, entries are cached for the specified number of seconds.</li> <li>If <code>ttl = -1</code>, entries are cached indefinitely.</li> <li>If <code>ttl = 0</code>, entries are not cached.</li> <li>If <code>ttl = None</code>, the default TTL is used.</li> </ul>"},{"location":"concepts/advanced/component_caching/#custom-cache-name","title":"Custom cache name","text":"<p>Since component caching uses Django's cache framework, you can specify a custom cache name with <code>Component.Cache.cache_name</code> to use a different cache backend:</p> <pre><code>class MyComponent(Component):\n    class Cache:\n        enabled = True\n        cache_name = \"my_cache\"\n</code></pre>"},{"location":"concepts/advanced/component_caching/#cache-key-generation","title":"Cache key generation","text":"<p>By default, the cache key is generated based on the component's input (args and kwargs). So the following two calls would generate separate entries in the cache:</p> <pre><code>MyComponent.render(name=\"Alice\")\nMyComponent.render(name=\"Bob\")\n</code></pre> <p>However, you have full control over the cache key generation. As such, you can:</p> <ul> <li>Cache the component on all inputs (default)</li> <li>Cache the component on particular inputs</li> <li>Cache the component irrespective of the inputs</li> </ul> <p>To achieve that, you can override the <code>Component.Cache.hash()</code> method to customize how arguments are hashed into the cache key.</p> <pre><code>class MyComponent(Component):\n    class Cache:\n        enabled = True\n\n        def hash(self, *args, **kwargs):\n            return f\"{json.dumps(args)}:{json.dumps(kwargs)}\"\n</code></pre> <p>For even more control, you can override other methods available on the <code>ComponentCache</code> class.</p> <p>Warning</p> <p>The default implementation of <code>Cache.hash()</code> simply serializes the input into a string. As such, it might not be suitable if you need to hash complex objects like Models.</p>"},{"location":"concepts/advanced/component_caching/#caching-slots","title":"Caching slots","text":"<p>By default, the cache key is generated based ONLY on the args and kwargs.</p> <p>To cache the component based on the slots, set <code>Component.Cache.include_slots</code> to <code>True</code>:</p> <pre><code>class MyComponent(Component):\n    class Cache:\n        enabled = True\n        include_slots = True\n</code></pre> <p>with <code>include_slots = True</code>, the cache key will be generated also based on the given slots.</p> <p>As such, the following two calls would generate separate entries in the cache:</p> <pre><code>{% component \"my_component\" position=\"left\" %}\n    Hello, Alice\n{% endcomponent %}\n\n{% component \"my_component\" position=\"left\" %}\n    Hello, Bob\n{% endcomponent %}\n</code></pre> <p>Same when using <code>Component.render()</code> with string slots:</p> <pre><code>MyComponent.render(\n    kwargs={\"position\": \"left\"},\n    slots={\"content\": \"Hello, Alice\"}\n)\nMyComponent.render(\n    kwargs={\"position\": \"left\"},\n    slots={\"content\": \"Hello, Bob\"}\n)\n</code></pre> <p>Warning</p> <p>Passing slots as functions to cached components with <code>include_slots=True</code> will raise an error.</p> <pre><code>MyComponent.render(\n    kwargs={\"position\": \"left\"},\n    slots={\"content\": lambda ctx: \"Hello, Alice\"}\n)\n</code></pre> <p>Warning</p> <p>Slot caching DOES NOT account for context variables within the <code>{% fill %}</code> tag.</p> <p>For example, the following two cases will be treated as the same entry:</p> <pre><code>{% with my_var=\"foo\" %}\n    {% component \"mycomponent\" name=\"foo\" %}\n        {{ my_var }}\n    {% endcomponent %}\n{% endwith %}\n\n{% with my_var=\"bar\" %}\n    {% component \"mycomponent\" name=\"bar\" %}\n        {{ my_var }}\n    {% endcomponent %}\n{% endwith %}\n</code></pre> <p>Currently it's impossible to capture used variables. This will be addressed in v2. Read more about it in django-components/#1164.</p>"},{"location":"concepts/advanced/component_caching/#example","title":"Example","text":"<p>Here's a complete example of a component with caching enabled:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    template = \"Hello, {{ name }}\"\n\n    class Cache:\n        enabled = True\n        ttl = 300  # Cache for 5 minutes\n        cache_name = \"my_cache\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"name\": kwargs[\"name\"]}\n</code></pre> <p>In this example, the component's rendered output is cached for 5 minutes using the <code>my_cache</code> backend.</p>"},{"location":"concepts/advanced/component_context_scope/","title":"Component context and scope","text":"<p>By default, context variables are passed down the template as in regular Django - deeper scopes can access the variables from the outer scopes. So if you have several nested forloops, then inside the deep-most loop you can access variables defined by all previous loops.</p> <p>With this in mind, the <code>{% component %}</code> tag behaves similarly to <code>{% include %}</code> tag - inside the component tag, you can access all variables that were defined outside of it.</p> <p>And just like with <code>{% include %}</code>, if you don't want a specific component template to have access to the parent context, add <code>only</code> to the <code>{% component %}</code> tag:</p> <pre><code>{% component \"calendar\" date=\"2015-06-19\" only / %}\n</code></pre> <p>NOTE: <code>{% csrf_token %}</code> tags need access to the top-level context, and they will not function properly if they are rendered in a component that is called with the <code>only</code> modifier.</p> <p>If you find yourself using the <code>only</code> modifier often, you can set the context_behavior option to <code>\"isolated\"</code>, which automatically applies the <code>only</code> modifier. This is useful if you want to make sure that components don't accidentally access the outer context.</p> <p>Components can also access the outer context in their context methods like <code>get_template_data</code> by accessing the property <code>self.outer_context</code>.</p>"},{"location":"concepts/advanced/component_context_scope/#example-of-accessing-outer-context","title":"Example of Accessing Outer Context","text":"<pre><code>&lt;div&gt;\n  {% component \"calender\" / %}\n&lt;/div&gt;\n</code></pre> <p>Assuming that the rendering context has variables such as <code>date</code>, you can use <code>self.outer_context</code> to access them from within <code>get_template_data</code>. Here's how you might implement it:</p> <pre><code>class Calender(Component):\n\n    ...\n\n    def get_template_data(self, args, kwargs, slots, context):\n        outer_field = self.outer_context[\"date\"]\n        return {\n            \"date\": outer_fields,\n        }\n</code></pre> <p>However, as a best practice, it\u2019s recommended not to rely on accessing the outer context directly through <code>self.outer_context</code>. Instead, explicitly pass the variables to the component. For instance, continue passing the variables in the component tag as shown in the previous examples.</p>"},{"location":"concepts/advanced/component_context_scope/#context-behavior","title":"Context behavior","text":"<p>django_components supports both Django and Vue-like behavior when it comes to passing data to and through components. This can be configured in context_behavior.</p> <p>This has two modes:</p> <ul> <li> <p><code>\"django\"</code></p> <p>The default Django template behavior.</p> <p>Inside the <code>{% fill %}</code> tag, the context variables you can access are a union of:</p> <ul> <li>All the variables that were OUTSIDE the fill tag, including any\\   <code>{% with %}</code> tags.</li> <li>Any loops (<code>{% for ... %}</code>)   that the <code>{% fill %}</code> tag is part of.</li> <li>Data returned from <code>Component.get_template_data()</code>   of the component that owns the fill tag.</li> </ul> </li> <li> <p><code>\"isolated\"</code></p> <p>Similar behavior to Vue or React, this is useful if you want to make sure that components don't accidentally access variables defined outside of the component.</p> <p>Inside the <code>{% fill %}</code> tag, you can ONLY access variables from 2 places:</p> <ul> <li>Any loops (<code>{% for ... %}</code>)   that the <code>{% fill %}</code> tag is part of.</li> <li><code>Component.get_template_data()</code>   of the component which defined the template (AKA the \"root\" component).</li> </ul> </li> </ul> <p>Warning</p> <p>Notice that the component whose <code>get_template_data()</code> we use inside <code>{% fill %}</code> is NOT the same across the two modes!</p> <p>Consider this example:</p> <pre><code>class Outer(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% component \"inner\" %}\n          {% fill \"content\" %}\n            {{ my_var }}\n          {% endfill %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <ul> <li> <p><code>\"django\"</code> - <code>my_var</code> has access to data from <code>get_template_data()</code> of both <code>Inner</code> and <code>Outer</code>.   If there are variables defined in both, then <code>Inner</code> overshadows <code>Outer</code>.</p> </li> <li> <p><code>\"isolated\"</code> - <code>my_var</code> has access to data from <code>get_template_data()</code> of ONLY <code>Outer</code>.</p> </li> </ul>"},{"location":"concepts/advanced/component_context_scope/#example-django","title":"Example \"django\"","text":"<p>Given this template:</p> <pre><code>@register(\"root_comp\")\nclass RootComp(Component):\n    template = \"\"\"\n        {% with cheese=\"feta\" %}\n            {% component 'my_comp' %}\n                {{ my_var }}  # my_var\n                {{ cheese }}  # cheese\n            {% endcomponent %}\n        {% endwith %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return { \"my_var\": 123 }\n</code></pre> <p>Then if <code>get_template_data()</code> of the component <code>\"my_comp\"</code> returns following data:</p> <pre><code>{ \"my_var\": 456 }\n</code></pre> <p>Then the template will be rendered as:</p> <pre><code>456   # my_var\nfeta  # cheese\n</code></pre> <p>Because <code>\"my_comp\"</code> overshadows the outer variable <code>\"my_var\"</code>, so <code>{{ my_var }}</code> equals <code>456</code>.</p> <p>And variable <code>\"cheese\"</code> equals <code>feta</code>, because the fill CAN access all the data defined in the outer layers, like the <code>{% with %}</code> tag.</p>"},{"location":"concepts/advanced/component_context_scope/#example-isolated","title":"Example \"isolated\"","text":"<p>Given this template:</p> <pre><code>class RootComp(Component):\n    template = \"\"\"\n        {% with cheese=\"feta\" %}\n            {% component 'my_comp' %}\n                {{ my_var }}  # my_var\n                {{ cheese }}  # cheese\n            {% endcomponent %}\n        {% endwith %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return { \"my_var\": 123 }\n</code></pre> <p>Then if <code>get_template_data()</code> of the component <code>\"my_comp\"</code> returns following data:</p> <pre><code>{ \"my_var\": 456 }\n</code></pre> <p>Then the template will be rendered as:</p> <pre><code>123   # my_var\n    # cheese\n</code></pre> <p>Because variables <code>\"my_var\"</code> and <code>\"cheese\"</code> are searched only inside <code>RootComponent.get_template_data()</code>. But since <code>\"cheese\"</code> is not defined there, it's empty.</p> <p>Info</p> <p>Notice that the variables defined with the <code>{% with %}</code> tag are ignored inside the <code>{% fill %}</code> tag with the <code>\"isolated\"</code> mode.</p>"},{"location":"concepts/advanced/component_libraries/","title":"Component libraries","text":"<p>You can publish and share your components for others to use. Below you will find the steps to do so.</p> <p>For live examples, see the Examples.</p>"},{"location":"concepts/advanced/component_libraries/#writing-component-libraries","title":"Writing component libraries","text":"<ol> <li> <p>Create a Django project with a similar structure:</p> <pre><code>project/\n  |--  myapp/\n    |--  __init__.py\n    |--  apps.py\n    |--  templates/\n      |--  table/\n        |--  table.py\n        |--  table.js\n        |--  table.css\n        |--  table.html\n    |--  menu.py   &lt;--- single-file component\n  |--  templatetags/\n    |--  __init__.py\n    |--  mytags.py\n</code></pre> </li> <li> <p>Create custom <code>Library</code>     and <code>ComponentRegistry</code> instances in <code>mytags.py</code></p> <p>This will be the entrypoint for using the components inside Django templates.</p> <p>Remember that Django requires the <code>Library</code> instance to be accessible under the <code>register</code> variable (See Django docs):</p> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry, RegistrySettings\n\nregister = library = django.template.Library()\ncomp_registry = ComponentRegistry(\n    library=library,\n    settings=RegistrySettings(\n        context_behavior=\"isolated\",\n        tag_formatter=\"django_components.component_formatter\",\n    ),\n)\n</code></pre> <p>As you can see above, this is also the place where we configure how our components should behave, using the <code>settings</code> argument. If omitted, default settings are used.</p> <p>For library authors, we recommend setting <code>context_behavior</code> to <code>\"isolated\"</code>, so that the state cannot leak into the components, and so the components' behavior is configured solely through the inputs. This means that the components will be more predictable and easier to debug.</p> <p>Next, you can decide how will others use your components by setting the <code>tag_formatter</code> options.</p> <p>If omitted or set to <code>\"django_components.component_formatter\"</code>, your components will be used like this:</p> <pre><code>{% component \"table\" items=items headers=headers %}\n{% endcomponent %}\n</code></pre> <p>Or you can use <code>\"django_components.component_shorthand_formatter\"</code> to use components like so:</p> <pre><code>{% table items=items headers=headers %}\n{% endtable %}\n</code></pre> <p>Or you can define a custom TagFormatter.</p> <p>Either way, these settings will be scoped only to your components. So, in the user code, there may be components side-by-side that use different formatters:</p> <pre><code>{% load mytags %}\n\n{# Component from your library \"mytags\", using the \"shorthand\" formatter #}\n{% table items=items headers=header %}\n{% endtable %}\n\n{# User-created components using the default settings #}\n{% component \"my_comp\" title=\"Abc...\" %}\n{% endcomponent %}\n</code></pre> </li> <li> <p>Write your components and register them with your instance of <code>ComponentRegistry</code></p> <p>There's one difference when you are writing components that are to be shared, and that's that the components must be explicitly registered with your instance of <code>ComponentRegistry</code> from the previous step.</p> <p>For better user experience, you can also define the types for the args, kwargs, slots and data.</p> <p>It's also a good idea to have a common prefix for your components, so they can be easily distinguished from users' components. In the example below, we use the prefix <code>my_</code> / <code>My</code>.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, SlotInput, register, types\n\nfrom myapp.templatetags.mytags import comp_registry\n\n# Define the component\n# NOTE: Don't forget to set the `registry`!\n@register(\"my_menu\", registry=comp_registry)\nclass MyMenu(Component):\n    # Define the types\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        vertical: Optional[bool] = None\n        klass: Optional[str] = None\n        style: Optional[str] = None\n\n    class Slots(NamedTuple):\n        default: Optional[SlotInput] = None\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        attrs = ...\n        return {\n            \"attrs\": attrs,\n        }\n\n    template: types.django_html = \"\"\"\n        {# Load django_components template tags #}\n        {% load component_tags %}\n\n        &lt;div {% html_attrs attrs class=\"my-menu\" %}&gt;\n            &lt;div class=\"my-menu__content\"&gt;\n                {% slot \"default\" default / %}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n</code></pre> </li> <li> <p>Import the components in <code>apps.py</code></p> <p>Normally, users rely on autodiscovery and <code>COMPONENTS.dirs</code> to load the component files.</p> <p>Since you, as the library author, are not in control of the file system, it is recommended to load the components manually.</p> <p>We recommend doing this in the <code>AppConfig.ready()</code> hook of your <code>apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\nclass MyAppConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"myapp\"\n\n    # This is the code that gets run when user adds myapp\n    # to Django's INSTALLED_APPS\n    def ready(self) -&gt; None:\n        # Import the components that you want to make available\n        # inside the templates.\n        from myapp.templates import (\n            menu,\n            table,\n        )\n</code></pre> <p>Note that you can also include any other startup logic within <code>AppConfig.ready()</code>.</p> </li> </ol> <p>And that's it! The next step is to publish it.</p>"},{"location":"concepts/advanced/component_libraries/#publishing-component-libraries","title":"Publishing component libraries","text":"<p>Once you are ready to share your library, you need to build a distribution and then publish it to PyPI.</p> <p>django_components uses the <code>build</code> utility to build a distribution:</p> <pre><code>python -m build --sdist --wheel --outdir dist/ .\n</code></pre> <p>And to publish to PyPI, you can use <code>twine</code> (See Python user guide)</p> <pre><code>twine upload --repository pypi dist/* -u __token__ -p &lt;PyPI_TOKEN&gt;\n</code></pre> <p>Notes on publishing:</p> <ul> <li>If you use components where the HTML / CSS / JS files are separate, you may need to define   <code>MANIFEST.in</code>   to include those files with the distribution   (see user guide).</li> </ul>"},{"location":"concepts/advanced/component_libraries/#installing-and-using-component-libraries","title":"Installing and using component libraries","text":"<p>After the package has been published, all that remains is to install it in other django projects:</p> <ol> <li> <p>Install the package:</p> <pre><code>pip install myapp django_components\n</code></pre> </li> <li> <p>Add the package to <code>INSTALLED_APPS</code></p> <pre><code>INSTALLED_APPS = [\n    ...\n    \"django_components\",\n    \"myapp\",\n]\n</code></pre> </li> <li> <p>Optionally add the template tags to the <code>builtins</code>,    so you don't have to call <code>{% load mytags %}</code> in every template:</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            'builtins': [\n                'myapp.templatetags.mytags',\n            ]\n        },\n    },\n]\n</code></pre> </li> <li> <p>And, at last, you can use the components in your own project!</p> <pre><code>{% my_menu title=\"Abc...\" %}\n    Hello World!\n{% endmy_menu %}\n</code></pre> </li> </ol>"},{"location":"concepts/advanced/component_registry/","title":"Registering components","text":"<p>In previous examples you could repeatedly see us using <code>@register()</code> to \"register\" the components. In this section we dive deeper into what it actually means and how you can manage (add or remove) components.</p> <p>As a reminder, we may have a component like this:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"template.html\"\n\n    # This component takes one parameter, a date string to show in the template\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n</code></pre> <p>which we then render in the template as:</p> <pre><code>{% component \"calendar\" date=\"1970-01-01\" %}\n{% endcomponent %}\n</code></pre> <p>As you can see, <code>@register</code> links up the component class with the <code>{% component %}</code> template tag. So when the template tag comes across a component called <code>\"calendar\"</code>, it can look up it's class and instantiate it.</p>"},{"location":"concepts/advanced/component_registry/#what-is-componentregistry","title":"What is ComponentRegistry","text":"<p>The <code>@register</code> decorator is a shortcut for working with the <code>ComponentRegistry</code>.</p> <p><code>ComponentRegistry</code> manages which components can be used in the template tags.</p> <p>Each <code>ComponentRegistry</code> instance is associated with an instance of Django's <code>Library</code>. And Libraries are inserted into Django template using the <code>{% load %}</code> tags.</p> <p>The <code>@register</code> decorator accepts an optional kwarg <code>registry</code>, which specifies, the <code>ComponentRegistry</code> to register components into. If omitted, the default <code>ComponentRegistry</code> instance defined in django_components is used.</p> <pre><code>my_registry = ComponentRegistry()\n\n@register(registry=my_registry)\nclass MyComponent(Component):\n    ...\n</code></pre> <p>The default <code>ComponentRegistry</code> is associated with the <code>Library</code> that you load when you call <code>{% load component_tags %}</code> inside your template, or when you add <code>django_components.templatetags.component_tags</code> to the template builtins.</p> <p>So when you register or unregister a component to/from a component registry, then behind the scenes the registry automatically adds/removes the component's template tags to/from the Library, so you can call the component from within the templates such as <code>{% component \"my_comp\" %}</code>.</p>"},{"location":"concepts/advanced/component_registry/#working-with-componentregistry","title":"Working with ComponentRegistry","text":"<p>The default <code>ComponentRegistry</code> instance can be imported as:</p> <pre><code>from django_components import registry\n</code></pre> <p>You can use the registry to manually add/remove/get components:</p> <pre><code>from django_components import registry\n\n# Register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n\n# Get all or single\nregistry.all()  # {\"button\": ButtonComponent, \"card\": CardComponent}\nregistry.get(\"card\")  # CardComponent\n\n# Check if component is registered\nregistry.has(\"button\")  # True\n\n# Unregister single component\nregistry.unregister(\"card\")\n\n# Unregister all components\nregistry.clear()\n</code></pre>"},{"location":"concepts/advanced/component_registry/#registering-components-to-custom-componentregistry","title":"Registering components to custom ComponentRegistry","text":"<p>If you are writing a component library to be shared with others, you may want to manage your own instance of <code>ComponentRegistry</code> and register components onto a different <code>Library</code> instance than the default one.</p> <p>The <code>Library</code> instance can be set at instantiation of <code>ComponentRegistry</code>. If omitted, then the default Library instance from django_components is used.</p> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry\n\nmy_library = Library(...)\nmy_registry = ComponentRegistry(library=my_library)\n</code></pre> <p>When you have defined your own <code>ComponentRegistry</code>, you can either register the components with <code>my_registry.register()</code>, or pass the registry to the <code>@component.register()</code> decorator via the <code>registry</code> kwarg:</p> <pre><code>from path.to.my.registry import my_registry\n\n@register(\"my_component\", registry=my_registry)\nclass MyComponent(Component):\n    ...\n</code></pre> <p>NOTE: The Library instance can be accessed under <code>library</code> attribute of <code>ComponentRegistry</code>.</p>"},{"location":"concepts/advanced/component_registry/#componentregistry-settings","title":"ComponentRegistry settings","text":"<p>When you are creating an instance of <code>ComponentRegistry</code>, you can define the components' behavior within the template.</p> <p>The registry accepts these settings:</p> <ul> <li><code>context_behavior</code></li> <li><code>tag_formatter</code></li> </ul> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry, RegistrySettings\n\nregister = library = django.template.Library()\ncomp_registry = ComponentRegistry(\n    library=library,\n    settings=RegistrySettings(\n        context_behavior=\"isolated\",\n        tag_formatter=\"django_components.component_formatter\",\n    ),\n)\n</code></pre> <p>These settings are the same as the ones you can set for django_components.</p> <p>In fact, when you set <code>COMPONENT.tag_formatter</code> or <code>COMPONENT.context_behavior</code>, these are forwarded to the default <code>ComponentRegistry</code>.</p> <p>This makes it possible to have multiple registries with different settings in one projects, and makes sharing of component libraries possible.</p>"},{"location":"concepts/advanced/extensions/","title":"Extensions","text":"<p>New in version 0.131</p> <p>Django-components functionality can be extended with \"extensions\". Extensions allow for powerful customization and integrations. They can:</p> <ul> <li>Tap into lifecycle events, such as when a component is created, deleted, registered, or unregistered.</li> <li>Add new attributes and methods to the components under an extension-specific nested class.</li> <li>Define custom commands that can be executed via the Django management command interface.</li> </ul>"},{"location":"concepts/advanced/extensions/#live-examples","title":"Live examples","text":"<ul> <li>djc-ext-pydantic</li> </ul>"},{"location":"concepts/advanced/extensions/#install-extensions","title":"Install extensions","text":"<p>Extensions are configured in the Django settings under <code>COMPONENTS.extensions</code>.</p> <p>Extensions can be set by either as an import string or by passing in a class:</p> <pre><code># settings.py\n\nclass MyExtension(ComponentExtension):\n    name = \"my_extension\"\n\n    class ComponentConfig(ExtensionComponentConfig):\n        ...\n\nCOMPONENTS = ComponentsSettings(\n    extensions=[\n        MyExtension,\n        \"another_app.extensions.AnotherExtension\",\n        \"my_app.extensions.ThirdExtension\",\n    ],\n)\n</code></pre>"},{"location":"concepts/advanced/extensions/#lifecycle-hooks","title":"Lifecycle hooks","text":"<p>Extensions can define methods to hook into lifecycle events, such as:</p> <ul> <li>Component creation or deletion</li> <li>Un/registering a component</li> <li>Creating or deleting a registry</li> <li>Pre-processing data passed to a component on render</li> <li>Post-processing data returned from <code>get_template_data()</code>   and others.</li> </ul> <p>See the full list in Extension Hooks Reference.</p>"},{"location":"concepts/advanced/extensions/#per-component-configuration","title":"Per-component configuration","text":"<p>Each extension has a corresponding nested class within the <code>Component</code> class. These allow to configure the extensions on a per-component basis.</p> <p>E.g.:</p> <ul> <li><code>\"view\"</code> extension -&gt; <code>Component.View</code></li> <li><code>\"cache\"</code> extension -&gt; <code>Component.Cache</code></li> <li><code>\"defaults\"</code> extension -&gt; <code>Component.Defaults</code></li> </ul> <p>Note</p> <p>Accessing the component instance from inside the nested classes:</p> <p>Each method of the nested classes has access to the <code>component</code> attribute, which points to the component instance.</p> <pre><code>class MyTable(Component):\n    class MyExtension:\n        def get(self, request):\n            # `self.component` points to the instance of `MyTable` Component.\n            return self.component.render_to_response(request=request)\n</code></pre>"},{"location":"concepts/advanced/extensions/#example-component-as-view","title":"Example: Component as View","text":"<p>The Components as Views feature is actually implemented as an extension that is configured by a <code>View</code> nested class.</p> <p>You can override the <code>get()</code>, <code>post()</code>, etc methods to customize the behavior of the component as a view:</p> <pre><code>class MyTable(Component):\n    class View:\n        def get(self, request):\n            return self.component_class.render_to_response(request=request)\n\n        def post(self, request):\n            return self.component_class.render_to_response(request=request)\n\n        ...\n</code></pre>"},{"location":"concepts/advanced/extensions/#example-storybook-integration","title":"Example: Storybook integration","text":"<p>The Storybook integration (work in progress) is an extension that is configured by a <code>Storybook</code> nested class.</p> <p>You can override methods such as <code>title</code>, <code>parameters</code>, etc, to customize how to generate a Storybook JSON file from the component.</p> <pre><code>class MyTable(Component):\n    class Storybook:\n        def title(self):\n            return self.component_cls.__name__\n\n        def parameters(self) -&gt; Parameters:\n            return {\n                \"server\": {\n                    \"id\": self.component_cls.__name__,\n                }\n            }\n\n        def stories(self) -&gt; List[StoryAnnotations]:\n            return []\n\n        ...\n</code></pre>"},{"location":"concepts/advanced/extensions/#extension-defaults","title":"Extension defaults","text":"<p>Extensions are incredibly flexible, but configuring the same extension for every component can be a pain.</p> <p>For this reason, django-components allows for extension defaults. This is like setting the extension config for every component.</p> <p>To set extension defaults, use the <code>COMPONENTS.extensions_defaults</code> setting.</p> <p>The <code>extensions_defaults</code> setting is a dictionary where the key is the extension name and the value is a dictionary of config attributes:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    extensions=[\n        \"my_extension.MyExtension\",\n        \"storybook.StorybookExtension\",\n    ],\n    extensions_defaults={\n        \"my_extension\": {\n            \"key\": \"value\",\n        },\n        \"view\": {\n            \"public\": True,\n        },\n        \"cache\": {\n            \"ttl\": 60,\n        },\n        \"storybook\": {\n            \"title\": lambda self: self.component_cls.__name__,\n        },\n    },\n)\n</code></pre> <p>Which is equivalent to setting the following for every component:</p> <pre><code>class MyTable(Component):\n    class MyExtension:\n        key = \"value\"\n\n    class View:\n        public = True\n\n    class Cache:\n        ttl = 60\n\n    class Storybook:\n        def title(self):\n            return self.component_cls.__name__\n</code></pre> <p>Info</p> <p>If you define an attribute as a function, it is like defining a method on the extension class.</p> <p>E.g. in the example above, <code>title</code> is a method on the <code>Storybook</code> extension class.</p> <p>As the name suggests, these are defaults, and so you can still selectively override them on a per-component basis:</p> <pre><code>class MyTable(Component):\n    class View:\n        public = False\n</code></pre>"},{"location":"concepts/advanced/extensions/#extensions-in-component-instances","title":"Extensions in component instances","text":"<p>Above, we've configured extensions <code>View</code> and <code>Storybook</code> for the <code>MyTable</code> component.</p> <p>You can access the instances of these extension classes in the component instance.</p> <p>Extensions are available under their names (e.g. <code>self.view</code>, <code>self.storybook</code>).</p> <p>For example, the View extension is available as <code>self.view</code>:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # `self.view` points to the instance of `View` extension.\n        return {\n            \"view\": self.view,\n        }\n</code></pre> <p>And the Storybook extension is available as <code>self.storybook</code>:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # `self.storybook` points to the instance of `Storybook` extension.\n        return {\n            \"title\": self.storybook.title(),\n        }\n</code></pre>"},{"location":"concepts/advanced/extensions/#writing-extensions","title":"Writing extensions","text":"<p>Creating extensions in django-components involves defining a class that inherits from <code>ComponentExtension</code>. This class can implement various lifecycle hooks and define new attributes or methods to be added to components.</p>"},{"location":"concepts/advanced/extensions/#extension-class","title":"Extension class","text":"<p>To create an extension, define a class that inherits from <code>ComponentExtension</code> and implement the desired hooks.</p> <ul> <li>Each extension MUST have a <code>name</code> attribute. The name MUST be a valid Python identifier.</li> <li> <p>The extension may implement any of the hook methods.</p> <p>Each hook method receives a context object with relevant data.</p> </li> <li> <p>Extension may own URLs or CLI commands.</p> </li> </ul> <pre><code>from django_components.extension import ComponentExtension, OnComponentClassCreatedContext\n\nclass MyExtension(ComponentExtension):\n    name = \"my_extension\"\n\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext) -&gt; None:\n        # Custom logic for when a component class is created\n        ctx.component_cls.my_attr = \"my_value\"\n</code></pre> <p>Warning</p> <p>The <code>name</code> attribute MUST be unique across all extensions.</p> <p>Moreover, the <code>name</code> attribute MUST NOT conflict with existing Component class API.</p> <p>So if you name an extension <code>render</code>, it will conflict with the <code>render()</code> method of the <code>Component</code> class.</p>"},{"location":"concepts/advanced/extensions/#component-config","title":"Component config","text":"<p>In previous sections we've seen the <code>View</code> and <code>Storybook</code> extensions classes that were nested within the <code>Component</code> class:</p> <pre><code>class MyComponent(Component):\n    class View:\n        ...\n\n    class Storybook:\n        ...\n</code></pre> <p>These can be understood as component-specific overrides or configuration.</p> <p>Whether it's <code>Component.View</code> or <code>Component.Storybook</code>, their respective extensions defined how these nested classes will behave.</p> <p>For example, the View extension defines the API that users may override in <code>ViewExtension.ComponentConfig</code>:</p> <pre><code>from django_components.extension import ComponentExtension, ExtensionComponentConfig\n\nclass ViewExtension(ComponentExtension):\n    name = \"view\"\n\n    # The default behavior of the `View` extension class.\n    class ComponentConfig(ExtensionComponentConfig):\n        def get(self, request):\n            raise NotImplementedError(\"You must implement the `get` method.\")\n\n        def post(self, request):\n            raise NotImplementedError(\"You must implement the `post` method.\")\n\n        ...\n</code></pre> <p>In any component that then defines a nested <code>Component.View</code> extension class, the resulting <code>View</code> class will actually subclass from the <code>ViewExtension.ComponentConfig</code> class.</p> <p>In other words, when you define a component like this:</p> <pre><code>class MyTable(Component):\n    class View:\n        def get(self, request):\n            # Do something\n            ...\n</code></pre> <p>Behind the scenes it is as if you defined the following:</p> <pre><code>class MyTable(Component):\n    class View(ViewExtension.ComponentConfig):\n        def get(self, request):\n            # Do something\n            ...\n</code></pre> <p>Warning</p> <p>When writing an extension, the <code>ComponentConfig</code> MUST subclass the base class <code>ExtensionComponentConfig</code>.</p> <p>This base class ensures that the extension class will have access to the component instance.</p>"},{"location":"concepts/advanced/extensions/#install-your-extension","title":"Install your extension","text":"<p>Once the extension is defined, it needs to be installed in the Django settings to be used by the application.</p> <p>Extensions can be given either as an extension class, or its import string:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"extensions\": [\n        \"my_app.extensions.MyExtension\",\n    ],\n}\n</code></pre> <p>Or by reference:</p> <pre><code># settings.py\nfrom my_app.extensions import MyExtension\n\nCOMPONENTS = {\n    \"extensions\": [\n        MyExtension,\n    ],\n}\n</code></pre>"},{"location":"concepts/advanced/extensions/#full-example-custom-logging-extension","title":"Full example: Custom logging extension","text":"<p>To tie it all together, here's an example of a custom logging extension that logs when components are created, deleted, or rendered:</p> <ul> <li>Each component can specify which color to use for the logging by setting <code>Component.ColorLogger.color</code>.</li> <li>The extension will log the component name and color when the component is created, deleted, or rendered.</li> </ul> <pre><code>from django_components.extension import (\n    ComponentExtension,\n    ExtensionComponentConfig,\n    OnComponentClassCreatedContext,\n    OnComponentClassDeletedContext,\n    OnComponentInputContext,\n)\n\n\nclass ColorLoggerExtension(ComponentExtension):\n    name = \"color_logger\"\n\n    # All `Component.ColorLogger` classes will inherit from this class.\n    class ComponentConfig(ExtensionComponentConfig):\n        color: str\n\n    # These hooks don't have access to the Component instance,\n    # only to the Component class, so we access the color\n    # as `Component.ColorLogger.color`.\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext):\n        log.info(\n            f\"Component {ctx.component_cls} created.\",\n            color=ctx.component_cls.ColorLogger.color,\n        )\n\n    def on_component_class_deleted(self, ctx: OnComponentClassDeletedContext):\n        log.info(\n            f\"Component {ctx.component_cls} deleted.\",\n            color=ctx.component_cls.ColorLogger.color,\n        )\n\n    # This hook has access to the Component instance, so we access the color\n    # as `self.component.color_logger.color`.\n    def on_component_input(self, ctx: OnComponentInputContext):\n        log.info(\n            f\"Rendering component {ctx.component_cls}.\",\n            color=ctx.component.color_logger.color,\n        )\n</code></pre> <p>To use the <code>ColorLoggerExtension</code>, add it to your settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"extensions\": [\n        ColorLoggerExtension,\n    ],\n}\n</code></pre> <p>Once installed, in any component, you can define a <code>ColorLogger</code> attribute:</p> <pre><code>class MyComponent(Component):\n    class ColorLogger:\n        color = \"red\"\n</code></pre> <p>This will log the component name and color when the component is created, deleted, or rendered.</p>"},{"location":"concepts/advanced/extensions/#utility-functions","title":"Utility functions","text":"<p>django-components provides a few utility functions to help with writing extensions:</p> <ul> <li><code>all_components()</code> - returns a list of all created component classes.</li> <li><code>all_registries()</code> - returns a list of all created registry instances.</li> </ul>"},{"location":"concepts/advanced/extensions/#access-component-class","title":"Access component class","text":"<p>You can access the owner <code>Component</code> class (<code>MyTable</code>) from within methods of the extension class (<code>MyExtension</code>) by using the <code>component_cls</code> attribute:</p> <pre><code>class MyTable(Component):\n    class MyExtension:\n        def some_method(self):\n            print(self.component_cls)\n</code></pre> <p>Here is how the <code>component_cls</code> attribute may be used with our <code>ColorLogger</code> extension shown above:</p> <pre><code>class ColorLoggerComponentConfig(ExtensionComponentConfig):\n    color: str\n\n    def log(self, msg: str) -&gt; None:\n        print(f\"{self.component_cls.__name__}: {msg}\")\n\n\nclass ColorLoggerExtension(ComponentExtension):\n    name = \"color_logger\"\n\n    # All `Component.ColorLogger` classes will inherit from this class.\n    ComponentConfig = ColorLoggerComponentConfig\n</code></pre>"},{"location":"concepts/advanced/extensions/#pass-slot-metadata","title":"Pass slot metadata","text":"<p>When a slot is passed to a component, it is copied, so that the original slot is not modified with rendering metadata.</p> <p>Therefore, don't use slot's identity to associate metadata with the slot:</p> <pre><code># \u274c Don't do this:\nslots_cache = {}\n\nclass LoggerExtension(ComponentExtension):\n    name = \"logger\"\n\n    def on_component_input(self, ctx: OnComponentInputContext):\n        for slot in ctx.component.slots.values():\n            slots_cache[id(slot)] = {\"some\": \"metadata\"}\n</code></pre> <p>Instead, use the <code>Slot.extra</code> attribute, which is copied from the original slot:</p> <pre><code># \u2705 Do this:\nclass LoggerExtension(ComponentExtension):\n    name = \"logger\"\n\n    # Save component-level logger settings for each slot when a component is rendered.\n    def on_component_input(self, ctx: OnComponentInputContext):\n        for slot in ctx.component.slots.values():\n            slot.extra[\"logger\"] = ctx.component.logger\n\n    # Then, when a fill is rendered with `{% slot %}`, we can access the logger settings\n    # from the slot's metadata.\n    def on_slot_rendered(self, ctx: OnSlotRenderedContext):\n        logger = ctx.slot.extra[\"logger\"]\n        logger.log(...)\n</code></pre>"},{"location":"concepts/advanced/extensions/#extension-commands","title":"Extension commands","text":"<p>Extensions in django-components can define custom commands that can be executed via the Django management command interface. This allows for powerful automation and customization capabilities.</p> <p>For example, if you have an extension that defines a command that prints \"Hello world\", you can run the command with:</p> <pre><code>python manage.py components ext run my_ext hello\n</code></pre> <p>Where:</p> <ul> <li><code>python manage.py components</code> - is the Django entrypoint</li> <li><code>ext run</code> - is the subcommand to run extension commands</li> <li><code>my_ext</code> - is the extension name</li> <li><code>hello</code> - is the command name</li> </ul>"},{"location":"concepts/advanced/extensions/#define-commands","title":"Define commands","text":"<p>To define a command, subclass from <code>ComponentCommand</code>. This subclass should define:</p> <ul> <li><code>name</code> - the command's name</li> <li><code>help</code> - the command's help text</li> <li><code>handle</code> - the logic to execute when the command is run</li> </ul> <pre><code>from django_components import ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n\n    def handle(self, *args, **kwargs):\n        print(\"Hello, world!\")\n\nclass MyExt(ComponentExtension):\n    name = \"my_ext\"\n    commands = [HelloCommand]\n</code></pre>"},{"location":"concepts/advanced/extensions/#define-arguments-and-options","title":"Define arguments and options","text":"<p>Commands can accept positional arguments and options (e.g. <code>--foo</code>), which are defined using the <code>arguments</code> attribute of the <code>ComponentCommand</code> class.</p> <p>The arguments are parsed with <code>argparse</code> into a dictionary of arguments and options. These are then available as keyword arguments to the <code>handle</code> method of the command.</p> <pre><code>from django_components import CommandArg, ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n\n    arguments = [\n        # Positional argument\n        CommandArg(\n            name_or_flags=\"name\",\n            help=\"The name to say hello to\",\n        ),\n        # Optional argument\n        CommandArg(\n            name_or_flags=[\"--shout\", \"-s\"],\n            action=\"store_true\",\n            help=\"Shout the hello\",\n        ),\n    ]\n\n    def handle(self, name: str, *args, **kwargs):\n        shout = kwargs.get(\"shout\", False)\n        msg = f\"Hello, {name}!\"\n        if shout:\n            msg = msg.upper()\n        print(msg)\n</code></pre> <p>You can run the command with arguments and options:</p> <pre><code>python manage.py components ext run my_ext hello John --shout\n&gt;&gt;&gt; HELLO, JOHN!\n</code></pre> <p>Note</p> <p>Command definitions are parsed with <code>argparse</code>, so you can use all the features of <code>argparse</code> to define your arguments and options.</p> <p>See the argparse documentation for more information.</p> <p>django-components defines types as <code>CommandArg</code>, <code>CommandArgGroup</code>, <code>CommandSubcommand</code>, and <code>CommandParserInput</code> to help with type checking.</p> <p>Note</p> <p>If a command doesn't have the <code>handle</code> method defined, the command will print a help message and exit.</p>"},{"location":"concepts/advanced/extensions/#argument-groups","title":"Argument groups","text":"<p>Arguments can be grouped using <code>CommandArgGroup</code> to provide better organization and help messages.</p> <p>Read more on argparse argument groups.</p> <pre><code>from django_components import CommandArg, CommandArgGroup, ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n\n    # Argument parsing is managed by `argparse`.\n    arguments = [\n        # Positional argument\n        CommandArg(\n            name_or_flags=\"name\",\n            help=\"The name to say hello to\",\n        ),\n        # Optional argument\n        CommandArg(\n            name_or_flags=[\"--shout\", \"-s\"],\n            action=\"store_true\",\n            help=\"Shout the hello\",\n        ),\n        # When printing the command help message, `--bar` and `--baz`\n        # will be grouped under \"group bar\".\n        CommandArgGroup(\n            title=\"group bar\",\n            description=\"Group description.\",\n            arguments=[\n                CommandArg(\n                    name_or_flags=\"--bar\",\n                    help=\"Bar description.\",\n                ),\n                CommandArg(\n                    name_or_flags=\"--baz\",\n                    help=\"Baz description.\",\n                ),\n            ],\n        ),\n    ]\n\n    def handle(self, name: str, *args, **kwargs):\n        shout = kwargs.get(\"shout\", False)\n        msg = f\"Hello, {name}!\"\n        if shout:\n            msg = msg.upper()\n        print(msg)\n</code></pre>"},{"location":"concepts/advanced/extensions/#subcommands","title":"Subcommands","text":"<p>Extensions can define subcommands, allowing for more complex command structures.</p> <p>Subcommands are defined similarly to root commands, as subclasses of <code>ComponentCommand</code> class.</p> <p>However, instead of defining the subcommands in the <code>commands</code> attribute of the extension, you define them in the <code>subcommands</code> attribute of the parent command:</p> <pre><code>from django_components import CommandArg, CommandArgGroup, ComponentCommand, ComponentExtension\n\nclass ChildCommand(ComponentCommand):\n    name = \"child\"\n    help = \"Child command\"\n\n    def handle(self, *args, **kwargs):\n        print(\"Child command\")\n\nclass ParentCommand(ComponentCommand):\n    name = \"parent\"\n    help = \"Parent command\"\n    subcommands = [\n        ChildCommand,\n    ]\n\n    def handle(self, *args, **kwargs):\n        print(\"Parent command\")\n</code></pre> <p>In this example, we can run two commands.</p> <p>Either the parent command:</p> <pre><code>python manage.py components ext run parent\n&gt;&gt;&gt; Parent command\n</code></pre> <p>Or the child command:</p> <pre><code>python manage.py components ext run parent child\n&gt;&gt;&gt; Child command\n</code></pre> <p>Warning</p> <p>Subcommands are independent of the parent command. When a subcommand runs, the parent command is NOT executed.</p> <p>As such, if you want to pass arguments to both the parent and child commands, e.g.:</p> <pre><code>python manage.py components ext run parent --foo child --bar\n</code></pre> <p>You should instead pass all the arguments to the subcommand:</p> <pre><code>python manage.py components ext run parent child --foo --bar\n</code></pre>"},{"location":"concepts/advanced/extensions/#help-message","title":"Help message","text":"<p>By default, all commands will print their help message when run with the <code>--help</code> / <code>-h</code> flag.</p> <pre><code>python manage.py components ext run my_ext --help\n</code></pre> <p>The help message prints out all the arguments and options available for the command, as well as any subcommands.</p>"},{"location":"concepts/advanced/extensions/#testing-commands","title":"Testing commands","text":"<p>Commands can be tested using Django's <code>call_command()</code> function, which allows you to simulate running the command in tests.</p> <pre><code>from django.core.management import call_command\n\ncall_command('components', 'ext', 'run', 'my_ext', 'hello', '--name', 'John')\n</code></pre> <p>To capture the output of the command, you can use the <code>StringIO</code> module to redirect the output to a string:</p> <pre><code>from io import StringIO\n\nout = StringIO()\nwith patch(\"sys.stdout\", new=out):\n    call_command('components', 'ext', 'run', 'my_ext', 'hello', '--name', 'John')\noutput = out.getvalue()\n</code></pre> <p>And to temporarily set the extensions, you can use the <code>@djc_test</code> decorator.</p> <p>Thus, a full test example can then look like this:</p> <pre><code>from io import StringIO\nfrom unittest.mock import patch\n\nfrom django.core.management import call_command\nfrom django_components.testing import djc_test\n\n@djc_test(\n    components_settings={\n        \"extensions\": [\n            \"my_app.extensions.MyExtension\",\n        ],\n    },\n)\ndef test_hello_command(self):\n    out = StringIO()\n    with patch(\"sys.stdout\", new=out):\n        call_command('components', 'ext', 'run', 'my_ext', 'hello', '--name', 'John')\n    output = out.getvalue()\n    assert output == \"Hello, John!\\n\"\n</code></pre>"},{"location":"concepts/advanced/extensions/#extension-urls","title":"Extension URLs","text":"<p>Extensions can define custom views and endpoints that can be accessed through the Django application.</p> <p>To define URLs for an extension, set them in the <code>urls</code> attribute of your <code>ComponentExtension</code> class. Each URL is defined using the <code>URLRoute</code> class, which specifies the path, handler, and optional name for the route.</p> <p>Here's an example of how to define URLs within an extension:</p> <pre><code>from django_components.extension import ComponentExtension, URLRoute\nfrom django.http import HttpResponse\n\ndef my_view(request):\n    return HttpResponse(\"Hello from my extension!\")\n\nclass MyExtension(ComponentExtension):\n    name = \"my_extension\"\n\n    urls = [\n        URLRoute(path=\"my-view/\", handler=my_view, name=\"my_view\"),\n        URLRoute(path=\"another-view/&lt;int:id&gt;/\", handler=my_view, name=\"another_view\"),\n    ]\n</code></pre> <p>Warning</p> <p>The <code>URLRoute</code> objects are different from objects created with Django's <code>django.urls.path()</code>. Do NOT use <code>URLRoute</code> objects in Django's <code>urlpatterns</code> and vice versa!</p> <p>django-components uses a custom <code>URLRoute</code> class to define framework-agnostic routing rules.</p> <p>As of v0.131, <code>URLRoute</code> objects are directly converted to Django's <code>URLPattern</code> and <code>URLResolver</code> objects.</p>"},{"location":"concepts/advanced/extensions/#url-paths","title":"URL paths","text":"<p>The URLs defined in an extension are available under the path</p> <pre><code>/components/ext/&lt;extension_name&gt;/\n</code></pre> <p>For example, if you have defined a URL with the path <code>my-view/&lt;str:name&gt;/</code> in an extension named <code>my_extension</code>, it can be accessed at:</p> <pre><code>/components/ext/my_extension/my-view/john/\n</code></pre>"},{"location":"concepts/advanced/extensions/#nested-urls","title":"Nested URLs","text":"<p>Extensions can also define nested URLs to allow for more complex routing structures.</p> <p>To define nested URLs, set the <code>children</code> attribute of the <code>URLRoute</code> object to a list of child <code>URLRoute</code> objects:</p> <pre><code>class MyExtension(ComponentExtension):\n    name = \"my_extension\"\n\n    urls = [\n        URLRoute(\n            path=\"parent/\",\n            name=\"parent_view\",\n            children=[\n                URLRoute(path=\"child/&lt;str:name&gt;/\", handler=my_view, name=\"child_view\"),\n            ],\n        ),\n    ]\n</code></pre> <p>In this example, the URL</p> <pre><code>/components/ext/my_extension/parent/child/john/\n</code></pre> <p>would call the <code>my_view</code> handler with the parameter <code>name</code> set to <code>\"John\"</code>.</p>"},{"location":"concepts/advanced/extensions/#extra-url-data","title":"Extra URL data","text":"<p>The <code>URLRoute</code> class is framework-agnostic, so that extensions could be used with non-Django frameworks in the future.</p> <p>However, that means that there may be some extra fields that Django's <code>django.urls.path()</code> accepts, but which are not defined on the <code>URLRoute</code> object.</p> <p>To address this, the <code>URLRoute</code> object has an <code>extra</code> attribute, which is a dictionary that can be used to pass any extra kwargs to <code>django.urls.path()</code>:</p> <pre><code>URLRoute(\n    path=\"my-view/&lt;str:name&gt;/\",\n    handler=my_view,\n    name=\"my_view\",\n    extra={\"kwargs\": {\"foo\": \"bar\"} },\n)\n</code></pre> <p>Is the same as:</p> <pre><code>django.urls.path(\n    \"my-view/&lt;str:name&gt;/\",\n    view=my_view,\n    name=\"my_view\",\n    kwargs={\"foo\": \"bar\"},\n)\n</code></pre> <p>because <code>URLRoute</code> is converted to Django's route like so:</p> <pre><code>django.urls.path(\n    route.path,\n    view=route.handler,\n    name=route.name,\n    **route.extra,\n)\n</code></pre>"},{"location":"concepts/advanced/hooks/","title":"Lifecycle hooks","text":"<p>New in version 0.96</p> <p>Intercept the rendering lifecycle with Component hooks.</p> <p>Unlike the extension hooks, these are defined directly on the <code>Component</code> class.</p>"},{"location":"concepts/advanced/hooks/#available-hooks","title":"Available hooks","text":""},{"location":"concepts/advanced/hooks/#on_render_before","title":"<code>on_render_before</code>","text":"<pre><code>def on_render_before(\n    self: Component,\n    context: Context,\n    template: Optional[Template],\n) -&gt; None:\n</code></pre> <p><code>Component.on_render_before</code> runs just before the component's template is rendered.</p> <p>It is called for every component, including nested ones, as part of the component render lifecycle.</p> <p>It receives the Context and the Template as arguments.</p> <p>The <code>template</code> argument is <code>None</code> if the component has no template.</p> <p>Example:</p> <p>You can use this hook to access the context or the template:</p> <pre><code>from django.template import Context, Template\nfrom django_components import Component\n\nclass MyTable(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        # Insert value into the Context\n        context[\"from_on_before\"] = \":)\"\n\n        assert isinstance(template, Template)\n</code></pre> <p>Warning</p> <p>If you want to pass data to the template, prefer using <code>get_template_data()</code> instead of this hook.</p> <p>Warning</p> <p>Do NOT modify the template in this hook. The template is reused across renders.</p>"},{"location":"concepts/advanced/hooks/#on_render","title":"<code>on_render</code>","text":"<p>New in version 0.140</p> <pre><code>def on_render(\n    self: Component,\n    context: Context,\n    template: Optional[Template],\n) -&gt; Union[str, SafeString, OnRenderGenerator, None]:\n</code></pre> <p><code>Component.on_render</code> does the actual rendering.</p> <p>You can override this method to:</p> <ul> <li>Change what template gets rendered</li> <li>Modify the context</li> <li>Modify the rendered output after it has been rendered</li> <li>Handle errors</li> </ul> <p>The default implementation renders the component's Template with the given Context.</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        if template:\n            return template.render(context)\n</code></pre> <p>The <code>template</code> argument is <code>None</code> if the component has no template.</p>"},{"location":"concepts/advanced/hooks/#modifying-rendered-template","title":"Modifying rendered template","text":"<p>To change what gets rendered, you can:</p> <ul> <li>Render a component</li> <li>Render a template</li> <li>Return a string or SafeString</li> </ul> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        # Return a string\n        return \"&lt;p&gt;Hello&lt;/p&gt;\"\n\n        # Render a component\n        return MyOtherTable.render(\n            args=self.args,\n            kwargs=self.kwargs,\n            slots=self.slots,\n            context=context,\n        )\n\n        # Render a template\n        return get_template(\"my_other_table.html\").render(context)\n</code></pre> <p>You can also use <code>on_render()</code> as a router, rendering other components based on the parent component's arguments:</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        # Select different component based on `feature_new_table` kwarg\n        if self.kwargs.get(\"feature_new_table\"):\n            comp_cls = NewTable\n        else:\n            comp_cls = OldTable\n\n        # Render the selected component\n        return comp_cls.render(\n            args=self.args,\n            kwargs=self.kwargs,\n            slots=self.slots,\n            context=context,\n        )\n</code></pre>"},{"location":"concepts/advanced/hooks/#post-processing-rendered-template","title":"Post-processing rendered template","text":"<p>When you render the original template in <code>on_render()</code> as:</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        result = template.render(context)\n</code></pre> <p>The result is NOT the final output, but an intermediate result. Nested components are not rendered yet.</p> <p>Instead, django-components needs to take this result and process it to actually render the child components.</p> <p>This is not a problem when you return the result directly as above. Django-components will take care of rendering the child components.</p> <p>But if you want to access the final output, you must <code>yield</code> the result instead of returning it.</p> <p>Yielding the result will return a tuple of <code>(rendered_html, error)</code>:</p> <ul> <li>On success, the error is <code>None</code> - <code>(string, None)</code></li> <li>On failure, the rendered HTML is <code>None</code> - <code>(None, Exception)</code></li> </ul> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n\n        if error is None:\n            # The rendering succeeded\n            return html\n        else:\n            # The rendering failed\n            print(f\"Error: {error}\")\n</code></pre> <p>Warning</p> <p>Notice that we actually yield a lambda function instead of the result itself. This is because calling <code>template.render(context)</code> may raise an exception.</p> <p>When you wrap the result in a lambda function, and the rendering fails, the error will be yielded back in the <code>(None, Exception)</code> tuple.</p> <p>At this point you can do 3 things:</p> <ol> <li> <p>Return new HTML</p> <p>The new HTML will be used as the final output.</p> <p>If the original template raised an error, the original error will be ignored.</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n\n        # Fallback if rendering failed\n        # Otherwise, we keep the original HTML\n        if error is not None:\n            return \"FALLBACK HTML\"\n</code></pre> </li> <li> <p>Raise new exception</p> <p>The new exception is what will bubble up from the component.</p> <p>The original HTML and original error will be ignored.</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n\n        # Override the original error\n        # Otherwise, we keep the original HTML\n        if error is not None:\n            raise Exception(\"My new error\") from error\n</code></pre> </li> <li> <p>No change - Return nothing or <code>None</code></p> <p>If you neither raise an exception, nor return a new HTML, then the original HTML / error will be used:</p> <ul> <li>If rendering succeeded, the original HTML will be used as the final output.</li> <li>If rendering failed, the original error will be propagated.</li> </ul> <p>This can be useful for side effects like tracking the errors that occurred during the rendering:</p> <pre><code>from myapp.metrics import track_rendering_error\n\nclass MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n\n        # Track how many times the rendering failed\n        if error is not None:\n            track_rendering_error(error)\n</code></pre> </li> </ol>"},{"location":"concepts/advanced/hooks/#multiple-yields","title":"Multiple yields","text":"<p>You can yield multiple times within the same <code>on_render()</code> method. This is useful for complex rendering scenarios:</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        # First yield\n        with context.push({\"mode\": \"header\"}):\n            header_html, header_error = yield lambda: template.render(context)\n\n        # Second yield\n        with context.push({\"mode\": \"body\"}):\n            body_html, body_error = yield lambda: template.render(context)\n\n        # Third yield\n        footer_html, footer_error = yield \"Footer content\"\n\n        # Process all\n        if header_error or body_error or footer_error:\n            return \"Error occurred during rendering\"\n\n        return f\"{header_html}\\n{body_html}\\n{footer_html}\"\n</code></pre> <p>Each yield operation is independent and returns its own <code>(html, error)</code> tuple, allowing you to handle each rendering result separately.</p>"},{"location":"concepts/advanced/hooks/#example-errorboundary","title":"Example: ErrorBoundary","text":"<p><code>on_render()</code> can be used to implement React's ErrorBoundary.</p> <p>That is, a component that catches errors in nested components and displays a fallback UI instead:</p> <pre><code>{% component \"error_boundary\" %}\n  {% fill \"default\" %}\n    {% component \"nested_component\" %}\n  {% endfill %}\n  {% fill \"fallback\" %}\n    Sorry, something went wrong.\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>To implement this, we render the fallback slot in <code>on_render()</code> and return it if an error occured:</p> <pre><code>from typing import NamedTuple, Optional\n\nfrom django.template import Context, Template\nfrom django.utils.safestring import mark_safe\nfrom django_components import Component, OnRenderGenerator, SlotInput, types\n\nclass ErrorFallback(Component):\n    class Slots(NamedTuple):\n        default: Optional[SlotInput] = None\n        fallback: Optional[SlotInput] = None\n\n    template: types.django_html = \"\"\"\n        {% if not error %}\n            {% slot \"default\" default / %}\n        {% else %}\n            {% slot \"fallback\" error=error / %}\n        {% endif %}\n    \"\"\"\n\n    def on_render(\n        self,\n        context: Context,\n        template: Template,\n    ) -&gt; OnRenderGenerator:\n        fallback_slot = self.slots.default\n\n        result, error = yield lambda: template.render(context)\n\n        # No error, return the original result\n        if error is None:\n            return None\n\n        # Error, return the fallback\n        if fallback_slot is not None:\n            # Render the template second time, this time rendering\n            # the fallback branch\n            with context.push({\"error\": error}):\n                return template.render(context)\n        else:\n            return mark_safe(\"&lt;pre&gt;An error occurred&lt;/pre&gt;\")\n</code></pre>"},{"location":"concepts/advanced/hooks/#on_render_after","title":"<code>on_render_after</code>","text":"<pre><code>def on_render_after(\n    self: Component,\n    context: Context,\n    template: Optional[Template],\n    result: Optional[str | SafeString],\n    error: Optional[Exception],\n) -&gt; Union[str, SafeString, None]:\n</code></pre> <p><code>on_render_after()</code> runs when the component was fully rendered, including all its children.</p> <p>It receives the same arguments as <code>on_render_before()</code>, plus the outcome of the rendering:</p> <ul> <li><code>result</code>: The rendered output of the component. <code>None</code> if the rendering failed.</li> <li><code>error</code>: The error that occurred during the rendering, or <code>None</code> if the rendering succeeded.</li> </ul> <p><code>on_render_after()</code> behaves the same way as the second part of <code>on_render()</code> (after the <code>yield</code>).</p> <pre><code>class MyTable(Component):\n    def on_render_after(self, context, template, result, error):\n        # If rendering succeeded, keep the original result\n        # Otherwise, print the error\n        if error is not None:\n            print(f\"Error: {error}\")\n</code></pre> <p>Same as <code>on_render()</code>, you can return a new HTML, raise a new exception, or return nothing:</p> <ol> <li> <p>Return new HTML</p> <p>The new HTML will be used as the final output.</p> <p>If the original template raised an error, the original error will be ignored.</p> <pre><code>class MyTable(Component):\n    def on_render_after(self, context, template, result, error):\n        # Fallback if rendering failed\n        # Otherwise, we keep the original HTML\n        if error is not None:\n            return \"FALLBACK HTML\"\n</code></pre> </li> <li> <p>Raise new exception</p> <p>The new exception is what will bubble up from the component.</p> <p>The original HTML and original error will be ignored.</p> <pre><code>class MyTable(Component):\n    def on_render_after(self, context, template, result, error):\n        # Override the original error\n        # Otherwise, we keep the original HTML\n        if error is not None:\n            raise Exception(\"My new error\") from error\n</code></pre> </li> <li> <p>No change - Return nothing or <code>None</code></p> <p>If you neither raise an exception, nor return a new HTML, then the original HTML / error will be used:</p> <ul> <li>If rendering succeeded, the original HTML will be used as the final output.</li> <li>If rendering failed, the original error will be propagated.</li> </ul> <p>This can be useful for side effects like tracking the errors that occurred during the rendering:</p> <pre><code>from myapp.metrics import track_rendering_error\n\nclass MyTable(Component):\n    def on_render_after(self, context, template, result, error):\n        # Track how many times the rendering failed\n        if error is not None:\n            track_rendering_error(error)\n</code></pre> </li> </ol>"},{"location":"concepts/advanced/hooks/#example-tabs","title":"Example: Tabs","text":"<p>You can use hooks together with provide / inject to create components that accept a list of items via a slot.</p> <p>In the example below, each <code>tab_item</code> component will be rendered on a separate tab page, but they are all defined in the default slot of the <code>tabs</code> component.</p> <p>See here for how it was done</p> <pre><code>{% component \"tabs\" %}\n  {% component \"tab_item\" header=\"Tab 1\" %}\n    &lt;p&gt;\n      hello from tab 1\n    &lt;/p&gt;\n    {% component \"button\" %}\n      Click me!\n    {% endcomponent %}\n  {% endcomponent %}\n\n  {% component \"tab_item\" header=\"Tab 2\" %}\n    Hello this is tab 2\n  {% endcomponent %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/advanced/html_fragments/","title":"HTML fragments","text":"<p>Django-components provides a seamless integration with HTML fragments with AJAX (HTML over the wire), whether you're using jQuery, HTMX, AlpineJS, vanilla JavaScript, or other.</p> <p>If the fragment component has any JS or CSS, django-components will:</p> <ul> <li>Automatically load the associated JS and CSS</li> <li>Ensure that JS is loaded and executed only once even if the fragment is inserted multiple times</li> </ul> <p>Info</p> <p>What are HTML fragments and \"HTML over the wire\"?</p> <p>It is one of the methods for updating the state in the browser UI upon user interaction.</p> <p>How it works is that:</p> <ol> <li>User makes an action - clicks a button or submits a form</li> <li>The action causes a request to be made from the client to the server.</li> <li>Server processes the request (e.g. form submission), and responds with HTML    of some part of the UI (e.g. a new entry in a table).</li> <li>A library like HTMX, AlpineJS, or custom function inserts the new HTML into    the correct place.</li> </ol>"},{"location":"concepts/advanced/html_fragments/#document-and-fragment-strategies","title":"Document and fragment strategies","text":"<p>Components support different \"strategies\" for rendering JS and CSS.</p> <p>Two of them are used to enable HTML fragments - \"document\" and \"fragment\".</p> <p>What's the difference?</p>"},{"location":"concepts/advanced/html_fragments/#document-strategy","title":"Document strategy","text":"<p>Document strategy assumes that the rendered components will be embedded into the HTML of the initial page load. This means that:</p> <ul> <li>The JS and CSS is embedded into the HTML as <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags   (see Default JS / CSS locations)</li> <li>Django-components injects a JS script for managing JS and CSS assets</li> </ul> <p>A component is rendered as a \"document\" when:</p> <ul> <li>It is embedded inside a template as <code>{% component %}</code></li> <li>It is rendered with <code>Component.render()</code> or <code>Component.render_to_response()</code>   with the <code>deps_strategy</code> kwarg set to <code>\"document\"</code> (default)</li> </ul> <p>Example:</p> <pre><code>MyTable.render(\n    kwargs={...},\n)\n\n# or\n\nMyTable.render(\n    kwargs={...},\n    deps_strategy=\"document\",\n)\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#fragment-strategy","title":"Fragment strategy","text":"<p>Fragment strategy assumes that the main HTML has already been rendered and loaded on the page. The component renders HTML that will be inserted into the page as a fragment, at a LATER time:</p> <ul> <li>JS and CSS is not directly embedded to avoid duplicately executing the same JS scripts.   So template tags like <code>{% component_js_dependencies %}</code>   inside of fragments are ignored.</li> <li>Instead, django-components appends the fragment's content with a JSON <code>&lt;script&gt;</code> to trigger a call   to its asset manager JS script, which will load the JS and CSS smartly.</li> <li>The asset manager JS script is assumed to be already loaded on the page.</li> </ul> <p>A component is rendered as \"fragment\" when:</p> <ul> <li>It is rendered with <code>Component.render()</code>   or <code>Component.render_to_response()</code>   with the <code>deps_strategy</code> kwarg set to <code>\"fragment\"</code></li> </ul> <p>Example:</p> <pre><code>MyTable.render(\n    kwargs={...},\n    deps_strategy=\"fragment\",\n)\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#live-examples","title":"Live examples","text":"<p>For live interactive examples, start our demo project (<code>sampleproject</code>).</p> <p>Then navigate to these URLs:</p> <ul> <li><code>/fragment/base/alpine</code></li> <li><code>/fragment/base/htmx</code></li> <li><code>/fragment/base/js</code></li> </ul>"},{"location":"concepts/advanced/html_fragments/#example-htmx","title":"Example - HTMX","text":""},{"location":"concepts/advanced/html_fragments/#1-define-document-html","title":"1. Define document HTML","text":"<p>This is the HTML into which a fragment will be loaded using HTMX.</p> [root]/components/demo.py<pre><code>from django_components import Component, types\n\nclass MyPage(Component):\n    template = \"\"\"\n        {% load component_tags %}\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n            &lt;head&gt;\n                {% component_css_dependencies %}\n                &lt;script src=\"https://unpkg.com/htmx.org@1.9.12\"&gt;&lt;/script&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div id=\"target\"&gt;OLD&lt;/div&gt;\n\n                &lt;button\n                    hx-get=\"/mypage/frag\"\n                    hx-swap=\"outerHTML\"\n                    hx-target=\"#target\"\n                &gt;\n                  Click me!\n                &lt;/button&gt;\n\n                {% component_js_dependencies %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    \"\"\"\n\n    class View:\n        def get(self, request):\n            return self.component_cls.render_to_response(request=request)\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#2-define-fragment-html","title":"2. Define fragment HTML","text":"<p>The fragment to be inserted into the document.</p> <p>IMPORTANT: Don't forget to set <code>deps_strategy=\"fragment\"</code></p> [root]/components/demo.py<pre><code>class Frag(Component):\n    template = \"\"\"\n        &lt;div class=\"frag\"&gt;\n            123\n            &lt;span id=\"frag-text\"&gt;&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    js = \"\"\"\n        document.querySelector('#frag-text').textContent = 'xxx';\n    \"\"\"\n\n    css = \"\"\"\n        .frag {\n            background: blue;\n        }\n    \"\"\"\n\n    class View:\n        def get(self, request):\n            return self.component_cls.render_to_response(\n                request=request,\n                # IMPORTANT: Don't forget `deps_strategy=\"fragment\"`\n                deps_strategy=\"fragment\",\n            )\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#3-create-view-and-urls","title":"3. Create view and URLs","text":"[app]/urls.py<pre><code>from django.urls import path\n\nfrom components.demo import MyPage, Frag\n\nurlpatterns = [\n    path(\"mypage/\", MyPage.as_view())\n    path(\"mypage/frag\", Frag.as_view()),\n]\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#example-alpinejs","title":"Example - AlpineJS","text":""},{"location":"concepts/advanced/html_fragments/#1-define-document-html_1","title":"1. Define document HTML","text":"<p>This is the HTML into which a fragment will be loaded using AlpineJS.</p> [root]/components/demo.py<pre><code>from django_components import Component, types\n\nclass MyPage(Component):\n    template = \"\"\"\n        {% load component_tags %}\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n            &lt;head&gt;\n                {% component_css_dependencies %}\n                &lt;script defer src=\"https://unpkg.com/alpinejs\"&gt;&lt;/script&gt;\n            &lt;/head&gt;\n            &lt;body x-data=\"{\n                htmlVar: 'OLD',\n                loadFragment: function () {\n                    const url = '/mypage/frag';\n                    fetch(url)\n                        .then(response =&gt; response.text())\n                        .then(html =&gt; {\n                            this.htmlVar = html;\n                        });\n                }\n            }\"&gt;\n                &lt;div id=\"target\" x-html=\"htmlVar\"&gt;OLD&lt;/div&gt;\n\n                &lt;button @click=\"loadFragment\"&gt;\n                  Click me!\n                &lt;/button&gt;\n\n                {% component_js_dependencies %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    \"\"\"\n\n    class View:\n        def get(self, request):\n            return self.component_cls.render_to_response(request=request)\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#2-define-fragment-html_1","title":"2. Define fragment HTML","text":"<p>The fragment to be inserted into the document.</p> <p>IMPORTANT: Don't forget to set <code>deps_strategy=\"fragment\"</code></p> [root]/components/demo.py<pre><code>class Frag(Component):\n    # NOTE: We wrap the actual fragment in a template tag with x-if=\"false\" to prevent it\n    #       from being rendered until we have registered the component with AlpineJS.\n    template = \"\"\"\n        &lt;template x-if=\"false\" data-name=\"frag\"&gt;\n            &lt;div class=\"frag\"&gt;\n                123\n                &lt;span x-data=\"frag\" x-text=\"fragVal\"&gt;\n                &lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/template&gt;\n    \"\"\"\n\n    js = \"\"\"\n        Alpine.data('frag', () =&gt; ({\n            fragVal: 'xxx',\n        }));\n\n        // Now that the component has been defined in AlpineJS, we can \"activate\"\n        // all instances where we use the `x-data=\"frag\"` directive.\n        document.querySelectorAll('[data-name=\"frag\"]').forEach((el) =&gt; {\n            el.setAttribute('x-if', 'true');\n        });\n    \"\"\"\n\n    css = \"\"\"\n        .frag {\n            background: blue;\n        }\n    \"\"\"\n\n    class View:\n        def get(self, request):\n            return self.component_cls.render_to_response(\n                request=request,\n                # IMPORTANT: Don't forget `deps_strategy=\"fragment\"`\n                deps_strategy=\"fragment\",\n            )\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#3-create-view-and-urls_1","title":"3. Create view and URLs","text":"[app]/urls.py<pre><code>from django.urls import path\n\nfrom components.demo import MyPage, Frag\n\nurlpatterns = [\n    path(\"mypage/\", MyPage.as_view())\n    path(\"mypage/frag\", Frag.as_view()),\n]\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#example-vanilla-js","title":"Example - Vanilla JS","text":""},{"location":"concepts/advanced/html_fragments/#1-define-document-html_2","title":"1. Define document HTML","text":"<p>This is the HTML into which a fragment will be loaded using vanilla JS.</p> [root]/components/demo.py<pre><code>from django_components import Component, types\n\nclass MyPage(Component):\n    template = \"\"\"\n        {% load component_tags %}\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n            &lt;head&gt;\n                {% component_css_dependencies %}\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div id=\"target\"&gt;OLD&lt;/div&gt;\n\n                &lt;button&gt;\n                  Click me!\n                &lt;/button&gt;\n                &lt;script&gt;\n                    const url = `/mypage/frag`;\n                    document.querySelector('#loader').addEventListener('click', function () {\n                        fetch(url)\n                            .then(response =&gt; response.text())\n                            .then(html =&gt; {\n                                document.querySelector('#target').outerHTML = html;\n                            });\n                    });\n                &lt;/script&gt;\n\n                {% component_js_dependencies %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    \"\"\"\n\n    class View:\n        def get(self, request):\n            return self.component_cls.render_to_response(request=request)\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#2-define-fragment-html_2","title":"2. Define fragment HTML","text":"<p>The fragment to be inserted into the document.</p> <p>IMPORTANT: Don't forget to set <code>deps_strategy=\"fragment\"</code></p> [root]/components/demo.py<pre><code>class Frag(Component):\n    template = \"\"\"\n        &lt;div class=\"frag\"&gt;\n            123\n            &lt;span id=\"frag-text\"&gt;&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    js = \"\"\"\n        document.querySelector('#frag-text').textContent = 'xxx';\n    \"\"\"\n\n    css = \"\"\"\n        .frag {\n            background: blue;\n        }\n    \"\"\"\n\n    class View:\n        def get(self, request):\n            return self.component_cls.render_to_response(\n                request=request,\n                # IMPORTANT: Don't forget `deps_strategy=\"fragment\"`\n                deps_strategy=\"fragment\",\n            )\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#3-create-view-and-urls_2","title":"3. Create view and URLs","text":"[app]/urls.py<pre><code>from django.urls import path\n\nfrom components.demo import MyPage, Frag\n\nurlpatterns = [\n    path(\"mypage/\", MyPage.as_view())\n    path(\"mypage/frag\", Frag.as_view()),\n]\n</code></pre>"},{"location":"concepts/advanced/provide_inject/","title":"Prop drilling and provide / inject","text":"<p>New in version 0.80:</p> <p><code>django-components</code> supports the provide / inject pattern, similarly to React's Context Providers or Vue's provide / inject.</p> <p>This is achieved with the combination of:</p> <ul> <li><code>{% provide %}</code> tag</li> <li><code>Component.inject()</code> method</li> </ul>"},{"location":"concepts/advanced/provide_inject/#what-is-prop-drilling","title":"What is \"prop drilling\"","text":"<p>Prop drilling refers to a scenario in UI development where you need to pass data through many layers of a component tree to reach the nested components that actually need the data.</p> <p>Normally, you'd use props to send data from a parent component to its children. However, this straightforward method becomes cumbersome and inefficient if the data has to travel through many levels or if several components scattered at different depths all need the same piece of information.</p> <p>This results in a situation where the intermediate components, which don't need the data for their own functioning, end up having to manage and pass along these props. This clutters the component tree and makes the code verbose and harder to manage.</p> <p>A neat solution to avoid prop drilling is using the \"provide and inject\" technique.</p> <p>With provide / inject, a parent component acts like a data hub for all its descendants. This setup allows any component, no matter how deeply nested it is, to access the required data directly from this centralized provider without having to messily pass props down the chain. This approach significantly cleans up the code and makes it easier to maintain.</p> <p>This feature is inspired by Vue's Provide / Inject and React's Context / useContext.</p> <p>As the name suggest, using provide / inject consists of 2 steps</p> <ol> <li>Providing data</li> <li>Injecting provided data</li> </ol> <p>For examples of advanced uses of provide / inject, see this discussion.</p>"},{"location":"concepts/advanced/provide_inject/#providing-data","title":"Providing data","text":"<p>First we use the <code>{% provide %}</code> tag to define the data we want to \"provide\" (make available).</p> <pre><code>{% provide \"my_data\" hello=\"hi\" another=123 %}\n    {% component \"child\" / %}  &lt;--- Can access \"my_data\"\n{% endprovide %}\n\n{% component \"child\" / %}  &lt;--- Cannot access \"my_data\"\n</code></pre> <p>The first argument to the <code>{% provide %}</code> tag is the key by which we can later access the data passed to this tag. The key in this case is <code>\"my_data\"</code>.</p> <p>The key must resolve to a valid identifier (AKA a valid Python variable name).</p> <p>Next you define the data you want to \"provide\" by passing them as keyword arguments. This is similar to how you pass data to the <code>{% with %}</code> tag or the <code>{% slot %}</code> tag.</p> <p>Note</p> <p>Kwargs passed to <code>{% provide %}</code> are NOT added to the context. In the example below, the <code>{{ hello }}</code> won't render anything:</p> <pre><code>{% provide \"my_data\" hello=\"hi\" another=123 %}\n    {{ hello }}\n{% endprovide %}\n</code></pre> <p>Similarly to slots and fills, also provide's name argument can be set dynamically via a variable, a template expression, or a spread operator:</p> <pre><code>{% with my_name=\"my_name\" %}\n    {% provide name=my_name ... %}\n        ...\n    {% endprovide %}\n{% endwith %}\n</code></pre>"},{"location":"concepts/advanced/provide_inject/#injecting-data","title":"Injecting data","text":"<p>To \"inject\" (access) the data defined on the <code>{% provide %}</code> tag, you can use the <code>Component.inject()</code> method from within any other component methods.</p> <p>For a component to be able to \"inject\" some data, the component (<code>{% component %}</code> tag) must be nested inside the <code>{% provide %}</code> tag.</p> <p>In the example from previous section, we've defined two kwargs: <code>hello=\"hi\" another=123</code>. That means that if we now inject <code>\"my_data\"</code>, we get an object with 2 attributes - <code>hello</code> and <code>another</code>.</p> <pre><code>class ChildComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        my_data = self.inject(\"my_data\")\n        print(my_data.hello)    # hi\n        print(my_data.another)  # 123\n</code></pre> <p>First argument to <code>Component.inject()</code> is the key (or name) of the provided data. This must match the string that you used in the <code>{% provide %}</code> tag.</p> <p>If no provider with given key is found, <code>inject()</code> raises a <code>KeyError</code>.</p> <p>To avoid the error, you can pass a second argument to <code>inject()</code>. This will act as a default value similar to <code>dict.get(key, default)</code>:</p> <pre><code>class ChildComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        my_data = self.inject(\"invalid_key\", DEFAULT_DATA)\n        assert my_data == DEFAULT_DATA\n</code></pre> <p>Note</p> <p>The instance returned from <code>inject()</code> is immutable (subclass of <code>NamedTuple</code>). This ensures that the data returned from <code>inject()</code> will always have all the keys that were passed to the <code>{% provide %}</code> tag.</p> <p>Warning</p> <p><code>inject()</code> works strictly only during render execution. If you try to call <code>inject()</code> from outside, it will raise an error.</p>"},{"location":"concepts/advanced/provide_inject/#full-example","title":"Full example","text":"<pre><code>@register(\"child\")\nclass ChildComponent(Component):\n    template = \"\"\"\n        &lt;div&gt; {{ my_data.hello }} &lt;/div&gt;\n        &lt;div&gt; {{ my_data.another }} &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        my_data = self.inject(\"my_data\", \"default\")\n        return {\"my_data\": my_data}\n\ntemplate_str = \"\"\"\n    {% load component_tags %}\n    {% provide \"my_data\" hello=\"hi\" another=123 %}\n        {% component \"child\" / %}\n    {% endprovide %}\n\"\"\"\n</code></pre> <p>renders:</p> <pre><code>&lt;div&gt;hi&lt;/div&gt;\n&lt;div&gt;123&lt;/div&gt;\n</code></pre>"},{"location":"concepts/advanced/rendering_js_css/","title":"Rendering JS / CSS","text":""},{"location":"concepts/advanced/rendering_js_css/#introduction","title":"Introduction","text":"<p>Components consist of 3 parts - HTML, JS and CSS.</p> <p>Handling of HTML is straightforward - it is rendered as is, and inserted where the <code>{% component %}</code> tag is.</p> <p>However, handling of JS and CSS is more complex:</p> <ul> <li>JS and CSS is are inserted elsewhere in the HTML. As a best practice, JS is placed in the <code>&lt;body&gt;</code> HTML tag, and CSS in the <code>&lt;head&gt;</code>.</li> <li>Multiple components may use the same JS and CSS files. We don't want to load the same files multiple times.</li> <li>Fetching of JS and CSS may block the page, so the JS / CSS should be embedded in the HTML.</li> <li>Components inserted as HTML fragments need different handling for JS and CSS.</li> </ul>"},{"location":"concepts/advanced/rendering_js_css/#default-js-css-locations","title":"Default JS / CSS locations","text":"<p>If your components use JS and CSS then, by default, the JS and CSS will be automatically inserted into the HTML:</p> <ul> <li>CSS styles will be inserted at the end of the <code>&lt;head&gt;</code></li> <li>JS scripts will be inserted at the end of the <code>&lt;body&gt;</code></li> </ul> <p>If you want to place the dependencies elsewhere in the HTML, you can override the locations by inserting following Django template tags:</p> <ul> <li><code>{% component_js_dependencies %}</code> - Set new location(s) for JS scripts</li> <li><code>{% component_css_dependencies %}</code> - Set new location(s) for CSS styles</li> </ul> <p>So if you have a component with JS and CSS:</p> <pre><code>from django_components import Component, types\n\nclass MyButton(Component):\n    template: types.django_html = \"\"\"\n        &lt;button class=\"my-button\"&gt;\n            Click me!\n        &lt;/button&gt;\n    \"\"\"\n\n    js: types.js = \"\"\"\n        for (const btnEl of document.querySelectorAll(\".my-button\")) {\n            btnEl.addEventListener(\"click\", () =&gt; {\n                console.log(\"BUTTON CLICKED!\");\n            });\n        }\n    \"\"\"\n\n    css: types.css \"\"\"\n        .my-button {\n            background: green;\n        }\n    \"\"\"\n\n    class Media:\n        js = [\"/extra/script.js\"]\n        css = [\"/extra/style.css\"]\n</code></pre> <p>Then:</p> <ul> <li> <p>JS from <code>MyButton.js</code> and <code>MyButton.Media.js</code> will be rendered at the default place (<code>&lt;body&gt;</code>),   or in <code>{% component_js_dependencies %}</code>.</p> </li> <li> <p>CSS from <code>MyButton.css</code> and <code>MyButton.Media.css</code> will be rendered at the default place (<code>&lt;head&gt;</code>), or in <code>{% component_css_dependencies %}</code>.</p> </li> </ul> <p>And if you don't specify <code>{% component_dependencies %}</code> tags, it is the equivalent of:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;MyPage&lt;/title&gt;\n    ...\n    {% component_css_dependencies %}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;main&gt;\n      ...\n    &lt;/main&gt;\n    {% component_js_dependencies %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Warning</p> <p>If the rendered HTML does NOT contain neither <code>{% component_dependencies %}</code> template tags, nor <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> HTML tags, then the JS and CSS will NOT be inserted!</p> <p>To force the JS and CSS to be inserted, use the <code>\"append\"</code> or <code>\"prepend\"</code> strategies.</p>"},{"location":"concepts/advanced/rendering_js_css/#dependencies-strategies","title":"Dependencies strategies","text":"<p>The rendered HTML may be used in different contexts (browser, email, etc). If your components use JS and CSS scripts, you may need to handle them differently.</p> <p>The different ways for handling JS / CSS are called \"dependencies strategies\".</p> <p><code>render()</code> and <code>render_to_response()</code> accept a <code>deps_strategy</code> parameter, which controls where and how the JS / CSS are inserted into the HTML.</p> <pre><code>main_page = MainPage.render(deps_strategy=\"document\")\nfragment = MyComponent.render_to_response(deps_strategy=\"fragment\")\n</code></pre> <p>The <code>deps_strategy</code> parameter is set at the root of a component render tree, which is why it is not available for the <code>{% component %}</code> tag.</p> <p>When you use Django's <code>django.shortcuts.render()</code> or <code>Template.render()</code> to render templates, you can't directly set the <code>deps_strategy</code> parameter.</p> <p>In this case, you can set the <code>deps_strategy</code> with the <code>DJC_DEPS_STRATEGY</code> context variable.</p> <pre><code>from django.template.context import Context\nfrom django.shortcuts import render\n\nctx = Context({\"DJC_DEPS_STRATEGY\": \"fragment\"})\nfragment = render(request, \"my_component.html\", ctx=ctx)\n</code></pre> <p>Info</p> <p>The <code>deps_strategy</code> parameter is ultimately passed to <code>render_dependencies()</code>.</p> <p>Why is <code>deps_strategy</code> required?</p> <p>This is a technical limitation of the current implementation.</p> <p>When a component is rendered, django-components embeds metadata about the component's JS and CSS into the HTML.</p> <p>This way we can compose components together, and know which JS / CSS dependencies are needed.</p> <p>As the last step of rendering, django-components extracts this metadata and uses a selected strategy to insert the JS / CSS into the HTML.</p> <p>There are six dependencies strategies:</p> <ul> <li><code>document</code> (default)<ul> <li>Smartly inserts JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Requires the HTML to be rendered in a JS-enabled browser.</li> <li>Inserts extra script for managing fragments.</li> </ul> </li> <li><code>fragment</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>Fragment will fetch its own JS / CSS dependencies when inserted into the page.</li> <li>Requires the HTML to be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>simple</code><ul> <li>Smartly insert JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>prepend</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>append</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>ignore</code><ul> <li>HTML is left as-is. You can still process it with a different strategy later with   <code>render_dependencies()</code>.</li> <li>Used for inserting rendered HTML into other components.</li> </ul> </li> </ul>"},{"location":"concepts/advanced/rendering_js_css/#document","title":"<code>document</code>","text":"<p><code>deps_strategy=\"document\"</code> is the default. Use this if you are rendering a whole page, or if no other option suits better.</p> <pre><code>html = Button.render(deps_strategy=\"document\")\n</code></pre> <p>When you render a component tree with the <code>\"document\"</code> strategy, it is expected that:</p> <ul> <li>The HTML will be rendered at page load.</li> <li>The HTML will be inserted into a page / browser where JS can be executed.</li> </ul> <p>Location:</p> <p>JS and CSS is inserted:</p> <ul> <li>Preferentially into JS / CSS placeholders like <code>{% component_js_dependencies %}</code></li> <li>Otherwise, JS into <code>&lt;body&gt;</code> element, and CSS into <code>&lt;head&gt;</code> element</li> <li>If neither found, JS / CSS are NOT inserted</li> </ul> <p>Included scripts:</p> <p>For the <code>\"document\"</code> strategy, the JS and CSS is set up to avoid any delays when the end user loads the page in the browser:</p> <ul> <li> <p>Components' primary JS and CSS scripts (<code>Component.js</code>   and <code>Component.css</code>) - fully inlined:</p> <pre><code>&lt;script&gt;\n    console.log(\"Hello from Button!\");\n&lt;/script&gt;\n&lt;style&gt;\n    .button {\n        background-color: blue;\n    }\n&lt;/style&gt;\n</code></pre> </li> <li> <p>Components' secondary JS and CSS scripts   (<code>Component.Media</code>) - inserted as links:</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://example.com/styles.css\" /&gt;\n&lt;script src=\"https://example.com/script.js\"&gt;&lt;/script&gt;\n</code></pre> </li> <li> <p>A JS script is injected to manage component dependencies, enabling lazy loading of JS and CSS   for HTML fragments.</p> </li> </ul> <p>How the dependency manager works</p> <p>The dependency manager is a JS script that keeps track of all the JS and CSS dependencies that have already been loaded.</p> <p>When a fragment is inserted into the page, it will also insert a JSON <code>&lt;script&gt;</code> tag with fragment metadata.</p> <p>The dependency manager will pick up on that, and check which scripts the fragment needs.</p> <p>It will then fetch only the scripts that haven't been loaded yet.</p>"},{"location":"concepts/advanced/rendering_js_css/#fragment","title":"<code>fragment</code>","text":"<p><code>deps_strategy=\"fragment\"</code> is used when rendering a piece of HTML that will be inserted into a page:</p> <pre><code>fragment = MyComponent.render(deps_strategy=\"fragment\")\n</code></pre> <p>The HTML of fragments is very lightweight because it doesn't include the JS and CSS scripts of the rendered components.</p> <p>With fragments, even if a component has JS and CSS, you can insert the same component into a page hundreds of times, and the JS and CSS will only ever be loaded once.</p> <p>This is intended for dynamic content that's loaded with AJAX after the initial page load, such as with jQuery, HTMX, AlpineJS or similar libraries.</p> <p>Location:</p> <p>None. The fragment's JS and CSS files will be loaded dynamically into the page.</p> <p>Included scripts:</p> <ul> <li>A special JSON <code>&lt;script&gt;</code> tag that tells the dependency manager what JS and CSS to load.</li> </ul>"},{"location":"concepts/advanced/rendering_js_css/#simple","title":"<code>simple</code>","text":"<p><code>deps_strategy=\"simple\"</code> is used either for non-browser use cases, or when you don't want to use the dependency manager.</p> <p>Practically, this is the same as the <code>\"document\"</code> strategy, except that the dependency manager is not used.</p> <pre><code>html = MyComponent.render(deps_strategy=\"simple\")\n</code></pre> <p>Location:</p> <p>JS and CSS is inserted:</p> <ul> <li>Preferentially into JS / CSS placeholders like <code>{% component_js_dependencies %}</code></li> <li>Otherwise, JS into <code>&lt;body&gt;</code> element, and CSS into <code>&lt;head&gt;</code> element</li> <li>If neither found, JS / CSS are NOT inserted</li> </ul> <p>Included scripts:</p> <ul> <li> <p>Components' primary JS and CSS scripts (<code>Component.js</code>   and <code>Component.css</code>) - fully inlined:</p> <pre><code>&lt;script&gt;\n    console.log(\"Hello from Button!\");\n&lt;/script&gt;\n&lt;style&gt;\n    .button {\n        background-color: blue;\n    }\n&lt;/style&gt;\n</code></pre> </li> <li> <p>Components' secondary JS and CSS scripts   (<code>Component.Media</code>) - inserted as links:</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://example.com/styles.css\" /&gt;\n&lt;script src=\"https://example.com/script.js\"&gt;&lt;/script&gt;\n</code></pre> </li> <li> <p>No extra scripts are inserted.</p> </li> </ul>"},{"location":"concepts/advanced/rendering_js_css/#prepend","title":"<code>prepend</code>","text":"<p>This is the same as <code>\"simple\"</code>, but placeholders like <code>{% component_js_dependencies %}</code> and HTML tags <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> are all ignored. The JS and CSS are always inserted before the rendered content.</p> <pre><code>html = MyComponent.render(deps_strategy=\"prepend\")\n</code></pre> <p>Location:</p> <p>JS and CSS is always inserted before the rendered content.</p> <p>Included scripts:</p> <p>Same as for the <code>\"simple\"</code> strategy.</p>"},{"location":"concepts/advanced/rendering_js_css/#append","title":"<code>append</code>","text":"<p>This is the same as <code>\"simple\"</code>, but placeholders like <code>{% component_js_dependencies %}</code> and HTML tags <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> are all ignored. The JS and CSS are always inserted after the rendered content.</p> <pre><code>html = MyComponent.render(deps_strategy=\"append\")\n</code></pre> <p>Location:</p> <p>JS and CSS is always inserted after the rendered content.</p> <p>Included scripts:</p> <p>Same as for the <code>\"simple\"</code> strategy.</p>"},{"location":"concepts/advanced/rendering_js_css/#ignore","title":"<code>ignore</code>","text":"<p><code>deps_strategy=\"ignore\"</code> is used when you do NOT want to process JS and CSS of the rendered HTML.</p> <pre><code>html = MyComponent.render(deps_strategy=\"ignore\")\n</code></pre> <p>The rendered HTML is left as-is. You can still process it with a different strategy later with <code>render_dependencies()</code>.</p> <p>This is useful when you want to insert rendered HTML into another component.</p> <pre><code>html = MyComponent.render(deps_strategy=\"ignore\")\nhtml = AnotherComponent.render(slots={\"content\": html})\n</code></pre>"},{"location":"concepts/advanced/rendering_js_css/#manually-rendering-js-css","title":"Manually rendering JS / CSS","text":"<p>When rendering templates or components, django-components covers all the traditional ways how components or templates can be rendered:</p> <ul> <li><code>Component.render()</code></li> <li><code>Component.render_to_response()</code></li> <li><code>Template.render()</code></li> <li><code>django.shortcuts.render()</code></li> </ul> <p>This way you don't need to manually handle rendering of JS / CSS.</p> <p>However, for advanced or low-level use cases, you may need to control when to render JS / CSS.</p> <p>In such case you can directly pass rendered HTML to <code>render_dependencies()</code>.</p> <p>This function will extract all used components in the HTML string, and insert the components' JS and CSS based on given strategy.</p> <p>Info</p> <p>The truth is that all the methods listed above call <code>render_dependencies()</code> internally.</p> <p>Example:</p> <p>To see how <code>render_dependencies()</code> works, let's render a template with a component.</p> <p>We will render it twice:</p> <ul> <li>First time, we let <code>template.render()</code> handle the rendering.</li> <li> <p>Second time, we prevent <code>template.render()</code> from inserting the component's JS and CSS with <code>deps_strategy=\"ignore\"</code>.</p> <p>Instead, we pass the \"unprocessed\" HTML to <code>render_dependencies()</code> ourselves to insert the component's JS and CSS.</p> </li> </ul> <pre><code>from django.template.base import Template\nfrom django.template.context import Context\nfrom django_components import render_dependencies\n\ntemplate = Template(\"\"\"\n    {% load component_tags %}\n    &lt;!doctype html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;MyPage&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;main&gt;\n            {% component \"my_button\" %}\n                Click me!\n            {% endcomponent %}\n        &lt;/main&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n\"\"\")\n\nrendered = template.render(Context({}))\n\nrendered2_raw = template.render(Context({\"DJC_DEPS_STRATEGY\": \"ignore\"}))\nrendered2 = render_dependencies(rendered2_raw)\n\nassert rendered == rendered2\n</code></pre> <p>Same applies to other strategies and other methods of rendering:</p> <pre><code>raw_html = MyComponent.render(deps_strategy=\"ignore\")\nhtml = render_dependencies(raw_html, deps_strategy=\"document\")\n\nhtml2 = MyComponent.render(deps_strategy=\"document\")\n\nassert html == html2\n</code></pre>"},{"location":"concepts/advanced/rendering_js_css/#html-fragments","title":"HTML fragments","text":"<p>Django-components provides a seamless integration with HTML fragments with AJAX (HTML over the wire), whether you're using jQuery, HTMX, AlpineJS, vanilla JavaScript, or other.</p> <p>This is achieved by the <code>\"fragment\"</code> strategy.</p> <p>Read more about HTML fragments.</p>"},{"location":"concepts/advanced/tag_formatters/","title":"Tag formatters","text":""},{"location":"concepts/advanced/tag_formatters/#customizing-component-tags-with-tagformatter","title":"Customizing component tags with TagFormatter","text":"<p>New in version 0.89</p> <p>By default, components are rendered using the pair of <code>{% component %}</code> / <code>{% endcomponent %}</code> template tags:</p> <pre><code>{% component \"button\" href=\"...\" disabled %}\nClick me!\n{% endcomponent %}\n\n{# or #}\n\n{% component \"button\" href=\"...\" disabled / %}\n</code></pre> <p>You can change this behaviour in the settings under the <code>COMPONENTS.tag_formatter</code>.</p> <p>For example, if you set the tag formatter to</p> <p><code>django_components.component_shorthand_formatter</code></p> <p>then the components' names will be used as the template tags:</p> <pre><code>{% button href=\"...\" disabled %}\n  Click me!\n{% endbutton %}\n\n{# or #}\n\n{% button href=\"...\" disabled / %}\n</code></pre>"},{"location":"concepts/advanced/tag_formatters/#available-tagformatters","title":"Available TagFormatters","text":"<p>django_components provides following predefined TagFormatters:</p> <ul> <li><code>ComponentFormatter</code> (<code>django_components.component_formatter</code>)</li> </ul> <p>Default</p> <p>Uses the <code>component</code> and <code>endcomponent</code> tags, and the component name is gives as the first positional argument.</p> <p>Example as block:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    {% fill \"content\" %}\n        ...\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Example as inlined tag:</p> <pre><code>{% component \"button\" href=\"...\" / %}\n</code></pre> <ul> <li><code>ShorthandComponentFormatter</code> (<code>django_components.component_shorthand_formatter</code>)</li> </ul> <p>Uses the component name as start tag, and <code>end&lt;component_name&gt;</code>   as an end tag.</p> <p>Example as block:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> <p>Example as inlined tag:</p> <pre><code>{% button href=\"...\" / %}\n</code></pre>"},{"location":"concepts/advanced/tag_formatters/#writing-your-own-tagformatter","title":"Writing your own TagFormatter","text":""},{"location":"concepts/advanced/tag_formatters/#background","title":"Background","text":"<p>First, let's discuss how TagFormatters work, and how components are rendered in django_components.</p> <p>When you render a component with <code>{% component %}</code> (or your own tag), the following happens:</p> <ol> <li><code>component</code> must be registered as a Django's template tag</li> <li>Django triggers django_components's tag handler for tag <code>component</code>.</li> <li>The tag handler passes the tag contents for pre-processing to <code>TagFormatter.parse()</code>.</li> </ol> <p>So if you render this:</p> <pre><code>{% component \"button\" href=\"...\" disabled %}\n{% endcomponent %}\n</code></pre> <p>Then <code>TagFormatter.parse()</code> will receive a following input:</p> <pre><code>[\"component\", '\"button\"', 'href=\"...\"', 'disabled']\n</code></pre> <ol> <li><code>TagFormatter</code> extracts the component name and the remaining input.</li> </ol> <p>So, given the above, <code>TagFormatter.parse()</code> returns the following:</p> <pre><code>TagResult(\n    component_name=\"button\",\n    tokens=['href=\"...\"', 'disabled']\n)\n</code></pre> <ol> <li>The tag handler resumes, using the tokens returned from <code>TagFormatter</code>.</li> </ol> <p>So, continuing the example, at this point the tag handler practically behaves as if you rendered:</p> <pre><code>{% component href=\"...\" disabled %}\n</code></pre> <ol> <li>Tag handler looks up the component <code>button</code>, and passes the args, kwargs, and slots to it.</li> </ol>"},{"location":"concepts/advanced/tag_formatters/#tagformatter","title":"TagFormatter","text":"<p><code>TagFormatter</code> handles following parts of the process above:</p> <ul> <li> <p>Generates start/end tags, given a component. This is what you then call from within your template as <code>{% component %}</code>.</p> </li> <li> <p>When you <code>{% component %}</code>, tag formatter pre-processes the tag contents, so it can link back the custom template tag to the right component.</p> </li> </ul> <p>To do so, subclass from <code>TagFormatterABC</code> and implement following method:</p> <ul> <li><code>start_tag</code></li> <li><code>end_tag</code></li> <li><code>parse</code></li> </ul> <p>For example, this is the implementation of <code>ShorthandComponentFormatter</code></p> <pre><code>class ShorthandComponentFormatter(TagFormatterABC):\n    # Given a component name, generate the start template tag\n    def start_tag(self, name: str) -&gt; str:\n        return name  # e.g. 'button'\n\n    # Given a component name, generate the start template tag\n    def end_tag(self, name: str) -&gt; str:\n        return f\"end{name}\"  # e.g. 'endbutton'\n\n    # Given a tag, e.g.\n    # `{% button href=\"...\" disabled %}`\n    #\n    # The parser receives:\n    # `['button', 'href=\"...\"', 'disabled']`\n    def parse(self, tokens: List[str]) -&gt; TagResult:\n        tokens = [*tokens]\n        name = tokens.pop(0)\n        return TagResult(\n            name,  # e.g. 'button'\n            tokens  # e.g. ['href=\"...\"', 'disabled']\n        )\n</code></pre> <p>That's it! And once your <code>TagFormatter</code> is ready, don't forget to update the settings!</p>"},{"location":"concepts/advanced/template_tags/","title":"Custom template tags","text":"<p>Template tags introduced by django-components, such as <code>{% component %}</code> and <code>{% slot %}</code>, offer additional features over the default Django template tags:</p> <ul> <li>Self-closing tags <code>{% mytag / %}</code></li> <li>Allowing the use of <code>:</code>, <code>-</code> (and more) in keys</li> <li>Spread operator <code>...</code></li> <li>Using template tags as inputs to other template tags</li> <li>Flat definition of dictionaries <code>attr:key=val</code></li> <li>Function-like input validation</li> </ul> <p>You too can easily create custom template tags that use the above features.</p>"},{"location":"concepts/advanced/template_tags/#defining-template-tags-with-template_tag","title":"Defining template tags with <code>@template_tag</code>","text":"<p>The simplest way to create a custom template tag is using the <code>template_tag</code> decorator. This decorator allows you to define a template tag by just writing a function that returns the rendered content.</p> <pre><code>from django.template import Context, Library\nfrom django_components import BaseNode, template_tag\n\nlibrary = Library()\n\n@template_tag(\n    library,\n    tag=\"mytag\",\n    end_tag=\"endmytag\",\n    allowed_flags=[\"required\"]\n)\ndef mytag(node: BaseNode, context: Context, name: str, **kwargs) -&gt; str:\n    return f\"Hello, {name}!\"\n</code></pre> <p>This will allow you to use the tag in your templates like this:</p> <pre><code>{% mytag name=\"John\" %}\n{% endmytag %}\n\n{# or with self-closing syntax #}\n{% mytag name=\"John\" / %}\n\n{# or with flags #}\n{% mytag name=\"John\" required %}\n{% endmytag %}\n</code></pre>"},{"location":"concepts/advanced/template_tags/#parameters","title":"Parameters","text":"<p>The <code>@template_tag</code> decorator accepts the following parameters:</p> <ul> <li><code>library</code>: The Django template library to register the tag with</li> <li><code>tag</code>: The name of the template tag (e.g. <code>\"mytag\"</code> for <code>{% mytag %}</code>)</li> <li><code>end_tag</code>: Optional. The name of the end tag (e.g. <code>\"endmytag\"</code> for <code>{% endmytag %}</code>)</li> <li><code>allowed_flags</code>: Optional. List of flags that can be used with the tag (e.g. <code>[\"required\"]</code> for <code>{% mytag required %}</code>)</li> </ul>"},{"location":"concepts/advanced/template_tags/#function-signature","title":"Function signature","text":"<p>The function decorated with <code>@template_tag</code> must accept at least two arguments:</p> <ol> <li><code>node</code>: The node instance (we'll explain this in detail in the next section)</li> <li><code>context</code>: The Django template context</li> </ol> <p>Any additional parameters in your function's signature define what inputs your template tag accepts. For example:</p> <pre><code>@template_tag(library, tag=\"greet\")\ndef greet(\n    node: BaseNode,\n    context: Context,\n    name: str,                    # required positional argument\n    count: int = 1,              # optional positional argument\n    *,                           # keyword-only arguments marker\n    msg: str,                    # required keyword argument\n    mode: str = \"default\",       # optional keyword argument\n) -&gt; str:\n    return f\"{msg}, {name}!\" * count\n</code></pre> <p>This allows the tag to be used like:</p> <pre><code>{# All parameters #}\n{% greet \"John\" count=2 msg=\"Hello\" mode=\"custom\" %}\n\n{# Only required parameters #}\n{% greet \"John\" msg=\"Hello\" %}\n\n{# Missing required parameter - will raise error #}\n{% greet \"John\" %}  {# Error: missing 'msg' #}\n</code></pre> <p>When you pass input to a template tag, it behaves the same way as if you passed the input to a function:</p> <ul> <li>If required parameters are missing, an error is raised</li> <li>If unexpected parameters are passed, an error is raised</li> </ul> <p>To accept keys that are not valid Python identifiers (e.g. <code>data-id</code>), or would conflict with Python keywords (e.g. <code>is</code>), you can use the <code>**kwargs</code> syntax:</p> <pre><code>@template_tag(library, tag=\"greet\")\ndef greet(\n    node: BaseNode,\n    context: Context,\n    **kwargs,\n) -&gt; str:\n    attrs = kwargs.copy()\n    is_var = attrs.pop(\"is\", None)\n    attrs_str = \" \".join(f'{k}=\"{v}\"' for k, v in attrs.items())\n\n    return mark_safe(f\"\"\"\n        &lt;div {attrs_str}&gt;\n            Hello, {is_var}!\n        &lt;/div&gt;\n    \"\"\")\n</code></pre> <p>This allows you to use the tag like this:</p> <pre><code>{% greet is=\"John\" data-id=\"123\" %}\n</code></pre>"},{"location":"concepts/advanced/template_tags/#defining-template-tags-with-basenode","title":"Defining template tags with <code>BaseNode</code>","text":"<p>For more control over your template tag, you can subclass <code>BaseNode</code> directly instead of using the decorator. This gives you access to additional features like the node's internal state and parsing details.</p> <pre><code>from django_components import BaseNode\n\nclass GreetNode(BaseNode):\n    tag = \"greet\"\n    end_tag = \"endgreet\"\n    allowed_flags = [\"required\"]\n\n    def render(self, context: Context, name: str, **kwargs) -&gt; str:\n        # Access node properties\n        if self.flags[\"required\"]:\n            return f\"Required greeting: Hello, {name}!\"\n        return f\"Hello, {name}!\"\n\n# Register the node\nGreetNode.register(library)\n</code></pre>"},{"location":"concepts/advanced/template_tags/#node-properties","title":"Node properties","text":"<p>When using <code>BaseNode</code>, you have access to several useful properties:</p> <ul> <li><code>node_id</code>: A unique identifier for this node instance</li> <li><code>flags</code>: Dictionary of flag values (e.g. <code>{\"required\": True}</code>)</li> <li><code>params</code>: List of raw parameters passed to the tag</li> <li><code>nodelist</code>: The template nodes between the start and end tags</li> <li><code>contents</code>: The raw contents between the start and end tags</li> <li><code>active_flags</code>: List of flags that are currently set to True</li> <li><code>template_name</code>: The name of the <code>Template</code> instance inside which the node was defined</li> <li><code>template_component</code>: The component class that the <code>Template</code> belongs to</li> </ul> <p>This is what the <code>node</code> parameter in the <code>@template_tag</code> decorator gives you access to - it's the instance of the node class that was automatically created for your template tag.</p>"},{"location":"concepts/advanced/template_tags/#rendering-content-between-tags","title":"Rendering content between tags","text":"<p>When your tag has an end tag, you can access and render the content between the tags using <code>nodelist</code>:</p> <pre><code>class WrapNode(BaseNode):\n    tag = \"wrap\"\n    end_tag = \"endwrap\"\n\n    def render(self, context: Context, tag: str = \"div\", **attrs) -&gt; str:\n        # Render the content between tags\n        inner = self.nodelist.render(context)\n        attrs_str = \" \".join(f'{k}=\"{v}\"' for k, v in attrs.items())\n        return f\"&lt;{tag} {attrs_str}&gt;{inner}&lt;/{tag}&gt;\"\n\n# Usage:\n{% wrap tag=\"section\" class=\"content\" %}\n    Hello, world!\n{% endwrap %}\n</code></pre>"},{"location":"concepts/advanced/template_tags/#unregistering-nodes","title":"Unregistering nodes","text":"<p>You can unregister a node from a library using the <code>unregister</code> method:</p> <pre><code>GreetNode.unregister(library)\n</code></pre> <p>This is particularly useful in testing when you want to clean up after registering temporary tags.</p>"},{"location":"concepts/advanced/testing/","title":"Testing","text":"<p>New in version 0.131</p> <p>The <code>@djc_test</code> decorator is a powerful tool for testing components created with <code>django-components</code>. It ensures that each test is properly isolated, preventing components registered in one test from affecting others.</p>"},{"location":"concepts/advanced/testing/#usage","title":"Usage","text":"<p>The <code>@djc_test</code> decorator can be applied to functions, methods, or classes.</p> <p>When applied to a class, it decorates all methods starting with <code>test_</code>, and all nested classes starting with <code>Test</code>, recursively.</p>"},{"location":"concepts/advanced/testing/#applying-to-a-function","title":"Applying to a Function","text":"<p>To apply <code>djc_test</code> to a function, simply decorate the function as shown below:</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\n@djc_test\ndef test_my_component():\n    @register(\"my_component\")\n    class MyComponent(Component):\n        template = \"...\"\n    ...\n</code></pre>"},{"location":"concepts/advanced/testing/#applying-to-a-class","title":"Applying to a Class","text":"<p>When applied to a class, <code>djc_test</code> decorates each <code>test_</code> method, as well as all nested classes starting with <code>Test</code>.</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\n@djc_test\nclass TestMyComponent:\n    def test_something(self):\n        ...\n\n    class TestNested:\n        def test_something_else(self):\n            ...\n</code></pre> <p>This is equivalent to applying the decorator to both of the methods individually:</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\nclass TestMyComponent:\n    @djc_test\n    def test_something(self):\n        ...\n\n    class TestNested:\n        @djc_test\n        def test_something_else(self):\n            ...\n</code></pre>"},{"location":"concepts/advanced/testing/#arguments","title":"Arguments","text":"<p>See the API reference for <code>@djc_test</code> for more details.</p>"},{"location":"concepts/advanced/testing/#setting-up-django","title":"Setting Up Django","text":"<p>If you want to define a common Django settings that would be the baseline for all tests, you can call <code>django.setup()</code> before the <code>@djc_test</code> decorator:</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\ndjango.setup(...)\n\n@djc_test\ndef test_my_component():\n    ...\n</code></pre> <p>Info</p> <p>If you omit <code>django.setup()</code> in the example above, <code>@djc_test</code> will call it for you, so you don't need to do it manually.</p>"},{"location":"concepts/advanced/testing/#example-parametrizing-context-behavior","title":"Example: Parametrizing Context Behavior","text":"<p>You can parametrize the context behavior using <code>djc_test</code>:</p> <pre><code>from django_components.testing import djc_test\n\n@djc_test(\n    # Settings applied to all cases\n    components_settings={\n        \"app_dirs\": [\"custom_dir\"],\n    },\n    # Parametrized settings\n    parametrize=(\n        [\"components_settings\"],\n        [\n            [{\"context_behavior\": \"django\"}],\n            [{\"context_behavior\": \"isolated\"}],\n        ],\n        [\"django\", \"isolated\"],\n    )\n)\ndef test_context_behavior(components_settings):\n    rendered = MyComponent.render()\n    ...\n</code></pre>"},{"location":"concepts/fundamentals/autodiscovery/","title":"Autodiscovery","text":"<p>django-components automatically searches for files containing components in the <code>COMPONENTS.dirs</code> and  <code>COMPONENTS.app_dirs</code> directories.</p>"},{"location":"concepts/fundamentals/autodiscovery/#manually-register-components","title":"Manually register components","text":"<p>Every component that you want to use in the template with the <code>{% component %}</code> tag needs to be registered with the <code>ComponentRegistry</code>.</p> <p>We use the <code>@register</code> decorator for that:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    ...\n</code></pre> <p>But for the component to be registered, the code needs to be executed - and for that, the file needs to be imported as a module.</p> <p>This is the \"discovery\" part of the process.</p> <p>One way to do that is by importing all your components in <code>apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\nclass MyAppConfig(AppConfig):\n    name = \"my_app\"\n\n    def ready(self) -&gt; None:\n        from components.card.card import Card\n        from components.list.list import List\n        from components.menu.menu import Menu\n        from components.button.button import Button\n        ...\n</code></pre> <p>However, there's a simpler way!</p>"},{"location":"concepts/fundamentals/autodiscovery/#autodiscovery","title":"Autodiscovery","text":"<p>By default, the Python files found in the <code>COMPONENTS.dirs</code> and  <code>COMPONENTS.app_dirs</code> are auto-imported in order to execute the code that registers the components.</p> <p>Autodiscovery occurs when Django is loaded, during the <code>AppConfig.ready()</code> hook of the <code>apps.py</code> file.</p> <p>If you are using autodiscovery, keep a few points in mind:</p> <ul> <li>Avoid defining any logic on the module-level inside the components directories, that you would not want to run anyway.</li> <li>Components inside the auto-imported files still need to be registered with <code>@register</code></li> <li>Auto-imported component files must be valid Python modules, they must use suffix <code>.py</code>, and module name should follow PEP-8.</li> <li>Subdirectories and files starting with an underscore <code>_</code> (except <code>__init__.py</code>) are ignored.</li> </ul> <p>Autodiscovery can be disabled in the settings with <code>autodiscover=False</code>.</p>"},{"location":"concepts/fundamentals/autodiscovery/#manually-trigger-autodiscovery","title":"Manually trigger autodiscovery","text":"<p>Autodiscovery can be also triggered manually, using the <code>autodiscover()</code> function. This is useful if you want to run autodiscovery at a custom point of the lifecycle:</p> <pre><code>from django_components import autodiscover\n\nautodiscover()\n</code></pre> <p>To get the same list of modules that <code>autodiscover()</code> would return, but without importing them, use <code>get_component_files()</code>:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre>"},{"location":"concepts/fundamentals/component_defaults/","title":"Component defaults","text":"<p>When a component is being rendered, the component inputs are passed to various methods like <code>get_template_data()</code>, <code>get_js_data()</code>, or <code>get_css_data()</code>.</p> <p>It can be cumbersome to specify default values for each input in each method.</p> <p>To make things easier, Components can specify their defaults. Defaults are used when no value is provided, or when the value is set to <code>None</code> for a particular input.</p>"},{"location":"concepts/fundamentals/component_defaults/#defining-defaults","title":"Defining defaults","text":"<p>To define defaults for a component, you create a nested <code>Defaults</code> class within your <code>Component</code> class. Each attribute in the <code>Defaults</code> class represents a default value for a corresponding input.</p> <pre><code>from django_components import Component, Default, register\n\n@register(\"my_table\")\nclass MyTable(Component):\n\n    class Defaults:\n        position = \"left\"\n        selected_items = Default(lambda: [1, 2, 3])\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"position\": kwargs[\"position\"],\n            \"selected_items\": kwargs[\"selected_items\"],\n        }\n\n    ...\n</code></pre> <p>In this example, <code>position</code> is a simple default value, while <code>selected_items</code> uses a factory function wrapped in <code>Default</code> to ensure a new list is created each time the default is used.</p> <p>Now, when we render the component, the defaults will be applied:</p> <pre><code>{% component \"my_table\" position=\"right\" / %}\n</code></pre> <p>In this case:</p> <ul> <li><code>position</code> input is set to <code>right</code>, so no defaults applied</li> <li><code>selected_items</code> is not set, so it will be set to <code>[1, 2, 3]</code>.</li> </ul> <p>Same applies to rendering the Component in Python with the <code>render()</code> method:</p> <pre><code>MyTable.render(\n    kwargs={\n        \"position\": \"right\",\n        \"selected_items\": None,\n    },\n)\n</code></pre> <p>Notice that we've set <code>selected_items</code> to <code>None</code>. <code>None</code> values are treated as missing values, and so <code>selected_items</code> will be set to <code>[1, 2, 3]</code>.</p> <p>Warning</p> <p>The defaults are aplied only to keyword arguments. They are NOT applied to positional arguments!</p> <p>Warning</p> <p>When typing your components with <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, you may be inclined to define the defaults in the classes.</p> <pre><code>class ProfileCard(Component):\n    class Kwargs(NamedTuple):\n        show_details: bool = True\n</code></pre> <p>This is NOT recommended, because:</p> <ul> <li>The defaults will NOT be applied to inputs when using <code>self.raw_kwargs</code> property.</li> <li>The defaults will NOT be applied when a field is given but set to <code>None</code>.</li> </ul> <p>Instead, define the defaults in the <code>Defaults</code> class.</p>"},{"location":"concepts/fundamentals/component_defaults/#default-factories","title":"Default factories","text":"<p>For objects such as lists, dictionaries or other instances, you have to be careful - if you simply set a default value, this instance will be shared across all instances of the component!</p> <pre><code>from django_components import Component\n\nclass MyTable(Component):\n    class Defaults:\n        # All instances will share the same list!\n        selected_items = [1, 2, 3]\n</code></pre> <p>To avoid this, you can use a factory function wrapped in <code>Default</code>.</p> <pre><code>from django_components import Component, Default\n\nclass MyTable(Component):\n    class Defaults:\n        # A new list is created for each instance\n        selected_items = Default(lambda: [1, 2, 3])\n</code></pre> <p>This is similar to how the dataclass fields work.</p> <p>In fact, you can also use the dataclass's <code>field</code> function to define the factories:</p> <pre><code>from dataclasses import field\nfrom django_components import Component\n\nclass MyTable(Component):\n    class Defaults:\n        selected_items = field(default_factory=lambda: [1, 2, 3])\n</code></pre>"},{"location":"concepts/fundamentals/component_defaults/#accessing-defaults","title":"Accessing defaults","text":"<p>Since the defaults are defined on the component class, you can access the defaults for a component with the <code>Component.Defaults</code> property.</p> <p>So if we have a component like this:</p> <pre><code>from django_components import Component, Default, register\n\n@register(\"my_table\")\nclass MyTable(Component):\n\n    class Defaults:\n        position = \"left\"\n        selected_items = Default(lambda: [1, 2, 3])\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"position\": kwargs[\"position\"],\n            \"selected_items\": kwargs[\"selected_items\"],\n        }\n</code></pre> <p>We can access individual defaults like this:</p> <pre><code>print(MyTable.Defaults.position)\nprint(MyTable.Defaults.selected_items)\n</code></pre>"},{"location":"concepts/fundamentals/component_views_urls/","title":"Component views and URLs","text":"<p>New in version 0.34</p> <p>Note: Since 0.92, <code>Component</code> is no longer a subclass of Django's <code>View</code>. Instead, the nested <code>Component.View</code> class is a subclass of Django's <code>View</code>.</p> <p>For web applications, it's common to define endpoints that serve HTML content (AKA views).</p> <p>django-components has a suite of features that help you write and manage views and their URLs:</p> <ul> <li> <p>For each component, you can define methods for handling HTTP requests (GET, POST, etc.) - <code>get()</code>, <code>post()</code>, etc.</p> </li> <li> <p>Use <code>Component.as_view()</code> to be able to use your Components with Django's <code>urlpatterns</code>. This works the same way as <code>View.as_view()</code>.</p> </li> <li> <p>To avoid having to manually define the endpoints for each component, you can set the component to be \"public\" with <code>Component.View.public = True</code>. This will automatically create a URL for the component. To retrieve the component URL, use <code>get_component_url()</code>.</p> </li> <li> <p>In addition, <code>Component</code> has a <code>render_to_response()</code> method that renders the component template based on the provided input and returns an <code>HttpResponse</code> object.</p> </li> </ul>"},{"location":"concepts/fundamentals/component_views_urls/#define-handlers","title":"Define handlers","text":"<p>Here's an example of a calendar component defined as a view. Simply define a <code>View</code> class with your custom <code>get()</code> method to handle GET requests:</p> [project root]/components/calendar.py<pre><code>from django_components import Component, ComponentView, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            &lt;div class=\"header\"&gt;\n                {% slot \"header\" / %}\n            &lt;/div&gt;\n            &lt;div class=\"body\"&gt;\n                Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    class View:\n        # Handle GET requests\n        def get(self, request, *args, **kwargs):\n            # Return HttpResponse with the rendered content\n            return Calendar.render_to_response(\n                request=request,\n                kwargs={\n                    \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n                },\n                slots={\n                    \"header\": \"Calendar header\",\n                },\n            )\n</code></pre> <p>Info</p> <p>The View class supports all the same HTTP methods as Django's <code>View</code> class. These are:</p> <p><code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code>, <code>head()</code>, <code>options()</code>, <code>trace()</code></p> <p>Each of these receive the <code>HttpRequest</code> object as the first argument.</p> <p>Warning</p> <p>Deprecation warning:</p> <p>Previously, the handler methods such as <code>get()</code> and <code>post()</code> could be defined directly on the <code>Component</code> class:</p> <pre><code>class Calendar(Component):\n    def get(self, request, *args, **kwargs):\n        return self.render_to_response(\n            kwargs={\n                \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n            }\n        )\n</code></pre> <p>This is deprecated from v0.137 onwards, and will be removed in v1.0.</p>"},{"location":"concepts/fundamentals/component_views_urls/#acccessing-component-class","title":"Acccessing component class","text":"<p>You can access the component class from within the View methods by using the <code>View.component_cls</code> attribute:</p> <pre><code>class Calendar(Component):\n    ...\n\n    class View:\n        def get(self, request):\n            return self.component_cls.render_to_response(request=request)\n</code></pre>"},{"location":"concepts/fundamentals/component_views_urls/#register-urls-manually","title":"Register URLs manually","text":"<p>To register the component as a route / endpoint in Django, add an entry to your <code>urlpatterns</code>. In place of the view function, create a view object with <code>Component.as_view()</code>:</p> [project root]/urls.py<pre><code>from django.urls import path\nfrom components.calendar.calendar import Calendar\n\nurlpatterns = [\n    path(\"calendar/\", Calendar.as_view()),\n]\n</code></pre> <p><code>Component.as_view()</code> internally calls <code>View.as_view()</code>, passing the component class as one of the arguments.</p>"},{"location":"concepts/fundamentals/component_views_urls/#register-urls-automatically","title":"Register URLs automatically","text":"<p>If you don't care about the exact URL of the component, you can let django-components manage the URLs for you by setting the <code>Component.View.public</code> attribute to <code>True</code>:</p> <pre><code>class MyComponent(Component):\n    class View:\n        public = True\n\n        def get(self, request):\n            return self.component_cls.render_to_response(request=request)\n    ...\n</code></pre> <p>Then, to get the URL for the component, use <code>get_component_url()</code>:</p> <pre><code>from django_components import get_component_url\n\nurl = get_component_url(MyComponent)\n</code></pre> <p>This way you don't have to mix your app URLs with component URLs.</p> <p>Info</p> <p>If you need to pass query parameters or a fragment to the component URL, you can do so by passing the <code>query</code> and <code>fragment</code> arguments to <code>get_component_url()</code>:</p> <pre><code>url = get_component_url(\n    MyComponent,\n    query={\"foo\": \"bar\", \"enabled\": True, \"debug\": False, \"unused\": None},\n    fragment=\"baz\",\n)\n# /components/ext/view/components/c1ab2c3?foo=bar&amp;enabled#baz\n</code></pre> <p>Query parameter handling:</p> <ul> <li><code>True</code> values are rendered as flag parameters without values (e.g., <code>?enabled</code>)</li> <li><code>False</code> and <code>None</code> values are omitted from the URL</li> <li>Other values are rendered normally (e.g., <code>?foo=bar</code>)</li> </ul>"},{"location":"concepts/fundamentals/html_attributes/","title":"HTML attributes","text":"<p>New in version 0.74:</p> <p>You can use the <code>{% html_attrs %}</code> tag to render various data as <code>key=\"value\"</code> HTML attributes.</p> <p><code>{% html_attrs %}</code> tag is versatile, allowing you to define HTML attributes however you need:</p> <ul> <li>Define attributes within the HTML template</li> <li>Define attributes in Python code</li> <li>Merge attributes from multiple sources</li> <li>Boolean attributes</li> <li>Append attributes</li> <li>Remove attributes</li> <li>Define default attributes</li> </ul> <p>From v0.135 onwards, <code>{% html_attrs %}</code> tag also supports merging <code>style</code> and <code>class</code> attributes the same way how Vue does.</p> <p>To get started, let's consider a simple example. If you have a template:</p> <pre><code>&lt;div class=\"{{ classes }}\" data-id=\"{{ my_id }}\"&gt;\n&lt;/div&gt;\n</code></pre> <p>You can rewrite it with the <code>{% html_attrs %}</code> tag:</p> <pre><code>&lt;div {% html_attrs class=classes data-id=my_id %}&gt;\n&lt;/div&gt;\n</code></pre> <p>The <code>{% html_attrs %}</code> tag accepts any number of keyword arguments, which will be merged and rendered as HTML attributes:</p> <pre><code>&lt;div class=\"text-red\" data-id=\"123\"&gt;\n&lt;/div&gt;\n</code></pre> <p>Moreover, the <code>{% html_attrs %}</code> tag accepts two positional arguments:</p> <ul> <li><code>attrs</code> - a dictionary of attributes to be rendered</li> <li><code>defaults</code> - a dictionary of default attributes</li> </ul> <p>You can use this for example to allow users of your component to add extra attributes. We achieve this by capturing the extra attributes and passing them to the <code>{% html_attrs %}</code> tag as a dictionary:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    # Pass all kwargs as `attrs`\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"attrs\": kwargs,\n            \"classes\": \"text-red\",\n            \"my_id\": 123,\n        }\n\n    template: t.django_html = \"\"\"\n        {# Pass the extra attributes to `html_attrs` #}\n        &lt;div {% html_attrs attrs class=classes data-id=my_id %}&gt;\n        &lt;/div&gt;\n    \"\"\"\n</code></pre> <p>This way you can render <code>MyComp</code> with extra attributes:</p> <p>Either via Django template:</p> <pre><code>{% component \"my_comp\"\n  id=\"example\"\n  class=\"pa-4\"\n  style=\"color: red;\"\n%}\n</code></pre> <p>Or via Python:</p> <pre><code>MyComp.render(\n    kwargs={\n        \"id\": \"example\",\n        \"class\": \"pa-4\",\n        \"style\": \"color: red;\",\n    }\n)\n</code></pre> <p>In both cases, the attributes will be merged and rendered as:</p> <pre><code>&lt;div id=\"example\" class=\"text-red pa-4\" style=\"color: red;\" data-id=\"123\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#summary","title":"Summary","text":"<ol> <li> <p>The two arguments, <code>attrs</code> and <code>defaults</code>, can be passed as positional args:</p> <pre><code>{% html_attrs attrs defaults key=val %}\n</code></pre> <p>or as kwargs:</p> <pre><code>{% html_attrs key=val defaults=defaults attrs=attrs %}\n</code></pre> </li> <li> <p>Both <code>attrs</code> and <code>defaults</code> are optional and can be omitted.</p> </li> <li> <p>Both <code>attrs</code> and <code>defaults</code> are dictionaries. As such, there's multiple ways to define them:</p> <ul> <li> <p>By referencing a variable:</p> <pre><code>{% html_attrs attrs=attrs %}\n</code></pre> </li> <li> <p>By defining a literal dictionary:</p> <pre><code>{% html_attrs attrs={\"key\": value} %}\n</code></pre> </li> <li> <p>Or by defining the dictionary keys:</p> <pre><code>{% html_attrs attrs:key=value %}\n</code></pre> </li> </ul> </li> <li> <p>All other kwargs are merged and can be repeated.</p> <pre><code>{% html_attrs class=\"text-red\" class=\"pa-4\" %}\n</code></pre> <p>Will render:</p> <pre><code>&lt;div class=\"text-red pa-4\"&gt;&lt;/div&gt;\n</code></pre> </li> </ol>"},{"location":"concepts/fundamentals/html_attributes/#usage","title":"Usage","text":""},{"location":"concepts/fundamentals/html_attributes/#boolean-attributes","title":"Boolean attributes","text":"<p>In HTML, boolean attributes are usually rendered with no value. Consider the example below where the first button is disabled and the second is not:</p> <pre><code>&lt;button disabled&gt;Click me!&lt;/button&gt;\n&lt;button&gt;Click me!&lt;/button&gt;\n</code></pre> <p>HTML rendering with <code>html_attrs</code> tag or <code>format_attributes</code> works the same way - an attribute set to <code>True</code> is rendered without the value, and an attribute set to <code>False</code> is not rendered at all.</p> <p>So given this input:</p> <pre><code>attrs = {\n    \"disabled\": True,\n    \"autofocus\": False,\n}\n</code></pre> <p>And template:</p> <pre><code>&lt;div {% html_attrs attrs %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then this renders:</p> <pre><code>&lt;div disabled&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#removing-attributes","title":"Removing attributes","text":"<p>Given how the boolean attributes work, you can \"remove\" or prevent an attribute from being rendered by setting it to <code>False</code> or <code>None</code>.</p> <p>So given this input:</p> <pre><code>attrs = {\n    \"class\": \"text-green\",\n    \"required\": False,\n    \"data-id\": None,\n}\n</code></pre> <p>And template:</p> <pre><code>&lt;div {% html_attrs attrs %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then this renders:</p> <pre><code>&lt;div class=\"text-green\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#default-attributes","title":"Default attributes","text":"<p>Sometimes you may want to specify default values for attributes. You can pass a second positional argument to set the defaults.</p> <pre><code>&lt;div {% html_attrs attrs defaults %}&gt;\n    ...\n&lt;/div&gt;\n</code></pre> <p>In the example above, if <code>attrs</code> contains a certain key, e.g. the <code>class</code> key, <code>{% html_attrs %}</code> will render:</p> <pre><code>&lt;div class=\"{{ attrs.class }}\"&gt;\n    ...\n&lt;/div&gt;\n</code></pre> <p>Otherwise, <code>{% html_attrs %}</code> will render:</p> <pre><code>&lt;div class=\"{{ defaults.class }}\"&gt;\n    ...\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#appending-attributes","title":"Appending attributes","text":"<p>For the <code>class</code> HTML attribute, it's common that we want to join multiple values, instead of overriding them.</p> <p>For example, if you're authoring a component, you may want to ensure that the component will ALWAYS have a specific class. Yet, you may want to allow users of your component to supply their own <code>class</code> attribute.</p> <p>We can achieve this by adding extra kwargs. These values will be appended, instead of overwriting the previous value.</p> <p>So if we have a variable <code>attrs</code>:</p> <pre><code>attrs = {\n    \"class\": \"my-class pa-4\",\n}\n</code></pre> <p>And on <code>{% html_attrs %}</code> tag, we set the key <code>class</code>:</p> <pre><code>&lt;div {% html_attrs attrs class=\"some-class\" %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then these will be merged and rendered as:</p> <pre><code>&lt;div data-value=\"my-class pa-4 some-class\"&gt;&lt;/div&gt;\n</code></pre> <p>To simplify merging of variables, you can supply the same key multiple times, and these will be all joined together:</p> <pre><code>{# my_var = \"class-from-var text-red\" #}\n&lt;div {% html_attrs attrs class=\"some-class another-class\" class=my_var %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Renders:</p> <pre><code>&lt;div\n  data-value=\"my-class pa-4 some-class another-class class-from-var text-red\"\n&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#merging-class-attributes","title":"Merging <code>class</code> attributes","text":"<p>The <code>class</code> attribute can be specified as a string of class names as usual.</p> <p>If you want granular control over individual class names, you can use a dictionary.</p> <ul> <li> <p>String: Used as is.</p> <pre><code>{% html_attrs class=\"my-class other-class\" %}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div class=\"my-class other-class\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Dictionary: Keys are the class names, and values are booleans. Only keys with truthy values are rendered.</p> <pre><code>{% html_attrs class={\n    \"extra-class\": True,\n    \"other-class\": False,\n} %}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div class=\"extra-class\"&gt;&lt;/div&gt;\n</code></pre> </li> </ul> <p>If a certain class is specified multiple times, it's the last instance that decides whether the class is rendered or not.</p> <p>Example:</p> <p>In this example, the <code>other-class</code> is specified twice. The last instance is <code>{\"other-class\": False}</code>, so the class is not rendered.</p> <pre><code>{% html_attrs\n    class=\"my-class other-class\"\n    class={\"extra-class\": True, \"other-class\": False}\n%}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div class=\"my-class extra-class\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#merging-style-attributes","title":"Merging <code>style</code> attributes","text":"<p>The <code>style</code> attribute can be specified as a string of style properties as usual.</p> <p>If you want granular control over individual style properties, you can use a dictionary.</p> <ul> <li> <p>String: Used as is.</p> <pre><code>{% html_attrs style=\"color: red; background-color: blue;\" %}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div style=\"color: red; background-color: blue;\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Dictionary: Keys are the style properties, and values are their values.</p> <pre><code>{% html_attrs style={\n    \"color\": \"red\",\n    \"background-color\": \"blue\",\n} %}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div style=\"color: red; background-color: blue;\"&gt;&lt;/div&gt;\n</code></pre> </li> </ul> <p>If a style property is specified multiple times, the last value is used.</p> <ul> <li>Properties set to <code>None</code> are ignored.</li> <li>If the last non-<code>None</code> instance of the property is set to <code>False</code>, the property is removed.</li> </ul> <p>Example:</p> <p>In this example, the <code>width</code> property is specified twice. The last instance is <code>{\"width\": False}</code>, so the property is removed.</p> <p>Secondly, the <code>background-color</code> property is also set twice. But the second time it's set to <code>None</code>, so that instance is ignored, leaving us only with <code>background-color: blue</code>.</p> <p>The <code>color</code> property is set to a valid value in both cases, so the latter (<code>green</code>) is used.</p> <pre><code>{% html_attrs\n    style=\"color: red; background-color: blue; width: 100px;\"\n    style={\"color\": \"green\", \"background-color\": None, \"width\": False}\n%}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div style=\"color: green; background-color: blue;\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#usage-outside-of-templates","title":"Usage outside of templates","text":"<p>In some cases, you want to prepare HTML attributes outside of templates.</p> <p>To achieve the same behavior as <code>{% html_attrs %}</code> tag, you can use the <code>merge_attributes()</code> and <code>format_attributes()</code> helper functions.</p>"},{"location":"concepts/fundamentals/html_attributes/#merging-attributes","title":"Merging attributes","text":"<p><code>merge_attributes()</code> accepts any number of dictionaries and merges them together, using the same merge strategy as <code>{% html_attrs %}</code>.</p> <pre><code>from django_components import merge_attributes\n\nmerge_attributes(\n    {\"class\": \"my-class\", \"data-id\": 123},\n    {\"class\": \"extra-class\"},\n    {\"class\": {\"cool-class\": True, \"uncool-class\": False} },\n)\n</code></pre> <p>Which will output:</p> <pre><code>{\n    \"class\": \"my-class extra-class cool-class\",\n    \"data-id\": 123,\n}\n</code></pre> <p>Warning</p> <p>Unlike <code>{% html_attrs %}</code>, where you can pass extra kwargs, <code>merge_attributes()</code> requires each argument to be a dictionary.</p>"},{"location":"concepts/fundamentals/html_attributes/#formatting-attributes","title":"Formatting attributes","text":"<p><code>format_attributes()</code> serializes attributes the same way as <code>{% html_attrs %}</code> tag does.</p> <pre><code>from django_components import format_attributes\n\nformat_attributes({\n    \"class\": \"my-class text-red pa-4\",\n    \"data-id\": 123,\n    \"required\": True,\n    \"disabled\": False,\n    \"ignored-attr\": None,\n})\n</code></pre> <p>Which will output:</p> <pre><code>'class=\"my-class text-red pa-4\" data-id=\"123\" required'\n</code></pre> <p>Note</p> <p>Prior to v0.135, the <code>format_attributes()</code> function was named <code>attributes_to_string()</code>.</p> <p>This function is now deprecated and will be removed in v1.0.</p>"},{"location":"concepts/fundamentals/html_attributes/#cheat-sheet","title":"Cheat sheet","text":"<p>Assuming that:</p> <pre><code>class_from_var = \"from-var\"\n\nattrs = {\n    \"class\": \"from-attrs\",\n    \"type\": \"submit\",\n}\n\ndefaults = {\n    \"class\": \"from-defaults\",\n    \"role\": \"button\",\n}\n</code></pre> <p>Then:</p> <ul> <li> <p>Empty tag</p> <pre><code>&lt;div {% html_attr %}&gt;&lt;/div&gt;\n</code></pre> <p>renders nothing:</p> <pre><code>&lt;div&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Only kwargs</p> <pre><code>&lt;div {% html_attr class=\"some-class\" class=class_from_var data-id=\"123\" %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"some-class from-var\" data-id=\"123\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Only attrs</p> <pre><code>&lt;div {% html_attr attrs %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs\" type=\"submit\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Attrs as kwarg</p> <pre><code>&lt;div {% html_attr attrs=attrs %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs\" type=\"submit\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Only defaults (as kwarg)</p> <pre><code>&lt;div {% html_attr defaults=defaults %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-defaults\" role=\"button\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Attrs using the <code>prefix:key=value</code> construct</p> <pre><code>&lt;div {% html_attr attrs:class=\"from-attrs\" attrs:type=\"submit\" %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs\" type=\"submit\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Defaults using the <code>prefix:key=value</code> construct</p> <pre><code>&lt;div {% html_attr defaults:class=\"from-defaults\" %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-defaults\" role=\"button\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>All together (1) - attrs and defaults as positional args:</p> <pre><code>&lt;div {% html_attrs attrs defaults class=\"added_class\" class=class_from_var data-id=123 %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs added_class from-var\" type=\"submit\" role=\"button\" data-id=123&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>All together (2) - attrs and defaults as kwargs args:</p> <pre><code>&lt;div {% html_attrs class=\"added_class\" class=class_from_var data-id=123 attrs=attrs defaults=defaults %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs added_class from-var\" type=\"submit\" role=\"button\" data-id=123&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>All together (3) - mixed:</p> <pre><code>&lt;div {% html_attrs attrs defaults:class=\"default-class\" class=\"added_class\" class=class_from_var data-id=123 %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs added_class from-var\" type=\"submit\" data-id=123&gt;&lt;/div&gt;\n</code></pre> </li> </ul>"},{"location":"concepts/fundamentals/html_attributes/#full-example","title":"Full example","text":"<pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template: t.django_html = \"\"\"\n        &lt;div\n            {% html_attrs attrs\n                defaults:class=\"pa-4 text-red\"\n                class=\"my-comp-date\"\n                class=class_from_var\n                data-id=\"123\"\n            %}\n        &gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n            \"attrs\": kwargs.get(\"attrs\", {}),\n            \"class_from_var\": \"extra-class\"\n        }\n\n@register(\"parent\")\nclass Parent(Component):\n    template: t.django_html = \"\"\"\n        {% component \"my_comp\"\n            date=date\n            attrs:class=\"pa-0 border-solid border-red\"\n            attrs:data-json=json_data\n            attrs:@click=\"(e) =&gt; onClick(e, 'from_parent')\"\n        / %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": datetime.now(),\n            \"json_data\": json.dumps({\"value\": 456})\n        }\n</code></pre> <p>Note: For readability, we've split the tags across multiple lines.</p> <p>Inside <code>MyComp</code>, we defined a default attribute</p> <pre><code>defaults:class=\"pa-4 text-red\"\n</code></pre> <p>So if <code>attrs</code> includes key <code>class</code>, the default above will be ignored.</p> <p><code>MyComp</code> also defines <code>class</code> key twice. It means that whether the <code>class</code> attribute is taken from <code>attrs</code> or <code>defaults</code>, the two <code>class</code> values will be appended to it.</p> <p>So by default, <code>MyComp</code> renders:</p> <pre><code>&lt;div class=\"pa-4 text-red my-comp-date extra-class\" data-id=\"123\"&gt;...&lt;/div&gt;\n</code></pre> <p>Next, let's consider what will be rendered when we call <code>MyComp</code> from <code>Parent</code> component.</p> <p><code>MyComp</code> accepts a <code>attrs</code> dictionary, that is passed to <code>html_attrs</code>, so the contents of that dictionary are rendered as the HTML attributes.</p> <p>In <code>Parent</code>, we make use of passing dictionary key-value pairs as kwargs to define individual attributes as if they were regular kwargs.</p> <p>So all kwargs that start with <code>attrs:</code> will be collected into an <code>attrs</code> dict.</p> <pre><code>    attrs:class=\"pa-0 border-solid border-red\"\n    attrs:data-json=json_data\n    attrs:@click=\"(e) =&gt; onClick(e, 'from_parent')\"\n</code></pre> <p>And <code>get_template_data</code> of <code>MyComp</code> will receive a kwarg named <code>attrs</code> with following keys:</p> <pre><code>attrs = {\n    \"class\": \"pa-0 border-solid\",\n    \"data-json\": '{\"value\": 456}',\n    \"@click\": \"(e) =&gt; onClick(e, 'from_parent')\",\n}\n</code></pre> <p><code>attrs[\"class\"]</code> overrides the default value for <code>class</code>, whereas other keys will be merged.</p> <p>So in the end <code>MyComp</code> will render:</p> <pre><code>&lt;div\n  class=\"pa-0 border-solid my-comp-date extra-class\"\n  data-id=\"123\"\n  data-json='{\"value\": 456}'\n  @click=\"(e) =&gt; onClick(e, 'from_parent')\"\n&gt;\n  ...\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/","title":"HTML / JS / CSS files","text":""},{"location":"concepts/fundamentals/html_js_css_files/#overview","title":"Overview","text":"<p>Each component can have single \"primary\" HTML, CSS and JS file associated with them.</p> <p>Each of these can be either defined inline, or in a separate file:</p> <ul> <li>HTML files are defined using <code>Component.template</code> or <code>Component.template_file</code></li> <li>CSS files are defined using <code>Component.css</code> or <code>Component.css_file</code></li> <li>JS files are defined using <code>Component.js</code> or <code>Component.js_file</code></li> </ul> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    css_file = \"calendar.css\"\n    js_file = \"calendar.js\"\n</code></pre> <p>or</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"welcome\"&gt;\n            Hi there!\n        &lt;/div&gt;\n    \"\"\"\n    css = \"\"\"\n        .welcome {\n            color: red;\n        }\n    \"\"\"\n    js = \"\"\"\n        console.log(\"Hello, world!\");\n    \"\"\"\n</code></pre> <p>These \"primary\" files will have special behavior. For example, each will receive variables from the component's data methods. Read more about each file type below:</p> <ul> <li>HTML</li> <li>CSS</li> <li>JS</li> </ul> <p>In addition, you can define extra \"secondary\" CSS / JS files using the nested <code>Component.Media</code> class, by setting <code>Component.Media.js</code> and <code>Component.Media.css</code>.</p> <p>Single component can have many secondary files. There is no special behavior for them.</p> <p>You can use these for third-party libraries, or for shared CSS / JS files.</p> <p>Read more about Secondary JS / CSS files.</p> <p>Warning</p> <p>You cannot use both inlined code and separate file for a single language type (HTML, CSS, JS).</p> <p>However, you can freely mix these for different languages:</p> <pre><code>class MyTable(Component):\n    template: types.django_html = \"\"\"\n      &lt;div class=\"welcome\"&gt;\n        Hi there!\n      &lt;/div&gt;\n    \"\"\"\n    js_file = \"my_table.js\"\n    css_file = \"my_table.css\"\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#html","title":"HTML","text":"<p>Components use Django's template system to define their HTML. This means that you can use Django's template syntax to define your HTML.</p> <p>Inside the template, you can access the data returned from the <code>get_template_data()</code> method.</p> <p>You can define the HTML directly in your Python code using the <code>template</code> attribute:</p> <pre><code>class Button(Component):\n    template = \"\"\"\n        &lt;button class=\"btn\"&gt;\n            {% if icon %}\n                &lt;i class=\"{{ icon }}\"&gt;&lt;/i&gt;\n            {% endif %}\n            {{ text }}\n        &lt;/button&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n            \"icon\": kwargs.get(\"icon\", None),\n        }\n</code></pre> <p>Or you can define the HTML in a separate file and reference it using <code>template_file</code>:</p> <pre><code>class Button(Component):\n    template_file = \"button.html\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n            \"icon\": kwargs.get(\"icon\", None),\n        }\n</code></pre> button.html<pre><code>&lt;button class=\"btn\"&gt;\n    {% if icon %}\n        &lt;i class=\"{{ icon }}\"&gt;&lt;/i&gt;\n    {% endif %}\n    {{ text }}\n&lt;/button&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#dynamic-templates","title":"Dynamic templates","text":"<p>Each component has only a single template associated with it.</p> <p>However, whether it's for A/B testing or for preserving public API when sharing your components, sometimes you may need to render different templates based on the input to your component.</p> <p>You can use <code>Component.on_render()</code> to dynamically override what template gets rendered.</p> <p>By default, the component's template is rendered as-is.</p> <pre><code>class Table(Component):\n    def on_render(self, context: Context, template: Optional[Template]):\n        if template is not None:\n            return template.render(context)\n</code></pre> <p>If you want to render a different template in its place, we recommended you to:</p> <ol> <li>Wrap the substitute templates as new Components</li> <li>Then render those Components inside <code>Component.on_render()</code>:</li> </ol> <pre><code>class TableNew(Component):\n    template_file = \"table_new.html\"\n\nclass TableOld(Component):\n    template_file = \"table_old.html\"\n\nclass Table(Component):\n    def on_render(self, context, template):\n        if self.kwargs.get(\"feat_table_new_ui\"):\n            return TableNew.render(\n                args=self.args,\n                kwargs=self.kwargs,\n                slots=self.slots,\n            )\n        else:\n            return TableOld.render(\n                args=self.args,\n                kwargs=self.kwargs,\n                slots=self.slots,\n            )\n</code></pre> <p>Warning</p> <p>If you do not wrap the templates as Components, there is a risk that some extensions will not work as expected.</p> <pre><code>new_template = Template(\"\"\"\n    {% load django_components %}\n    &lt;div&gt;\n        {% slot \"content\" %}\n            Other template\n        {% endslot %}\n    &lt;/div&gt;\n\"\"\")\n\nclass Table(Component):\n    def on_render(self, context, template):\n        if self.kwargs.get(\"feat_table_new_ui\"):\n            return new_template.render(context)\n        else:\n            return template.render(context)\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#template-less-components","title":"Template-less components","text":"<p>Since you can use <code>Component.on_render()</code> to render other components, there is no need to define a template for the component.</p> <p>So even an empty component like this is valid:</p> <pre><code>class MyComponent(Component):\n    pass\n</code></pre> <p>These \"template-less\" components can be useful as base classes for other components, or as mixins.</p>"},{"location":"concepts/fundamentals/html_js_css_files/#html-processing","title":"HTML processing","text":"<p>Django Components expects the rendered template to be a valid HTML. This is needed to enable features like CSS / JS variables.</p> <p>Here is how the HTML is post-processed:</p> <ol> <li> <p>Insert component ID: Each root element in the rendered HTML automatically receives a <code>data-djc-id-cxxxxxx</code> attribute containing a unique component instance ID.</p> <pre><code>&lt;!-- Output HTML --&gt;\n&lt;div class=\"card\" data-djc-id-c1a2b3c&gt;\n    ...\n&lt;/div&gt;\n&lt;div class=\"backdrop\" data-djc-id-c1a2b3c&gt;\n    ...\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Insert CSS ID: If the component defines CSS variables through <code>get_css_data()</code>, the root elements also receive a <code>data-djc-css-xxxxxx</code> attribute. This attribute links the element to its specific CSS variables.</p> <pre><code>&lt;!-- Output HTML --&gt;\n&lt;div class=\"card\" data-djc-id-c1a2b3c data-djc-css-d4e5f6&gt;\n    &lt;!-- Component content --&gt;\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Insert JS and CSS: After the HTML is rendered, Django Components handles inserting JS and CSS dependencies into the page based on the dependencies rendering strategy (document, fragment, or inline).</p> <p>For example, if your component contains the <code>{% component_js_dependencies %}</code> or <code>{% component_css_dependencies %}</code> tags, or the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> elements, the JS and CSS scripts will be inserted into the HTML.</p> <p>For more information on how JS and CSS dependencies are rendered, see Rendering JS / CSS.</p> </li> </ol>"},{"location":"concepts/fundamentals/html_js_css_files/#js","title":"JS","text":"<p>The component's JS script is executed in the browser:</p> <ul> <li>It is executed AFTER the \"secondary\" JS files from <code>Component.Media.js</code> are loaded.</li> <li>The script is only executed once, even if there are multiple instances of the component on the page.</li> <li>Component JS scripts are executed in the order how they appeared in the template / HTML (top to bottom).</li> </ul> <p>You can define the JS directly in your Python code using the <code>js</code> attribute:</p> <pre><code>class Button(Component):\n    js = \"\"\"\n        console.log(\"Hello, world!\");\n    \"\"\"\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n        }\n</code></pre> <p>Or you can define the JS in a separate file and reference it using <code>js_file</code>:</p> <pre><code>class Button(Component):\n    js_file = \"button.js\"\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n        }\n</code></pre> button.js<pre><code>console.log(\"Hello, world!\");\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#css","title":"CSS","text":"<p>You can define the CSS directly in your Python code using the <code>css</code> attribute:</p> <pre><code>class Button(Component):\n    css = \"\"\"\n        .btn {\n            width: 100px;\n            color: var(--color);\n        }\n    \"\"\"\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs.get(\"color\", \"red\"),\n        }\n</code></pre> <p>Or you can define the CSS in a separate file and reference it using <code>css_file</code>:</p> <pre><code>class Button(Component):\n    css_file = \"button.css\"\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n        }\n</code></pre> button.css<pre><code>.btn {\n    color: red;\n}\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#file-paths","title":"File paths","text":"<p>Compared to the secondary JS / CSS files, the definition of file paths for the main HTML / JS / CSS files is quite simple - just strings, without any lists, objects, or globs.</p> <p>However, similar to the secondary JS / CSS files, you can specify the file paths relative to the component's directory.</p> <p>So if you have a directory with following files:</p> <pre><code>[project root]/components/calendar/\n\u251c\u2500\u2500 calendar.html\n\u251c\u2500\u2500 calendar.css\n\u251c\u2500\u2500 calendar.js\n\u2514\u2500\u2500 calendar.py\n</code></pre> <p>You can define the component like this:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    css_file = \"calendar.css\"\n    js_file = \"calendar.js\"\n</code></pre> <p>Assuming that <code>COMPONENTS.dirs</code> contains path <code>[project root]/components</code>, the example above is the same as writing out:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n    css_file = \"calendar/style.css\"\n    js_file = \"calendar/script.js\"\n</code></pre> <p>If the path cannot be resolved relative to the component, django-components will attempt to resolve the path relative to the component directories, as set in <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code>.</p> <p>Read more about file path resolution.</p>"},{"location":"concepts/fundamentals/html_js_css_files/#access-component-definition","title":"Access component definition","text":"<p>Component's HTML / CSS / JS is resolved and loaded lazily.</p> <p>This means that, when you specify any of <code>template_file</code>, <code>js_file</code>, <code>css_file</code>, or <code>Media.js/css</code>, these file paths will be resolved only once you either:</p> <ol> <li> <p>Access any of the following attributes on the component:</p> <ul> <li><code>media</code>,  <code>template</code>,  <code>template_file</code>,  <code>js</code>,  <code>js_file</code>,  <code>css</code>,  <code>css_file</code></li> </ul> </li> <li> <p>Render the component.</p> </li> </ol> <p>Once the component's media files have been loaded once, they will remain in-memory on the Component class:</p> <ul> <li>HTML from <code>Component.template_file</code>   will be available under <code>Component.template</code></li> <li>CSS from <code>Component.css_file</code>   will be available under <code>Component.css</code></li> <li>JS from <code>Component.js_file</code>   will be available under <code>Component.js</code></li> </ul> <p>Thus, whether you define HTML via <code>Component.template_file</code> or <code>Component.template</code>, you can always access the HTML content under <code>Component.template</code>. And the same applies for JS and CSS.</p> <p>Example:</p> <pre><code># When we create Calendar component, the files like `calendar/template.html`\n# are not yet loaded!\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n    css_file = \"calendar/style.css\"\n    js_file = \"calendar/script.js\"\n\n    class Media:\n        css = \"calendar/style1.css\"\n        js = \"calendar/script2.js\"\n\n# It's only at this moment that django-components reads the files like `calendar/template.html`\nprint(Calendar.css)\n# Output:\n# .calendar {\n#   width: 200px;\n#   background: pink;\n# }\n</code></pre> <p>Warning</p> <p>Do NOT modify HTML / CSS / JS after it has been loaded</p> <p>django-components assumes that the component's media files like <code>js_file</code> or <code>Media.js/css</code> are static.</p> <p>If you need to dynamically change these media files, consider instead defining multiple Components.</p> <p>Modifying these files AFTER the component has been loaded at best does nothing. However, this is an untested behavior, which may lead to unexpected errors.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/","title":"HTML / JS / CSS variables","text":"<p>When a component recieves input through <code>{% component %}</code> tag, or the <code>Component.render()</code> or <code>Component.render_to_response()</code> methods, you can define how the input is handled, and what variables will be available to the template, JavaScript and CSS.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#overview","title":"Overview","text":"<p>Django Components offers three key methods for passing variables to different parts of your component:</p> <ul> <li><code>get_template_data()</code> - Provides variables to your HTML template</li> <li><code>get_js_data()</code> - Provides variables to your JavaScript code</li> <li><code>get_css_data()</code> - Provides variables to your CSS styles</li> </ul> <p>These methods let you pre-process inputs before they're used in rendering.</p> <p>Each method handles the data independently - you can define different data for the template, JS, and CSS.</p> <pre><code>class ProfileCard(Component):\n    class Kwargs(NamedTuple):\n        user_id: int\n        show_details: bool\n\n    class Defaults:\n        show_details = True\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        user = User.objects.get(id=kwargs.user_id)\n        return {\n            \"user\": user,\n            \"show_details\": kwargs.show_details,\n        }\n\n    def get_js_data(self, args, kwargs: Kwargs, slots, context):\n        return {\n            \"user_id\": kwargs.user_id,\n        }\n\n    def get_css_data(self, args, kwargs: Kwargs, slots, context):\n        text_color = \"red\" if kwargs.show_details else \"blue\"\n        return {\n            \"text_color\": text_color,\n        }\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_variables/#template-variables","title":"Template variables","text":"<p>The <code>get_template_data()</code> method is the primary way to provide variables to your HTML template. It receives the component inputs and returns a dictionary of data that will be available in the template.</p> <p>If <code>get_template_data()</code> returns <code>None</code>, an empty dictionary will be used.</p> <pre><code>class ProfileCard(Component):\n    template_file = \"profile_card.html\"\n\n    class Kwargs(NamedTuple):\n        user_id: int\n        show_details: bool\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        user = User.objects.get(id=kwargs.user_id)\n\n        # Process and transform inputs\n        return {\n            \"user\": user,\n            \"show_details\": kwargs.show_details,\n            \"user_joined_days\": (timezone.now() - user.date_joined).days,\n        }\n</code></pre> <p>In your template, you can then use these variables:</p> <pre><code>&lt;div class=\"profile-card\"&gt;\n    &lt;h2&gt;{{ user.username }}&lt;/h2&gt;\n\n    {% if show_details %}\n        &lt;p&gt;Member for {{ user_joined_days }} days&lt;/p&gt;\n        &lt;p&gt;Email: {{ user.email }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_variables/#legacy-get_context_data","title":"Legacy <code>get_context_data()</code>","text":"<p>The <code>get_context_data()</code> method is the legacy way to provide variables to your HTML template. It serves the same purpose as <code>get_template_data()</code> - it receives the component inputs and returns a dictionary of data that will be available in the template.</p> <p>However, <code>get_context_data()</code> has a few drawbacks:</p> <ul> <li>It does NOT receive the <code>slots</code> and <code>context</code> parameters.</li> <li>The <code>args</code> and <code>kwargs</code> parameters are given as variadic <code>*args</code> and <code>**kwargs</code> parameters. As such, they cannot be typed.</li> </ul> <pre><code>class ProfileCard(Component):\n    template_file = \"profile_card.html\"\n\n    def get_context_data(self, user_id, show_details=False, *args, **kwargs):\n        user = User.objects.get(id=user_id)\n        return {\n            \"user\": user,\n            \"show_details\": show_details,\n        }\n</code></pre> <p>There is a slight difference between <code>get_context_data()</code> and <code>get_template_data()</code> when rendering a component with the <code>{% component %}</code> tag.</p> <p>For example if you have component that accepts kwarg <code>date</code>:</p> <pre><code>class MyComponent(Component):\n    def get_context_data(self, date, *args, **kwargs):\n        return {\n            \"date\": date,\n        }\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n</code></pre> <p>The difference is that:</p> <ul> <li> <p>With <code>get_context_data()</code>, you can pass <code>date</code> either as arg or kwarg:</p> <pre><code>\u2705\n{% component \"my_component\" date=some_date %}\n{% component \"my_component\" some_date %}\n</code></pre> </li> <li> <p>But with <code>get_template_data()</code>, <code>date</code> MUST be passed as kwarg:</p> <pre><code>\u2705\n{% component \"my_component\" date=some_date %}\n\n\u274c\n{% component \"my_component\" some_date %}\n</code></pre> </li> </ul> <p>Warning</p> <p><code>get_template_data()</code> and <code>get_context_data()</code> are mutually exclusive.</p> <p>If both methods return non-empty dictionaries, an error will be raised.</p> <p>Note</p> <p>The <code>get_context_data()</code> method will be removed in v2.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#accessing-component-inputs","title":"Accessing component inputs","text":"<p>The component inputs are available in 3 ways:</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#function-arguments","title":"Function arguments","text":"<p>The data methods receive the inputs as parameters directly.</p> <pre><code>class ProfileCard(Component):\n    # Access inputs directly as parameters\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"user_id\": args[0],\n            \"show_details\": kwargs[\"show_details\"],\n        }\n</code></pre> <p>Info</p> <p>By default, the <code>args</code> parameter is a list, while <code>kwargs</code> and <code>slots</code> are dictionaries.</p> <p>If you add typing to your component with <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, the respective inputs will be given as instances of these classes.</p> <p>Learn more about Component typing.</p> <pre><code>class ProfileCard(Component):\n    class Args(NamedTuple):\n        user_id: int\n\n    class Kwargs(NamedTuple):\n        show_details: bool\n\n    # Access inputs directly as parameters\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots, context):\n        return {\n            \"user_id\": args.user_id,\n            \"show_details\": kwargs.show_details,\n        }\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_variables/#args-kwargs-slots-properties","title":"<code>args</code>, <code>kwargs</code>, <code>slots</code> properties","text":"<p>In other methods, you can access the inputs via <code>self.args</code>, <code>self.kwargs</code>, and <code>self.slots</code> properties:</p> <pre><code>class ProfileCard(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]):\n        # Access inputs via self.args, self.kwargs, self.slots\n        self.args[0]\n        self.kwargs.get(\"show_details\", False)\n        self.slots[\"footer\"]\n</code></pre> <p>Info</p> <p>These properties work the same way as <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters in the data methods:</p> <p>By default, the <code>args</code> property is a list, while <code>kwargs</code> and <code>slots</code> are dictionaries.</p> <p>If you add typing to your component with <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, the respective inputs will be given as instances of these classes.</p> <p>Learn more about Component typing.</p> <pre><code>class ProfileCard(Component):\n    class Args(NamedTuple):\n        user_id: int\n\n    class Kwargs(NamedTuple):\n        show_details: bool\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots, context):\n        return {\n            \"user_id\": self.args.user_id,\n            \"show_details\": self.kwargs.show_details,\n        }\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_variables/#input-property-low-level","title":"<code>input</code> property (low-level)","text":"<p>Warning</p> <p>The <code>input</code> property is deprecated and will be removed in v1.</p> <p>Instead, use properties defined on the <code>Component</code> class directly like <code>self.context</code>.</p> <p>To access the unmodified inputs, use <code>self.raw_args</code>, <code>self.raw_kwargs</code>, and <code>self.raw_slots</code> properties.</p> <p>The previous two approaches allow you to access only the most important inputs.</p> <p>There are additional settings that may be passed to components. If you need to access these, you can use <code>self.input</code> property for a low-level access to all the inputs.</p> <p>The <code>input</code> property contains all the inputs passed to the component (instance of <code>ComponentInput</code>).</p> <p>This includes:</p> <ul> <li><code>input.args</code> - List of positional arguments</li> <li><code>input.kwargs</code> - Dictionary of keyword arguments</li> <li><code>input.slots</code> - Dictionary of slots. Values are normalized to <code>Slot</code> instances</li> <li><code>input.context</code> - <code>Context</code> object that should be used to render the component</li> <li><code>input.type</code> - The type of the component (document, fragment)</li> <li><code>input.render_dependencies</code> - Whether to render dependencies (CSS, JS)</li> </ul> <pre><code>class ProfileCard(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access positional arguments\n        user_id = self.input.args[0] if self.input.args else None\n\n        # Access keyword arguments\n        show_details = self.input.kwargs.get(\"show_details\", False)\n\n        # Render component differently depending on the type\n        if self.input.type == \"fragment\":\n            ...\n\n        return {\n            \"user_id\": user_id,\n            \"show_details\": show_details,\n        }\n</code></pre> <p>Info</p> <p>Unlike the parameters passed to the data methods, the <code>args</code>, <code>kwargs</code>, and <code>slots</code> in <code>self.input</code> property are always lists and dictionaries, regardless of whether you added typing classes to your component (like <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code>).</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#default-values","title":"Default values","text":"<p>You can use <code>Defaults</code> class to provide default values for your inputs.</p> <p>These defaults will be applied either when:</p> <ul> <li>The input is not provided at rendering time</li> <li>The input is provided as <code>None</code></li> </ul> <p>When you then access the inputs in your data methods, the default values will be already applied.</p> <p>Read more about Component Defaults.</p> <pre><code>from django_components import Component, Default, register\n\n@register(\"profile_card\")\nclass ProfileCard(Component):\n    class Kwargs(NamedTuple):\n        show_details: bool\n\n    class Defaults:\n        show_details = True\n\n    # show_details will be set to True if `None` or missing\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        return {\n            \"show_details\": kwargs.show_details,\n        }\n\n    ...\n</code></pre> <p>Warning</p> <p>When typing your components with <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, you may be inclined to define the defaults in the classes.</p> <pre><code>class ProfileCard(Component):\n    class Kwargs(NamedTuple):\n        show_details: bool = True\n</code></pre> <p>This is NOT recommended, because:</p> <ul> <li>The defaults will NOT be applied to inputs when using <code>self.raw_kwargs</code> property.</li> <li>The defaults will NOT be applied when a field is given but set to <code>None</code>.</li> </ul> <p>Instead, define the defaults in the <code>Defaults</code> class.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#accessing-render-api","title":"Accessing Render API","text":"<p>All three data methods have access to the Component's Render API, which includes:</p> <ul> <li><code>self.args</code> - The positional arguments for the current render call</li> <li><code>self.kwargs</code> - The keyword arguments for the current render call</li> <li><code>self.slots</code> - The slots for the current render call</li> <li><code>self.raw_args</code> - Unmodified positional arguments for the current render call</li> <li><code>self.raw_kwargs</code> - Unmodified keyword arguments for the current render call</li> <li><code>self.raw_slots</code> - Unmodified slots for the current render call</li> <li><code>self.context</code> - The context for the current render call</li> <li><code>self.id</code> - The unique ID for the current render call</li> <li><code>self.request</code> - The request object</li> <li><code>self.context_processors_data</code> - Data from Django's context processors</li> <li><code>self.inject()</code> - Inject data into the component</li> <li><code>self.registry</code> - The <code>ComponentRegistry</code> instance</li> <li><code>self.registered_name</code> - The name under which the component was registered</li> <li><code>self.outer_context</code> - The context outside of the <code>{% component %}</code> tag</li> <li><code>self.deps_strategy</code> - The strategy for rendering dependencies</li> </ul>"},{"location":"concepts/fundamentals/html_js_css_variables/#type-hints","title":"Type hints","text":""},{"location":"concepts/fundamentals/html_js_css_variables/#typing-inputs","title":"Typing inputs","text":"<p>You can add type hints for the component inputs to ensure that the component logic is correct.</p> <p>For this, define the <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes, and then add type hints to the data methods.</p> <p>This will also validate the inputs at runtime, as the type classes will be instantiated with the inputs.</p> <p>Read more about Component typing.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, SlotInput\n\nclass Button(Component):\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        footer: SlotInput\n\n    # Use the above classes to add type hints to the data method\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        # The parameters are instances of the classes we defined\n        assert isinstance(args, Button.Args)\n        assert isinstance(kwargs, Button.Kwargs)\n        assert isinstance(slots, Button.Slots)\n</code></pre> <p>Note</p> <p>To access \"untyped\" inputs, use <code>self.raw_args</code>, <code>self.raw_kwargs</code>, and <code>self.raw_slots</code> properties.</p> <p>These are plain lists and dictionaries, even when you added typing to your component.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#typing-data","title":"Typing data","text":"<p>In the same fashion, you can add types and validation for the data that should be RETURNED from each data method.</p> <p>For this, set the <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code> classes on the component class.</p> <p>For each data method, you can either return a plain dictionary with the data, or an instance of the respective data class.</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Button(Component):\n    class TemplateData(NamedTuple):\n        data1: str\n        data2: int\n\n    class JsData(NamedTuple):\n        js_data1: str\n        js_data2: int\n\n    class CssData(NamedTuple):\n        css_data1: str\n        css_data2: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return Button.TemplateData(\n            data1=\"...\",\n            data2=123,\n        )\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return Button.JsData(\n            js_data1=\"...\",\n            js_data2=123,\n        )\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return Button.CssData(\n            css_data1=\"...\",\n            css_data2=123,\n        )\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_variables/#pass-through-kwargs","title":"Pass-through kwargs","text":"<p>It's best practice to explicitly define what args and kwargs a component accepts.</p> <p>However, if you want a looser setup, you can easily write components that accept any number of kwargs, and pass them all to the template (similar to django-cotton).</p> <p>To do that, simply return the <code>kwargs</code> dictionary itself from <code>get_template_data()</code>:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre> <p>You can do the same for <code>get_js_data()</code> and <code>get_css_data()</code>, if needed:</p> <pre><code>class MyComponent(Component):\n    def get_js_data(self, args, kwargs, slots, context):\n        return kwargs\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre>"},{"location":"concepts/fundamentals/http_request/","title":"HTTP Request","text":"<p>The most common use of django-components is to render HTML when the server receives a request. As such, there are a few features that are dependent on the request object.</p>"},{"location":"concepts/fundamentals/http_request/#passing-the-httprequest-object","title":"Passing the HttpRequest object","text":"<p>In regular Django templates, the request object is available only within the <code>RequestContext</code>.</p> <p>In Components, you can either use <code>RequestContext</code>, or pass the <code>request</code> object explicitly to <code>Component.render()</code> and <code>Component.render_to_response()</code>.</p> <p>So the request object is available to components either when:</p> <ul> <li>The component is rendered with <code>RequestContext</code> (Regular Django behavior)</li> <li>The component is rendered with a regular <code>Context</code> (or none), but you set the <code>request</code> kwarg     of <code>Component.render()</code>.</li> <li>The component is nested and the parent has access to the request object.</li> </ul> <pre><code># \u2705 With request\nMyComponent.render(request=request)\nMyComponent.render(context=RequestContext(request, {}))\n\n# \u274c Without request\nMyComponent.render()\nMyComponent.render(context=Context({}))\n</code></pre> <p>When a component is rendered within a template with <code>{% component %}</code> tag, the request object is available depending on whether the template is rendered with <code>RequestContext</code> or not.</p> <pre><code>template = Template(\"\"\"\n&lt;div&gt;\n  {% component \"MyComponent\" / %}\n&lt;/div&gt;\n\"\"\")\n\n# \u274c No request\nrendered = template.render(Context({}))\n\n# \u2705 With request\nrendered = template.render(RequestContext(request, {}))\n</code></pre>"},{"location":"concepts/fundamentals/http_request/#accessing-the-httprequest-object","title":"Accessing the HttpRequest object","text":"<p>When the component has access to the <code>request</code> object, the request object will be available in <code>Component.request</code>.</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            'user_id': self.request.GET['user_id'],\n        }\n</code></pre>"},{"location":"concepts/fundamentals/http_request/#context-processors","title":"Context Processors","text":"<p>Components support Django's context processors.</p> <p>In regular Django templates, the context processors are applied only when the template is rendered with <code>RequestContext</code>.</p> <p>In Components, the context processors are applied when the component has access to the <code>request</code> object.</p>"},{"location":"concepts/fundamentals/http_request/#accessing-context-processors-data","title":"Accessing context processors data","text":"<p>The data from context processors is automatically available within the component's template.</p> <pre><code>class MyComponent(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {{ csrf_token }}\n        &lt;/div&gt;\n    \"\"\"\n\nMyComponent.render(request=request)\n</code></pre> <p>You can also access the context processors data from within <code>get_template_data()</code> and other methods under <code>Component.context_processors_data</code>.</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        csrf_token = self.context_processors_data['csrf_token']\n        return {\n            'csrf_token': csrf_token,\n        }\n</code></pre> <p>This is a dictionary with the context processors data.</p> <p>If the request object is not available, then <code>self.context_processors_data</code> will be an empty dictionary.</p> <p>Warning</p> <p>The <code>self.context_processors_data</code> object is generated dynamically, so changes to it are not persisted.</p>"},{"location":"concepts/fundamentals/render_api/","title":"Render API","text":"<p>When a component is being rendered, whether with <code>Component.render()</code> or <code>{% component %}</code>, a component instance is populated with the current inputs and context. This allows you to access things like component inputs.</p> <p>We refer to these render-time-only methods and attributes as the \"Render API\".</p> <p>Render API is available inside these <code>Component</code> methods:</p> <ul> <li><code>get_template_data()</code></li> <li><code>get_js_data()</code></li> <li><code>get_css_data()</code></li> <li><code>get_context_data()</code></li> <li><code>on_render_before()</code></li> <li><code>on_render()</code></li> <li><code>on_render_after()</code></li> </ul> <p>Example:</p> <pre><code>class Table(Component):\n    def on_render_before(self, context, template):\n        # Access component's ID\n        assert self.id == \"c1A2b3c\"\n\n        # Access component's inputs, slots and context\n        assert self.args == [123, \"str\"]\n        assert self.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.slots[\"footer\"]\n        some_var = self.context[\"some_var\"]\n\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access the request object and Django's context processors, if available\n        assert self.request.GET == {\"query\": \"something\"}\n        assert self.context_processors_data['user'].username == \"admin\"\n\nrendered = Table.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"footer\": \"MY_SLOT\"},\n)\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#overview","title":"Overview","text":"<p>The Render API includes:</p> <ul> <li> <p>Component inputs:</p> <ul> <li><code>self.args</code> - The positional arguments for the current render call</li> <li><code>self.kwargs</code> - The keyword arguments for the current render call</li> <li><code>self.slots</code> - The slots for the current render call</li> <li><code>self.raw_args</code> - Unmodified positional arguments for the current render call</li> <li><code>self.raw_kwargs</code> - Unmodified keyword arguments for the current render call</li> <li><code>self.raw_slots</code> - Unmodified slots for the current render call</li> <li><code>self.context</code> - The context for the current render call</li> <li><code>self.deps_strategy</code> - The strategy for rendering dependencies</li> </ul> </li> <li> <p>Request-related:</p> <ul> <li><code>self.request</code> - The request object (if available)</li> <li><code>self.context_processors_data</code> - Data from Django's context processors</li> </ul> </li> <li> <p>Provide / inject:</p> <ul> <li><code>self.inject()</code> - Inject data into the component</li> </ul> </li> <li> <p>Template tag metadata:</p> <ul> <li><code>self.node</code> - The <code>ComponentNode</code> instance</li> <li><code>self.registry</code> - The <code>ComponentRegistry</code> instance</li> <li><code>self.registered_name</code> - The name under which the component was registered</li> <li><code>self.outer_context</code> - The context outside of the <code>{% component %}</code> tag</li> </ul> </li> <li> <p>Other metadata:</p> <ul> <li><code>self.id</code> - The unique ID for the current render call</li> </ul> </li> </ul>"},{"location":"concepts/fundamentals/render_api/#component-inputs","title":"Component inputs","text":""},{"location":"concepts/fundamentals/render_api/#args","title":"Args","text":"<p>The <code>args</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>If you defined the <code>Component.Args</code> class, then the <code>Component.args</code> property will return an instance of that class.</p> <p>Otherwise, <code>args</code> will be a plain list.</p> <p>Use <code>self.raw_args</code> to access the positional arguments as a plain list irrespective of <code>Component.Args</code>.</p> <p>Example:</p> <p>With <code>Args</code> class:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    class Args(NamedTuple):\n        page: int\n        per_page: int\n\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.args.page == 123\n        assert self.args.per_page == 10\n\nrendered = Table.render(\n    args=[123, 10],\n)\n</code></pre> <p>Without <code>Args</code> class:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.args[0] == 123\n        assert self.args[1] == 10\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#kwargs","title":"Kwargs","text":"<p>The <code>kwargs</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>If you defined the <code>Component.Kwargs</code> class, then the <code>Component.kwargs</code> property will return an instance of that class.</p> <p>Otherwise, <code>kwargs</code> will be a plain dictionary.</p> <p>Use <code>self.raw_kwargs</code> to access the keyword arguments as a plain dictionary irrespective of <code>Component.Kwargs</code>.</p> <p>Example:</p> <p>With <code>Kwargs</code> class:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    class Kwargs(NamedTuple):\n        page: int\n        per_page: int\n\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.kwargs.page == 123\n        assert self.kwargs.per_page == 10\n\nrendered = Table.render(\n    kwargs={\"page\": 123, \"per_page\": 10},\n)\n</code></pre> <p>Without <code>Kwargs</code> class:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.kwargs[\"page\"] == 123\n        assert self.kwargs[\"per_page\"] == 10\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#slots","title":"Slots","text":"<p>The <code>slots</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>If you defined the <code>Component.Slots</code> class, then the <code>Component.slots</code> property will return an instance of that class.</p> <p>Otherwise, <code>slots</code> will be a plain dictionary.</p> <p>Use <code>self.raw_slots</code> to access the slots as a plain dictionary irrespective of <code>Component.Slots</code>.</p> <p>Example:</p> <p>With <code>Slots</code> class:</p> <pre><code>from django_components import Component, Slot, SlotInput\n\nclass Table(Component):\n    class Slots(NamedTuple):\n        header: SlotInput\n        footer: SlotInput\n\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert isinstance(self.slots.header, Slot)\n        assert isinstance(self.slots.footer, Slot)\n\nrendered = Table.render(\n    slots={\n        \"header\": \"MY_HEADER\",\n        \"footer\": lambda ctx: \"FOOTER: \" + ctx.data[\"user_id\"],\n    },\n)\n</code></pre> <p>Without <code>Slots</code> class:</p> <pre><code>from django_components import Component, Slot, SlotInput\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert isinstance(self.slots[\"header\"], Slot)\n        assert isinstance(self.slots[\"footer\"], Slot)\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#context","title":"Context","text":"<p>The <code>context</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>This is Django's Context with which the component template is rendered.</p> <p>If the root component or template was rendered with <code>RequestContext</code> then this will be an instance of <code>RequestContext</code>.</p> <p>Whether the context variables defined in <code>context</code> are available to the template depends on the context behavior mode:</p> <ul> <li> <p>In <code>\"django\"</code> context behavior mode, the template will have access to the keys of this context.</p> </li> <li> <p>In <code>\"isolated\"</code> context behavior mode, the template will NOT have access to this context,     and data MUST be passed via component's args and kwargs.</p> </li> </ul>"},{"location":"concepts/fundamentals/render_api/#component-id","title":"Component ID","text":"<p>Component ID (or render ID) is a unique identifier for the current render call.</p> <p>That means that if you call <code>Component.render()</code> multiple times, the ID will be different for each call.</p> <p>It is available as <code>self.id</code>.</p> <p>The ID is a 7-letter alphanumeric string in the format <code>cXXXXXX</code>, where <code>XXXXXX</code> is a random string of 6 alphanumeric characters (case-sensitive).</p> <p>E.g. <code>c1a2b3c</code>.</p> <p>A single render ID has a chance of collision 1 in 57 billion. However, due to birthday paradox, the chance of collision increases to 1% when approaching ~33K render IDs.</p> <p>Thus, there is currently a soft-cap of ~30K components rendered on a single page.</p> <p>If you need to expand this limit, please open an issue on GitHub.</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's ID\n        assert self.id == \"c1A2b3c\"\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#request-and-context-processors","title":"Request and context processors","text":"<p>Components have access to the request object and context processors data if the component was:</p> <ul> <li>Given a <code>request</code> kwarg directly</li> <li>Rendered with <code>RenderContext</code></li> <li>Nested in another component for which any of these conditions is true</li> </ul> <p>Then the request object will be available in <code>self.request</code>.</p> <p>If the request object is available, you will also be able to access the <code>context processors</code> data in <code>self.context_processors_data</code>.</p> <p>This is a dictionary with the context processors data.</p> <p>If the request object is not available, then <code>self.context_processors_data</code> will be an empty dictionary.</p> <p>Read more about the request object and context processors in the HTTP Request section.</p> <pre><code>from django.http import HttpRequest\n\nclass Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access the request object and Django's context processors\n        assert self.request.GET == {\"query\": \"something\"}\n        assert self.context_processors_data['user'].username == \"admin\"\n\nrendered = Table.render(\n    request=HttpRequest(),\n)\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#provide-inject","title":"Provide / Inject","text":"<p>Components support a provide / inject system as known from Vue or React.</p> <p>When rendering the component, you can call <code>self.inject()</code> with the key of the data you want to inject.</p> <p>The object returned by <code>self.inject()</code></p> <p>To provide data to components, use the <code>{% provide %}</code> template tag.</p> <p>Read more about Provide / Inject.</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access provided data\n        data = self.inject(\"some_data\")\n        assert data.some_data == \"some_data\"\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#template-tag-metadata","title":"Template tag metadata","text":"<p>If the component is rendered with <code>{% component %}</code> template tag, the following metadata is available:</p> <ul> <li><code>self.node</code> - The <code>ComponentNode</code> instance</li> <li><code>self.registry</code> - The <code>ComponentRegistry</code> instance   that was used to render the component</li> <li><code>self.registered_name</code> - The name under which the component was registered</li> <li> <p><code>self.outer_context</code> - The context outside of the <code>{% component %}</code> tag</p> <pre><code>{% with abc=123 %}\n    {{ abc }} {# &lt;--- This is in outer context #}\n    {% component \"my_component\" / %}\n{% endwith %}\n</code></pre> </li> </ul> <p>You can use these to check whether the component was rendered inside a template with <code>{% component %}</code> tag or in Python with <code>Component.render()</code>.</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        if self.registered_name is None:\n            # Do something for the render() function\n        else:\n            # Do something for the {% component %} template tag\n</code></pre> <p>You can access the <code>ComponentNode</code> under <code>Component.node</code>:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, context, template):\n        if self.node is not None:\n            assert self.node.name == \"my_component\"\n</code></pre> <p>Accessing the <code>ComponentNode</code> is mostly useful for extensions, which can modify their behaviour based on the source of the Component.</p> <p>For example, if <code>MyComponent</code> was used in another component - that is, with a <code>{% component \"my_component\" %}</code> tag in a template that belongs to another component - then you can use <code>self.node.template_component</code> to access the owner <code>Component</code> class.</p> <pre><code>class Parent(Component):\n    template: types.django_html = \"\"\"\n        &lt;div&gt;\n            {% component \"my_component\" / %}\n        &lt;/div&gt;\n    \"\"\"\n\n@register(\"my_component\")\nclass MyComponent(Component):\n    def get_template_data(self, context, template):\n        if self.node is not None:\n            assert self.node.template_component == Parent\n</code></pre> <p>Info</p> <p><code>Component.node</code> is <code>None</code> if the component is created by <code>Component.render()</code> (but you can pass in the <code>node</code> kwarg yourself).</p>"},{"location":"concepts/fundamentals/rendering_components/","title":"Rendering components","text":"<p>Your components can be rendered either within your Django templates, or directly in Python code.</p>"},{"location":"concepts/fundamentals/rendering_components/#overview","title":"Overview","text":"<p>Django Components provides three main methods to render components:</p> <ul> <li><code>{% component %}</code> tag - Renders the component within your Django templates</li> <li><code>Component.render()</code> method - Renders the component to a string</li> <li><code>Component.render_to_response()</code> method - Renders the component and wraps it in an HTTP response</li> </ul>"},{"location":"concepts/fundamentals/rendering_components/#component-tag","title":"<code>{% component %}</code> tag","text":"<p>Use the <code>{% component %}</code> tag to render a component within your Django templates.</p> <p>The <code>{% component %}</code> tag takes:</p> <ul> <li>Component's registered name as the first positional argument,</li> <li>Followed by any number of positional and keyword arguments.</li> </ul> <pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"button\" name=\"John\" job=\"Developer\" / %}\n&lt;/div&gt;\n</code></pre> <p>To pass in slots content, you can insert <code>{% fill %}</code> tags, directly within the <code>{% component %}</code> tag to \"fill\" the slots:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n    {% fill \"pagination\" %}\n      &lt; 1 | 2 | 3 &gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>You can even nest <code>{% fill %}</code> tags within <code>{% if %}</code>, <code>{% for %}</code> and other tags:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n    {% if rows %}\n        {% fill \"pagination\" %}\n            &lt; 1 | 2 | 3 &gt;\n        {% endfill %}\n    {% endif %}\n{% endcomponent %}\n</code></pre> <p>Omitting the <code>component</code> keyword</p> <p>If you would like to omit the <code>component</code> keyword, and simply refer to your components by their registered names:</p> <pre><code>{% button name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>You can do so by setting the \"shorthand\" Tag formatter in the settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\",\n}\n</code></pre> <p>Extended template tag syntax</p> <p>Unlike regular Django template tags, django-components' tags offer extra features like defining literal lists and dicts, and more. Read more about Template tag syntax.</p>"},{"location":"concepts/fundamentals/rendering_components/#registering-components","title":"Registering components","text":"<p>For a component to be renderable with the <code>{% component %}</code> tag, it must be first registered with the <code>@register()</code> decorator.</p> <p>For example, if you register a component under the name <code>\"button\"</code>:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component, register\n\n@register(\"button\")\nclass Button(Component):\n    template_file = \"button.html\"\n\n    class Kwargs(NamedTuple):\n        name: str\n        job: str\n\n    def get_template_data(self, args, kwargs, slots, context):\n        ...\n</code></pre> <p>Then you can render this component by using its registered name <code>\"button\"</code> in the template:</p> <pre><code>{% component \"button\" name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>As you can see above, the args and kwargs passed to the <code>{% component %}</code> tag correspond to the component's input.</p> <p>For more details, read Registering components.</p> <p>Why do I need to register components?</p> <p>TL;DR: To be able to share components as libraries, and because components can be registed with multiple registries / libraries.</p> <p>Django-components allows to share components across projects.</p> <p>However, different projects may use different settings. For example, one project may prefer the \"long\" format:</p> <pre><code>{% component \"button\" name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>While the other may use the \"short\" format:</p> <pre><code>{% button name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>Both approaches are supported simultaneously for backwards compatibility, because django-components started out with only the \"long\" format.</p> <p>To avoid ambiguity, when you use a 3rd party library, it uses the syntax that the author had configured for it.</p> <p>So when you are creating a component, django-components need to know which registry the component belongs to, so it knows which syntax to use.</p>"},{"location":"concepts/fundamentals/rendering_components/#rendering-templates","title":"Rendering templates","text":"<p>If you have embedded the component in a Django template using the <code>{% component %}</code> tag:</p> [project root]/templates/my_template.html<pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"calendar\" date=\"2024-12-13\" / %}\n&lt;/div&gt;\n</code></pre> <p>You can simply render the template with the Django's API:</p> <ul> <li> <p><code>django.shortcuts.render()</code></p> <pre><code>from django.shortcuts import render\n\ncontext = {\"date\": \"2024-12-13\"}\nrendered_template = render(request, \"my_template.html\", context)\n</code></pre> </li> <li> <p><code>Template.render()</code></p> <pre><code>from django.template import Template\nfrom django.template.loader import get_template\n\n# Either from a file\ntemplate = get_template(\"my_template.html\")\n\n# or inlined\ntemplate = Template(\"\"\"\n    {% load component_tags %}\n    &lt;div&gt;\n        {% component \"calendar\" date=\"2024-12-13\" / %}\n    &lt;/div&gt;\n\"\"\")\n\nrendered_template = template.render()\n</code></pre> </li> </ul>"},{"location":"concepts/fundamentals/rendering_components/#isolating-components","title":"Isolating components","text":"<p>By default, components behave similarly to Django's <code>{% include %}</code>, and the template inside the component has access to the variables defined in the outer template.</p> <p>You can selectively isolate a component, using the <code>only</code> flag, so that the inner template can access only the data that was explicitly passed to it:</p> <pre><code>{% component \"name\" positional_arg keyword_arg=value ... only / %}\n</code></pre> <p>Alternatively, you can set all components to be isolated by default, by setting <code>context_behavior</code> to <code>\"isolated\"</code> in your settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"context_behavior\": \"isolated\",\n}\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#render-method","title":"<code>render()</code> method","text":"<p>The <code>Component.render()</code> method renders a component to a string.</p> <p>This is the equivalent of calling the <code>{% component %}</code> tag.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, SlotInput\n\nclass Button(Component):\n    template_file = \"button.html\"\n\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n\n    class Slots(NamedTuple):\n        footer: Optional[SlotInput] = None\n\n    def get_template_data(self, args, kwargs, slots, context):\n        ...\n\nButton.render(\n    args=[\"John\"],\n    kwargs={\n        \"surname\": \"Doe\",\n        \"age\": 30,\n    },\n    slots={\n        \"footer\": \"i AM A SLOT\",\n    },\n)\n</code></pre> <p><code>Component.render()</code> accepts the following arguments:</p> <ul> <li><code>args</code> - Positional arguments to pass to the component (as a list or tuple)</li> <li><code>kwargs</code> - Keyword arguments to pass to the component (as a dictionary)</li> <li><code>slots</code> - Slot content to pass to the component (as a dictionary)</li> <li><code>context</code> - Django context for rendering (can be a dictionary or a <code>Context</code> object)</li> <li><code>deps_strategy</code> - Dependencies rendering strategy (default: <code>\"document\"</code>)</li> <li><code>request</code> - HTTP request object, used for context processors (optional)</li> </ul> <p>All arguments are optional. If not provided, they default to empty values or sensible defaults.</p> <p>See the API reference for <code>Component.render()</code> for more details on the arguments.</p>"},{"location":"concepts/fundamentals/rendering_components/#render_to_response-method","title":"<code>render_to_response()</code> method","text":"<p>The <code>Component.render_to_response()</code> method works just like <code>Component.render()</code>, but wraps the result in an HTTP response.</p> <p>It accepts all the same arguments as <code>Component.render()</code>.</p> <p>Any extra arguments are passed to the <code>HttpResponse</code> constructor.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, SlotInput\n\nclass Button(Component):\n    template_file = \"button.html\"\n\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n\n    class Slots(NamedTuple):\n        footer: Optional[SlotInput] = None\n\n    def get_template_data(self, args, kwargs, slots, context):\n        ...\n\n# Render the component to an HttpResponse\nresponse = Button.render_to_response(\n    args=[\"John\"],\n    kwargs={\n        \"surname\": \"Doe\",\n        \"age\": 30,\n    },\n    slots={\n        \"footer\": \"i AM A SLOT\",\n    },\n    # Additional response arguments\n    status=200,\n    headers={\"X-Custom-Header\": \"Value\"},\n)\n</code></pre> <p>This method is particularly useful in view functions, as you can return the result of the component directly:</p> <pre><code>def profile_view(request, user_id):\n    return Button.render_to_response(\n        kwargs={\n            \"surname\": \"Doe\",\n            \"age\": 30,\n        },\n        request=request,\n    )\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#custom-response-classes","title":"Custom response classes","text":"<p>By default, <code>Component.render_to_response()</code> returns a standard Django <code>HttpResponse</code>.</p> <p>You can customize this by setting the <code>response_class</code> attribute on your component:</p> <pre><code>from django.http import HttpResponse\nfrom django_components import Component\n\nclass MyHttpResponse(HttpResponse):\n    ...\n\nclass MyComponent(Component):\n    response_class = MyHttpResponse\n\nresponse = MyComponent.render_to_response()\nassert isinstance(response, MyHttpResponse)\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#dependencies-rendering","title":"Dependencies rendering","text":"<p>The rendered HTML may be used in different contexts (browser, email, etc), and each may need different handling of JS and CSS scripts.</p> <p><code>render()</code> and <code>render_to_response()</code> accept a <code>deps_strategy</code> parameter, which controls where and how the JS / CSS are inserted into the HTML.</p> <p>The <code>deps_strategy</code> parameter is ultimately passed to <code>render_dependencies()</code>.</p> <p>Learn more about Rendering JS / CSS.</p> <p>There are six dependencies rendering strategies:</p> <ul> <li><code>document</code> (default)<ul> <li>Smartly inserts JS / CSS into placeholders (<code>{% component_js_dependencies %}</code>) or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Requires the HTML to be rendered in a JS-enabled browser.</li> <li>Inserts extra script for managing fragments.</li> </ul> </li> <li><code>fragment</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>Fragment will fetch its own JS / CSS dependencies when inserted into the page.</li> <li>Requires the HTML to be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>simple</code><ul> <li>Smartly insert JS / CSS into placeholders (<code>{% component_js_dependencies %}</code>) or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>prepend</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>Ignores the placeholders (<code>{% component_js_dependencies %}</code>) and any <code>&lt;head&gt;</code>/<code>&lt;body&gt;</code> HTML tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>append</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>Ignores the placeholders (<code>{% component_js_dependencies %}</code>) and any <code>&lt;head&gt;</code>/<code>&lt;body&gt;</code> HTML tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>ignore</code><ul> <li>HTML is left as-is. You can still process it with a different strategy later with   <code>render_dependencies()</code>.</li> <li>Used for inserting rendered HTML into other components.</li> </ul> </li> </ul> <p>Info</p> <p>You can use the <code>\"prepend\"</code> and <code>\"append\"</code> strategies to force to output JS / CSS for components that don't have neither the placeholders like <code>{% component_js_dependencies %}</code>, nor any <code>&lt;head&gt;</code>/<code>&lt;body&gt;</code> HTML tags:</p> <pre><code>rendered = Calendar.render_to_response(\n    request=request,\n    kwargs={\n        \"date\": request.GET.get(\"date\", \"\"),\n    },\n    deps_strategy=\"append\",\n)\n</code></pre> <p>Renders something like this:</p> <pre><code>&lt;!-- Calendar component --&gt;\n&lt;div class=\"calendar\"&gt;\n    ...\n&lt;/div&gt;\n&lt;!-- Appended JS / CSS --&gt;\n&lt;script src=\"...\"&gt;&lt;/script&gt;\n&lt;link href=\"...\"&gt;&lt;/link&gt;\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#passing-context","title":"Passing context","text":"<p>The <code>render()</code> and <code>render_to_response()</code> methods accept an optional <code>context</code> argument. This sets the context within which the component is rendered.</p> <p>When a component is rendered within a template with the <code>{% component %}</code> tag, this will be automatically set to the Context instance that is used for rendering the template.</p> <p>When you call <code>Component.render()</code> directly from Python, there is no context object, so you can ignore this input most of the time. Instead, use <code>args</code>, <code>kwargs</code>, and <code>slots</code> to pass data to the component.</p> <p>However, you can pass <code>RequestContext</code> to the <code>context</code> argument, so that the component will gain access to the request object and will use context processors. Read more on Working with HTTP requests.</p> <pre><code>Button.render(\n    context=RequestContext(request),\n)\n</code></pre> <p>For advanced use cases, you can use <code>context</code> argument to \"pre-render\" the component in Python, and then pass the rendered output as plain string to the template. With this, the inner component is rendered as if it was within the template with <code>{% component %}</code>.</p> <pre><code>class Button(Component):\n    def render(self, context, template):\n        # Pass `context` to Icon component so it is rendered\n        # as if nested within Button.\n        icon = Icon.render(\n            context=context,\n            args=[\"icon-name\"],\n            deps_strategy=\"ignore\",\n        )\n        # Update context with icon\n        with context.update({\"icon\": icon}):\n            return template.render(context)\n</code></pre> <p>Warning</p> <p>Whether the variables defined in <code>context</code> are actually available in the template depends on the context behavior mode:</p> <ul> <li> <p>In <code>\"django\"</code> context behavior mode, the template will have access to the keys of this context.</p> </li> <li> <p>In <code>\"isolated\"</code> context behavior mode, the template will NOT have access to this context,     and data MUST be passed via component's args and kwargs.</p> </li> </ul> <p>Therefore, it's strongly recommended to not rely on defining variables on the context object, but instead passing them through as <code>args</code> and <code>kwargs</code></p> <p>\u274c Don't do this:</p> <pre><code>html = ProfileCard.render(\n    context={\"name\": \"John\"},\n)\n</code></pre> <p>\u2705 Do this:</p> <pre><code>html = ProfileCard.render(\n    kwargs={\"name\": \"John\"},\n)\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#typing-render-methods","title":"Typing render methods","text":"<p>Neither <code>Component.render()</code> nor <code>Component.render_to_response()</code> are typed, due to limitations of Python's type system.</p> <p>To add type hints, you can wrap the inputs in component's <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes.</p> <p>Read more on Typing and validation.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, Slot, SlotInput\n\n# Define the component with the types\nclass Button(Component):\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        footer: SlotInput\n\n# Add type hints to the render call\nButton.render(\n    args=Button.Args(\n        name=\"John\",\n    ),\n    kwargs=Button.Kwargs(\n        surname=\"Doe\",\n        age=30,\n    ),\n    slots=Button.Slots(\n        footer=Slot(lambda ctx: \"Click me!\"),\n    ),\n)\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#components-as-input","title":"Components as input","text":"<p>django_components makes it possible to compose components in a \"React-like\" way, where you can render one component and use its output as input to another component:</p> <pre><code>from django.utils.safestring import mark_safe\n\n# Render the inner component\ninner_html = InnerComponent.render(\n    kwargs={\"some_data\": \"value\"},\n    deps_strategy=\"ignore\",  # Important for nesting!\n)\n\n# Use inner component's output in the outer component\nouter_html = OuterComponent.render(\n    kwargs={\n        \"content\": mark_safe(inner_html),  # Mark as safe to prevent escaping\n    },\n)\n</code></pre> <p>The key here is setting <code>deps_strategy=\"ignore\"</code> for the inner component. This prevents duplicate rendering of JS / CSS dependencies when the outer component is rendered.</p> <p>When <code>deps_strategy=\"ignore\"</code>:</p> <ul> <li>No JS or CSS dependencies will be added to the output HTML</li> <li>The component's content is rendered as-is</li> <li>The outer component will take care of including all needed dependencies</li> </ul> <p>Read more about Rendering JS / CSS.</p>"},{"location":"concepts/fundamentals/rendering_components/#dynamic-components","title":"Dynamic components","text":"<p>Django components defines a special \"dynamic\" component (<code>DynamicComponent</code>).</p> <p>Normally, you have to hard-code the component name in the template:</p> <pre><code>{% component \"button\" / %}\n</code></pre> <p>The dynamic component allows you to dynamically render any component based on the <code>is</code> kwarg. This is similar to Vue's dynamic components (<code>&lt;component :is&gt;</code>).</p> <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>As with other components, the dynamic component can be rendered from Python:</p> <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            deps_strategy=\"ignore\",\n        ),\n    },\n)\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#dynamic-component-name","title":"Dynamic component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#html-fragments","title":"HTML fragments","text":"<p>Django-components provides a seamless integration with HTML fragments with AJAX (HTML over the wire), whether you're using jQuery, HTMX, AlpineJS, vanilla JavaScript, or other.</p> <p>This is achieved by the combination of the <code>\"document\"</code> and <code>\"fragment\"</code> dependencies rendering strategies.</p> <p>Read more about HTML fragments and Rendering JS / CSS.</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/","title":"Secondary JS / CSS files","text":""},{"location":"concepts/fundamentals/secondary_js_css_files/#overview","title":"Overview","text":"<p>Each component can define extra or \"secondary\" CSS / JS files using the nested <code>Component.Media</code> class, by setting <code>Component.Media.js</code> and <code>Component.Media.css</code>.</p> <p>The main HTML / JS / CSS files are limited to 1 per component. This is not the case for the secondary files, where components can have many of them.</p> <p>There is also no special behavior or post-processing for these secondary files, they are loaded as is.</p> <p>You can use these for third-party libraries, or for shared CSS / JS files.</p> <p>These must be set as paths, URLs, or custom objects.</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    class Media:\n        js = [\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",\n            \"calendar/script.js\",\n        ]\n        css = [\n            \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",\n            \"calendar/style.css\",\n        ]\n</code></pre> <p>Note</p> <p>django-component's management of files is inspired by Django's <code>Media</code> class.</p> <p>To be familiar with how Django handles static files, we recommend reading also:</p> <ul> <li>How to manage static files (e.g. images, JavaScript, CSS)</li> </ul>"},{"location":"concepts/fundamentals/secondary_js_css_files/#media-class","title":"<code>Media</code> class","text":"<p>Use the <code>Media</code> class to define secondary JS / CSS files for a component.</p> <p>This <code>Media</code> class behaves similarly to Django's Media class:</p> <ul> <li>Static paths - Paths are handled as static file paths, and are resolved to URLs with Django's   <code>{% static %}</code> template tag.</li> <li>URLs - A path that starts with <code>http</code>, <code>https</code>, or <code>/</code> is considered a URL. URLs are NOT resolved with <code>{% static %}</code>.</li> <li>HTML tags - Both static paths and URLs are rendered to <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> HTML tags with   <code>media_class.render_js()</code> and <code>media_class.render_css()</code>.</li> <li>Bypass formatting - A <code>SafeString</code>,   or a function (with <code>__html__</code> method) is considered an already-formatted HTML tag, skipping both static file   resolution and rendering with <code>media_class.render_js()</code> or <code>media_class.render_css()</code>.</li> <li>Inheritance - You can set <code>extend</code> to configure     whether to inherit JS / CSS from parent components. See Media inheritance.</li> </ul> <p>However, there's a few differences from Django's Media class:</p> <ol> <li>Our Media class accepts various formats for the JS and CSS files: either a single file, a list,    or (CSS-only) a dictonary (See <code>ComponentMediaInput</code>).</li> <li>Individual JS / CSS files can be any of <code>str</code>, <code>bytes</code>, <code>Path</code>,    <code>SafeString</code>, or a function    (See <code>ComponentMediaInputPath</code>).</li> <li>Individual JS / CSS files can be glob patterns, e.g. <code>*.js</code> or <code>styles/**/*.css</code>.</li> <li>If you set <code>Media.extend</code> to a list,    it should be a list of <code>Component</code> classes.</li> </ol> <pre><code>from components.layout import LayoutComp\n\nclass MyTable(Component):\n    class Media:\n        js = [\n            \"path/to/script.js\",\n            \"path/to/*.js\",  # Or as a glob\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",  # AlpineJS\n        ]\n        css = {\n            \"all\": [\n                \"path/to/style.css\",\n                \"path/to/*.css\",  # Or as a glob\n                \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",  # TailwindCSS\n            ],\n            \"print\": [\"path/to/style2.css\"],\n        }\n\n        # Reuse JS / CSS from LayoutComp\n        extend = [\n            LayoutComp,\n        ]\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/#css-media-types","title":"CSS media types","text":"<p>You can define which stylesheets will be associated with which CSS media types. You do so by defining CSS files as a dictionary.</p> <p>See the corresponding Django Documentation.</p> <p>Again, you can set either a single file or a list of files per media type:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": \"path/to/style1.css\",\n            \"print\": [\"path/to/style2.css\", \"path/to/style3.css\"],\n        }\n</code></pre> <p>Which will render the following HTML:</p> <pre><code>&lt;link href=\"/static/path/to/style1.css\" media=\"all\" rel=\"stylesheet\"&gt;\n&lt;link href=\"/static/path/to/style2.css\" media=\"print\" rel=\"stylesheet\"&gt;\n&lt;link href=\"/static/path/to/style3.css\" media=\"print\" rel=\"stylesheet\"&gt;\n</code></pre> <p>Note</p> <p>When you define CSS as a string or a list, the <code>all</code> media type is implied.</p> <p>So these two examples are the same:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        css = \"path/to/style1.css\"\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": [\"path/to/style1.css\"],\n        }\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/#media-inheritance","title":"Media inheritance","text":"<p>By default, the media files are inherited from the parent component.</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"parent.js\", \"script.js\"]\n</code></pre> <p>You can set the component NOT to inherit from the parent component by setting the <code>extend</code> attribute to <code>False</code>:</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        extend = False  # Don't inherit parent media\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"script.js\"]\n</code></pre> <p>Alternatively, you can specify which components to inherit from. In such case, the media files are inherited ONLY from the specified components, and NOT from the original parent components:</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        # Only inherit from these, ignoring the files from the parent\n        extend = [OtherComponent1, OtherComponent2]\n\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"script.js\", \"other1.js\", \"other2.js\"]\n</code></pre> <p>Info</p> <p>The <code>extend</code> behaves consistently with Django's Media class, with one exception:</p> <ul> <li>When you set <code>extend</code> to a list, the list is expected to contain Component classes (or other classes that have a nested <code>Media</code> class).</li> </ul>"},{"location":"concepts/fundamentals/secondary_js_css_files/#accessing-media-files","title":"Accessing Media files","text":"<p>To access the files that you defined under <code>Component.Media</code>, use <code>Component.media</code> (lowercase).</p> <p>This is consistent behavior with Django's Media class.</p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"path/to/script.js\"\n        css = \"path/to/style.css\"\n\nprint(MyComponent.media)\n# Output:\n# &lt;script src=\"/static/path/to/script.js\"&gt;&lt;/script&gt;\n# &lt;link href=\"/static/path/to/style.css\" media=\"all\" rel=\"stylesheet\"&gt;\n</code></pre> <p>When working with component media files, it is important to understand the difference:</p> <ul> <li> <p><code>Component.Media</code></p> <ul> <li>Is the \"raw\" media definition, or the input, which holds only the component's own media definition</li> <li>This class is NOT instantiated, it merely holds the JS / CSS files.</li> </ul> </li> <li> <p><code>Component.media</code></p> <ul> <li>Returns all resolved media files, including those inherited from parent components</li> <li>Is an instance of <code>Component.media_class</code></li> </ul> </li> </ul> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass ChildComponent(ParentComponent):\n    class Media:\n        js = [\"child.js\"]\n\n# Access only this component's media\nprint(ChildComponent.Media.js)  # [\"child.js\"]\n\n# Access all inherited media\nprint(ChildComponent.media._js)  # [\"parent.js\", \"child.js\"]\n</code></pre> <p>Note</p> <p>You should not manually modify <code>Component.media</code> or <code>Component.Media</code> after the component has been resolved, as this may lead to unexpected behavior.</p> <p>If you want to modify the class that is instantiated for <code>Component.media</code>, you can configure <code>Component.media_class</code> (See example).</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/#file-paths","title":"File paths","text":"<p>Unlike the main HTML / JS / CSS files, the path definition for the secondary files are quite ergonomic.</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/#relative-to-component","title":"Relative to component","text":"<p>As seen in the getting started example, to associate HTML / JS / CSS files with a component, you can set them as <code>Component.template_file</code>, <code>Component.js_file</code> and <code>Component.css_file</code> respectively:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"template.html\"\n    css_file = \"style.css\"\n    js_file = \"script.js\"\n</code></pre> <p>In the example above, we defined the files relative to the directory where the component file is defined.</p> <p>Alternatively, you can specify the file paths relative to the directories set in <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code>.</p> <p>If you specify the paths relative to component's directory, django-componenents does the conversion automatically for you.</p> <p>Thus, assuming that <code>COMPONENTS.dirs</code> contains path <code>[project root]/components</code>, the example above is the same as writing:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n    css_file = \"calendar/style.css\"\n    js_file = \"calendar/script.js\"\n</code></pre> <p>Important</p> <p>File path resolution in-depth</p> <p>At component class creation, django-components checks all file paths defined on the component (e.g. <code>Component.template_file</code>).</p> <p>For each file path, it checks if the file path is relative to the component's directory. And such file exists, the component's file path is re-written to be defined relative to a first matching directory in <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code>.</p> <p>Example:</p> [root]/components/mytable/mytable.py<pre><code>class MyTable(Component):\n    template_file = \"mytable.html\"\n</code></pre> <ol> <li>Component <code>MyTable</code> is defined in file <code>[root]/components/mytable/mytable.py</code>.</li> <li>The component's directory is thus <code>[root]/components/mytable/</code>.</li> <li>Because <code>MyTable.template_file</code> is <code>mytable.html</code>, django-components tries to     resolve it as <code>[root]/components/mytable/mytable.html</code>.</li> <li>django-components checks the filesystem. If there's no such file, nothing happens.</li> <li>If there IS such file, django-components tries to rewrite the path.</li> <li>django-components searches <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> for a first     directory that contains <code>[root]/components/mytable/mytable.html</code>.</li> <li>It comes across <code>[root]/components/</code>, which DOES contain the path to <code>mytable.html</code>.</li> <li>Thus, it rewrites <code>template_file</code> from <code>mytable.html</code> to <code>mytable/mytable.html</code>.</li> </ol> <p>NOTE: In case of ambiguity, the preference goes to resolving the files relative to the component's directory.</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/#globs","title":"Globs","text":"<p>Components can have many secondary files. To simplify their declaration, you can use globs.</p> <p>Globs MUST be relative to the component's directory.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    class Media:\n        js = [\n            \"path/to/*.js\",\n            \"another/path/*.js\",\n        ]\n        css = \"*.css\"\n</code></pre> <p>How this works is that django-components will detect that the path is a glob, and will try to resolve all files matching the glob pattern relative to the component's directory.</p> <p>After that, the file paths are handled the same way as if you defined them explicitly.</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/#supported-types","title":"Supported types","text":"<p>File paths can be any of:</p> <ul> <li><code>str</code></li> <li><code>bytes</code></li> <li><code>PathLike</code> (<code>__fspath__</code> method)</li> <li><code>SafeData</code> (<code>__html__</code> method)</li> <li><code>Callable</code> that returns any of the above, evaluated at class creation (<code>__new__</code>)</li> </ul> <p>To help with typing the union, use <code>ComponentMediaInputPath</code>.</p> <pre><code>from pathlib import Path\n\nfrom django.utils.safestring import mark_safe\n\nclass SimpleComponent(Component):\n    class Media:\n        css = [\n            mark_safe('&lt;link href=\"/static/calendar/style1.css\" rel=\"stylesheet\" /&gt;'),\n            Path(\"calendar/style1.css\"),\n            \"calendar/style2.css\",\n            b\"calendar/style3.css\",\n            lambda: \"calendar/style4.css\",\n        ]\n        js = [\n            mark_safe('&lt;script src=\"/static/calendar/script1.js\"&gt;&lt;/script&gt;'),\n            Path(\"calendar/script1.js\"),\n            \"calendar/script2.js\",\n            b\"calendar/script3.js\",\n            lambda: \"calendar/script4.js\",\n        ]\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/#paths-as-objects","title":"Paths as objects","text":"<p>In the example above, you can see that when we used Django's <code>mark_safe()</code> to mark a string as a <code>SafeString</code>, we had to define the URL / path as an HTML <code>&lt;script&gt;</code>/<code>&lt;link&gt;</code> elements.</p> <p>This is an extension of Django's Paths as objects feature, where \"safe\" strings are taken as is, and are accessed only at render time.</p> <p>Because of that, the paths defined as \"safe\" strings are NEVER resolved, neither relative to component's directory, nor relative to <code>COMPONENTS.dirs</code>. It is assumed that you will define the full <code>&lt;script&gt;</code>/<code>&lt;link&gt;</code> tag with the correct URL / path.</p> <p>\"Safe\" strings can be used to lazily resolve a path, or to customize the <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> tag for individual paths:</p> <p>In the example below, we make use of \"safe\" strings to add <code>type=\"module\"</code> to the script tag that will fetch <code>calendar/script2.js</code>. In this case, we implemented a \"safe\" string by defining a <code>__html__</code> method.</p> <pre><code># Path object\nclass ModuleJsPath:\n    def __init__(self, static_path: str) -&gt; None:\n        self.static_path = static_path\n\n    # Lazily resolve the path\n    def __html__(self):\n        full_path = static(self.static_path)\n        return format_html(\n            f'&lt;script type=\"module\" src=\"{full_path}\"&gt;&lt;/script&gt;'\n        )\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n\n    class Media:\n        css = \"calendar/style1.css\"\n        js = [\n            # &lt;script&gt; tag constructed by Media class\n            \"calendar/script1.js\",\n            # Custom &lt;script&gt; tag\n            ModuleJsPath(\"calendar/script2.js\"),\n        ]\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/#rendering-paths","title":"Rendering paths","text":"<p>As part of the rendering process, the secondary JS / CSS files are resolved and rendered into <code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> HTML tags, so they can be inserted into the render.</p> <p>In the Paths as objects section, we saw that we can use that to selectively change how the HTML tags are constructed.</p> <p>However, if you need to change how ALL CSS and JS files are rendered for a given component, you can provide your own subclass of Django's <code>Media</code> class to the <code>Component.media_class</code> attribute.</p> <p>To change how the tags are constructed, you can override the <code>Media.render_js()</code> and <code>Media.render_css()</code> methods:</p> <pre><code>from django.forms.widgets import Media\nfrom django_components import Component, register\n\nclass MyMedia(Media):\n    # Same as original Media.render_js, except\n    # the `&lt;script&gt;` tag has also `type=\"module\"`\n    def render_js(self):\n        tags = []\n        for path in self._js:\n            if hasattr(path, \"__html__\"):\n                tag = path.__html__()\n            else:\n                tag = format_html(\n                    '&lt;script type=\"module\" src=\"{}\"&gt;&lt;/script&gt;',\n                    self.absolute_path(path)\n                )\n        return tags\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n    css_file = \"calendar/style.css\"\n    js_file = \"calendar/script.js\"\n\n    class Media:\n        css = \"calendar/style1.css\"\n        js = \"calendar/script2.js\"\n\n    # Override the behavior of Media class\n    media_class = MyMedia\n</code></pre>"},{"location":"concepts/fundamentals/single_file_components/","title":"Single-file components","text":"<p>Components can be defined in a single file, inlining the HTML, JS and CSS within the Python code.</p>"},{"location":"concepts/fundamentals/single_file_components/#writing-single-file-components","title":"Writing single file components","text":"<p>To do this, you can use the <code>template</code>, <code>js</code>, and <code>css</code> class attributes instead of the <code>template_file</code>, <code>js_file</code>, and <code>css_file</code>.</p> <p>For example, here's the calendar component from the Getting started tutorial:</p> calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n</code></pre> <p>And here is the same component, rewritten in a single file:</p> [project root]/components/calendar.py<pre><code>from django_components import Component, register, types\n\n@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n\n    template: types.django_html = \"\"\"\n        &lt;div class=\"calendar\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css: types.css = \"\"\"\n        .calendar {\n            width: 200px;\n            background: pink;\n        }\n        .calendar span {\n            font-weight: bold;\n        }\n    \"\"\"\n\n    js: types.js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar\")) {\n                document.querySelector(\".calendar\").onclick = () =&gt; {\n                    alert(\"Clicked calendar!\");\n                };\n            }\n        })()\n    \"\"\"\n</code></pre> <p>You can mix and match, so you can have a component with inlined HTML, while the JS and CSS are in separate files:</p> [project root]/components/calendar.py<pre><code>from django_components import Component, register, types\n\n@register(\"calendar\")\nclass Calendar(Component):\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    template: types.django_html = \"\"\"\n        &lt;div class=\"calendar\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/single_file_components/#syntax-highlighting","title":"Syntax highlighting","text":"<p>If you \"inline\" the HTML, JS and CSS code into the Python class, you should set up syntax highlighting to let your code editor know that the inlined code is HTML, JS and CSS.</p> <p>In the examples above, we've annotated the <code>template</code>, <code>js</code>, and <code>css</code> attributes with the <code>types.django_html</code>, <code>types.js</code> and <code>types.css</code> types. These are used for syntax highlighting in VSCode.</p> <p>Warning</p> <p>Autocompletion / intellisense does not work in the inlined code.</p> <p>Help us add support for intellisense in the inlined code! Start a conversation in the GitHub Discussions.</p>"},{"location":"concepts/fundamentals/single_file_components/#vscode","title":"VSCode","text":"<ol> <li> <p>First install Python Inline Source Syntax Highlighting extension, it will give you syntax highlighting for the template, CSS, and JS.</p> </li> <li> <p>Next, in your component, set typings of <code>Component.template</code>, <code>Component.js</code>, <code>Component.css</code> to <code>types.django_html</code>, <code>types.css</code>, and <code>types.js</code> respectively. The extension will recognize these and will activate syntax highlighting.</p> </li> </ol> [project root]/components/calendar.py<pre><code>from django_components import Component, register, types\n\n@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n\n    template: types.django_html = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css: types.css = \"\"\"\n        .calendar-component {\n            width: 200px;\n            background: pink;\n        }\n        .calendar-component span {\n            font-weight: bold;\n        }\n    \"\"\"\n\n    js: types.js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar-component\")) {\n                document.querySelector(\".calendar-component\").onclick = function(){ alert(\"Clicked calendar!\"); };\n            }\n        })()\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/single_file_components/#pycharm-or-other-jetbrains-ides","title":"Pycharm (or other Jetbrains IDEs)","text":"<p>With PyCharm (or any other editor from Jetbrains), you don't need to use <code>types.django_html</code>, <code>types.css</code>, <code>types.js</code> since Pycharm uses language injections.</p> <p>You only need to write the comments <code># language=&lt;lang&gt;</code> above the variables.</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n\n    # language=HTML\n    template= \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    # language=CSS\n    css = \"\"\"\n        .calendar-component {\n            width: 200px;\n            background: pink;\n        }\n        .calendar-component span {\n            font-weight: bold;\n        }\n    \"\"\"\n\n    # language=JS\n    js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar-component\")) {\n                document.querySelector(\".calendar-component\").onclick = function(){ alert(\"Clicked calendar!\"); };\n            }\n        })()\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/single_file_components/#markdown-code-blocks-with-pygments","title":"Markdown code blocks with Pygments","text":"<p>Pygments is a syntax highlighting library written in Python. It's also what's used by this documentation site (mkdocs-material) to highlight code blocks.</p> <p>To write code blocks with syntax highlighting, you need to install the <code>pygments-djc</code> package.</p> <pre><code>pip install pygments-djc\n</code></pre> <p>And then initialize it by importing <code>pygments_djc</code> somewhere in your project:</p> <pre><code>import pygments_djc\n</code></pre> <p>Now you can use the <code>djc_py</code> code block to write code blocks with syntax highlighting for components.</p> <pre><code>\\```djc_py\nfrom django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n        .calendar-component {\n            width: 200px;\n            background: pink;\n        }\n        .calendar-component span {\n            font-weight: bold;\n        }\n    \"\"\"\n\\```\n</code></pre> <p>Will be rendered as below. Notice that the CSS and HTML are highlighted correctly:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template= \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n        .calendar-component {\n            width: 200px;\n            background: pink;\n        }\n        .calendar-component span {\n            font-weight: bold;\n        }\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/slots/","title":"Slots","text":"<p>django-components has the most extensive slot system of all the popular Python templating engines.</p> <p>The slot system is based on Vue, and works across both Django templates and Python code.</p>"},{"location":"concepts/fundamentals/slots/#what-are-slots","title":"What are slots?","text":"<p>Components support something called 'slots'.</p> <p>When you write a component, you define its template. The template will always be the same each time you render the component.</p> <p>However, sometimes you may want to customize the component slightly to change the content of the component. This is where slots come in.</p> <p>Slots allow you to insert parts of HTML into the component. This makes components more reusable and composable.</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {# This is where the component will insert the content #}\n        {% slot \"header\" / %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#slot-anatomy","title":"Slot anatomy","text":"<p>Slots consists of two parts:</p> <ol> <li><code>{% slot %}</code> tag - Inside your component you decide where you want to insert the content.</li> <li><code>{% fill %}</code> tag - In the parent template (outside the component) you decide what content to insert into the slot.    It \"fills\" the slot with the specified content.</li> </ol> <p>Let's look at an example:</p> <p>First, we define the component template. This component contains two slots, <code>header</code> and <code>body</code>.</p> <pre><code>&lt;!-- calendar.html --&gt;\n&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"header\" %}\n            Calendar header\n        {% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"body\" %}\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        {% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Next, when using the component, we can insert our own content into the slots. It looks like this:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"body\" %}\n        Can you believe it's already\n        &lt;span&gt;{{ date }}&lt;/span&gt;??\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Since the <code>'header'</code> fill is unspecified, it's default value is used.</p> <p>When rendered, notice that:</p> <ul> <li>The body is filled with the content we specified,</li> <li>The header is still the default value we defined in the component template.</li> </ul> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        Calendar header\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        Can you believe it's already &lt;span&gt;2020-06-06&lt;/span&gt;??\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#slots-overview","title":"Slots overview","text":""},{"location":"concepts/fundamentals/slots/#slot-definition","title":"Slot definition","text":"<p>Slots are defined with the <code>{% slot %}</code> tag:</p> <pre><code>{% slot \"name\" %}\n    Default content\n{% endslot %}\n</code></pre> <p>Single component can have multiple slots:</p> <pre><code>{% slot \"name\" %}\n    Default content\n{% endslot %}\n\n{% slot \"other_name\" / %}\n</code></pre> <p>And you can even define the same slot in multiple places:</p> <pre><code>&lt;div&gt;\n    {% slot \"name\" %}\n        First content\n    {% endslot %}\n&lt;/div&gt;\n&lt;div&gt;\n    {% slot \"name\" %}\n        Second content\n    {% endslot %}\n&lt;/div&gt;\n</code></pre> <p>Info</p> <p>If you define the same slot in multiple places, you must mark each slot individually when setting <code>default</code> or <code>required</code> flags, e.g.:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#slot-filling","title":"Slot filling","text":"<p>Fill can be defined with the <code>{% fill %}</code> tag:</p> <pre><code>{% component \"calendar\" %}\n    {% fill \"name\" %}\n        Filled content\n    {% endfill %}\n    {% fill \"other_name\" %}\n        Filled content\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Or in Python with the <code>slots</code> argument:</p> <pre><code>Calendar.render(\n    slots={\n        \"name\": \"Filled content\",\n        \"other_name\": \"Filled content\",\n    },\n)\n</code></pre>"},{"location":"concepts/fundamentals/slots/#default-slot","title":"Default slot","text":"<p>You can make the syntax shorter by marking the slot as <code>default</code>:</p> <pre><code>{% slot \"name\" default %}\n    Default content\n{% endslot %}\n</code></pre> <p>This allows you to fill the slot directly in the <code>{% component %}</code> tag, omitting the <code>{% fill %}</code> tag:</p> <pre><code>{% component \"calendar\" %}\n    Filled content\n{% endcomponent %}\n</code></pre> <p>To target the default slot in Python, you can use the <code>\"default\"</code> slot name:</p> <pre><code>Calendar.render(\n    slots={\"default\": \"Filled content\"},\n)\n</code></pre> <p>Accessing default slot in Python</p> <p>Since the default slot is stored under the slot name <code>default</code>, you can access the default slot in Python under the <code>\"default\"</code> key:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        default_slot = slots[\"default\"]\n        return {\n            \"default_slot\": default_slot,\n        }\n</code></pre> <p>Warning</p> <p>Only one <code>{% slot %}</code> can be marked as <code>default</code>. But you can have multiple slots with the same name all marked as <code>default</code>.</p> <p>If you define multiple different slots as <code>default</code>, this will raise an error.</p> <p>\u274c Don't do this</p> <pre><code>{% slot \"name\" default %}\n    Default content\n{% endslot %}\n{% slot \"other_name\" default %}\n    Default content\n{% endslot %}\n</code></pre> <p>\u2705 Do this instead</p> <pre><code>{% slot \"name\" default %}\n    Default content\n{% endslot %}\n{% slot \"name\" default %}\n    Default content\n{% endslot %}\n</code></pre> <p>Warning</p> <p>Do NOT combine default fills with explicit named <code>{% fill %}</code> tags.</p> <p>The following component template will raise an error when rendered:</p> <p>\u274c Don't do this</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}Totally new header!{% endfill %}\n    Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n{% endcomponent %}\n</code></pre> <p>\u2705 Do this instead</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}Totally new header!{% endfill %}\n    {% fill \"default\" %}\n        Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Warning</p> <p>You cannot double-fill a slot.</p> <p>That is, if both <code>{% fill \"default\" %}</code> and <code>{% fill \"header\" %}</code> point to the same slot, this will raise an error when rendered.</p>"},{"location":"concepts/fundamentals/slots/#required-slot","title":"Required slot","text":"<p>You can make the slot required by adding the <code>required</code> keyword:</p> <pre><code>{% slot \"name\" required %}\n    Default content\n{% endslot %}\n</code></pre> <p>This will raise an error if the slot is not filled.</p>"},{"location":"concepts/fundamentals/slots/#access-fills","title":"Access fills","text":"<p>You can access the fills with the <code>{{ component_vars.slots.&lt;name&gt; }}</code> template variable:</p> <pre><code>{% if component_vars.slots.my_slot %}\n    &lt;div&gt;\n        {% fill \"my_slot\" %}\n            Filled content\n        {% endfill %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre> <p>And in Python with the <code>Component.slots</code> property:</p> <pre><code>class Calendar(Component):\n    # `get_template_data` receives the `slots` argument directly\n    def get_template_data(self, args, kwargs, slots, context):\n        if \"my_slot\" in slots:\n            content = \"Filled content\"\n        else:\n            content = \"Default content\"\n\n        return {\n            \"my_slot\": content,\n        }\n\n    # In other methods you can still access the slots with `Component.slots`\n    def on_render_before(self, context, template):\n        if \"my_slot\" in self.slots:\n            # Do something\n</code></pre>"},{"location":"concepts/fundamentals/slots/#dynamic-fills","title":"Dynamic fills","text":"<p>The slot and fill names can be set as variables. This way you can fill slots dynamically:</p> <pre><code>{% with \"body\" as slot_name %}\n    {% component \"calendar\" %}\n        {% fill slot_name %}\n            Filled content\n        {% endfill %}\n    {% endcomponent %}\n{% endwith %}\n</code></pre> <p>You can even use <code>{% if %}</code> and <code>{% for %}</code> tags inside the <code>{% component %}</code> tag to fill slots with more control:</p> <pre><code>{% component \"calendar\" %}\n    {% if condition %}\n        {% fill \"name\" %}\n            Filled content\n        {% endfill %}\n    {% endif %}\n\n    {% for item in items %}\n        {% fill item.name %}\n            Item: {{ item.value }}\n        {% endfill %}\n    {% endfor %}\n{% endcomponent %}\n</code></pre> <p>You can also use <code>{% with %}</code> or even custom tags to generate the fills dynamically:</p> <pre><code>{% component \"calendar\" %}\n    {% with item.name as name %}\n        {% fill name %}\n            Item: {{ item.value }}\n        {% endfill %}\n    {% endwith %}\n{% endcomponent %}\n</code></pre> <p>Warning</p> <p>If you dynamically generate <code>{% fill %}</code> tags, be careful to render text only inside the <code>{% fill %}</code> tags.</p> <p>Any text rendered outside <code>{% fill %}</code> tags will be considered a default fill and will raise an error if combined with explicit fills. (See Default slot)</p>"},{"location":"concepts/fundamentals/slots/#slot-data","title":"Slot data","text":"<p>Sometimes the slots need to access data from the component. Imagine an HTML table component which has a slot to configure how to render the rows. Each row has a different data, so you need to pass the data to the slot.</p> <p>Similarly to Vue's scoped slots, you can pass data to the slot, and then access it in the fill.</p> <p>This consists of two steps:</p> <ol> <li>Passing data to <code>{% slot %}</code> tag</li> <li>Accessing data in <code>{% fill %}</code> tag</li> </ol> <p>The data is passed to the slot as extra keyword arguments. Below we set two extra arguments: <code>first_name</code> and <code>job</code>.</p> <pre><code>{# Pass data to the slot #}\n{% slot \"name\" first_name=\"John\" job=\"Developer\" %}\n    {# Fallback implementation #}\n    Name: {{ first_name }}\n    Job: {{ job }}\n{% endslot %}\n</code></pre> <p>Note</p> <p><code>name</code> kwarg is already used for slot name, so you cannot pass it as slot data.</p> <p>To access the slot's data in the fill, use the <code>data</code> keyword. This sets the name of the variable that holds the data in the fill:</p> <pre><code>{# Access data in the fill #}\n{% component \"profile\" %}\n    {% fill \"name\" data=\"d\" %}\n        Hello, my name is &lt;h1&gt;{{ d.first_name }}&lt;/h1&gt;\n        and I'm a &lt;h2&gt;{{ d.job }}&lt;/h2&gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>To access the slot data in Python, use the <code>data</code> attribute in slot functions.</p> <pre><code>def my_slot(ctx):\n    return f\"\"\"\n        Hello, my name is &lt;h1&gt;{ctx.data[\"first_name\"]}&lt;/h1&gt;\n        and I'm a &lt;h2&gt;{ctx.data[\"job\"]}&lt;/h2&gt;\n    \"\"\"\n\nProfile.render(\n    slots={\n        \"name\": my_slot,\n    },\n)\n</code></pre> <p>Slot data can be set also when rendering a slot in Python:</p> <pre><code>slot = Slot(lambda ctx: f\"Hello, {ctx.data['name']}!\")\n\n# Render the slot\nhtml = slot({\"name\": \"John\"})\n</code></pre> <p>Info</p> <p>To access slot data on a default slot, you have to explictly define the <code>{% fill %}</code> tags with name <code>\"default\"</code>.</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"default\" data=\"slot_data\" %}\n        {{ slot_data.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Warning</p> <p>You cannot set the <code>data</code> attribute and <code>fallback</code> attribute to the same name. This raises an error:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"content\" data=\"slot_var\" fallback=\"slot_var\" %}\n        {{ slot_var.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#slot-fallback","title":"Slot fallback","text":"<p>The content between the <code>{% slot %}..{% endslot %}</code> tags is the fallback content that will be rendered if no fill is given for the slot.</p> <pre><code>{% slot \"name\" %}\n    Hello, my name is {{ name }}  &lt;!-- Fallback content --&gt;\n{% endslot %}\n</code></pre> <p>Sometimes you may want to keep the fallback content, but only wrap it in some other content.</p> <p>To do so, you can access the fallback content via the <code>fallback</code> kwarg. This sets the name of the variable that holds the fallback content in the fill:</p> <pre><code>{% component \"profile\" %}\n    {% fill \"name\" fallback=\"fb\" %}\n        Original content:\n        &lt;div&gt;\n            {{ fb }}  &lt;!-- fb = 'Hello, my name...' --&gt;\n        &lt;/div&gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>To access the fallback content in Python, use the <code>fallback</code> attribute in slot functions.</p> <p>The fallback value is rendered lazily. Coerce the fallback to a string to render it.</p> <pre><code>def my_slot(ctx):\n    # Coerce the fallback to a string\n    fallback = str(ctx.fallback)\n    return f\"Original content: \" + fallback\n\nProfile.render(\n    slots={\n        \"name\": my_slot,\n    },\n)\n</code></pre> <p>Fallback can be set also when rendering a slot in Python:</p> <pre><code>slot = Slot(lambda ctx: f\"Hello, {ctx.data['name']}!\")\n\n# Render the slot\nhtml = slot({\"name\": \"John\"}, fallback=\"Hello, world!\")\n</code></pre> <p>Info</p> <p>To access slot fallback on a default slot, you have to explictly define the <code>{% fill %}</code> tags with name <code>\"default\"</code>.</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"default\" fallback=\"fallback\" %}\n        {{ fallback }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Warning</p> <p>You cannot set the <code>data</code> attribute and <code>fallback</code> attribute to the same name. This raises an error:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"content\" data=\"slot_var\" fallback=\"slot_var\" %}\n        {{ slot_var.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#slot-functions","title":"Slot functions","text":"<p>In Python code, slot fills can be defined as strings, functions, or <code>Slot</code> instances that wrap the two. Slot functions have access to slot <code>data</code>, <code>fallback</code>, and <code>context</code>.</p> <pre><code>def row_slot(ctx):\n    if ctx.data[\"disabled\"]:\n        return ctx.fallback\n\n    item = ctx.data[\"item\"]\n    if ctx.data[\"type\"] == \"table\":\n        return f\"&lt;tr&gt;&lt;td&gt;{item}&lt;/td&gt;&lt;/tr&gt;\"\n    else:\n        return f\"&lt;li&gt;{item}&lt;/li&gt;\"\n\nTable.render(\n    slots={\n        \"prepend\": \"Ice cream selection:\",\n        \"append\": Slot(\"\u00a9 2025\"),\n        \"row\": row_slot,\n        \"column_title\": Slot(lambda ctx: f\"&lt;th&gt;{ctx.data['name']}&lt;/th&gt;\"),\n    },\n)\n</code></pre> <p>Inside the component, these will all be normalized to <code>Slot</code> instances:</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        assert isinstance(slots[\"prepend\"], Slot)\n        assert isinstance(slots[\"row\"], Slot)\n        assert isinstance(slots[\"header\"], Slot)\n        assert isinstance(slots[\"footer\"], Slot)\n</code></pre> <p>You can render <code>Slot</code> instances by simply calling them with data:</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        prepend_slot = slots[\"prepend\"]\n        return {\n            \"prepend\": prepend_slot({\"item\": \"ice cream\"}),\n        }\n</code></pre>"},{"location":"concepts/fundamentals/slots/#filling-slots-with-functions","title":"Filling slots with functions","text":"<p>You can \"fill\" slots by passing a string or <code>Slot</code> instance directly to the <code>{% fill %}</code> tag:</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        def my_fill(ctx):\n            return f\"Hello, {ctx.data['name']}!\"\n\n        return {\n            \"my_fill\": Slot(my_fill),\n        }\n</code></pre> <pre><code>{% component \"table\" %}\n    {% fill \"name\" body=my_fill / %}\n{% endcomponent %}\n</code></pre> <p>Note</p> <p>Django automatically executes functions when it comes across them in templates.</p> <p>Because of this you MUST wrap the function in <code>Slot</code> instance to prevent it from being called.</p> <p>Read more about Django's <code>do_not_call_in_templates</code>.</p>"},{"location":"concepts/fundamentals/slots/#slot-class","title":"Slot class","text":"<p>The <code>Slot</code> class is a wrapper around a function that can be used to fill a slot.</p> <pre><code>from django_components import Component, Slot\n\ndef footer(ctx):\n    return f\"Hello, {ctx.data['name']}!\"\n\nTable.render(\n    slots={\n        \"footer\": Slot(footer),\n    },\n)\n</code></pre> <p>Slot class can be instantiated with a function or a string:</p> <pre><code>slot1 = Slot(lambda ctx: f\"Hello, {ctx.data['name']}!\")\nslot2 = Slot(\"Hello, world!\")\n</code></pre> <p>Warning</p> <p>Passing a <code>Slot</code> instance to the <code>Slot</code> constructor results in an error:</p> <pre><code>slot = Slot(\"Hello\")\n\n# Raises an error\nslot2 = Slot(slot)\n</code></pre>"},{"location":"concepts/fundamentals/slots/#rendering-slots","title":"Rendering slots","text":"<p>Python</p> <p>You can render a <code>Slot</code> instance by simply calling it with data:</p> <pre><code>slot = Slot(lambda ctx: f\"Hello, {ctx.data['name']}!\")\n\n# Render the slot with data\nhtml = slot({\"name\": \"John\"})\n</code></pre> <p>Optionally you can pass the fallback value to the slot. Fallback should be a string.</p> <pre><code>html = slot({\"name\": \"John\"}, fallback=\"Hello, world!\")\n</code></pre> <p>Template</p> <p>Alternatively, you can pass the <code>Slot</code> instance to the <code>{% fill %}</code> tag:</p> <pre><code>{% fill \"name\" body=slot / %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#slot-context","title":"Slot context","text":"<p>If a slot function is rendered by the <code>{% slot %}</code> tag, you can access the current Context using the <code>context</code> attribute.</p> <pre><code>class Table(Component):\n    template = \"\"\"\n        {% with \"abc\" as my_var %}\n            {% slot \"name\" %}\n                Hello!\n            {% endslot %}\n        {% endwith %}\n    \"\"\"\n\ndef slot_func(ctx):\n    return f\"Hello, {ctx.context['my_var']}!\"\n\nslot = Slot(slot_func)\nhtml = slot()\n</code></pre> <p>Warning</p> <p>While available, try to avoid using the <code>context</code> attribute in slot functions.</p> <p>Instead, prefer using the <code>data</code> and <code>fallback</code> attributes.</p> <p> Access to <code>context</code> may be removed in future versions (v2, v3).</p>"},{"location":"concepts/fundamentals/slots/#slot-metadata","title":"Slot metadata","text":"<p>When accessing slots from within <code>Component</code> methods, the <code>Slot</code> instances are populated with extra metadata:</p> <ul> <li><code>component_name</code></li> <li><code>slot_name</code></li> <li><code>nodelist</code></li> <li><code>fill_node</code></li> <li><code>extra</code></li> </ul> <p>These are populated the first time a slot is passed to a component.</p> <p>So if you pass the same slot through multiple nested components, the metadata will still point to the first component that received the slot.</p> <p>You can use these for debugging, such as printing out the slot's component name and slot name.</p> <p>Fill node</p> <p>Components or extensions can use <code>Slot.fill_node</code> to handle slots differently based on whether the slot was defined in the template with <code>{% fill %}</code> and <code>{% component %}</code> tags, or in the component's Python code.</p> <p>If the slot was created from a <code>{% fill %}</code> tag, this will be the <code>FillNode</code> instance.</p> <p>If the slot was a default slot created from a <code>{% component %}</code> tag, this will be the <code>ComponentNode</code> instance.</p> <p>You can use this to find the <code>Component</code> in whose template the <code>{% fill %}</code> tag was defined:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        footer_slot = slots.get(\"footer\")\n        if footer_slot is not None and footer_slot.fill_node is not None:\n            owner_component = footer_slot.fill_node.template_component\n            # ...\n</code></pre> <p>Extra</p> <p>You can also pass any additional data along with the slot by setting it in <code>Slot.extra</code>:</p> <pre><code>slot = Slot(\n    lambda ctx: f\"Hello, {ctx.data['name']}!\",\n    extra={\"foo\": \"bar\"},\n)\n</code></pre> <p>When you create a slot, you can set any of these fields too:</p> <pre><code># Either at slot creation\nslot = Slot(\n    lambda ctx: f\"Hello, {ctx.data['name']}!\",\n    # Optional\n    component_name=\"table\",\n    slot_name=\"name\",\n    extra={},\n)\n\n# Or later\nslot.component_name = \"table\"\nslot.slot_name = \"name\"\nslot.extra[\"foo\"] = \"bar\"\n</code></pre> <p>Read more in Pass slot metadata.</p>"},{"location":"concepts/fundamentals/slots/#slot-contents","title":"Slot contents","text":"<p>Whether you create a slot from a function, a string, or from the <code>{% fill %}</code> tags, the <code>Slot</code> class normalizes its contents to a function.</p> <p>Use <code>Slot.contents</code> to access the original value that was passed to the Slot constructor.</p> <pre><code>slot = Slot(\"Hello!\")\nprint(slot.contents)  # \"Hello!\"\n</code></pre> <p>If the slot was created from a string or from the <code>{% fill %}</code> tags, the contents will be accessible also as a Nodelist under <code>Slot.nodelist</code>.</p> <pre><code>slot = Slot(\"Hello!\")\nprint(slot.nodelist)  # &lt;django.template.Nodelist: ['Hello!']&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#escaping-slots-content","title":"Escaping slots content","text":"<p>Slots content are automatically escaped by default to prevent XSS attacks.</p> <p>In other words, it's as if you would be using Django's <code>escape()</code> on the slot contents / result:</p> <pre><code>from django.utils.html import escape\n\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {% slot \"date\" default date=date / %}\n        &lt;/div&gt;\n    \"\"\"\n\nCalendar.render(\n    slots={\n        \"date\": escape(\"&lt;b&gt;Hello&lt;/b&gt;\"),\n    }\n)\n</code></pre> <p>To disable escaping, you can wrap the slot string or slot result in Django's <code>mark_safe()</code>:</p> <pre><code>Calendar.render(\n    slots={\n        # string\n        \"date\": mark_safe(\"&lt;b&gt;Hello&lt;/b&gt;\"),\n\n        # function\n        \"date\": lambda ctx: mark_safe(\"&lt;b&gt;Hello&lt;/b&gt;\"),\n    }\n)\n</code></pre> <p>Info</p> <p>Read more about Django's <code>format_html</code> and <code>mark_safe</code>.</p>"},{"location":"concepts/fundamentals/slots/#examples","title":"Examples","text":""},{"location":"concepts/fundamentals/slots/#pass-through-all-the-slots","title":"Pass through all the slots","text":"<p>You can dynamically pass all slots to a child component. This is similar to passing all slots in Vue:</p> <pre><code>class MyTable(Component):\n    template = \"\"\"\n        &lt;div&gt;\n          {% component \"child\" %}\n            {% for slot_name, slot in component_vars.slots.items %}\n              {% fill name=slot_name body=slot / %}\n            {% endfor %}\n          {% endcomponent %}\n        &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/slots/#required-and-default-slots","title":"Required and default slots","text":"<p>Since each <code>{% slot %}</code> is tagged with <code>required</code> and <code>default</code> individually, you can have multiple slots with the same name but different conditions.</p> <p>In this example, we have a component that renders a user avatar - a small circular image with a profile picture or name initials.</p> <p>If the component is given <code>image_src</code> or <code>name_initials</code> variables, the <code>image</code> slot is optional.</p> <p>But if neither of those are provided, you MUST fill the <code>image</code> slot.</p> <pre><code>&lt;div class=\"avatar\"&gt;\n    {# Image given, so slot is optional #}\n    {% if image_src %}\n        {% slot \"image\" default %}\n            &lt;img src=\"{{ image_src }}\" /&gt;\n        {% endslot %}\n\n    {# Image not given, but we can make image from initials, so slot is optional #}    \n    {% elif name_initials %}\n        {% slot \"image\" default %}\n            &lt;div style=\"\n                border-radius: 25px;\n                width: 50px;\n                height: 50px;\n                background: blue;\n            \"&gt;\n                {{ name_initials }}\n            &lt;/div&gt;\n        {% endslot %}\n\n    {# Neither image nor initials given, so slot is required #}\n    {% else %}\n        {% slot \"image\" default required / %}\n    {% endif %}\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#dynamic-slots-in-table-component","title":"Dynamic slots in table component","text":"<p>Sometimes you may want to generate slots based on the given input. One example of this is Vuetify's table component, which creates a header and an item slots for each user-defined column.</p> <p>So if you pass columns named <code>name</code> and <code>age</code> to the table component:</p> <pre><code>[\n    {\"key\": \"name\", \"title\": \"Name\"},\n    {\"key\": \"age\", \"title\": \"Age\"},\n]\n</code></pre> <p>Then the component will accept fills named <code>header-name</code> and <code>header-age</code> (among others):</p> <pre><code>{% fill \"header-name\" data=\"data\" %}\n    &lt;b&gt;{{ data.value }}&lt;/b&gt;\n{% endfill %}\n\n{% fill \"header-age\" data=\"data\" %}\n    &lt;b&gt;{{ data.value }}&lt;/b&gt;\n{% endfill %}\n</code></pre> <p>In django-components you can achieve the same, simply by using a variable or a template expression instead of a string literal:</p> <pre><code>&lt;table&gt;\n  &lt;tr&gt;\n    {% for header in headers %}\n      &lt;th&gt;\n        {% slot \"header-{{ header.key }}\" value=header.title %}\n          {{ header.title }}\n        {% endslot %}\n      &lt;/th&gt;\n    {% endfor %}\n  &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre> <p>When using the component, you can either set the fill explicitly:</p> <pre><code>{% component \"table\" headers=headers items=items %}\n    {% fill \"header-name\" data=\"data\" %}\n        &lt;b&gt;{{ data.value }}&lt;/b&gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Or also use a variable:</p> <pre><code>{% component \"table\" headers=headers items=items %}\n    {% fill \"header-{{ active_header_name }}\" data=\"data\" %}\n        &lt;b&gt;{{ data.value }}&lt;/b&gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Note</p> <p>It's better to use literal slot names whenever possible for clarity. The dynamic slot names should be reserved for advanced use only.</p>"},{"location":"concepts/fundamentals/slots/#spread-operator","title":"Spread operator","text":"<p>Lastly, you can also pass the slot name through the spread operator.</p> <p>When you define a slot name, it's actually a shortcut for a <code>name</code> keyword argument.</p> <p>So this:</p> <pre><code>{% slot \"content\" / %}\n</code></pre> <p>is the same as:</p> <pre><code>{% slot name=\"content\" / %}\n</code></pre> <p>So it's possible to define a <code>name</code> key on a dictionary, and then spread that onto the slot tag:</p> <pre><code>{# slot_props = {\"name\": \"content\"} #}\n{% slot ...slot_props / %}\n</code></pre> <p>Full example:</p> <pre><code>class MyTable(Component):\n    template = \"\"\"\n        {% slot ...slot_props / %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"slot_props\": {\"name\": \"content\", \"extra_field\": 123},\n        }\n</code></pre> <p>Info</p> <p>This applies for both <code>{% slot %}</code> and <code>{% fill %}</code> tags.</p>"},{"location":"concepts/fundamentals/slots/#legacy-conditional-slots","title":"Legacy conditional slots","text":"<p>Since version 0.70, you could check if a slot was filled with</p> <p><code>{{ component_vars.is_filled.&lt;name&gt; }}</code></p> <p>Since version 0.140, this has been deprecated and superseded with</p> <p><code>{% component_vars.slots.&lt;name&gt; %}</code></p> <p>The <code>component_vars.is_filled</code> variable is still available, but will be removed in v1.0.</p> <p>NOTE: <code>component_vars.slots</code> no longer escapes special characters in slot names.</p> <p>You can use <code>{{ component_vars.is_filled.&lt;name&gt; }}</code> together with Django's <code>{% if / elif / else / endif %}</code> tags to define a block whose contents will be rendered only if the component slot with the corresponding 'name' is filled.</p> <p>This is what our example looks like with <code>component_vars.is_filled</code>.</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}\n            Title\n        {% endslot %}\n    &lt;/div&gt;\n    {% if component_vars.is_filled.subtitle %}\n        &lt;div class=\"subtitle\"&gt;\n            {% slot \"subtitle\" %}\n                {# Optional subtitle #}\n            {% endslot %}\n        &lt;/div&gt;\n    {% elif component_vars.is_filled.title %}\n        ...\n    {% elif component_vars.is_filled.&lt;name&gt; %}\n        ...\n    {% endif %}\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#accessing-is_filled-of-slot-names-with-special-characters","title":"Accessing <code>is_filled</code> of slot names with special characters","text":"<p>To be able to access a slot name via <code>component_vars.is_filled</code>, the slot name needs to be composed of only alphanumeric characters and underscores (e.g. <code>this__isvalid_123</code>).</p> <p>However, you can still define slots with other special characters. In such case, the slot name in <code>component_vars.is_filled</code> is modified to replace all invalid characters into <code>_</code>.</p> <p>So a slot named <code>\"my super-slot :)\"</code> will be available as <code>component_vars.is_filled.my_super_slot___</code>.</p> <p>Same applies when you are accessing <code>is_filled</code> from within the Python, e.g.:</p> <pre><code>class MyTable(Component):\n    def on_render_before(self, context, template) -&gt; None:\n        # \u2705 Works\n        if self.is_filled[\"my_super_slot___\"]:\n            # Do something\n\n        # \u274c Does not work\n        if self.is_filled[\"my super-slot :)\"]:\n            # Do something\n</code></pre>"},{"location":"concepts/fundamentals/subclassing_components/","title":"Subclassing components","text":"<p>In larger projects, you might need to write multiple components with similar behavior. In such cases, you can extract shared behavior into a standalone component class to keep things DRY.</p> <p>When subclassing a component, there's a couple of things to keep in mind:</p>"},{"location":"concepts/fundamentals/subclassing_components/#template-js-and-css-inheritance","title":"Template, JS, and CSS inheritance","text":"<p>When it comes to the pairs:</p> <ul> <li><code>Component.template</code>/<code>Component.template_file</code></li> <li><code>Component.js</code>/<code>Component.js_file</code></li> <li><code>Component.css</code>/<code>Component.css_file</code></li> </ul> <p>inheritance follows these rules:</p> <ul> <li>If a child component class defines either member of a pair (e.g., either <code>template</code> or <code>template_file</code>), it takes precedence and the parent's definition is ignored completely.</li> <li>For example, if a child component defines <code>template_file</code>, the parent's <code>template</code> or <code>template_file</code> will be ignored.</li> <li>This applies independently to each pair - you can inherit the JS while overriding the template, for instance.</li> </ul> <p>For example:</p> <pre><code>class BaseCard(Component):\n    template = \"\"\"\n        &lt;div class=\"card\"&gt;\n            &lt;div class=\"card-content\"&gt;{{ content }}&lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n    css = \"\"\"\n        .card {\n            border: 1px solid gray;\n        }\n    \"\"\"\n    js = \"\"\"console.log('Base card loaded');\"\"\"\n\n# This class overrides parent's template, but inherits CSS and JS\nclass SpecialCard(BaseCard):\n    template = \"\"\"\n        &lt;div class=\"card special\"&gt;\n            &lt;div class=\"card-content\"&gt;\u2728 {{ content }} \u2728&lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n# This class overrides parent's template and CSS, but inherits JS\nclass CustomCard(BaseCard):\n    template_file = \"custom_card.html\"\n    css = \"\"\"\n        .card {\n            border: 2px solid gold;\n        }\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/subclassing_components/#media-inheritance","title":"Media inheritance","text":"<p>The <code>Component.Media</code> nested class follows Django's media inheritance rules:</p> <ul> <li>If both parent and child define a <code>Media</code> class, the child's media will automatically include both its own and the parent's JS and CSS files.</li> <li>This behavior can be configured using the <code>extend</code> attribute in the Media class, similar to Django's forms.   Read more on this in Media inheritance.</li> </ul> <p>For example:</p> <pre><code>class BaseModal(Component):\n    template = \"&lt;div&gt;Modal content&lt;/div&gt;\"\n\n    class Media:\n        css = [\"base_modal.css\"]\n        js = [\"base_modal.js\"]  # Contains core modal functionality\n\nclass FancyModal(BaseModal):\n    class Media:\n        # Will include both base_modal.css/js AND fancy_modal.css/js\n        css = [\"fancy_modal.css\"]  # Additional styling\n        js = [\"fancy_modal.js\"]    # Additional animations\n\nclass SimpleModal(BaseModal):\n    class Media:\n        extend = False  # Don't inherit parent's media\n        css = [\"simple_modal.css\"]  # Only this CSS will be included\n        js = [\"simple_modal.js\"]    # Only this JS will be included\n</code></pre>"},{"location":"concepts/fundamentals/subclassing_components/#opt-out-of-inheritance","title":"Opt out of inheritance","text":"<p>For the following media attributes, when you don't want to inherit from the parent, but you also don't need to set the template / JS / CSS to any specific value, you can set these attributes to <code>None</code>.</p> <ul> <li><code>template</code> / <code>template_file</code></li> <li><code>js</code> / <code>js_file</code></li> <li><code>css</code> / <code>css_file</code></li> <li><code>Media</code> class</li> </ul> <p>For example:</p> <pre><code>class BaseForm(Component):\n    template = \"...\"\n    css = \"...\"\n    js = \"...\"\n\n    class Media:\n        js = [\"form.js\"]\n\n# Use parent's template and CSS, but no JS\nclass ContactForm(BaseForm):\n    js = None\n    Media = None\n</code></pre>"},{"location":"concepts/fundamentals/subclassing_components/#regular-python-inheritance","title":"Regular Python inheritance","text":"<p>All other attributes and methods (including the <code>Component.View</code> class and its methods) follow standard Python inheritance rules.</p> <p>For example:</p> <pre><code>class BaseForm(Component):\n    template = \"\"\"\n        &lt;form&gt;\n            {{ form_content }}\n            &lt;button type=\"submit\"&gt;\n                {{ submit_text }}\n            &lt;/button&gt;\n        &lt;/form&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"form_content\": self.get_form_content(),\n            \"submit_text\": \"Submit\"\n        }\n\n    def get_form_content(self):\n        return \"&lt;input type='text' name='data'&gt;\"\n\nclass ContactForm(BaseForm):\n    # Extend parent's \"context\"\n    # but override \"submit_text\"\n    def get_template_data(self, args, kwargs, slots, context):\n        context = super().get_template_data(args, kwargs, slots, context)\n        context[\"submit_text\"] = \"Send Message\"  \n        return context\n\n    # Completely override parent's get_form_content\n    def get_form_content(self):\n        return \"\"\"\n            &lt;input type='text' name='name' placeholder='Your Name'&gt;\n            &lt;input type='email' name='email' placeholder='Your Email'&gt;\n            &lt;textarea name='message' placeholder='Your Message'&gt;&lt;/textarea&gt;\n        \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/","title":"Template tag syntax","text":"<p>All template tags in django_component, like <code>{% component %}</code> or <code>{% slot %}</code>, and so on, support extra syntax that makes it possible to write components like in Vue or React (JSX).</p>"},{"location":"concepts/fundamentals/template_tag_syntax/#self-closing-tags","title":"Self-closing tags","text":"<p>When you have a tag like <code>{% component %}</code> or <code>{% slot %}</code>, but it has no content, you can simply append a forward slash <code>/</code> at the end, instead of writing out the closing tags like <code>{% endcomponent %}</code> or <code>{% endslot %}</code>:</p> <p>So this:</p> <pre><code>{% component \"button\" %}{% endcomponent %}\n</code></pre> <p>becomes</p> <pre><code>{% component \"button\" / %}\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/#special-characters","title":"Special characters","text":"<p>New in version 0.71:</p> <p>Keyword arguments can contain special characters <code># @ . - _</code>, so keywords like so are still valid:</p> <pre><code>&lt;body&gt;\n    {% component \"calendar\" my-date=\"2015-06-19\" @click.native=do_something #some_id=True / %}\n&lt;/body&gt;\n</code></pre> <p>These can then be accessed inside <code>get_template_data</code> so:</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"my-date\"],\n            \"id\": kwargs[\"#some_id\"],\n            \"on_click\": kwargs[\"@click.native\"]\n        }\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/#spread-operator","title":"Spread operator","text":"<p>New in version 0.93:</p> <p>Instead of passing keyword arguments one-by-one:</p> <pre><code>{% component \"calendar\" title=\"How to abc\" date=\"2015-06-19\" author=\"John Wick\" / %}\n</code></pre> <p>You can use a spread operator <code>...dict</code> to apply key-value pairs from a dictionary:</p> <pre><code>post_data = {\n    \"title\": \"How to...\",\n    \"date\": \"2015-06-19\",\n    \"author\": \"John Wick\",\n}\n</code></pre> <pre><code>{% component \"calendar\" ...post_data / %}\n</code></pre> <p>This behaves similar to JSX's spread operator or Vue's <code>v-bind</code>.</p> <p>Spread operators are treated as keyword arguments, which means that:</p> <ol> <li>Spread operators must come after positional arguments.</li> <li>You cannot use spread operators for positional-only arguments.</li> </ol> <p>Other than that, you can use spread operators multiple times, and even put keyword arguments in-between or after them:</p> <pre><code>{% component \"calendar\" ...post_data id=post.id ...extra / %}\n</code></pre> <p>In a case of conflicts, the values added later (right-most) overwrite previous values.</p>"},{"location":"concepts/fundamentals/template_tag_syntax/#template-tags-inside-literal-strings","title":"Template tags inside literal strings","text":"<p>New in version 0.93</p> <p>When passing data around, sometimes you may need to do light transformations, like negating booleans or filtering lists.</p> <p>Normally, what you would have to do is to define ALL the variables inside <code>get_template_data()</code>. But this can get messy if your components contain a lot of logic.</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"editable\": kwargs[\"editable\"],\n            \"readonly\": not kwargs[\"editable\"],\n            \"input_id\": f\"input-{kwargs['id']}\",\n            \"icon_id\": f\"icon-{kwargs['id']}\",\n            ...\n        }\n</code></pre> <p>Instead, template tags in django_components (<code>{% component %}</code>, <code>{% slot %}</code>, <code>{% provide %}</code>, etc) allow you to treat literal string values as templates:</p> <pre><code>{% component 'blog_post'\n  \"As positional arg {# yay #}\"\n  title=\"{{ person.first_name }} {{ person.last_name }}\"\n  id=\"{% random_int 10 20 %}\"\n  readonly=\"{{ editable|not }}\"\n  author=\"John Wick {# TODO: parametrize #}\"\n/ %}\n</code></pre> <p>In the example above, the component receives:</p> <ul> <li>Positional argument <code>\"As positional arg \"</code> (Comment omitted)</li> <li><code>title</code> - passed as <code>str</code>, e.g. <code>John Doe</code></li> <li><code>id</code> - passed as <code>int</code>, e.g. <code>15</code></li> <li><code>readonly</code> - passed as <code>bool</code>, e.g. <code>False</code></li> <li><code>author</code> - passed as <code>str</code>, e.g. <code>John Wick</code> (Comment omitted)</li> </ul> <p>This is inspired by django-cotton.</p>"},{"location":"concepts/fundamentals/template_tag_syntax/#passing-data-as-string-vs-original-values","title":"Passing data as string vs original values","text":"<p>In the example above, the kwarg <code>id</code> was passed as an integer, NOT a string.</p> <p>When the string literal contains only a single template tag, with no extra text (and no extra whitespace), then the value is passed as the original type instead of a string.</p> <p>Here, <code>page</code> is an integer:</p> <pre><code>{% component 'blog_post' page=\"{% random_int 10 20 %}\" / %}\n</code></pre> <p>Here, <code>page</code> is a string:</p> <pre><code>{% component 'blog_post' page=\" {% random_int 10 20 %} \" / %}\n</code></pre> <p>And same applies to the <code>{{ }}</code> variable tags:</p> <p>Here, <code>items</code> is a list:</p> <pre><code>{% component 'cat_list' items=\"{{ cats|slice:':2' }}\" / %}\n</code></pre> <p>Here, <code>items</code> is a string:</p> <pre><code>{% component 'cat_list' items=\"{{ cats|slice:':2' }} See more\" / %}\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/#evaluating-python-expressions-in-template","title":"Evaluating Python expressions in template","text":"<p>You can even go a step further and have a similar experience to Vue or React, where you can evaluate arbitrary code expressions:</p> <pre><code>&lt;MyForm value={isEnabled ? inputValue : null} /&gt;\n</code></pre> <p>Similar is possible with <code>django-expr</code>, which adds an <code>expr</code> tag and filter that you can use to evaluate Python expressions from within the template:</p> <pre><code>{% component \"my_form\"\n  value=\"{% expr 'input_value if is_enabled else None' %}\"\n/ %}\n</code></pre> <p>Note: Never use this feature to mix business logic and template logic. Business logic should still be in the view!</p>"},{"location":"concepts/fundamentals/template_tag_syntax/#pass-dictonary-by-its-key-value-pairs","title":"Pass dictonary by its key-value pairs","text":"<p>New in version 0.74:</p> <p>Sometimes, a component may expect a dictionary as one of its inputs.</p> <p>Most commonly, this happens when a component accepts a dictionary of HTML attributes (usually called <code>attrs</code>) to pass to the underlying template.</p> <p>In such cases, we may want to define some HTML attributes statically, and other dynamically. But for that, we need to define this dictionary on Python side:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        {% component \"other\" attrs=attrs / %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        attrs = {\n            \"class\": \"pa-4 flex\",\n            \"data-some-id\": kwargs[\"some_id\"],\n            \"@click.stop\": \"onClickHandler\",\n        }\n        return {\"attrs\": attrs}\n</code></pre> <p>But as you can see in the case above, the event handler <code>@click.stop</code> and styling <code>pa-4 flex</code> are disconnected from the template. If the component grew in size and we moved the HTML to a separate file, we would have hard time reasoning about the component's template.</p> <p>Luckily, there's a better way.</p> <p>When we want to pass a dictionary to a component, we can define individual key-value pairs as component kwargs, so we can keep all the relevant information in the template. For that, we prefix the key with the name of the dict and <code>:</code>. So key <code>class</code> of input <code>attrs</code> becomes <code>attrs:class</code>. And our example becomes:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        {% component \"other\"\n            attrs:class=\"pa-4 flex\"\n            attrs:data-some-id=some_id\n            attrs:@click.stop=\"onClickHandler\"\n        / %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"some_id\": kwargs[\"some_id\"]}\n</code></pre> <p>Sweet! Now all the relevant HTML is inside the template, and we can move it to a separate file with confidence:</p> <pre><code>{% component \"other\"\n    attrs:class=\"pa-4 flex\"\n    attrs:data-some-id=some_id\n    attrs:@click.stop=\"onClickHandler\"\n/ %}\n</code></pre> <p>Note: It is NOT possible to define nested dictionaries, so <code>attrs:my_key:two=2</code> would be interpreted as:</p> <pre><code>{\"attrs\": {\"my_key:two\": 2}}\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/#multiline-tags","title":"Multiline tags","text":"<p>By default, Django expects a template tag to be defined on a single line.</p> <p>However, this can become unwieldy if you have a component with a lot of inputs:</p> <pre><code>{% component \"card\" title=\"Joanne Arc\" subtitle=\"Head of Kitty Relations\" date_last_active=\"2024-09-03\" ... %}\n</code></pre> <p>Instead, when you install django_components, it automatically configures Django to suport multi-line tags.</p> <p>So we can rewrite the above as:</p> <pre><code>{% component \"card\"\n    title=\"Joanne Arc\"\n    subtitle=\"Head of Kitty Relations\"\n    date_last_active=\"2024-09-03\"\n    ...\n%}\n</code></pre> <p>Much better!</p> <p>To disable this behavior, set <code>COMPONENTS.multiline_tag</code> to <code>False</code></p>"},{"location":"concepts/fundamentals/typing_and_validation/","title":"Typing and validation","text":""},{"location":"concepts/fundamentals/typing_and_validation/#typing-overview","title":"Typing overview","text":"<p>Warning</p> <p>In versions 0.92 to 0.139 (inclusive), the component typing was specified through generics.</p> <p>Since v0.140, the types must be specified as class attributes of the Component class - <code>Args</code>, <code>Kwargs</code>, <code>Slots</code>, <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code>.</p> <p>See Migrating from generics to class attributes for more info.</p> <p>Warning</p> <p>Input validation was NOT part of Django Components between versions 0.136 and 0.139 (inclusive).</p> <p>The <code>Component</code> class optionally accepts class attributes that allow you to define the types of args, kwargs, slots, as well as the data returned from the data methods.</p> <p>Use this to add type hints to your components, to validate the inputs at runtime, and to document them.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django.template import Context\nfrom django_components import Component, SlotInput\n\nclass Button(Component):\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        variable: str\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        ...\n\n    template_file = \"button.html\"\n</code></pre> <p>The class attributes are:</p> <ul> <li><code>Args</code> - Type for positional arguments.</li> <li><code>Kwargs</code> - Type for keyword arguments.</li> <li><code>Slots</code> - Type for slots.</li> <li><code>TemplateData</code> - Type for data returned from <code>get_template_data()</code>.</li> <li><code>JsData</code> - Type for data returned from <code>get_js_data()</code>.</li> <li><code>CssData</code> - Type for data returned from <code>get_css_data()</code>.</li> </ul> <p>You can specify as many or as few of these as you want, the rest will default to <code>None</code>.</p>"},{"location":"concepts/fundamentals/typing_and_validation/#typing-inputs","title":"Typing inputs","text":"<p>You can use <code>Component.Args</code>, <code>Component.Kwargs</code>, and <code>Component.Slots</code> to type the component inputs.</p> <p>When you set these classes, at render time the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters of the data methods (<code>get_template_data()</code>, <code>get_js_data()</code>, <code>get_css_data()</code>) will be instances of these classes.</p> <p>This way, each component can have runtime validation of the inputs:</p> <ul> <li>When you use <code>NamedTuple</code>   or <code>@dataclass</code>,   instantiating these classes will check ONLY for the presence of the attributes.</li> <li>When you use Pydantic models,   instantiating these classes will check for the presence AND type of the attributes.</li> </ul> <p>If you omit the <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, or set them to <code>None</code>, the inputs will be passed as plain lists or dictionaries, and will not be validated.</p> <pre><code>from typing_extensions import NamedTuple, TypedDict\nfrom django.template import Context\nfrom django_components import Component, Slot, SlotInput\n\n# The data available to the `footer` scoped slot\nclass ButtonFooterSlotData(TypedDict):\n    value: int\n\n# Define the component with the types\nclass Button(Component):\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        # Use `SlotInput` to allow slots to be given as `Slot` instance,\n        # plain string, or a function that returns a string.\n        my_slot: Optional[SlotInput] = None\n        # Use `Slot` to allow ONLY `Slot` instances.\n        # The generic is optional, and it specifies the data available\n        # to the slot function.\n        footer: Slot[ButtonFooterSlotData]\n\n    # Add type hints to the data method\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        # The parameters are instances of the classes we defined\n        assert isinstance(args, Button.Args)\n        assert isinstance(kwargs, Button.Kwargs)\n        assert isinstance(slots, Button.Slots)\n\n        args.name  # str\n        kwargs.age  # int\n        slots.footer  # Slot[ButtonFooterSlotData]\n\n# Add type hints to the render call\nButton.render(\n    args=Button.Args(\n        name=\"John\",\n    ),\n    kwargs=Button.Kwargs(\n        surname=\"Doe\",\n        age=30,\n    ),\n    slots=Button.Slots(\n        footer=Slot(lambda ctx: \"Click me!\"),\n    ),\n)\n</code></pre> <p>If you don't want to validate some parts, set them to <code>None</code> or omit them.</p> <p>The following will validate only the keyword inputs:</p> <pre><code>class Button(Component):\n    # We could also omit these\n    Args = None\n    Slots = None\n\n    class Kwargs(NamedTuple):\n        name: str\n        age: int\n\n    # Only `kwargs` is instantiated. `args` and `slots` are not.\n    def get_template_data(self, args, kwargs: Kwargs, slots, context: Context):\n        assert isinstance(args, list)\n        assert isinstance(slots, dict)\n        assert isinstance(kwargs, Button.Kwargs)\n\n        args[0]  # str\n        slots[\"footer\"]  # Slot[ButtonFooterSlotData]\n        kwargs.age  # int\n</code></pre> <p>Info</p> <p>Components can receive slots as strings, functions, or instances of <code>Slot</code>.</p> <p>Internally these are all normalized to instances of <code>Slot</code>.</p> <p>Therefore, the <code>slots</code> dictionary available in data methods (like <code>get_template_data()</code>) will always be a dictionary of <code>Slot</code> instances.</p> <p>To correctly type this dictionary, you should set the fields of <code>Slots</code> to <code>Slot</code> or <code>SlotInput</code>:</p> <p><code>SlotInput</code> is a union of <code>Slot</code>, string, and function types.</p>"},{"location":"concepts/fundamentals/typing_and_validation/#typing-data","title":"Typing data","text":"<p>You can use <code>Component.TemplateData</code>, <code>Component.JsData</code>, and <code>Component.CssData</code> to type the data returned from <code>get_template_data()</code>, <code>get_js_data()</code>, and <code>get_css_data()</code>.</p> <p>When you set these classes, at render time they will be instantiated with the data returned from these methods.</p> <p>This way, each component can have runtime validation of the returned data:</p> <ul> <li>When you use <code>NamedTuple</code>   or <code>@dataclass</code>,   instantiating these classes will check ONLY for the presence of the attributes.</li> <li>When you use Pydantic models,   instantiating these classes will check for the presence AND type of the attributes.</li> </ul> <p>If you omit the <code>TemplateData</code>, <code>JsData</code>, or <code>CssData</code> classes, or set them to <code>None</code>, the validation and instantiation will be skipped.</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Button(Component):\n    class TemplateData(NamedTuple):\n        data1: str\n        data2: int\n\n    class JsData(NamedTuple):\n        js_data1: str\n        js_data2: int\n\n    class CssData(NamedTuple):\n        css_data1: str\n        css_data2: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"data1\": \"...\",\n            \"data2\": 123,\n        }\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"js_data1\": \"...\",\n            \"js_data2\": 123,\n        }\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"css_data1\": \"...\",\n            \"css_data2\": 123,\n        }\n</code></pre> <p>For each data method, you can either return a plain dictionary with the data, or an instance of the respective data class directly.</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Button(Component):\n    class TemplateData(NamedTuple):\n        data1: str\n        data2: int\n\n    class JsData(NamedTuple):\n        js_data1: str\n        js_data2: int\n\n    class CssData(NamedTuple):\n        css_data1: str\n        css_data2: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return Button.TemplateData(\n            data1=\"...\",\n            data2=123,\n        )\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return Button.JsData(\n            js_data1=\"...\",\n            js_data2=123,\n        )\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return Button.CssData(\n            css_data1=\"...\",\n            css_data2=123,\n        )\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#custom-types","title":"Custom types","text":"<p>We recommend to use <code>NamedTuple</code> for the <code>Args</code> class, and <code>NamedTuple</code>, dataclasses, or Pydantic models for <code>Kwargs</code>, <code>Slots</code>, <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code> classes.</p> <p>However, you can use any class, as long as they meet the conditions below.</p> <p>For example, here is how you can use Pydantic models to validate the inputs at runtime.</p> <pre><code>from django_components import Component\nfrom pydantic import BaseModel\n\nclass Table(Component):\n    class Kwargs(BaseModel):\n        name: str\n        age: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        assert isinstance(kwargs, Table.Kwargs)\n\nTable.render(\n    kwargs=Table.Kwargs(name=\"John\", age=30),\n)\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#args-class","title":"<code>Args</code> class","text":"<p>The <code>Args</code> class represents a list of positional arguments. It must meet two conditions:</p> <ol> <li> <p>The constructor for the <code>Args</code> class must accept positional arguments.</p> <pre><code>Args(*args)\n</code></pre> </li> <li> <p>The <code>Args</code> instance must be convertable to a list.</p> <pre><code>list(Args(1, 2, 3))\n</code></pre> </li> </ol> <p>To implement the conversion to a list, you can implement the <code>__iter__()</code> method:</p> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#dictionary-classes","title":"Dictionary classes","text":"<p>On the other hand, other types (<code>Kwargs</code>, <code>Slots</code>, <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code>) represent dictionaries. They must meet these two conditions:</p> <ol> <li> <p>The constructor must accept keyword arguments.</p> <pre><code>Kwargs(**kwargs)\nSlots(**slots)\n</code></pre> </li> <li> <p>The instance must be convertable to a dictionary.</p> <pre><code>dict(Kwargs(a=1, b=2))\ndict(Slots(a=1, b=2))\n</code></pre> </li> </ol> <p>To implement the conversion to a dictionary, you can implement either:</p> <ol> <li> <p><code>_asdict()</code> method     <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def _asdict(self):\n        return {'x': self.x, 'y': self.y}\n</code></pre></p> </li> <li> <p>Or make the class dict-like with <code>__iter__()</code> and <code>__getitem__()</code> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code></pre></p> </li> </ol>"},{"location":"concepts/fundamentals/typing_and_validation/#passing-variadic-args-and-kwargs","title":"Passing variadic args and kwargs","text":"<p>You may have a component that accepts any number of args or kwargs.</p> <p>However, this cannot be described with the current Python's typing system (as of v0.140).</p> <p>As a workaround:</p> <ul> <li> <p>For a variable number of positional arguments (<code>*args</code>), set a positional argument that accepts a list of values:</p> <pre><code>class Table(Component):\n    class Args(NamedTuple):\n        args: List[str]\n\nTable.render(\n    args=Table.Args(args=[\"a\", \"b\", \"c\"]),\n)\n</code></pre> </li> <li> <p>For a variable number of keyword arguments (<code>**kwargs</code>), set a keyword argument that accepts a dictionary of values:</p> <pre><code>class Table(Component):\n    class Kwargs(NamedTuple):\n        variable: str\n        another: int\n        # Pass any extra keys under `extra`\n        extra: Dict[str, any]\n\nTable.render(\n    kwargs=Table.Kwargs(\n        variable=\"a\",\n        another=1,\n        extra={\"foo\": \"bar\"},\n    ),\n)\n</code></pre> </li> </ul>"},{"location":"concepts/fundamentals/typing_and_validation/#handling-no-args-or-no-kwargs","title":"Handling no args or no kwargs","text":"<p>To declare that a component accepts no args, kwargs, etc, define the types with no attributes using the <code>pass</code> keyword:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Button(Component):\n    class Args(NamedTuple):\n        pass\n\n    class Kwargs(NamedTuple):\n        pass\n\n    class Slots(NamedTuple):\n        pass\n</code></pre> <p>This can get repetitive, so we added a <code>Empty</code> type to make it easier:</p> <pre><code>from django_components import Component, Empty\n\nclass Button(Component):\n    Args = Empty\n    Kwargs = Empty\n    Slots = Empty\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#subclassing","title":"Subclassing","text":"<p>Subclassing components with types is simple.</p> <p>Since each type class is a separate class attribute, you can just override them in the Component subclass.</p> <p>In the example below, <code>ButtonExtra</code> inherits <code>Kwargs</code> from <code>Button</code>, but overrides the <code>Args</code> class.</p> <pre><code>from django_components import Component, Empty\n\nclass Button(Component):\n    class Args(NamedTuple):\n        size: int\n\n    class Kwargs(NamedTuple):\n        color: str\n\nclass ButtonExtra(Button):\n    class Args(NamedTuple):\n        name: str\n        size: int\n\n# Stil works the same way!\nButtonExtra.render(\n    args=ButtonExtra.Args(name=\"John\", size=30),\n    kwargs=ButtonExtra.Kwargs(color=\"red\"),\n)\n</code></pre> <p>The only difference is when it comes to type hints to the data methods like <code>get_template_data()</code>.</p> <p>When you define the nested classes like <code>Args</code> and <code>Kwargs</code> directly on the class, you can reference them just by their class name (<code>Args</code> and <code>Kwargs</code>).</p> <p>But when you have a Component subclass, and it uses <code>Args</code> or <code>Kwargs</code> from the parent, you will have to reference the type as a forward reference, including the full name of the component (<code>Button.Args</code> and <code>Button.Kwargs</code>).</p> <p>Compare the following:</p> <pre><code>class Button(Component):\n    class Args(NamedTuple):\n        size: int\n\n    class Kwargs(NamedTuple):\n        color: str\n\n    # Both `Args` and `Kwargs` are defined on the class\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots, context):\n        pass\n\nclass ButtonExtra(Button):\n    class Args(NamedTuple):\n        name: str\n        size: int\n\n    # `Args` is defined on the subclass, `Kwargs` is defined on the parent\n    def get_template_data(self, args: Args, kwargs: \"ButtonExtra.Kwargs\", slots, context):\n        pass\n\nclass ButtonSame(Button):\n    # Both `Args` and `Kwargs` are defined on the parent\n    def get_template_data(self, args: \"ButtonSame.Args\", kwargs: \"ButtonSame.Kwargs\", slots, context):\n        pass\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#runtime-type-validation","title":"Runtime type validation","text":"<p>When you add types to your component, and implement them as <code>NamedTuple</code> or <code>dataclass</code>, the validation will check only for the presence of the attributes.</p> <p>So this will not catch if you pass a string to an <code>int</code> attribute.</p> <p>To enable runtime type validation, you need to use Pydantic models, and install the <code>djc-ext-pydantic</code> extension.</p> <p>The <code>djc-ext-pydantic</code> extension ensures compatibility between django-components' classes such as <code>Component</code>, or <code>Slot</code> and Pydantic models.</p> <p>First install the extension:</p> <pre><code>pip install djc-ext-pydantic\n</code></pre> <p>And then add the extension to your project:</p> <pre><code>COMPONENTS = {\n    \"extensions\": [\n        \"djc_pydantic.PydanticExtension\",\n    ],\n}\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#migrating-from-generics-to-class-attributes","title":"Migrating from generics to class attributes","text":"<p>In versions 0.92 to 0.139 (inclusive), the component typing was specified through generics.</p> <p>Since v0.140, the types must be specified as class attributes of the Component class - <code>Args</code>, <code>Kwargs</code>, <code>Slots</code>, <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code>.</p> <p>This change was necessary to make it possible to subclass components. Subclassing with generics was otherwise too complicated. Read the discussion here.</p> <p>Because of this change, the <code>Component.render()</code> method is no longer typed. To type-check the inputs, you should wrap the inputs in <code>Component.Args</code>, <code>Component.Kwargs</code>, <code>Component.Slots</code>, etc.</p> <p>For example, if you had a component like this:</p> <pre><code>from typing import NotRequired, Tuple, TypedDict\nfrom django_components import Component, Slot, SlotInput\n\nButtonArgs = Tuple[int, str]\n\nclass ButtonKwargs(TypedDict):\n    variable: str\n    another: int\n    maybe_var: NotRequired[int] # May be omitted\n\nclass ButtonSlots(TypedDict):\n    # Use `SlotInput` to allow slots to be given as `Slot` instance,\n    # plain string, or a function that returns a string.\n    my_slot: NotRequired[SlotInput]\n    # Use `Slot` to allow ONLY `Slot` instances.\n    another_slot: Slot\n\nButtonType = Component[ButtonArgs, ButtonKwargs, ButtonSlots]\n\nclass Button(ButtonType):\n    def get_context_data(self, *args, **kwargs):\n        self.input.args[0]  # int\n        self.input.kwargs[\"variable\"]  # str\n        self.input.slots[\"my_slot\"]  # Slot[MySlotData]\n\nButton.render(\n    args=(1, \"hello\"),\n    kwargs={\n        \"variable\": \"world\",\n        \"another\": 123,\n    },\n    slots={\n        \"my_slot\": \"...\",\n        \"another_slot\": Slot(lambda ctx: ...),\n    },\n)\n</code></pre> <p>The steps to migrate are:</p> <ol> <li>Convert all the types (<code>ButtonArgs</code>, <code>ButtonKwargs</code>, <code>ButtonSlots</code>) to subclasses     of <code>NamedTuple</code>.</li> <li>Move these types inside the Component class (<code>Button</code>), and rename them to <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code>.</li> <li>If you defined typing for the data methods (like <code>get_context_data()</code>), move them inside the Component class, and rename them to <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code>.</li> <li>Remove the <code>Component</code> generic.</li> <li> <p>If you accessed the <code>args</code>, <code>kwargs</code>, or <code>slots</code> attributes via     <code>self.input</code>, you will need to add the type hints yourself, because <code>self.input</code> is no longer typed.</p> <p>Otherwise, you may use <code>Component.get_template_data()</code> instead of <code>get_context_data()</code>, as <code>get_template_data()</code> receives <code>args</code>, <code>kwargs</code>, <code>slots</code> and <code>context</code> as arguments. You will still need to add the type hints yourself.</p> </li> <li> <p>Lastly, you will need to update the <code>Component.render()</code>     calls to wrap the inputs in <code>Component.Args</code>, <code>Component.Kwargs</code>, and <code>Component.Slots</code>, to manually add type hints.</p> </li> </ol> <p>Thus, the code above will become:</p> <pre><code>from typing import NamedTuple, Optional\nfrom django.template import Context\nfrom django_components import Component, Slot, SlotInput\n\n# The Component class does not take any generics\nclass Button(Component):\n    # Types are now defined inside the component class\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        variable: str\n        another: int\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        # Use `SlotInput` to allow slots to be given as `Slot` instance,\n        # plain string, or a function that returns a string.\n        my_slot: Optional[SlotInput] = None\n        # Use `Slot` to allow ONLY `Slot` instances.\n        another_slot: Slot\n\n    # The args, kwargs, slots are instances of the component's Args, Kwargs, and Slots classes\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        args.size  # int\n        kwargs.variable  # str\n        slots.my_slot  # Slot[MySlotData]\n\nButton.render(\n    # Wrap the inputs in the component's Args, Kwargs, and Slots classes\n    args=Button.Args(1, \"hello\"),\n    kwargs=Button.Kwargs(\n        variable=\"world\",\n        another=123,\n    ),\n    slots=Button.Slots(\n        my_slot=\"...\",\n        another_slot=Slot(lambda ctx: ...),\n    ),\n)\n</code></pre>"},{"location":"examples/","title":"Overview","text":"<p><code>django-components</code> makes it easy to share components between projects (See how to package components).</p> <p>Here you will find public examples of components and component libraries.</p> <p>If you have components that would be useful to others, open a pull request to add them to this collection.</p>"},{"location":"examples/#components","title":"Components","text":"<ul> <li>Form - A form component that automatically generates labels and arranges fields in a grid.</li> <li>Tabs - Dynamic tabs with AlpineJS.</li> </ul>"},{"location":"examples/#packages","title":"Packages","text":"<p>Packages or projects that define components for django-components:</p> <ul> <li>djc-heroicons - Icons from HeroIcons.com for django-components.</li> <li><code>django-htmx-components</code> - A set of components for use with htmx.</li> </ul>"},{"location":"examples/form/","title":"Form","text":"<p>A <code>Form</code> component that automatically generates labels and arranges fields in a grid. It simplifies form creation by handling the layout for you.</p> <p></p> <p>To get started, use the following example to create a simple form with 2 fields - <code>project</code> and <code>option</code>:</p> <pre><code>{% component \"form\" %}\n  {% fill \"field:project\" %}\n    &lt;input name=\"project\" required&gt;\n  {% endfill %}\n\n  {% fill \"field:option\" %}\n    &lt;select name=\"option\" required&gt;\n      &lt;option value=\"1\"&gt;Option 1&lt;/option&gt;\n      &lt;option value=\"2\"&gt;Option 2&lt;/option&gt;\n      &lt;option value=\"3\"&gt;Option 3&lt;/option&gt;\n    &lt;/select&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>This will render a <code>&lt;form&gt;</code> where fields are defined using <code>field:&lt;field_name&gt;</code> slots.</p> <p>Labels are automatically generated from the field name. If you want to define a custom label for a field, you can use the <code>label:&lt;field_name&gt;</code> slot.</p> <pre><code>{% component \"form\" %}\n  {# Custom label for \"description\" field #}\n  {% fill \"label:description\" %}\n    {% component \"form_label\"\n      field_name=\"description\"\n      title=\"Marvelous description\"\n    / %}\n  {% endfill %}\n\n  {% fill \"field:description\" %}\n    &lt;textarea name=\"description\" required&gt;&lt;/textarea&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Whether you define custom labels or not, the form will have the following structure:</p> <p></p>"},{"location":"examples/form/#api","title":"API","text":""},{"location":"examples/form/#form-component","title":"<code>Form</code> component","text":"<p>The <code>Form</code> component is the main container for your form fields. It accepts the following arguments:</p> <ul> <li><code>editable</code> (optional, default <code>True</code>): A boolean that determines if the form is editable.</li> <li><code>method</code> (optional, default <code>\"post\"</code>): The HTTP method for the form submission.</li> <li><code>form_content_attrs</code> (optional): A dictionary of HTML attributes to be added to the form's content container.</li> <li><code>attrs</code> (optional): A dictionary of HTML attributes to be added to the <code>&lt;form&gt;</code> element itself.</li> </ul> <p>To define the fields, you define a slot for each field.</p> <p>Slots:</p> <ul> <li><code>field:&lt;field_name&gt;</code>: Use this slot to define a form field. The component will automatically generate a label for it based on <code>&lt;field_name&gt;</code>.</li> <li><code>label:&lt;field_name&gt;</code>: If you need a custom label for a field, you can define it using this slot.</li> <li><code>prepend</code>: Content in this slot will be placed at the beginning of the form, before the main fields.</li> <li><code>append</code>: Content in this slot will be placed at the end of the form, after the main fields. This is a good place for submit buttons.</li> </ul>"},{"location":"examples/form/#formlabel-component","title":"<code>FormLabel</code> component","text":"<p>When <code>Form</code> component automatically generates labels for fields, it uses the <code>FormLabel</code> component.</p> <p>When you need a custom label for a field, you can use the <code>FormLabel</code> component explicitly in <code>label:&lt;field_name&gt;</code> slots.</p> <p>The <code>FormLabel</code> component accepts the following arguments:</p> <ul> <li><code>field_name</code> (required): The name of the field that this label is for. This will be used as the <code>for</code> attribute of the label.</li> <li><code>title</code> (optional): Custom text for the label. If not provided, the component will automatically generate a title from the <code>field_name</code> by replacing underscores and hyphens with spaces and applying title case.</li> </ul> <p>Example:</p> <pre><code>{% component \"form_label\"\n  field_name=\"user_name\"\n  title=\"Your Name\"\n/ %}\n</code></pre> <p>This will render:</p> <pre><code>&lt;label for=\"user_name\" class=\"font-semibold text-gray-700\"&gt;\n  Your Name\n&lt;/label&gt;\n</code></pre> <p>If <code>title</code> is not provided, <code>field_name=\"user_name\"</code> would automatically generate the title \"User Name\", converting snake_case to \"Title Case\".</p>"},{"location":"examples/form/#example","title":"Example","text":"<p>To see the component in action, you can set up a view and a URL pattern as shown below.</p>"},{"location":"examples/form/#viewspy","title":"<code>views.py</code>","text":"<pre><code>from django.http import HttpRequest\nfrom django.utils.safestring import mark_safe\n\nfrom django_components import Component, types\n\n\nclass FormPage(Component):\n    class Media:\n        js = (\n            # AlpineJS\n            mark_safe('&lt;script src=\"https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js\" defer&gt;&lt;/script&gt;'),\n            # TailwindCSS\n            \"https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4\",\n        )\n\n    template: types.django_html = \"\"\"\n      &lt;html&gt;\n        &lt;head&gt;\n          &lt;title&gt;Form&lt;/title&gt;\n          &lt;script src=\"https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp,container-queries\"&gt;&lt;/script&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n          &lt;div x-data=\"{\n            onSubmit: () =&gt; {\n              alert('Submitted!');\n            }\n          }\"&gt;\n            &lt;div class=\"prose-xl p-6\"&gt;\n              &lt;h3&gt;Submit form&lt;/h3&gt;\n            &lt;/div&gt;\n\n            {% component \"form\"\n              attrs:class=\"pb-4 px-4 pt-6 sm:px-6 lg:px-8 flex-auto flex flex-col\"\n              attrs:style=\"max-width: 600px;\"\n              attrs:@submit.prevent=\"onSubmit\"\n            %}\n              {% fill \"field:project\" %}\n                &lt;input\n                  name=\"project\"\n                  required\n                  class=\"block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6\"\n                &gt;\n              {% endfill %}\n\n              {% fill \"field:option\" %}\n                &lt;select\n                  name=\"option\"\n                  required\n                  class=\"block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:max-w-xs sm:text-sm sm:leading-6\"\n                &gt;\n                  &lt;option value=\"1\"&gt;Option 1&lt;/option&gt;\n                  &lt;option value=\"2\"&gt;Option 2&lt;/option&gt;\n                  &lt;option value=\"3\"&gt;Option 3&lt;/option&gt;\n                &lt;/select&gt;\n              {% endfill %}\n\n              {# Defined both label and field because label name is different from field name #}\n              {% fill \"label:description\" %}\n                {% component \"form_label\" field_name=\"description\" title=\"Marvelous description\" / %}\n              {% endfill %}\n              {% fill \"field:description\" %}\n                &lt;textarea\n                  name=\"description\"\n                  id=\"description\"\n                  rows=\"5\"\n                  class=\"block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6\"\n                &gt;&lt;/textarea&gt;\n              {% endfill %}\n\n              {% fill \"append\" %}\n                &lt;div class=\"flex justify-end items-center gap-x-6 border-t border-gray-900/10 py-4\"&gt;\n                  &lt;button type=\"submit\" class=\"rounded-md bg-indigo-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600\"&gt;\n                    Submit\n                  &lt;/button&gt;\n                  &lt;button type=\"button\" class=\"text-sm font-semibold leading-6 text-gray-900\"&gt;\n                    Cancel\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              {% endfill %}\n            {% endcomponent %}\n          &lt;/div&gt;\n        &lt;/body&gt;\n      &lt;/html&gt;\n    \"\"\"  # noqa: E501\n\n    class View:\n        def get(self, request: HttpRequest):\n            return FormPage.render_to_response(request=request)\n</code></pre>"},{"location":"examples/form/#urlspy","title":"<code>urls.py</code>","text":"<pre><code>from django.urls import path\n\nfrom examples.pages.form import FormPage\n\nurlpatterns = [\n    path(\"examples/form\", FormPage.as_view(), name=\"form\"),\n]\n</code></pre>"},{"location":"examples/form/#definition","title":"Definition","text":""},{"location":"examples/form/#formpy","title":"<code>form.py</code>","text":"<pre><code>from typing import Any, Dict, List, NamedTuple, Optional, Set, Tuple\n\nfrom django_components import Component, Slot, register, types\n\n\n@register(\"form\")\nclass Form(Component):\n    template_file = \"form.html\"\n\n    class Kwargs(NamedTuple):\n        editable: bool = True\n        method: str = \"post\"\n        form_content_attrs: Optional[dict] = None\n        attrs: Optional[dict] = None\n\n    def get_template_data(self, args, kwargs: Kwargs, slots: Dict[str, Slot], context):\n        fields = prepare_form_grid(slots)\n\n        return {\n            \"form_content_attrs\": kwargs.form_content_attrs,\n            \"method\": kwargs.method,\n            \"editable\": kwargs.editable,\n            \"attrs\": kwargs.attrs,\n            \"fields\": fields,\n        }\n\n\n# Users of this component can define form fields as slots.\n#\n# For example:\n# ```django\n# {% component \"form\" %}\n#   {% fill \"field:field_1\" / %}\n#     &lt;textarea name=\"field_1\" /&gt;\n#   {% endfill %}\n#   {% fill \"field:field_2\" / %}\n#     &lt;select name=\"field_2\"&gt;\n#       &lt;option value=\"1\"&gt;Option 1&lt;/option&gt;\n#       &lt;option value=\"2\"&gt;Option 2&lt;/option&gt;\n#     &lt;/select&gt;\n#   {% endfill %}\n# {% endcomponent %}\n# ```\n#\n# The above will automatically generate labels for the fields,\n# and the form will be aligned with a grid.\n#\n# To explicitly define a label, use `label:&lt;field_name&gt;` slot name.\n#\n# For example:\n# ```django\n# {% component \"form\" %}\n#   {% fill \"label:field_1\" / %}\n#     &lt;label for=\"field_1\"&gt;Label 1&lt;/label&gt;\n#   {% endfill %}\n#   {% fill \"field:field_1\" / %}\n#     &lt;textarea name=\"field_1\" /&gt;\n#   {% endfill %}\n# {% endcomponent %}\n# ```\ndef prepare_form_grid(slots: Dict[str, Slot]):\n    used_labels: Set[str] = set()\n    unused_labels: Set[str] = set()\n    fields: List[Tuple[str, str]] = []\n\n    for slot_name in slots:\n        # Case: Label slot\n        is_label = slot_name.startswith(\"label:\")\n        if is_label and slot_name not in used_labels:\n            unused_labels.add(slot_name)\n            continue\n\n        # Case: non-field, non-label slot\n        is_field = slot_name.startswith(\"field:\")\n        if not is_field:\n            continue\n\n        # Case: Field slot\n        field_name = slot_name.split(\":\", 1)[1]\n        label_slot_name = f\"label:{field_name}\"\n        label = None\n        if label_slot_name in slots:\n            # Case: Component user explicitly defined how to render the label\n            label_slot: Slot[Any] = slots[label_slot_name]\n            label = label_slot()\n\n            unused_labels.discard(label_slot_name)\n            used_labels.add(slot_name)\n        else:\n            # Case: Component user didn't explicitly define how to render the label\n            #       We will create the label for the field automatically\n            label = FormLabel.render(\n                kwargs=FormLabel.Kwargs(field_name=field_name),\n                deps_strategy=\"ignore\",\n            )\n\n        fields.append((slot_name, label))\n\n    if unused_labels:\n        raise ValueError(f\"Unused labels: {unused_labels}\")\n\n    return fields\n\n\n@register(\"form_label\")\nclass FormLabel(Component):\n    template: types.django_html = \"\"\"\n        &lt;label for=\"{{ field_name }}\" class=\"font-semibold text-gray-700\"&gt;\n            {{ title }}\n        &lt;/label&gt;\n    \"\"\"\n\n    class Kwargs(NamedTuple):\n        field_name: str\n        title: Optional[str] = None\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        if kwargs.title:\n            title = kwargs.title\n        else:\n            title = kwargs.field_name.replace(\"_\", \" \").replace(\"-\", \" \").title()\n\n        return {\n            \"field_name\": kwargs.field_name,\n            \"title\": title,\n        }\n</code></pre>"},{"location":"examples/form/#formhtml","title":"<code>form.html</code>","text":"<pre><code>{% load component_tags %}\n&lt;form\n  {% if submit_href and editable %} action=\"{{ submit_href }}\" {% endif %}\n  method=\"{{ method }}\"\n  {% html_attrs attrs %}\n&gt;\n  {% slot \"prepend\" / %}\n\n  &lt;div {% html_attrs form_content_attrs %}&gt;\n    {# Generate a grid of fields and labels out of given slots #}\n    &lt;div class=\"grid grid-cols-[auto,1fr] gap-x-4 gap-y-2 items-center\"&gt;\n      {% for field_name, label in fields %}\n        {{ label }}\n        {% slot name=field_name / %}\n      {% endfor %}\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  {% slot \"append\" / %}\n&lt;/form&gt;\n</code></pre>"},{"location":"examples/tabs/","title":"Tabs (AlpineJS)","text":"<p>(By @JuroOravec and @mscheper)</p> <p>This example defines a tabs component. Tabs are dynamic - to change the currently opened tab, click on the tab headers.</p> <p>To get started, use the following example to create a simple container with 2 tabs:</p> <pre><code>{% component \"Tablist\" id=\"my-tablist\" name=\"My Tabs\" %}\n    {% component \"Tab\" header=\"Tab 1\" %}\n        This is the content of Tab 1\n    {% endcomponent %}\n    {% component \"Tab\" header=\"Tab 2\" disabled=True %}\n        This is the content of Tab 2\n    {% endcomponent %}\n{% endcomponent %}\n</code></pre> <p></p>"},{"location":"examples/tabs/#api","title":"API","text":"<p>The tab component is composed of two parts: <code>Tablist</code> and <code>Tab</code>. Here's how you can customize them.</p>"},{"location":"examples/tabs/#tablist-component","title":"<code>Tablist</code> component","text":"<p>The <code>Tablist</code> component is the main container for the tabs. It accepts the following arguments:</p> <ul> <li><code>id</code> (optional): A unique ID for the tab list. If not provided, it's generated from the <code>name</code>.</li> <li><code>name</code>: The name of the tab list, used as a WAI-ARIA label for accessibility.</li> <li><code>selected_tab</code> (optional): The <code>id</code> of the tab that should be selected by default.</li> <li><code>container_attrs</code>, <code>tablist_attrs</code>, <code>tab_attrs</code>, <code>tabpanel_attrs</code> (optional): Dictionaries of HTML attributes to be added to the corresponding elements.</li> </ul> <p>Inside the <code>Tablist</code>'s default slot you will define the individual tabs.</p>"},{"location":"examples/tabs/#tab-component","title":"<code>Tab</code> component","text":"<p>The <code>Tab</code> component defines an individual tab. It MUST be nested inside a <code>Tablist</code>. It accepts the following arguments:</p> <ul> <li><code>header</code>: The text to be displayed in the tab's header.</li> <li><code>disabled</code> (optional): A boolean that disables the tab if <code>True</code>.</li> <li><code>id</code> (optional): A unique ID for the tab. If not provided, it's generated from the header.</li> </ul> <p>Use the <code>Tab</code>'s default slot to define the content of the tab.</p>"},{"location":"examples/tabs/#example","title":"Example","text":"<p>To see the component in action, you can set up a view and a URL pattern as shown below.</p>"},{"location":"examples/tabs/#viewspy","title":"<code>views.py</code>","text":"<p>This example shows how to render a full page with the tab component.</p> <pre><code>from django.http import HttpRequest\n\nfrom django_components import Component, types\n\n\nclass TabsPage(Component):\n    template: types.django_html = \"\"\"\n      &lt;html&gt;\n        &lt;head&gt;\n          &lt;title&gt;Tabs&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n          {% component \"Tablist\"\n            id=\"optional-tablist-id\"\n            name=\"Bonza tablist\"\n            container_attrs:class=\"optional-container-attrs\"\n            tablist_attrs:class=\"optional-tablist-attrs\"\n            tab_attrs:class=\"optional-tab-attrs\"\n            tabpanel_attrs:class=\"optional-panel-attrs\"\n          %}\n            {% component \"Tab\" id=\"optional-tab-id\" header=\"I'm a tab!\" %}\n              {% lorem %}\n            {% endcomponent %}\n            {% component \"Tab\" header=\"I'm also a tab!\" %}\n              &lt;p&gt;{% lorem %}&lt;/p&gt;\n              &lt;p&gt;{% lorem %}&lt;/p&gt;\n            {% endcomponent %}\n            {% component \"Tab\" header=\"I am a gorilla!\" %}\n              &lt;p&gt;{% lorem %}&lt;/p&gt;\n              &lt;p&gt;I wonder if anyone got the Monty Python reference. \ud83e\udd14&lt;/p&gt;\n            {% endcomponent %}\n          {% endcomponent %}\n        &lt;/body&gt;\n      &lt;/html&gt;\n    \"\"\"\n\n    class View:\n        def get(self, request: HttpRequest):\n            return TabsPage.render_to_response(request=request)\n</code></pre>"},{"location":"examples/tabs/#urlspy","title":"<code>urls.py</code>","text":"<pre><code>from django.urls import path\n\nfrom examples.pages.tabs import TabsPage\n\nurlpatterns = [\n    path(\"examples/tabs\", TabsPage.as_view(), name=\"tabs\"),\n]\n</code></pre>"},{"location":"examples/tabs/#how-it-works","title":"How it works","text":"<p>At the start of rendering, <code>Tablist</code> defines special context that <code>Tab</code>s recognize.</p> <p>When a <code>Tab</code> component is nested and rendered inside a <code>Tablist</code>, it registers itself with the parent <code>Tablist</code> component.</p> <p>After the rendering of <code>Tablist</code>'s body is done, we end up with list of rendered <code>Tabs</code> that were encountered.</p> <p><code>Tablist</code> then uses this information to dynamically render the tab HTML.</p>"},{"location":"examples/tabs/#definition","title":"Definition","text":""},{"location":"examples/tabs/#tabspy","title":"<code>tabs.py</code>","text":"<pre><code>\"\"\"\nAlpine-based tab components: Tablist and Tab.\n\nBased on https://github.com/django-components/django-components/discussions/540\n\"\"\"\n\nfrom typing import List, NamedTuple, Optional\n\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import slugify\n\nfrom django_components import Component, register\nfrom django_components import types as t\n\n\nclass TabDatum(NamedTuple):\n    \"\"\"Datum for an individual tab.\"\"\"\n\n    tab_id: str\n    tabpanel_id: str\n    header: str\n    content: str\n    disabled: bool = False\n\n\nclass TabContext(NamedTuple):\n    id: str\n    tab_data: List[TabDatum]\n    enabled: bool\n\n\n@register(\"_tabset\")\nclass _TablistImpl(Component):\n    \"\"\"\n    Delegated Tablist component.\n\n    Refer to `Tablist` API below.\n    \"\"\"\n\n    template_file = \"tabs.html\"\n    css_file = \"tabs.css\"\n\n    class Media:\n        js = (\n            # `mark_safe` is used so the script tag is usd as is, so we can add `defer` flag.\n            # `defer` is used so that AlpineJS is actually loaded only after all plugins are registered\n            mark_safe('&lt;script src=\"https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js\" defer&gt;&lt;/script&gt;'),\n        )\n\n    class Kwargs(NamedTuple):\n        tab_data: List[TabDatum]\n        id: Optional[str] = None\n        name: Optional[str] = None\n        selected_tab: Optional[str] = None\n        container_attrs: Optional[dict] = None\n        tablist_attrs: Optional[dict] = None\n        tab_attrs: Optional[dict] = None\n        tabpanel_attrs: Optional[dict] = None\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        selected_tab = kwargs.selected_tab if kwargs.selected_tab is not None else kwargs.tab_data[0].tab_id\n        tab_data = [\n            (tab, tab.tab_id != selected_tab)  # (tab, is_hidden)\n            for tab in kwargs.tab_data\n        ]\n\n        return {\n            \"id\": kwargs.id,\n            \"name\": kwargs.name,\n            \"container_attrs\": kwargs.container_attrs,\n            \"tablist_attrs\": kwargs.tablist_attrs,\n            \"tab_attrs\": kwargs.tab_attrs,\n            \"tabpanel_attrs\": kwargs.tabpanel_attrs,\n            \"tab_data\": tab_data,\n            \"selected_tab\": selected_tab,\n        }\n\n\n@register(\"Tablist\")\nclass Tablist(Component):\n    \"\"\"\n    Tablist role component comprised of nested tab components.\n\n    After the input is processed, this component delegates to an internal implementation\n    component that renders the content.\n\n    `name` identifies the tablist and is used as a WAI-ARIA label\n\n    `id`, by default, is a sligified `name`, we could be used to preselect a tab based\n    on query parameters (TODO)\n\n    Example:\n    ```\n    {% component \"Tablist\" id=\"my-tablist\" name=\"My Tabs\" %}\n        {% component Tab header=\"Tab 1\" %}\n            This is the content of Tab 1\n        {% endcomponent %}\n        {% component Tab header=\"Tab 2\" disabled=True %}\n            This is the content of Tab 2\n        {% endcomponent %}\n    {% endcomponent %}\n    ```\n\n    \"\"\"\n\n    template: t.django_html = \"\"\"\n        {% load component_tags %}\n        {% provide \"_tab\" ...tab_context %}\n            {% slot \"content\" default / %}\n        {% endprovide %}\n    \"\"\"\n\n    class Kwargs(NamedTuple):\n        id: Optional[str] = None\n        name: str = \"Tabs\"\n        selected_tab: Optional[str] = None\n        container_attrs: Optional[dict] = None\n        tablist_attrs: Optional[dict] = None\n        tab_attrs: Optional[dict] = None\n        tabpanel_attrs: Optional[dict] = None\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        self.tablist_id: str = kwargs.id or slugify(kwargs.name)\n        self.tab_data: List[TabDatum] = []\n\n        tab_context = TabContext(\n            id=self.tablist_id,\n            tab_data=self.tab_data,\n            enabled=True,\n        )\n\n        return {\n            \"tab_context\": tab_context._asdict(),\n        }\n\n    def on_render_after(self, context, template, result, error) -&gt; Optional[str]:\n        \"\"\"\n        Render the tab set.\n\n        By the time we get here, all child Tab components should have been rendered,\n        and they should've populated the tablist.\n        \"\"\"\n        if error or result is None:\n            return None\n\n        kwargs: Tablist.Kwargs = self.kwargs\n\n        # Render the TablistImpl component in place of Tablist.\n        return _TablistImpl.render(\n            kwargs=_TablistImpl.Kwargs(\n                # Access variables we've defined in get_template_data\n                id=self.tablist_id,\n                tab_data=self.tab_data,\n                name=kwargs.name,\n                selected_tab=kwargs.selected_tab,\n                container_attrs=kwargs.container_attrs,\n                tablist_attrs=kwargs.tablist_attrs,\n                tab_attrs=kwargs.tab_attrs,\n                tabpanel_attrs=kwargs.tabpanel_attrs,\n            ),\n            deps_strategy=\"ignore\",\n        )\n\n\n@register(\"Tab\")\nclass Tab(Component):\n    \"\"\"\n    Individual tab, inside the default slot of the `Tablist` component.\n\n    Example:\n    ```\n    {% component \"Tablist\" id=\"my-tablist\" name=\"My Tabs\" %}\n        {% component Tab header=\"Tab 1\" %}\n            This is the content of Tab 1\n        {% endcomponent %}\n        {% component Tab header=\"Tab 2\" disabled=True %}\n            This is the content of Tab 2\n        {% endcomponent %}\n    {% endcomponent %}\n    ```\n\n    \"\"\"\n\n    template: t.django_html = \"\"\"\n        {% load component_tags %}\n        {% provide \"_tab\" ...overriding_tab_context %}\n            {% slot \"content\" default / %}\n        {% endprovide %}\n    \"\"\"\n\n    class Kwargs(NamedTuple):\n        header: str\n        disabled: bool = False\n        id: Optional[str] = None\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        \"\"\"\n        Access the tab data registered for the parent Tablist component.\n\n        This raises if we're not nested inside a Tablist component.\n        \"\"\"\n        tab_ctx: TabContext = self.inject(\"_tab\")\n\n        # We accessed the _tab context, but we're inside ANOTHER Tab\n        if not tab_ctx.enabled:\n            raise RuntimeError(\n                f\"Component '{self.name}' was called with no parent Tablist component. \"\n                f\"Either wrap '{self.name}' in Tablist component, or check if the \"\n                f\"component is not a descendant of another instance of '{self.name}'\"\n            )\n\n        if kwargs.id:\n            slug = kwargs.id\n        else:\n            group_slug = slugify(tab_ctx.id)\n            tab_slug = slugify(kwargs.header)\n            slug = f\"{group_slug}_{tab_slug}\"\n\n        self.tab_id = f\"{slug}_tab\"\n        self.tabpanel_id = f\"{slug}_content\"\n        self.parent_tabs: List[TabDatum] = tab_ctx.tab_data\n\n        # Prevent Tab's children from accessing the parent Tablist context.\n        # If we didn't do this, then you could place a Tab inside another Tab,\n        # ```\n        # {% component Tablist %}\n        #     {% component Tab header=\"Tab 1\" %}\n        #         {% component Tab header=\"Tab 2\" %}\n        #             This is the content of Tab 2\n        #         {% endcomponent %}\n        #     {% endcomponent %}\n        # {% endcomponent %}\n        # ```\n        overriding_tab_context = TabContext(\n            id=self.tab_id,\n            tab_data=[],\n            enabled=False,\n        )\n\n        return {\n            \"overriding_tab_context\": overriding_tab_context._asdict(),\n        }\n\n    # This runs when the Tab component is rendered and the content is returned.\n    # We add the TabDatum to the parent Tablist component.\n    def on_render_after(self, context, template, result, error) -&gt; None:\n        if error or result is None:\n            return\n\n        kwargs: Tab.Kwargs = self.kwargs\n\n        self.parent_tabs.append(\n            TabDatum(\n                tab_id=self.tab_id,\n                tabpanel_id=self.tabpanel_id,\n                header=kwargs.header,\n                disabled=kwargs.disabled,\n                content=mark_safe(result.strip()),\n            ),\n        )\n</code></pre>"},{"location":"examples/tabs/#tabshtml","title":"<code>tabs.html</code>","text":"<pre><code>{% load component_tags %}\n&lt;div\n  x-data=\"{ selectedTab: '{{ selected_tab }}' }\"\n  {% html_attrs\n    container_attrs\n    id=id\n  %}\n&gt;\n  &lt;div\n    {% html_attrs\n      tablist_attrs\n      role=\"tablist\"\n      aria-label=name\n    %}&gt;\n    {% for tab_datum, is_hidden in tab_data %}\n      &lt;button\n        :aria-selected=\"selectedTab === '{{ tab_datum.tab_id }}'\"\n        @click=\"selectedTab = '{{ tab_datum.tab_id }}'\"\n        {% html_attrs\n          tab_attrs\n          id=tab_datum.tab_id\n          role=\"tab\"\n          aria-controls=tab_datum.tabpanel_id\n          disabled=tab_datum.disabled\n        %}&gt;\n        {{ tab_datum.header }}\n      &lt;/button&gt;\n    {% endfor %}\n  &lt;/div&gt;\n  {% for tab_datum, is_hidden in tab_data %}\n    &lt;article\n      :hidden=\"selectedTab != '{{ tab_datum.tab_id }}'\"\n      {% html_attrs\n        tabpanel_attrs\n        hidden=is_hidden\n        role=\"tabpanel\"\n        id=tab_datum.tabpanel_id\n        aria-labelledby=tab_datum.tab_id\n      %}&gt;\n      {{ tab_datum.content }}\n    &lt;/article&gt;\n  {% endfor %}\n&lt;/div&gt;\n</code></pre>"},{"location":"examples/tabs/#tabscss","title":"<code>tabs.css</code>","text":"<pre><code>/* based on https://codepen.io/brettsmason/pen/zYGEgZP */\n\n[role=\"tablist\"] {\n  margin: 0 0 -0.1em;\n  overflow: visible;\n}\n\n[role=\"tab\"] {\n  position: relative;\n  margin: 0;\n  padding: 0.3em 0.5em 0.4em;\n  border: 1px solid hsl(219, 1%, 72%);\n  border-radius: 0.2em 0.2em 0 0;\n  box-shadow: 0 0 0.2em hsl(219, 1%, 72%);\n  overflow: visible;\n  font-family: inherit;\n  font-size: inherit;\n  background: hsl(220, 20%, 94%);\n}\n\n[role=\"tab\"]:hover::before,\n[role=\"tab\"]:focus::before,\n[role=\"tab\"][aria-selected=\"true\"]::before {\n  position: absolute;\n  bottom: 100%;\n  right: -1px;\n  left: -1px;\n  border-radius: 0.2em 0.2em 0 0;\n  border-top: 3px solid LinkText;\n  content: '';\n}\n\n[role=\"tab\"][aria-selected=\"true\"] {\n  border-radius: 0;\n  background: hsl(220, 43%, 99%);\n  outline: 0;\n}\n\n[role=\"tab\"][aria-selected=\"true\"]:not(:focus):not(:hover)::before {\n  border-top: 5px solid SelectedItem;\n}\n\n[role=\"tab\"][aria-selected=\"true\"]::after {\n  position: absolute;\n  z-index: 3;\n  bottom: -1px;\n  right: 0;\n  left: 0;\n  height: 0.3em;\n  background: hsl(220, 43%, 99%);\n  box-shadow: none;\n  content: '';\n}\n\n[role=\"tab\"]:hover,\n[role=\"tab\"]:focus,\n[role=\"tab\"]:active {\n  outline: 0;\n  border-radius: 0;\n  color: inherit;\n}\n\n[role=\"tab\"]:hover::before,\n[role=\"tab\"]:focus::before {\n  border-color: LinkText;\n}\n\n[role=\"tabpanel\"] {\n  position: relative;\n  z-index: 2;\n  padding: 0.5em 0.5em 0.7em;\n  border: 1px solid hsl(219, 1%, 72%);\n  border-radius: 0 0.2em 0.2em 0.2em;\n  box-shadow: 0 0 0.2em hsl(219, 1%, 72%);\n  background: hsl(220, 43%, 99%);\n}\n\n[role=\"tabpanel\"]:focus {\n  border-color: LinkText;\n  box-shadow: 0 0 0.2em LinkText;\n  outline: 0;\n}\n\n[role=\"tabpanel\"]:focus::after {\n  position: absolute;\n  bottom: 0;\n  right: -1px;\n  left: -1px;\n  border-bottom: 3px solid LinkText;\n  border-radius: 0 0 0.2em 0.2em;\n  content: '';\n}\n\n[role=\"tabpanel\"] p {\n  margin: 0;\n}\n\n[role=\"tabpanel\"] * + p {\n  margin-top: 1em;\n}\n</code></pre>"},{"location":"getting_started/adding_js_and_css/","title":"Adding JS and CSS","text":"<p>Next we will add CSS and JavaScript to our template.</p> <p>Info</p> <p>In django-components, using JS and CSS is as simple as defining them on the Component class. You don't have to insert the <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags into the HTML manually.</p> <p>Behind the scenes, django-components keeps track of which components use which JS and CSS files. Thus, when a component is rendered on the page, the page will contain only the JS and CSS used by the components, and nothing more!</p>"},{"location":"getting_started/adding_js_and_css/#1-update-project-structure","title":"1. Update project structure","text":"<p>Start by creating empty <code>calendar.js</code> and <code>calendar.css</code> files:</p> <pre><code>sampleproject/\n\u251c\u2500\u2500 calendarapp/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 calendar/\n\u2502       \u251c\u2500\u2500 calendar.py\n\u2502       \u251c\u2500\u2500 calendar.js       \ud83c\udd95\n\u2502       \u251c\u2500\u2500 calendar.css      \ud83c\udd95\n\u2502       \u2514\u2500\u2500 calendar.html\n\u251c\u2500\u2500 sampleproject/\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting_started/adding_js_and_css/#2-write-css","title":"2. Write CSS","text":"<p>Inside <code>calendar.css</code>, write:</p> [project root]/components/calendar/calendar.css<pre><code>.calendar {\n  width: 200px;\n  background: pink;\n}\n.calendar span {\n  font-weight: bold;\n}\n</code></pre> <p>Be sure to prefix your rules with unique CSS class like <code>calendar</code>, so the CSS doesn't clash with other rules.</p> <p>Note</p> <p>Soon, django-components will automatically scope your CSS by default, so you won't have to worry about CSS class clashes.</p> <p>This CSS will be inserted into the page as an inlined <code>&lt;style&gt;</code> tag, at the position defined by <code>{% component_css_dependencies %}</code>, or at the end of the inside the <code>&lt;head&gt;</code> tag (See Default JS / CSS locations).</p> <p>So in your HTML, you may see something like this:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n    &lt;style&gt;\n      .calendar {\n        width: 200px;\n        background: pink;\n      }\n      .calendar span {\n        font-weight: bold;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting_started/adding_js_and_css/#3-write-js","title":"3. Write JS","text":"<p>Next we write a JavaScript file that specifies how to interact with this component.</p> <p>You are free to use any javascript framework you want.</p> [project root]/components/calendar/calendar.js<pre><code>(function () {\n  document.querySelector(\".calendar\").onclick = () =&gt; {\n    alert(\"Clicked calendar!\");\n  };\n})();\n</code></pre> <p>A good way to make sure the JS of this component doesn't clash with other components is to define all JS code inside an anonymous self-invoking function (<code>(() =&gt; { ... })()</code>). This makes all variables defined only be defined inside this component and not affect other components.</p> <p>Note</p> <p>Soon, django-components will automatically wrap your JS in a self-invoking function by default (except for JS defined with <code>&lt;script type=\"module\"&gt;</code>).</p> <p>Similarly to CSS, JS will be inserted into the page as an inlined <code>&lt;script&gt;</code> tag, at the position defined by <code>{% component_js_dependencies %}</code>, or at the end of the inside the <code>&lt;body&gt;</code> tag (See Default JS / CSS locations).</p> <p>So in your HTML, you may see something like this:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n    &lt;script&gt;\n      (function () {\n        document.querySelector(\".calendar\").onclick = () =&gt; {\n          alert(\"Clicked calendar!\");\n        };\n      })();\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting_started/adding_js_and_css/#rules-of-js-execution","title":"Rules of JS execution","text":"<ol> <li> <p>JS is executed in the order in which the components are found in the HTML</p> <p>By default, the JS is inserted as a synchronous script (<code>&lt;script&gt; ... &lt;/script&gt;</code>)</p> <p>So if you define multiple components on the same page, their JS will be executed in the order in which the components are found in the HTML.</p> <p>So if we have a template like so:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component \"calendar\" / %}\n    {% component \"table\" / %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Then the JS file of the component <code>calendar</code> will be executed first, and the JS file of component <code>table</code> will be executed second.</p> </li> <li> <p>JS will be executed only once, even if there is multiple instances of the same component</p> <p>In this case, the JS of <code>calendar</code> will STILL execute first (because it was found first), and will STILL execute only once, even though it's present twice:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component \"calendar\" / %}\n    {% component \"table\" / %}\n    {% component \"calendar\" / %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> </ol>"},{"location":"getting_started/adding_js_and_css/#4-link-js-and-css-to-a-component","title":"4. Link JS and CSS to a component","text":"<p>Finally, we return to our Python component in <code>calendar.py</code> to tie this together.</p> <p>To link JS and CSS defined in other files, use <code>js_file</code> and <code>css_file</code> attributes:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"   # &lt;--- new\n    css_file = \"calendar.css\"   # &lt;--- new\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>And that's it! If you were to embed this component in an HTML, django-components will automatically embed the associated JS and CSS.</p> <p>Note</p> <p>Similarly to the template file, the JS and CSS file paths can be either:</p> <ol> <li>Relative to the Python component file (as seen above),</li> <li>Relative to any of the component directories as defined by <code>COMPONENTS.dirs</code> and/or <code>COMPONENTS.app_dirs</code> (e.g. <code>[your apps]/components</code> dir and <code>[project root]/components</code>)</li> <li>Relative to any of the directories defined by <code>STATICFILES_DIRS</code>.</li> </ol>"},{"location":"getting_started/adding_js_and_css/#5-link-additional-js-and-css-to-a-component","title":"5. Link additional JS and CSS to a component","text":"<p>Your components may depend on third-party packages or styling, or other shared logic. To load these additional dependencies, you can use a nested <code>Media</code> class.</p> <p>This <code>Media</code> class behaves similarly to Django's Media class, with a few differences:</p> <ol> <li>Our Media class accepts various formats for the JS and CSS files: either a single file, a list, or (CSS-only) a dictonary (see below).</li> <li>Individual JS / CSS files can be any of <code>str</code>, <code>bytes</code>, <code>Path</code>, <code>SafeString</code>, or a function.</li> <li>Individual JS / CSS files can be glob patterns, e.g. <code>*.js</code> or <code>styles/**/*.css</code>.</li> <li>If you set <code>Media.extend</code> to a list,    it should be a list of <code>Component</code> classes.</li> </ol> <p>Learn more about using Media.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    class Media:   # &lt;--- new\n        js = [\n            \"path/to/shared.js\",\n            \"path/to/*.js\",  # Or as a glob\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",  # AlpineJS\n        ]\n        css = [\n            \"path/to/shared.css\",\n            \"path/to/*.css\",  # Or as a glob\n            \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",  # Tailwind\n        ]\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>Note</p> <p>Same as with the \"primary\" JS and CSS, the file paths files can be either:</p> <ol> <li>Relative to the Python component file (as seen above),</li> <li>Relative to any of the component directories as defined by <code>COMPONENTS.dirs</code> and/or <code>COMPONENTS.app_dirs</code> (e.g. <code>[your apps]/components</code> dir and <code>[project root]/components</code>)</li> </ol> <p>Info</p> <p>The <code>Media</code> nested class is shaped based on Django's Media class.</p> <p>As such, django-components allows multiple formats to define the nested Media class:</p> <pre><code># Single files\nclass Media:\n    js = \"calendar.js\"\n    css = \"calendar.css\"\n\n# Lists of files\nclass Media:\n    js = [\"calendar.js\", \"calendar2.js\"]\n    css = [\"calendar.css\", \"calendar2.css\"]\n\n# Dictionary of media types for CSS\nclass Media:\n    js = [\"calendar.js\", \"calendar2.js\"]\n    css = {\n      \"all\": [\"calendar.css\", \"calendar2.css\"],\n    }\n</code></pre> <p>If you define a list of JS files, they will be executed one-by-one, left-to-right.</p>"},{"location":"getting_started/adding_js_and_css/#rules-of-execution-of-scripts-in-mediajs","title":"Rules of execution of scripts in <code>Media.js</code>","text":"<p>The scripts defined in <code>Media.js</code> still follow the rules outlined above:</p> <ol> <li>JS is executed in the order in which the components are found in the HTML.</li> <li>JS will be executed only once, even if there is multiple instances of the same component.</li> </ol> <p>Additionally to <code>Media.js</code> applies that:</p> <ol> <li>JS in <code>Media.js</code> is executed before the component's primary JS.</li> <li>JS in <code>Media.js</code> is executed in the same order as it was defined.</li> <li>If there is multiple components that specify the same JS path or URL in <code>Media.js</code>,    this JS will be still loaded and executed only once.</li> </ol> <p>Putting all of this together, our <code>Calendar</code> component above would render HTML like so:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n    &lt;!-- CSS from Media.css --&gt;\n    &lt;link href=\"/static/path/to/shared.css\" media=\"all\" rel=\"stylesheet\" /&gt;\n    &lt;link\n      href=\"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\"\n      media=\"all\"\n      rel=\"stylesheet\"\n    /&gt;\n    &lt;!-- CSS from Component.css_file --&gt;\n    &lt;style&gt;\n      .calendar {\n        width: 200px;\n        background: pink;\n      }\n      .calendar span {\n        font-weight: bold;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n    &lt;!-- JS from Media.js --&gt;\n    &lt;script src=\"/static/path/to/shared.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\"&gt;&lt;/script&gt;\n    &lt;!-- JS from Component.js_file --&gt;\n    &lt;script&gt;\n      (function () {\n        document.querySelector(\".calendar\").onclick = () =&gt; {\n          alert(\"Clicked calendar!\");\n        };\n      })();\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now that we have a fully-defined component, next let's use it in a Django template \u27a1\ufe0f.</p>"},{"location":"getting_started/adding_slots/","title":"Adding slots","text":"<p>Our calendar component's looking great! But we just got a new assignment from our colleague - The calendar date needs to be shown on 3 different pages:</p> <ol> <li>On one page, it needs to be shown as is</li> <li>On the second, the date needs to be bold</li> <li>On the third, the date needs to be in italics</li> </ol> <p>As a reminder, this is what the component's template looks like:</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>There's many ways we could approach this:</p> <ul> <li>Expose the date in a slot</li> <li>Style <code>.calendar &gt; span</code> differently on different pages</li> <li>Pass a variable to the component that decides how the date is rendered</li> <li>Create a new component</li> </ul> <p>First two options are more flexible, because the custom styling is not baked into a component's implementation. And for the sake of demonstration, we'll solve this challenge with slots.</p>"},{"location":"getting_started/adding_slots/#1-what-are-slots","title":"1. What are slots","text":"<p>Components support something called Slots.</p> <p>When a component is used inside another template, slots allow the parent template to override specific parts of the child component by passing in different content.</p> <p>This mechanism makes components more reusable and composable.</p> <p>This behavior is similar to slots in Vue.</p> <p>In the example below we introduce two tags that work hand in hand to make this work. These are...</p> <ul> <li><code>{% slot &lt;name&gt; %}</code>/<code>{% endslot %}</code>: Declares a new slot in the component template.</li> <li><code>{% fill &lt;name&gt; %}</code>/<code>{% endfill %}</code>: (Used inside a <code>{% component %}</code>   tag pair.) Fills a declared slot with the specified content.</li> </ul>"},{"location":"getting_started/adding_slots/#2-add-a-slot-tag","title":"2. Add a slot tag","text":"<p>Let's update our calendar component to support more customization. We'll add <code>{% slot %}</code> tag to the template:</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is\n  {% slot \"date\" default %}  {# &lt;--- new #}\n    &lt;span&gt;{{ date }}&lt;/span&gt;\n  {% endslot %}\n&lt;/div&gt;\n</code></pre> <p>Notice that:</p> <ol> <li> <p>We named the slot <code>date</code> - so we can fill this slot by using <code>{% fill \"date\" %}</code></p> </li> <li> <p>We also made it the default slot.</p> </li> <li> <p>We placed our original implementation inside the <code>{% slot %}</code>    tag - this is what will be rendered when the slot is NOT overriden.</p> </li> </ol>"},{"location":"getting_started/adding_slots/#3-add-fill-tag","title":"3. Add fill tag","text":"<p>Now we can use <code>{% fill %}</code> tags inside the <code>{% component %}</code> tags to override the <code>date</code> slot to generate the bold and italics variants:</p> <pre><code>{# Default #}\n{% component \"calendar\" date=\"2024-12-13\" / %}\n\n{# Bold #}\n{% component \"calendar\" date=\"2024-12-13\" %}\n  &lt;b&gt; 2024-12-13 &lt;/b&gt;\n{% endcomponent %}\n\n{# Italics #}\n{% component \"calendar\" date=\"2024-12-13\" %}\n  &lt;i&gt; 2024-12-13 &lt;/i&gt;\n{% endcomponent %}\n</code></pre> <p>Which will render as:</p> <pre><code>&lt;!-- Default --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;2024-12-13&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;!-- Bold --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;b&gt;2024-12-13&lt;/b&gt;\n&lt;/div&gt;\n\n&lt;!-- Italics --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;i&gt;2024-12-13&lt;/i&gt;\n&lt;/div&gt;\n</code></pre> <p>Info</p> <p>Since we used the <code>default</code> flag on <code>{% slot \"date\" %}</code> inside our calendar component, we can target the <code>date</code> component in multiple ways:</p> <ol> <li> <p>Explicitly by it's name     <pre><code>{% component \"calendar\" date=\"2024-12-13\" %}\n  {% fill \"date\" %}\n    &lt;i&gt; 2024-12-13 &lt;/i&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre></p> </li> <li> <p>Implicitly as the default slot (Omitting the     <code>{% fill %}</code> tag)     <pre><code>{% component \"calendar\" date=\"2024-12-13\" %}\n  &lt;i&gt; 2024-12-13 &lt;/i&gt;\n{% endcomponent %}\n</code></pre></p> </li> <li> <p>Explicitly as the default slot (Setting fill name to <code>default</code>)     <pre><code>{% component \"calendar\" date=\"2024-12-13\" %}\n  {% fill \"default\" %}\n    &lt;i&gt; 2024-12-13 &lt;/i&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre></p> </li> </ol>"},{"location":"getting_started/adding_slots/#4-wait-theres-a-bug","title":"4. Wait, there's a bug","text":"<p>There is a mistake in our code! <code>2024-12-13</code> is Friday, so that's fine. But if we updated the to <code>2024-12-14</code>, which is Saturday, our template from previous step would render this:</p> <pre><code>&lt;!-- Default --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;2024-12-16&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;!-- Bold --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;b&gt;2024-12-14&lt;/b&gt;\n&lt;/div&gt;\n\n&lt;!-- Italics --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;i&gt;2024-12-14&lt;/i&gt;\n&lt;/div&gt;\n</code></pre> <p>The first instance rendered <code>2024-12-16</code>, while the rest rendered <code>2024-12-14</code>!</p> <p>Why? Remember that in the <code>get_template_data()</code> method of our Calendar component, we pre-process the date. If the date falls on Saturday or Sunday, we shift it to next Monday:</p> [project root]/components/calendar/calendar.py<pre><code>from datetime import date\n\nfrom django_components import Component, register\n\n# If date is Sat or Sun, shift it to next Mon, so the date is always workweek.\ndef to_workweek_date(d: date):\n    ...\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    ...\n    def get_template_data(self, args, kwargs, slots, context):\n        workweek_date = to_workweek_date(kwargs[\"date\"])\n        return {\n            \"date\": workweek_date,\n            \"extra_class\": kwargs.get(\"extra_class\", \"text-blue\"),\n        }\n</code></pre> <p>And the issue is that in our template, we used the <code>date</code> value that we used as input, which is NOT the same as the <code>date</code> variable used inside Calendar's template.</p>"},{"location":"getting_started/adding_slots/#5-adding-data-to-slots","title":"5. Adding data to slots","text":"<p>We want to use the same <code>date</code> variable that's used inside Calendar's template.</p> <p>Luckily, django-components allows passing data to slots, also known as Scoped slots.</p> <p>This consists of two steps:</p> <ol> <li>Pass the <code>date</code> variable to the <code>{% slot %}</code> tag</li> <li>Access the <code>date</code> variable in the <code>{% fill %}</code>    tag by using the special <code>data</code> kwarg</li> </ol> <p>Let's update the Calendar's template:</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is\n  {% slot \"date\" default date=date %}  {# &lt;--- changed #}\n    &lt;span&gt;{{ date }}&lt;/span&gt;\n  {% endslot %}\n&lt;/div&gt;\n</code></pre> <p>Info</p> <p>The <code>{% slot %}</code> tag has one special kwarg, <code>name</code>. When you write</p> <pre><code>{% slot \"date\" / %}\n</code></pre> <p>It's the same as:</p> <pre><code>{% slot name=\"date\" / %}\n</code></pre> <p>Other than the <code>name</code> kwarg, you can pass any extra kwargs to the <code>{% slot %}</code> tag, and these will be exposed as the slot's data.</p> <pre><code>{% slot name=\"date\" kwarg1=123 kwarg2=\"text\" kwarg3=my_var / %}\n</code></pre>"},{"location":"getting_started/adding_slots/#6-accessing-slot-data-in-fills","title":"6. Accessing slot data in fills","text":"<p>Now, on the <code>{% fill %}</code> tags, we can use the <code>data</code> kwarg to specify the variable under which the slot data will be available.</p> <p>The variable from the <code>data</code> kwarg contains all the extra kwargs passed to the <code>{% slot %}</code> tag.</p> <p>So if we set <code>data=\"slot_data\"</code>, then we can access the date variable under <code>slot_data.date</code>:</p> <pre><code>{# Default #}\n{% component \"calendar\" date=\"2024-12-13\" / %}\n\n{# Bold #}\n{% component \"calendar\" date=\"2024-12-13\" %}\n  {% fill \"date\" data=\"slot_data\" %}\n    &lt;b&gt; {{ slot_data.date }} &lt;/b&gt;\n  {% endfill %}\n{% endcomponent %}\n\n{# Italics #}\n{% component \"calendar\" date=\"2024-12-13\" %}\n  {% fill \"date\" data=\"slot_data\" %}\n    &lt;i&gt; {{ slot_data.date }} &lt;/i&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>By using the <code>date</code> variable from the slot, we'll render the correct date each time:</p> <pre><code>&lt;!-- Default --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;2024-12-16&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;!-- Bold --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;b&gt;2024-12-16&lt;/b&gt;\n&lt;/div&gt;\n\n&lt;!-- Italics --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;i&gt;2024-12-16&lt;/i&gt;\n&lt;/div&gt;\n</code></pre> <p>Info</p> <p>When to use slots vs variables?</p> <p>Generally, slots are more flexible - you can access the slot data, even the original slot content. Thus, slots behave more like functions that render content based on their context.</p> <p>On the other hand, variables are simpler - the variable you pass to a component is what will be used.</p> <p>Moreover, slots are treated as part of the template - for example the CSS scoping (work in progress) is applied to the slot content too.</p> <p>So far we've rendered components using template tag. Next, let\u2019s explore other ways to render components \u27a1\ufe0f</p>"},{"location":"getting_started/components_in_templates/","title":"Components in templates","text":"<p>By the end of this section, we want to be able to use our components in Django templates like so:</p> <pre><code>{% load component_tags %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component \"calendar\" / %}\n  &lt;/body&gt;\n&lt;html&gt;\n</code></pre>"},{"location":"getting_started/components_in_templates/#1-register-component","title":"1. Register component","text":"<p>First, however, we need to register our component class with <code>ComponentRegistry</code>.</p> <p>To register a component with a <code>ComponentRegistry</code>, we will use the <code>@register</code> decorator, and give it a name under which the component will be accessible from within the template:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register  # &lt;--- new\n\n@register(\"calendar\")  # &lt;--- new\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>This will register the component to the default registry. Default registry is loaded into the template by calling <code>{% load component_tags %}</code> inside the template.</p> <p>Info</p> <p>Why do we have to register components?</p> <p>We want to use our component as a template tag (<code>{% ... %}</code>) in Django template.</p> <p>In Django, template tags are managed by the <code>Library</code> instances. Whenever you include <code>{% load xxx %}</code> in your template, you are loading a <code>Library</code> instance into your template.</p> <p><code>ComponentRegistry</code> acts like a router and connects the registered components with the associated <code>Library</code>.</p> <p>That way, when you include <code>{% load component_tags %}</code> in your template, you are able to \"call\" components like <code>{% component \"calendar\" / %}</code>.</p> <p><code>ComponentRegistries</code> also make it possible to group and share components as standalone packages. Learn more here.</p> <p>Note</p> <p>You can create custom <code>ComponentRegistry</code> instances, which will use different <code>Library</code> instances. In that case you will have to load different libraries depending on which components you want to use:</p> <p>Example 1 - Using component defined in the default registry <pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"calendar\" / %}\n&lt;/div&gt;\n</code></pre></p> <p>Example 2 - Using component defined in a custom registry <pre><code>{% load my_custom_tags %}\n&lt;div&gt;\n  {% my_component \"table\" / %}\n&lt;/div&gt;\n</code></pre></p> <p>Note that, because the tag name <code>component</code> is use by the default ComponentRegistry, the custom registry was configured to use the tag <code>my_component</code> instead. Read more here</p>"},{"location":"getting_started/components_in_templates/#2-load-and-use-the-component-in-template","title":"2. Load and use the component in template","text":"<p>The component is now registered under the name <code>calendar</code>. All that remains to do is to load and render the component inside a template:</p> <pre><code>{% load component_tags %}  {# Load the default registry #}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component \"calendar\" / %}  {# Render the component #}\n  &lt;/body&gt;\n&lt;html&gt;\n</code></pre> <p>Info</p> <p>Component tags should end with <code>/</code> if they do not contain any Slot fills. But you can also use <code>{% endcomponent %}</code> instead:</p> <pre><code>{% component \"calendar\" %}{% endcomponent %}\n</code></pre> <p>We defined the Calendar's template as</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>and the variable <code>date</code> as <code>\"1970-01-01\"</code>.</p> <p>Thus, the final output will look something like this:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n    &lt;style&gt;\n      .calendar {\n        width: 200px;\n        background: pink;\n      }\n      .calendar span {\n        font-weight: bold;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"calendar\"&gt;\n      Today's date is &lt;span&gt;1970-01-01&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n      (function () {\n        document.querySelector(\".calendar\").onclick = () =&gt; {\n          alert(\"Clicked calendar!\");\n        };\n      })();\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;html&gt;\n</code></pre> <p>This makes it possible to organize your front-end around reusable components, instead of relying on template tags and keeping your CSS and Javascript in the static directory.</p> <p>Info</p> <p>Remember that you can use <code>{% component_js_dependencies %}</code> and <code>{% component_css_dependencies %}</code> to change where the <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags will be rendered (See Default JS / CSS locations).</p> <p>Info</p> <p>How does django-components pick up registered components?</p> <p>Notice that it was enough to add <code>@register</code> to the component. We didn't need to import the component file anywhere to execute it.</p> <p>This is because django-components automatically imports all Python files found in the component directories during an event called Autodiscovery.</p> <p>So with Autodiscovery, it's the same as if you manually imported the component files on the <code>ready()</code> hook:</p> <pre><code>class MyApp(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"myapp\"\n\n    def ready(self):\n        import myapp.components.calendar\n        import myapp.components.table\n        ...\n</code></pre> <p>You can now render the components in templates!</p> <p>Currently our component always renders the same content. Let's parametrise it, so that our Calendar component is configurable from within the template \u27a1\ufe0f</p>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#basic-installation","title":"Basic installation","text":"<ol> <li> <p>Install <code>django_components</code> into your environment:</p> <pre><code>pip install django_components\n</code></pre> </li> <li> <p>Load <code>django_components</code> into Django by adding it into <code>INSTALLED_APPS</code> in your settings file:</p> <pre><code># app/settings.py\nINSTALLED_APPS = [\n    ...,\n    'django_components',\n]\n</code></pre> </li> <li> <p><code>BASE_DIR</code> setting is required. Ensure that it is defined:</p> <pre><code># app/settings.py\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).resolve().parent.parent\n</code></pre> </li> <li> <p>Next, modify <code>TEMPLATES</code> section of <code>settings.py</code> as follows:</p> <ul> <li>Remove <code>'APP_DIRS': True,</code><ul> <li>NOTE: Instead of <code>APP_DIRS: True</code>, we will use   <code>django.template.loaders.app_directories.Loader</code>,   which has the same effect.</li> </ul> </li> <li>Add <code>loaders</code> to <code>OPTIONS</code> list and set it to following value:</li> </ul> <p>This allows Django to load component HTML files as Django templates.</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            ...,\n            'loaders':[(\n                'django.template.loaders.cached.Loader', [\n                    # Default Django loader\n                    'django.template.loaders.filesystem.Loader',\n                    # Including this is the same as APP_DIRS=True\n                    'django.template.loaders.app_directories.Loader',\n                    # Components loader\n                    'django_components.template_loader.Loader',\n                ]\n            )],\n        },\n    },\n]\n</code></pre> </li> <li> <p>Add django-component's URL paths to your <code>urlpatterns</code>:</p> <p>Django components already prefixes all URLs with <code>components/</code>. So when you are adding the URLs to <code>urlpatterns</code>, you can use an empty string as the first argument:</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    ...\n    path(\"\", include(\"django_components.urls\")),\n]\n</code></pre> </li> </ol>"},{"location":"getting_started/installation/#adding-support-for-js-and-css","title":"Adding support for JS and CSS","text":"<p>If you want to use JS or CSS with components, you will need to:</p> <ol> <li> <p>Add <code>\"django_components.finders.ComponentsFileSystemFinder\"</code> to <code>STATICFILES_FINDERS</code> in your settings file.</p> <p>This allows Django to serve component JS and CSS as static files.</p> <pre><code>STATICFILES_FINDERS = [\n    # Default finders\n    \"django.contrib.staticfiles.finders.FileSystemFinder\",\n    \"django.contrib.staticfiles.finders.AppDirectoriesFinder\",\n    # Django components\n    \"django_components.finders.ComponentsFileSystemFinder\",\n]\n</code></pre> </li> <li> <p>Optional. If you want to change where the JS and CSS is rendered, use     <code>{% component_js_dependencies %}</code>     and <code>{% component_css_dependencies %}</code>.</p> <p>By default, the JS <code>&lt;script&gt;</code> and CSS <code>&lt;link&gt;</code> tags are automatically inserted into the HTML (See Default JS / CSS locations).</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    ...\n    {% component_css_dependencies %}\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n    {% component_js_dependencies %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Optional. By default, components' JS and CSS files are cached in memory.</p> <p>If you want to change the cache backend, set the <code>COMPONENTS.cache</code> setting.</p> <p>Read more in Caching.</p> </li> </ol>"},{"location":"getting_started/installation/#optional","title":"Optional","text":""},{"location":"getting_started/installation/#builtin-template-tags","title":"Builtin template tags","text":"<p>To avoid loading the app in each template using <code>{% load component_tags %}</code>, you can add the tag as a 'builtin' in <code>settings.py</code>:</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            ...,\n            'builtins': [\n                'django_components.templatetags.component_tags',\n            ]\n        },\n    },\n]\n</code></pre>"},{"location":"getting_started/installation/#component-directories","title":"Component directories","text":"<p>django-components needs to know where to search for component HTML, JS and CSS files.</p> <p>There are two ways to configure the component directories:</p> <ul> <li><code>COMPONENTS.dirs</code> sets global component directories.</li> <li><code>COMPONENTS.app_dirs</code> sets app-level component directories.</li> </ul> <p>By default, django-components will look for a top-level <code>/components</code> directory, <code>{BASE_DIR}/components</code>, equivalent to:</p> <pre><code>from django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    dirs=[\n        ...,\n        Path(BASE_DIR) / \"components\",\n    ],\n)\n</code></pre> <p>For app-level directories, the default is <code>[app]/components</code>, equivalent to:</p> <pre><code>from django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    app_dirs=[\n        ...,\n        \"components\",\n    ],\n)\n</code></pre> <p>Note</p> <p>The input to <code>COMPONENTS.dirs</code> is the same as for <code>STATICFILES_DIRS</code>, and the paths must be full paths. See Django docs.</p> <p>Now you're all set! Read on to find out how to build your first component.</p>"},{"location":"getting_started/parametrising_components/","title":"Parametrising components","text":"<p>So far, our Calendar component will always render the date <code>1970-01-01</code>. Let's make it more useful and flexible by being able to pass in custom date.</p> <p>What we want is to be able to use the Calendar component within the template like so:</p> <pre><code>{% component \"calendar\" date=\"2024-12-13\" extra_class=\"text-red\" / %}\n</code></pre>"},{"location":"getting_started/parametrising_components/#1-understading-component-inputs","title":"1. Understading component inputs","text":"<p>In section Create your first component, we defined the <code>get_template_data()</code> method that defines what variables will be available within the template:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    ...\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>What we didn't say is that <code>get_template_data()</code> actually receives the args and kwargs that were passed to a component.</p> <p>So if we call a component with a <code>date</code> and <code>extra_class</code> keywords:</p> <pre><code>{% component \"calendar\" date=\"2024-12-13\" extra_class=\"text-red\" / %}\n</code></pre> <p>This is the same as calling:</p> <pre><code>Calendar.get_template_data(\n    args=[],\n    kwargs={\"date\": \"2024-12-13\", \"extra_class\": \"text-red\"},\n)\n</code></pre> <p>And same applies to positional arguments, or mixing args and kwargs, where:</p> <pre><code>{% component \"calendar\" \"2024-12-13\" extra_class=\"text-red\" / %}\n</code></pre> <p>is same as</p> <pre><code>Calendar.get_template_data(\n    args=[\"2024-12-13\"],\n    kwargs={\"extra_class\": \"text-red\"},\n)\n</code></pre>"},{"location":"getting_started/parametrising_components/#2-define-inputs","title":"2. Define inputs","text":"<p>Let's put this to test. We want to pass <code>date</code> and <code>extra_class</code> kwargs to the component. And so, we can write the <code>get_template_data()</code> method such that it expects those parameters:</p> [project root]/components/calendar/calendar.py<pre><code>from datetime import date\n\nfrom django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    ...\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n            \"extra_class\": kwargs.get(\"extra_class\", \"text-blue\"),\n        }\n</code></pre> <p>Since <code>extra_class</code> is optional in the function signature, it's optional also in the template. So both following calls are valid:</p> <pre><code>{% component \"calendar\" date=\"2024-12-13\" / %}\n{% component \"calendar\" date=\"2024-12-13\" extra_class=\"text-red\" / %}\n</code></pre> <p>Warning</p> <p><code>get_template_data()</code> differentiates between positional and keyword arguments, so you have to make sure to pass the arguments correctly.</p> <p>Since <code>date</code> is expected to be a keyword argument, it MUST be provided as such:</p> <pre><code>\u2705 `date` is kwarg\n{% component \"calendar\" date=\"2024-12-13\" / %}\n\n\u274c `date` is arg\n{% component \"calendar\" \"2024-12-13\" / %}\n</code></pre>"},{"location":"getting_started/parametrising_components/#3-process-inputs","title":"3. Process inputs","text":"<p>The <code>get_template_data()</code> method is powerful, because it allows us to decouple component inputs from the template variables. In other words, we can pre-process the component inputs, and massage them into a shape that's most appropriate for what the template needs. And it also allows us to pass in static data into the template.</p> <p>Imagine our component receives data from the database that looks like below (taken from Django).</p> <pre><code>cities = [\n    {\"name\": \"Mumbai\", \"population\": \"19,000,000\", \"country\": \"India\"},\n    {\"name\": \"Calcutta\", \"population\": \"15,000,000\", \"country\": \"India\"},\n    {\"name\": \"New York\", \"population\": \"20,000,000\", \"country\": \"USA\"},\n    {\"name\": \"Chicago\", \"population\": \"7,000,000\", \"country\": \"USA\"},\n    {\"name\": \"Tokyo\", \"population\": \"33,000,000\", \"country\": \"Japan\"},\n]\n</code></pre> <p>We need to group the list items by size into following buckets by population:</p> <ul> <li>0-10,000,000</li> <li>10,000,001-20,000,000</li> <li>20,000,001-30,000,000</li> <li>+30,000,001</li> </ul> <p>So we want to end up with following data:</p> <pre><code>cities_by_pop = [\n    {\n      \"name\": \"0-10,000,000\",\n      \"items\": [\n          {\"name\": \"Chicago\", \"population\": \"7,000,000\", \"country\": \"USA\"},\n      ]\n    },\n    {\n      \"name\": \"10,000,001-20,000,000\",\n      \"items\": [\n          {\"name\": \"Calcutta\", \"population\": \"15,000,000\", \"country\": \"India\"},\n          {\"name\": \"Mumbai\", \"population\": \"19,000,000\", \"country\": \"India\"},\n          {\"name\": \"New York\", \"population\": \"20,000,000\", \"country\": \"USA\"},\n      ]\n    },\n    {\n      \"name\": \"30,000,001-40,000,000\",\n      \"items\": [\n          {\"name\": \"Tokyo\", \"population\": \"33,000,000\", \"country\": \"Japan\"},\n      ]\n    },\n]\n</code></pre> <p>Without the <code>get_template_data()</code> method, we'd have to either:</p> <ol> <li>Pre-process the data in Python before passing it to the components.</li> <li>Define a Django filter or template tag to take the data and process it on the spot.</li> </ol> <p>Instead, with <code>get_template_data()</code>, we can keep this transformation private to this component, and keep the rest of the codebase clean.</p> <pre><code>def group_by_pop(data):\n    ...\n\n@register(\"population_table\")\nclass PopulationTable(Component):\n    template_file = \"population_table.html\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"data\": group_by_pop(kwargs[\"data\"]),\n        }\n</code></pre> <p>Similarly we can make use of <code>get_template_data()</code> to pre-process the date that was given to the component:</p> [project root]/components/calendar/calendar.py<pre><code>from datetime import date\n\nfrom django_components import Component, register\n\n# If date is Sat or Sun, shift it to next Mon, so the date is always workweek.\ndef to_workweek_date(d: date):\n    ...\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    ...\n    def get_template_data(self, args, kwargs, slots, context):\n        workweek_date = to_workweek_date(kwargs[\"date\"])  # &lt;--- new\n        return {\n            \"date\": workweek_date,  # &lt;--- changed\n            \"extra_class\": kwargs.get(\"extra_class\", \"text-blue\"),\n        }\n</code></pre>"},{"location":"getting_started/parametrising_components/#4-pass-inputs-to-components","title":"4. Pass inputs to components","text":"<p>Once we're happy with <code>Calendar.get_template_data()</code>, we can update our templates to use the parametrized version of the component:</p> <pre><code>&lt;div&gt;\n  {% component \"calendar\" date=\"2024-12-13\" / %}\n  {% component \"calendar\" date=\"1970-01-01\" / %}\n&lt;/div&gt;\n</code></pre>"},{"location":"getting_started/parametrising_components/#5-add-defaults","title":"5. Add defaults","text":"<p>In our example, we've set the <code>extra_class</code> to default to <code>\"text-blue\"</code> by setting it in the <code>get_template_data()</code> method.</p> <p>However, you may want to use the same default value in multiple methods, like <code>get_js_data()</code> or <code>get_css_data()</code>.</p> <p>To make things easier, Components can specify their defaults. Defaults are used when no value is provided, or when the value is set to <code>None</code> for a particular input.</p> <p>To define defaults for a component, you create a nested <code>Defaults</code> class within your <code>Component</code> class. Each attribute in the <code>Defaults</code> class represents a default value for a corresponding input.</p> <pre><code>from django_components import Component, Default, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n\n    class Defaults:  # &lt;--- new\n        extra_class = \"text-blue\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        workweek_date = to_workweek_date(kwargs[\"date\"])\n        return {\n            \"date\": workweek_date,\n            \"extra_class\": kwargs[\"extra_class\"],  # &lt;--- changed\n        }\n</code></pre> <p>Next, you will learn how to use slots give your components even more flexibility \u27a1\ufe0f</p>"},{"location":"getting_started/rendering_components/","title":"Rendering components","text":"<p>Our calendar component can accept and pre-process data, defines its own CSS and JS, and can be used in templates.</p> <p>...But how do we actually render the components into HTML?</p> <p>There's 3 ways to render a component:</p> <ul> <li>Render the template that contains the <code>{% component %}</code> tag</li> <li>Render the component directly with <code>Component.render()</code></li> <li>Render the component directly with <code>Component.render_to_response()</code></li> </ul> <p>As a reminder, this is what the calendar component looks like:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre>"},{"location":"getting_started/rendering_components/#1-render-the-template","title":"1. Render the template","text":"<p>If you have embedded the component in a Django template using the <code>{% component %}</code> tag:</p> [project root]/templates/my_template.html<pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"calendar\" date=\"2024-12-13\" / %}\n&lt;/div&gt;\n</code></pre> <p>You can simply render the template with the Django tooling:</p>"},{"location":"getting_started/rendering_components/#with-djangoshortcutsrender","title":"With <code>django.shortcuts.render()</code>","text":"<pre><code>from django.shortcuts import render\n\ncontext = {\"date\": \"2024-12-13\"}\nrendered_template = render(request, \"my_template.html\", context)\n</code></pre>"},{"location":"getting_started/rendering_components/#with-templaterender","title":"With <code>Template.render()</code>","text":"<p>Either loading the template with <code>get_template()</code>:</p> <pre><code>from django.template.loader import get_template\n\ntemplate = get_template(\"my_template.html\")\ncontext = {\"date\": \"2024-12-13\"}\nrendered_template = template.render(context)\n</code></pre> <p>Or creating a new <code>Template</code> instance:</p> <pre><code>from django.template import Template\n\ntemplate = Template(\"\"\"\n{% load component_tags %}\n&lt;div&gt;\n  {% component \"calendar\" date=\"2024-12-13\" / %}\n&lt;/div&gt;\n\"\"\")\nrendered_template = template.render()\n</code></pre>"},{"location":"getting_started/rendering_components/#2-render-the-component","title":"2. Render the component","text":"<p>You can also render the component directly with <code>Component.render()</code>, without wrapping the component in a template.</p> <pre><code>from components.calendar import Calendar\n\ncalendar = Calendar\nrendered_component = calendar.render()\n</code></pre> <p>You can pass args, kwargs, slots, and more, to the component:</p> <pre><code>from components.calendar import Calendar\n\ncalendar = Calendar\nrendered_component = calendar.render(\n    args=[\"2024-12-13\"],\n    kwargs={\n        \"extra_class\": \"my-class\"\n    },\n    slots={\n        \"date\": \"&lt;b&gt;2024-12-13&lt;/b&gt;\"\n    },\n)\n</code></pre> <p>Info</p> <p>Among other, you can pass also the <code>request</code> object to the <code>render</code> method:</p> <pre><code>from components.calendar import Calendar\n\ncalendar = Calendar\nrendered_component = calendar.render(request=request)\n</code></pre> <p>The <code>request</code> object is required for some of the component's features, like using Django's context processors.</p>"},{"location":"getting_started/rendering_components/#3-render-the-component-to-httpresponse","title":"3. Render the component to HttpResponse","text":"<p>A common pattern in Django is to render the component and then return the resulting HTML as a response to an HTTP request.</p> <p>For this, you can use the <code>Component.render_to_response()</code> convenience method.</p> <p><code>render_to_response()</code> accepts the same args, kwargs, slots, and more, as <code>Component.render()</code>, but wraps the result in an <code>HttpResponse</code>.</p> <pre><code>from components.calendar import Calendar\n\ndef my_view(request):\n    response = Calendar.render_to_response(\n        args=[\"2024-12-13\"],\n        kwargs={\n            \"extra_class\": \"my-class\"\n        },\n        slots={\n            \"date\": \"&lt;b&gt;2024-12-13&lt;/b&gt;\"\n        },\n        request=request,\n    )\n    return response\n</code></pre> <p>Info</p> <p>Response class of <code>render_to_response</code></p> <p>While <code>render</code> method returns a plain string, <code>render_to_response</code> wraps the rendered content in a \"Response\" class. By default, this is <code>django.http.HttpResponse</code>.</p> <p>If you want to use a different Response class in <code>render_to_response</code>, set the <code>Component.response_class</code> attribute:</p> <pre><code>class MyCustomResponse(HttpResponse):\n    def __init__(self, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        # Configure response\n        self.headers = ...\n        self.status = ...\n\nclass SimpleComponent(Component):\n    response_class = MyCustomResponse\n</code></pre>"},{"location":"getting_started/rendering_components/#4-rendering-slots","title":"4. Rendering slots","text":"<p>Slots content are automatically escaped by default to prevent XSS attacks.</p> <p>In other words, it's as if you would be using Django's <code>escape()</code> on the slot contents / result:</p> <pre><code>from django.utils.html import escape\n\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {% slot \"date\" default date=date / %}\n        &lt;/div&gt;\n    \"\"\"\n\nCalendar.render(\n    slots={\n        \"date\": escape(\"&lt;b&gt;Hello&lt;/b&gt;\"),\n    }\n)\n</code></pre> <p>To disable escaping, you can wrap the slot string or slot result in Django's <code>mark_safe()</code>:</p> <pre><code>Calendar.render(\n    slots={\n        # string\n        \"date\": mark_safe(\"&lt;b&gt;Hello&lt;/b&gt;\"),\n\n        # function\n        \"date\": lambda ctx: mark_safe(\"&lt;b&gt;Hello&lt;/b&gt;\"),\n    }\n)\n</code></pre> <p>Info</p> <p>Read more about Django's <code>format_html</code> and <code>mark_safe</code>.</p>"},{"location":"getting_started/rendering_components/#5-component-views-and-urls","title":"5. Component views and URLs","text":"<p>For web applications, it's common to define endpoints that serve HTML content (AKA views).</p> <p>If this is your case, you can define the view request handlers directly on your component by using the nested<code>Component.View</code> class.</p> <p>This is a great place for:</p> <ul> <li> <p>Endpoints that render whole pages, if your component   is a page component.</p> </li> <li> <p>Endpoints that render the component as HTML fragments, to be used with HTMX or similar libraries.</p> </li> </ul> <p>Read more on Component views and URLs.</p> [project root]/components/calendar.py<pre><code>from django_components import Component, ComponentView, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            &lt;div class=\"header\"&gt;\n                {% slot \"header\" / %}\n            &lt;/div&gt;\n            &lt;div class=\"body\"&gt;\n                Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    class View:\n        # Handle GET requests\n        def get(self, request, *args, **kwargs):\n            # Return HttpResponse with the rendered content\n            return Calendar.render_to_response(\n                request=request,\n                kwargs={\n                    \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n                },\n                slots={\n                    \"header\": \"Calendar header\",\n                },\n            )\n</code></pre> <p>Info</p> <p>The View class supports all the same HTTP methods as Django's <code>View</code> class. These are:</p> <p><code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code>, <code>head()</code>, <code>options()</code>, <code>trace()</code></p> <p>Each of these receive the <code>HttpRequest</code> object as the first argument.</p> <p>Next, you need to set the URL for the component.</p> <p>You can either:</p> <ol> <li> <p>Automatically assign the URL by setting the <code>Component.View.public</code> attribute to <code>True</code>.</p> <p>In this case, use <code>get_component_url()</code> to get the URL for the component view.</p> <pre><code>from django_components import Component, get_component_url\n\nclass Calendar(Component):\n    class View:\n        public = True\n\nurl = get_component_url(Calendar)\n</code></pre> </li> <li> <p>Manually assign the URL by setting <code>Component.as_view()</code> to your <code>urlpatterns</code>:</p> <pre><code>from django.urls import path\nfrom components.calendar import Calendar\n\nurlpatterns = [\n    path(\"calendar/\", Calendar.as_view()),\n]\n</code></pre> </li> </ol> <p>And with that, you're all set! When you visit the URL, the component will be rendered and the content will be returned.</p> <p>The <code>get()</code>, <code>post()</code>, etc methods will receive the <code>HttpRequest</code> object as the first argument. So you can parametrize how the component is rendered for example by passing extra query parameters to the URL:</p> <pre><code>http://localhost:8000/calendar/?date=2024-12-13\n</code></pre>"},{"location":"getting_started/your_first_component/","title":"Create your first component","text":"<p>A component in django-components can be as simple as a Django template and Python code to declare the component:</p> calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n</code></pre> <p>Or a combination of Django template, Python, CSS, and Javascript:</p> calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> calendar.css<pre><code>.calendar {\n  width: 200px;\n  background: pink;\n}\n</code></pre> calendar.js<pre><code>document.querySelector(\".calendar\").onclick = function () {\n  alert(\"Clicked calendar!\");\n};\n</code></pre> calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n</code></pre> <p>Alternatively, you can \"inline\" HTML, JS, and CSS right into the component class:</p> <pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template = \"\"\"\n      &lt;div class=\"calendar\"&gt;\n        Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n      &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n      .calendar {\n        width: 200px;\n        background: pink;\n      }\n    \"\"\"\n\n    js = \"\"\"\n      document.querySelector(\".calendar\").onclick = function () {\n        alert(\"Clicked calendar!\");\n      };\n    \"\"\"\n</code></pre> <p>Note</p> <p>If you \"inline\" the HTML, JS and CSS code into the Python class, you can set up syntax highlighting for better experience. However, autocompletion / intellisense does not work with syntax highlighting.</p> <p>We'll start by creating a component that defines only a Django template:</p>"},{"location":"getting_started/your_first_component/#1-create-project-structure","title":"1. Create project structure","text":"<p>Start by creating empty <code>calendar.py</code> and <code>calendar.html</code> files:</p> <pre><code>sampleproject/\n\u251c\u2500\u2500 calendarapp/\n\u251c\u2500\u2500 components/             \ud83c\udd95\n\u2502   \u2514\u2500\u2500 calendar/           \ud83c\udd95\n\u2502       \u251c\u2500\u2500 calendar.py     \ud83c\udd95\n\u2502       \u2514\u2500\u2500 calendar.html   \ud83c\udd95\n\u251c\u2500\u2500 sampleproject/\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting_started/your_first_component/#2-write-django-template","title":"2. Write Django template","text":"<p>Inside <code>calendar.html</code>, write:</p> [project root]/components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>In this example we've defined one template variable <code>date</code>. You can use any and as many variables as you like. These variables will be defined in the Python file in <code>get_template_data()</code> when creating an instance of this component.</p> <p>Note</p> <p>The template will be rendered with whatever template backend you've specified in your Django settings file.</p> <p>Currently django-components supports only the default <code>\"django.template.backends.django.DjangoTemplates\"</code> template backend!</p>"},{"location":"getting_started/your_first_component/#3-create-new-component-in-python","title":"3. Create new Component in Python","text":"<p>In <code>calendar.py</code>, create a subclass of Component to create a new component.</p> <p>To link the HTML template with our component, set <code>template_file</code> to the name of the HTML file.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n</code></pre> <p>Note</p> <p>The path to the template file can be either:</p> <ol> <li>Relative to the component's python file (as seen above),</li> <li>Relative to any of the component directories as defined by <code>COMPONENTS.dirs</code> and/or <code>COMPONENTS.app_dirs</code> (e.g. <code>[your apps]/components</code> dir and <code>[project root]/components</code>)</li> </ol>"},{"location":"getting_started/your_first_component/#4-define-the-template-variables","title":"4. Define the template variables","text":"<p>In <code>calendar.html</code>, we've used the variable <code>date</code>. So we need to define it for the template to work.</p> <p>This is done using <code>Component.get_template_data()</code>. It's a function that returns a dictionary. The entries in this dictionary will become available within the template as variables, e.g. as <code>{{ date }}</code>.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>Now, when we render the component with <code>Component.render()</code> method:</p> <pre><code>Calendar.render()\n</code></pre> <p>It will output</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;1970-01-01&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>And voil\u00e1!! We've created our first component.</p> <p>Next, let's add JS and CSS to this component \u27a1\ufe0f.</p>"},{"location":"guides/other/troubleshooting/","title":"Troubleshooting","text":"<p>As larger projects get more complex, it can be hard to debug issues. Django Components provides a number of tools and approaches that can help you with that.</p>"},{"location":"guides/other/troubleshooting/#component-and-slot-highlighting","title":"Component and slot highlighting","text":"<p>Django Components provides a visual debugging feature that helps you understand the structure and boundaries of your components and slots. When enabled, it adds a colored border and a label around each component and slot on your rendered page.</p> <p>To enable component and slot highlighting for all components and slots, set <code>highlight_components</code> and <code>highlight_slots</code> to <code>True</code> in extensions defaults in your <code>settings.py</code> file:</p> <pre><code>from django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    extensions_defaults={\n        \"debug_highlight\": {\n            \"highlight_slots\": True,\n            \"highlight_components\": True,\n        },\n    },\n)\n</code></pre> <p>Alternatively, you can enable highlighting for specific components by setting <code>Component.DebugHighlight.highlight_components</code> to <code>True</code>:</p> <pre><code>class MyComponent(Component):\n    class DebugHighlight:\n        highlight_components = True\n        highlight_slots = True\n</code></pre> <p>Components will be highlighted with a blue border and label:</p> <p></p> <p>While the slots will be highlighted with a red border and label:</p> <p></p> <p>Warning</p> <p>Use this feature ONLY in during development. Do NOT use it in production.</p>"},{"location":"guides/other/troubleshooting/#component-path-in-errors","title":"Component path in errors","text":"<p>When an error occurs, the error message will show the path to the component that caused the error. E.g.</p> <pre><code>KeyError: \"An error occured while rendering components MyPage &gt; MyLayout &gt; MyComponent &gt; Childomponent(slot:content)\n</code></pre> <p>The error message contains also the slot paths, so if you have a template like this:</p> <pre><code>{% component \"my_page\" %}\n    {% slot \"content\" %}\n        {% component \"table\" %}\n            {% slot \"header\" %}\n                {% component \"table_header\" %}\n                    ...  {# ERROR HERE #}\n                {% endcomponent %}\n            {% endslot %}\n        {% endcomponent %}\n    {% endslot %}\n{% endcomponent %}\n</code></pre> <p>Then the error message will show the path to the component that caused the error:</p> <pre><code>KeyError: \"An error occured while rendering components my_page &gt; layout &gt; layout(slot:content) &gt; my_page(slot:content) &gt; table &gt; table(slot:header) &gt; table_header &gt; table_header(slot:content)\n</code></pre>"},{"location":"guides/other/troubleshooting/#debug-and-trace-logging","title":"Debug and trace logging","text":"<p>Django components supports logging with Django.</p> <p>To configure logging for Django components, set the <code>django_components</code> logger in <code>LOGGING</code> in <code>settings.py</code> (below).</p> <p>Also see the <code>settings.py</code> file in sampleproject for a real-life example.</p> <pre><code>import logging\nimport sys\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    \"handlers\": {\n        \"console\": {\n            'class': 'logging.StreamHandler',\n            'stream': sys.stdout,\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": logging.DEBUG,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre> <p>Info</p> <p>To set TRACE level, set <code>\"level\"</code> to <code>5</code>:</p> <pre><code>LOGGING = {\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": 5,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre>"},{"location":"guides/other/troubleshooting/#logger-levels","title":"Logger levels","text":"<p>As of v0.126, django-components primarily uses these logger levels:</p> <ul> <li><code>DEBUG</code>: Report on loading associated HTML / JS / CSS files, autodiscovery, etc.</li> <li><code>TRACE</code>: Detailed interaction of components and slots. Logs when template tags,   components, and slots are started / ended rendering, and when a slot is filled.</li> </ul>"},{"location":"guides/other/troubleshooting/#slot-origin","title":"Slot origin","text":"<p>When you pass a slot fill to a Component, the component and slot names is remebered on the slot object.</p> <p>Thus, you can check where a slot was filled from by printing it out:</p> <pre><code>class MyComponent(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]):\n        print(self.slots)\n</code></pre> <p>might print:</p> <pre><code>{\n    'content': &lt;Slot component_name='layout' slot_name='content'&gt;,\n    'header': &lt;Slot component_name='my_page' slot_name='header'&gt;,\n    'left_panel': &lt;Slot component_name='layout' slot_name='left_panel'&gt;,\n}\n</code></pre>"},{"location":"guides/other/troubleshooting/#agentic-debugging","title":"Agentic debugging","text":"<p>All the features above make django-components to work really well with coding AI agents like Github Copilot or CursorAI.</p> <p>To debug component rendering with LLMs, you want to provide the LLM with:</p> <ol> <li>The components source code</li> <li>The rendered output</li> <li>As much additional context as possible</li> </ol> <p>Your codebase already contains the components source code, but not the latter two.</p>"},{"location":"guides/other/troubleshooting/#providing-rendered-output","title":"Providing rendered output","text":"<p>To provide the LLM with the rendered output, you can simply export the rendered output to a file.</p> <pre><code>rendered = ProjectPage.render(...)\nwith open(\"result.html\", \"w\") as f:\n    f.write(rendered)\n</code></pre> <p>If you're using <code>render_to_response</code>, access the output from the <code>HttpResponse</code> object:</p> <pre><code>response = ProjectPage.render_to_response(...)\nwith open(\"result.html\", \"wb\") as f:\n    f.write(response.content)\n</code></pre>"},{"location":"guides/other/troubleshooting/#providing-contextual-logs","title":"Providing contextual logs","text":"<p>Next, we provide the agent with info on HOW we got the result that we have. We do so by providing the agent with the trace-level logs.</p> <p>In your <code>settings.py</code>, configure the trace-level logs to be written to the <code>django_components.log</code> file:</p> <pre><code>LOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"handlers\": {\n        \"file\": {\n            \"class\": \"logging.FileHandler\",\n            \"filename\": \"django_components.log\",\n            \"mode\": \"w\",  # Overwrite the file each time\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": 5,\n            \"handlers\": [\"file\"],\n        },\n    },\n}\n</code></pre>"},{"location":"guides/other/troubleshooting/#prompting-the-agent","title":"Prompting the agent","text":"<p>Now, you can prompt the agent and include the trace log and the rendered output to guide the agent with debugging.</p> <p>I have a django-components (DJC) project. DJC is like if Vue or React component-based web development but made for Django ecosystem.</p> <p>In the view <code>project_view</code>, I am rendering the <code>ProjectPage</code> component. However, the output is not as expected. The output is missing the tabs.</p> <p>You have access to the full log trace in <code>django_components.log</code>.</p> <p>You can also see the rendered output in <code>result.html</code>.</p> <p>With this information, help me debug the issue.</p> <p>First, tell me what kind of info you would be looking for in the logs, and why (how it relates to understanding the cause of the bug).</p> <p>Then tell me if that info was there, and what the implications are.</p> <p>Finally, tell me what you would do to fix the issue.</p>"},{"location":"guides/setup/caching/","title":"Caching","text":"<p>This page describes the kinds of assets that django-components caches and how to configure the cache backends.</p>"},{"location":"guides/setup/caching/#component-caching","title":"Component caching","text":"<p>You can cache the output of your components by setting the <code>Component.Cache</code> options.</p> <p>Read more about Component caching.</p>"},{"location":"guides/setup/caching/#components-js-and-css-files","title":"Component's JS and CSS files","text":"<p>django-components simultaneously supports:</p> <ul> <li>Rendering and fetching components as HTML fragments</li> <li>Allowing components (even fragments) to have JS and CSS files associated with them</li> <li>Features like JS/CSS variables or CSS scoping</li> </ul> <p>To achieve all this, django-components defines additional temporary JS and CSS files. These temporary files need to be stored somewhere, so that they can be fetched by the browser when the component is rendered as a fragment. And for that, django-components uses Django's cache framework.</p> <p>This includes:</p> <ul> <li>Inlined JS/CSS defined via <code>Component.js</code> and <code>Component.css</code></li> <li>JS/CSS variables generated from <code>get_js_data()</code> and <code>get_css_data()</code></li> </ul> <p>By default, django-components uses Django's local memory cache backend to store these assets. You can configure it to use any of your Django cache backends by setting the <code>COMPONENTS.cache</code> option in your settings:</p> <pre><code>COMPONENTS = {\n    # Name of the cache backend to use\n    \"cache\": \"my-cache-backend\",\n}\n</code></pre> <p>The value should be the name of one of your configured cache backends from Django's <code>CACHES</code> setting.</p> <p>For example, to use Redis for caching component assets:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django.core.cache.backends.locmem.LocMemCache\",\n    },\n    \"component-media\": {\n        \"BACKEND\": \"django.core.cache.backends.redis.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/1\",\n    }\n}\n\nCOMPONENTS = {\n    # Use the Redis cache backend\n    \"cache\": \"component-media\",\n}\n</code></pre> <p>See <code>COMPONENTS.cache</code> for more details about this setting.</p>"},{"location":"guides/setup/development_server/","title":"Development server","text":""},{"location":"guides/setup/development_server/#reload-dev-server-on-component-file-changes","title":"Reload dev server on component file changes","text":"<p>This is relevant if you are using the project structure as shown in our examples, where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <pre><code>sampleproject/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 calendar/\n\u2502       \u251c\u2500\u2500 calendar.py\n\u2502       \u2514\u2500\u2500 calendar.html\n\u2502       \u2514\u2500\u2500 calendar.css\n\u2502       \u2514\u2500\u2500 calendar.js\n\u251c\u2500\u2500 sampleproject/\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>From relevant StackOverflow thread:</p> <p>TL;DR is that the server won't reload if it thinks the changed file is in a templates directory, or in a nested sub directory of a templates directory. This is by design.</p> <p>To make the dev server reload on all component files, set <code>reload_on_file_change</code> to <code>True</code>. This configures Django to watch for component files too.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"overview/compatibility/","title":"Compatibility","text":"<p>Django-components supports all supported combinations versions of Django and Python.</p> Python version Django version 3.8 4.2 3.9 4.2 3.10 4.2, 5.1, 5.2 3.11 4.2, 5.1, 5.2 3.12 4.2, 5.1, 5.2 3.13 5.1, 5.2"},{"location":"overview/compatibility/#operating-systems","title":"Operating systems","text":"<p>django-components is tested against Ubuntu and Windows, and should work on any operating system that supports Python.</p> <p>Note</p> <p>django-components uses Rust-based parsers for better performance.</p> <p>These sub-packages are built with maturin which supports a wide range of operating systems, architectures, and Python versions (see the full list).</p> <p>This should cover most of the cases.</p> <p>However, if your environment is not supported, you will need to install Rust and Cargo to build the sub-packages from source.</p>"},{"location":"overview/license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2019 Emil Stenstr\u00f6m</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"overview/performance/","title":"Performance","text":"<p>We track the performance of <code>django-components</code> using ASV.</p> <p>See the benchmarks dashboard.</p> <p>Our aim is to be at least as fast as Django templates.</p> <p>As of <code>0.130</code>, <code>django-components</code> is ~4x slower than Django templates.</p> Render time django 68.9\u00b10.6ms django-components 259\u00b14ms <p>See the full performance breakdown for more information.</p>"},{"location":"overview/security_notes/","title":"Security notes \ud83d\udea8","text":"<p>It is strongly recommended to read this section before using django-components in production.</p>"},{"location":"overview/security_notes/#static-files","title":"Static files","text":"<p>TL;DR: No action needed from v0.100 onwards. Before v0.100, use <code>safer_staticfiles</code> to avoid exposing backend logic.</p> <p>Components can be organized however you prefer. That said, our prefered way is to keep the files of a component close together by bundling them in the same directory.</p> <p>This means that files containing backend logic, such as Python modules and HTML templates, live in the same directory as static files, e.g. JS and CSS.</p> <p>From v0.100 onwards, we keep component files (as defined by <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code>) separate from the rest of the static files (defined by <code>STATICFILES_DIRS</code>). That way, the Python and HTML files are NOT exposed by the server. Only the static JS, CSS, and other common formats.</p> <p>Note</p> <p>If you need to expose different file formats, you can configure these with <code>COMPONENTS.static_files_allowed</code> and <code>COMPONENTS.static_files_forbidden</code>.</p>"},{"location":"overview/security_notes/#static-files-prior-to-v0100","title":"Static files prior to v0.100","text":"<p>Prior to v0.100, if your were using django.contrib.staticfiles to collect static files, no distinction was made between the different kinds of files.</p> <p>As a result, your Python code and templates may inadvertently become available on your static file server. You probably don't want this, as parts of your backend logic will be exposed, posing a potential security vulnerability.</p> <p>From v0.27 until v0.100, django-components shipped with an additional installable app django_components.safer_staticfiles. It was a drop-in replacement for django.contrib.staticfiles. Its behavior is 100% identical except it ignores <code>.py</code> and <code>.html</code> files, meaning these will not end up on your static files server.</p> <p>To use it, add it to <code>INSTALLED_APPS</code> and remove django.contrib.staticfiles.</p> <pre><code>INSTALLED_APPS = [\n    # 'django.contrib.staticfiles',   # &lt;-- REMOVE\n    'django_components',\n    'django_components.safer_staticfiles'  # &lt;-- ADD\n]\n</code></pre> <p>If you are on an pre-v0.27 version of django-components, your alternatives are:</p> <ul> <li>a) passing <code>--ignore &lt;pattern&gt;</code> options to the collecstatic CLI command,</li> <li>b) defining a subclass of StaticFilesConfig.</li> </ul> <p>Both routes are described in the official docs of the staticfiles app.</p> <p>Note that <code>safer_staticfiles</code> excludes the <code>.py</code> and <code>.html</code> files for collectstatic command:</p> <pre><code>python manage.py collectstatic\n</code></pre> <p>but it is ignored on the development server:</p> <pre><code>python manage.py runserver\n</code></pre> <p>For a step-by-step guide on deploying production server with static files, see the demo project.</p> <p>See the older versions of the sampleproject for a setup with pre-v0.100 version.</p>"},{"location":"overview/welcome/","title":"Welcome to Django Components","text":"<p><code>django-components</code> combines Django's templating system with the modularity seen in modern frontend frameworks like Vue or React.</p> <p>With <code>django-components</code> you can support Django projects small and large without leaving the Django ecosystem.</p>"},{"location":"overview/welcome/#sponsors","title":"Sponsors","text":""},{"location":"overview/welcome/#quickstart","title":"Quickstart","text":"<p>A component in django-components can be as simple as a Django template and Python code to declare the component:</p> components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n</code></pre> <p>Or a combination of Django template, Python, CSS, and Javascript:</p> components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> components/calendar/calendar.css<pre><code>.calendar {\n  width: 200px;\n  background: pink;\n}\n</code></pre> components/calendar/calendar.js<pre><code>document.querySelector(\".calendar\").onclick = () =&gt; {\n  alert(\"Clicked calendar!\");\n};\n</code></pre> components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"date\": kwargs[\"date\"]}\n</code></pre> <p>Use the component like this:</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}{% endcomponent %}\n</code></pre> <p>And this is what gets rendered:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n  Today's date is &lt;span&gt;2024-11-06&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>Read on to learn about all the exciting details and configuration possibilities!</p> <p>(If you instead prefer to jump right into the code, check out the example project)</p>"},{"location":"overview/welcome/#features","title":"Features","text":""},{"location":"overview/welcome/#modern-and-modular-ui","title":"Modern and modular UI","text":"<ul> <li>Create self-contained, reusable UI elements.</li> <li>Each component can include its own HTML, CSS, and JS, or additional third-party JS and CSS.</li> <li>HTML, CSS, and JS can be defined on the component class, or loaded from files.</li> </ul> <pre><code>from django_components import Component\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar\"&gt;\n            Today's date is\n            &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n        .calendar {\n            width: 200px;\n            background: pink;\n        }\n    \"\"\"\n\n    js = \"\"\"\n        document.querySelector(\".calendar\")\n            .addEventListener(\"click\", () =&gt; {\n                alert(\"Clicked calendar!\");\n            });\n    \"\"\"\n\n    # Additional JS and CSS\n    class Media:\n        js = [\"https://cdn.jsdelivr.net/npm/htmx.org@2/dist/htmx.min.js\"]\n        css = [\"bootstrap/dist/css/bootstrap.min.css\"]\n\n    # Variables available in the template\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"]\n        }\n</code></pre>"},{"location":"overview/welcome/#composition-with-slots","title":"Composition with slots","text":"<ul> <li>Render components inside templates with   <code>{% component %}</code> tag.</li> <li>Compose them with <code>{% slot %}</code>   and <code>{% fill %}</code> tags.</li> <li>Vue-like slot system, including scoped slots.</li> </ul> <pre><code>{% component \"Layout\"\n    bookmarks=bookmarks\n    breadcrumbs=breadcrumbs\n%}\n    {% fill \"header\" %}\n        &lt;div class=\"flex justify-between gap-x-12\"&gt;\n            &lt;div class=\"prose\"&gt;\n                &lt;h3&gt;{{ project.name }}&lt;/h3&gt;\n            &lt;/div&gt;\n            &lt;div class=\"font-semibold text-gray-500\"&gt;\n                {{ project.start_date }} - {{ project.end_date }}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    {% endfill %}\n\n    {# Access data passed to `{% slot %}` with `data` #}\n    {% fill \"tabs\" data=\"tabs_data\" %}\n        {% component \"TabItem\" header=\"Project Info\" %}\n            {% component \"ProjectInfo\"\n                project=project\n                project_tags=project_tags\n                attrs:class=\"py-5\"\n                attrs:width=tabs_data.width\n            / %}\n        {% endcomponent %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"overview/welcome/#extended-template-tags","title":"Extended template tags","text":"<p><code>django-components</code> is designed for flexibility, making working with templates a breeze.</p> <p>It extends Django's template tags syntax with:</p> <ul> <li>Literal lists and dictionaries in the template</li> <li>Self-closing tags <code>{% mytag / %}</code></li> <li>Multi-line template tags</li> <li>Spread operator <code>...</code> to dynamically pass args or kwargs into the template tag</li> <li>Template tags inside literal strings like <code>\"{{ first_name }} {{ last_name }}\"</code></li> <li>Pass dictonaries by their key-value pairs <code>attr:key=val</code></li> </ul> <pre><code>{% component \"table\"\n    ...default_attrs\n    title=\"Friend list for {{ user.name }}\"\n    headers=[\"Name\", \"Age\", \"Email\"]\n    data=[\n        {\n            \"name\": \"John\"|upper,\n            \"age\": 30|add:1,\n            \"email\": \"john@example.com\",\n            \"hobbies\": [\"reading\"],\n        },\n        {\n            \"name\": \"Jane\"|upper,\n            \"age\": 25|add:1,\n            \"email\": \"jane@example.com\",\n            \"hobbies\": [\"reading\", \"coding\"],\n        },\n    ],\n    attrs:class=\"py-4 ma-2 border-2 border-gray-300 rounded-md\"\n/ %}\n</code></pre> <p>You too can define template tags with these features by using <code>@template_tag()</code> or <code>BaseNode</code>.</p> <p>Read more on Custom template tags.</p>"},{"location":"overview/welcome/#full-programmatic-access","title":"Full programmatic access","text":"<p>When you render a component, you can access everything about the component:</p> <ul> <li>Component input: args, kwargs, slots and context</li> <li>Component's template, CSS and JS</li> <li>Django's context processors</li> <li>Unique render ID</li> </ul> <pre><code>class Table(Component):\n    js_file = \"table.js\"\n    css_file = \"table.css\"\n\n    template = \"\"\"\n        &lt;div class=\"table\"&gt;\n            &lt;span&gt;{{ variable }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's ID\n        assert self.id == \"djc1A2b3c\"\n\n        # Access component's inputs and slots\n        assert self.args == [123, \"str\"]\n        assert self.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.slots[\"footer\"]\n        some_var = self.context[\"some_var\"]\n\n        # Access the request object and Django's context processors, if available\n        assert self.request.GET == {\"query\": \"something\"}\n        assert self.context_processors_data['user'].username == \"admin\"\n\n        return {\n            \"variable\": kwargs[\"variable\"],\n        }\n\n# Access component's HTML / JS / CSS\nTable.template\nTable.js\nTable.css\n\n# Render the component\nrendered = Table.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"footer\": \"MY_FOOTER\"},\n)\n</code></pre>"},{"location":"overview/welcome/#granular-html-attributes","title":"Granular HTML attributes","text":"<p>Use the <code>{% html_attrs %}</code> template tag to render HTML attributes.</p> <p>It supports:</p> <ul> <li>Defining attributes as whole dictionaries or keyword arguments</li> <li>Merging attributes from multiple sources</li> <li>Boolean attributes</li> <li>Appending attributes</li> <li>Removing attributes</li> <li>Defining default attributes</li> </ul> <pre><code>&lt;div\n    {% html_attrs\n        attrs\n        defaults:class=\"default-class\"\n        class=\"extra-class\"\n    %}\n&gt;\n</code></pre> <p><code>{% html_attrs %}</code> offers a Vue-like granular control for <code>class</code> and <code>style</code> HTML attributes, where you can use a dictionary to manage each class name or style property separately.</p> <pre><code>{% html_attrs\n    class=\"foo bar\"\n    class={\n        \"baz\": True,\n        \"foo\": False,\n    }\n    class=\"extra\"\n%}\n</code></pre> <pre><code>{% html_attrs\n    style=\"text-align: center; background-color: blue;\"\n    style={\n        \"background-color\": \"green\",\n        \"color\": None,\n        \"width\": False,\n    }\n    style=\"position: absolute; height: 12px;\"\n%}\n</code></pre> <p>Read more about HTML attributes.</p>"},{"location":"overview/welcome/#html-fragment-support","title":"HTML fragment support","text":"<p><code>django-components</code> makes integration with HTMX, AlpineJS or jQuery easy by allowing components to be rendered as HTML fragments:</p> <ul> <li> <p>Components's JS and CSS files are loaded automatically when the fragment is inserted into the DOM.</p> </li> <li> <p>Components can be exposed as Django Views with <code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code> methods</p> </li> <li> <p>Automatically create an endpoint for a component with <code>Component.View.public</code></p> </li> </ul> <pre><code># components/calendar/calendar.py\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n\n    class View:\n        # Register Component with `urlpatterns`\n        public = True\n\n        # Define handlers\n        def get(self, request, *args, **kwargs):\n            page = request.GET.get(\"page\", 1)\n            return self.component.render_to_response(\n                request=request,\n                kwargs={\n                    \"page\": page,\n                },\n            )\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"page\": kwargs[\"page\"],\n        }\n\n# Get auto-generated URL for the component\nurl = get_component_url(Calendar)\n\n# Or define explicit URL in urls.py\npath(\"calendar/\", Calendar.as_view())\n</code></pre>"},{"location":"overview/welcome/#provide-inject","title":"Provide / Inject","text":"<p><code>django-components</code> supports the provide / inject pattern, similarly to React's Context Providers or Vue's provide / inject:</p> <ul> <li>Use the <code>{% provide %}</code> tag to provide data to the component tree</li> <li>Use the <code>Component.inject()</code> method to inject data into the component</li> </ul> <p>Read more about Provide / Inject.</p> <pre><code>&lt;body&gt;\n    {% provide \"theme\" variant=\"light\" %}\n        {% component \"header\" / %}\n    {% endprovide %}\n&lt;/body&gt;\n</code></pre> <pre><code>@register(\"header\")\nclass Header(Component):\n    template = \"...\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        theme = self.inject(\"theme\").variant\n        return {\n            \"theme\": theme,\n        }\n</code></pre>"},{"location":"overview/welcome/#input-validation-and-static-type-hints","title":"Input validation and static type hints","text":"<p>Avoid needless errors with type hints and runtime input validation.</p> <p>To opt-in to input validation, define types for component's args, kwargs, slots:</p> <pre><code>from typing import NamedTuple, Optional\nfrom django.template import Context\nfrom django_components import Component, Slot, SlotInput\n\nclass Button(Component):\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        variable: str\n        another: int\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        another_slot: SlotInput\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        args.size  # int\n        kwargs.variable  # str\n        slots.my_slot  # Slot[MySlotData]\n</code></pre> <p>To have type hints when calling <code>Button.render()</code> or <code>Button.render_to_response()</code>, wrap the inputs in their respective <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes:</p> <pre><code>Button.render(\n    # Error: First arg must be `int`, got `float`\n    args=Button.Args(\n        size=1.25,\n        text=\"abc\",\n    ),\n    # Error: Key \"another\" is missing\n    kwargs=Button.Kwargs(\n        variable=\"text\",\n    ),\n)\n</code></pre>"},{"location":"overview/welcome/#extensions","title":"Extensions","text":"<p>Django-components functionality can be extended with Extensions. Extensions allow for powerful customization and integrations. They can:</p> <ul> <li>Tap into lifecycle events, such as when a component is created, deleted, or registered</li> <li>Add new attributes and methods to the components</li> <li>Add custom CLI commands</li> <li>Add custom URLs</li> </ul> <p>Some of the extensions include:</p> <ul> <li>Component caching</li> <li>Django View integration</li> <li>Component defaults</li> <li>Pydantic integration (input validation)</li> </ul> <p>Some of the planned extensions include:</p> <ul> <li>AlpineJS integration</li> <li>Storybook integration</li> <li>Component-level benchmarking with asv</li> </ul>"},{"location":"overview/welcome/#caching","title":"Caching","text":"<ul> <li>Components can be cached using Django's cache framework.</li> <li>Caching rules can be configured on a per-component basis.</li> <li>Components are cached based on their input. Or you can write custom caching logic.</li> </ul> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n\n        def hash(self, *args, **kwargs):\n            return hash(f\"{json.dumps(args)}:{json.dumps(kwargs)}\")\n</code></pre>"},{"location":"overview/welcome/#simple-testing","title":"Simple testing","text":"<ul> <li>Write tests for components with <code>@djc_test</code> decorator.</li> <li>The decorator manages global state, ensuring that tests don't leak.</li> <li>If using <code>pytest</code>, the decorator allows you to parametrize Django or Components settings.</li> <li>The decorator also serves as a stand-in for Django's <code>@override_settings</code>.</li> </ul> <pre><code>from django_components.testing import djc_test\n\nfrom components.my_table import MyTable\n\n@djc_test\ndef test_my_table():\n    rendered = MyTable.render(\n        kwargs={\n            \"title\": \"My table\",\n        },\n    )\n    assert rendered == \"&lt;table&gt;My table&lt;/table&gt;\"\n</code></pre>"},{"location":"overview/welcome/#debugging-features","title":"Debugging features","text":"<ul> <li>Visual component inspection: Highlight components and slots directly in your browser.</li> <li>Detailed tracing logs to supply AI-agents with context: The logs include component and slot names and IDs, and their position in the tree.</li> </ul>"},{"location":"overview/welcome/#sharing-components","title":"Sharing components","text":"<ul> <li>Install and use third-party components from PyPI</li> <li>Or publish your own \"component registry\"</li> <li> <p>Highly customizable - Choose how the components are called in the template (and more):</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}\n{% endcomponent %}\n\n{% calendar date=\"2024-11-06\" %}\n{% endcalendar %}\n</code></pre> </li> </ul>"},{"location":"reference/api/","title":"API","text":""},{"location":"reference/api/#api","title":"API","text":""},{"location":"reference/api/#django_components.BaseNode","title":"BaseNode","text":"<pre><code>BaseNode(params: List[TagAttr], flags: Optional[Dict[str, bool]] = None, nodelist: Optional[NodeList] = None, node_id: Optional[str] = None, contents: Optional[str] = None, template_name: Optional[str] = None, template_component: Optional[Type[Component]] = None)\n</code></pre> <p>Bases: <code>django.template.base.Node</code></p> <p>See source code</p> <p>Node class for all django-components custom template tags.</p> <p>This class has a dual role:</p> <ol> <li> <p>It declares how a particular template tag should be parsed - By setting the    <code>tag</code>,    <code>end_tag</code>,    and <code>allowed_flags</code> attributes:</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n    allowed_flags = [\"required\"]\n</code></pre> <p>This will allow the template tag <code>{% slot %}</code> to be used like this:</p> <pre><code>{% slot required %} ... {% endslot %}\n</code></pre> </li> <li> <p>The <code>render</code> method is     the actual implementation of the template tag.</p> <p>This is where the tag's logic is implemented:</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mynode\"\n\n    def render(self, context: Context, name: str, **kwargs: Any) -&gt; str:\n        return f\"Hello, {name}!\"\n</code></pre> <p>This will allow the template tag <code>{% mynode %}</code> to be used like this:</p> <pre><code>{% mynode name=\"John\" %}\n</code></pre> </li> </ol> <p>The template tag accepts parameters as defined on the <code>render</code> method's signature.</p> <p>For more info, see <code>BaseNode.render()</code>.</p> <p>Methods:</p> <ul> <li> <code>parse</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>unregister</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>active_flags</code>               (<code>List[str]</code>)           \u2013            </li> <li> <code>allowed_flags</code>               (<code>Optional[Iterable[str]]</code>)           \u2013            </li> <li> <code>contents</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>end_tag</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>flags</code>               (<code>Dict[str, bool]</code>)           \u2013            </li> <li> <code>node_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>nodelist</code>               (<code>NodeList</code>)           \u2013            </li> <li> <code>params</code>               (<code>List[TagAttr]</code>)           \u2013            </li> <li> <code>tag</code>               (<code>str</code>)           \u2013            </li> <li> <code>template_component</code>               (<code>Optional[Type[Component]]</code>)           \u2013            </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.BaseNode.active_flags","title":"active_flags  <code>property</code>","text":"<pre><code>active_flags: List[str]\n</code></pre> <p>See source code</p> <p>Flags that were set for this specific instance as a list of strings.</p> <p>E.g. the following tag:</p> <pre><code>{% slot \"content\" default required / %}\n</code></pre> <p>Will have the following flags:</p> <pre><code>[\"default\", \"required\"]\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.allowed_flags","title":"allowed_flags  <code>class-attribute</code>","text":"<pre><code>allowed_flags: Optional[Iterable[str]] = None\n</code></pre> <p>See source code</p> <p>The list of all possible flags for this tag.</p> <p>E.g. <code>[\"required\"]</code> will allow this tag to be used like <code>{% slot required %}</code>.</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n    allowed_flags = [\"required\", \"default\"]\n</code></pre> <p>This will allow the template tag <code>{% slot %}</code> to be used like this:</p> <pre><code>{% slot required %} ... {% endslot %}\n{% slot default %} ... {% endslot %}\n{% slot required default %} ... {% endslot %}\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.contents","title":"contents  <code>instance-attribute</code>","text":"<pre><code>contents: Optional[str] = contents\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The contents of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>contents</code> will be <code>\"&lt;div&gt; ... &lt;/div&gt;\"</code>.</p>"},{"location":"reference/api/#django_components.BaseNode.end_tag","title":"end_tag  <code>class-attribute</code>","text":"<pre><code>end_tag: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The end tag name.</p> <p>E.g. <code>\"endcomponent\"</code> or <code>\"endslot\"</code> will make this class match template tags <code>{% endcomponent %}</code> or <code>{% endslot %}</code>.</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n</code></pre> <p>This will allow the template tag <code>{% slot %}</code> to be used like this:</p> <pre><code>{% slot %} ... {% endslot %}\n</code></pre> <p>If not set, then this template tag has no end tag.</p> <p>So instead of <code>{% component %} ... {% endcomponent %}</code>, you'd use only <code>{% component %}</code>.</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mytag\"\n    end_tag = None\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.flags","title":"flags  <code>instance-attribute</code>","text":"<pre><code>flags: Dict[str, bool] = flags or {flag: Falsefor flag in (allowed_flags or [])}\n</code></pre> <p>See source code</p> <p>See source code</p> <p>Dictionary of all <code>allowed_flags</code> that were set on the tag.</p> <p>Flags that were set are <code>True</code>, and the rest are <code>False</code>.</p> <p>E.g. the following tag:</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n    allowed_flags = [\"default\", \"required\"]\n</code></pre> <pre><code>{% slot \"content\" default %}\n</code></pre> <p>Has 2 flags, <code>default</code> and <code>required</code>, but only <code>default</code> was set.</p> <p>The <code>flags</code> dictionary will be:</p> <pre><code>{\n    \"default\": True,\n    \"required\": False,\n}\n</code></pre> <p>You can check if a flag is set by doing:</p> <pre><code>if node.flags[\"default\"]:\n    ...\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.node_id","title":"node_id  <code>instance-attribute</code>","text":"<pre><code>node_id: str = node_id or gen_id()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The unique ID of the node.</p> <p>Extensions can use this ID to store additional information.</p>"},{"location":"reference/api/#django_components.BaseNode.nodelist","title":"nodelist  <code>instance-attribute</code>","text":"<pre><code>nodelist: NodeList = nodelist or NodeList()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The nodelist of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>nodelist</code> will contain the <code>&lt;div&gt; ... &lt;/div&gt;</code> part.</p> <p>Unlike <code>contents</code>, the <code>nodelist</code> contains the actual Nodes, not just the text.</p>"},{"location":"reference/api/#django_components.BaseNode.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: List[TagAttr] = params\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The parameters to the tag in the template.</p> <p>A single param represents an arg or kwarg of the template tag.</p> <p>E.g. the following tag:</p> <pre><code>{% component \"my_comp\" key=val key2='val2 two' %}\n</code></pre> <p>Has 3 params:</p> <ul> <li>Posiitonal arg <code>\"my_comp\"</code></li> <li>Keyword arg <code>key=val</code></li> <li>Keyword arg <code>key2='val2 two'</code></li> </ul>"},{"location":"reference/api/#django_components.BaseNode.tag","title":"tag  <code>class-attribute</code>","text":"<pre><code>tag: str\n</code></pre> <p>See source code</p> <p>The tag name.</p> <p>E.g. <code>\"component\"</code> or <code>\"slot\"</code> will make this class match template tags <code>{% component %}</code> or <code>{% slot %}</code>.</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n</code></pre> <p>This will allow the template tag <code>{% slot %}</code> to be used like this:</p> <pre><code>{% slot %} ... {% endslot %}\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.template_component","title":"template_component  <code>instance-attribute</code>","text":"<pre><code>template_component: Optional[Type[Component]] = template_component\n</code></pre> <p>See source code</p> <p>See source code</p> <p>If the template that contains this node belongs to a <code>Component</code>, then this will be the <code>Component</code> class.</p>"},{"location":"reference/api/#django_components.BaseNode.template_name","title":"template_name  <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = template_name\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The name of the <code>Template</code> that contains this node.</p> <p>The template name is set by Django's template loaders.</p> <p>For example, the filesystem template loader will set this to the absolute path of the template file.</p> <pre><code>\"/home/user/project/templates/my_template.html\"\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(parser: Parser, token: Token, **kwargs: Any) -&gt; BaseNode\n</code></pre> <p>See source code</p> <p>This function is what is passed to Django's <code>Library.tag()</code> when registering the tag.</p> <p>In other words, this method is called by Django's template parser when we encounter a tag that matches this node's tag, e.g. <code>{% component %}</code> or <code>{% slot %}</code>.</p> <p>To register the tag, you can use <code>BaseNode.register()</code>.</p>"},{"location":"reference/api/#django_components.BaseNode.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>A convenience method for registering the tag with the given library.</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mynode\"\n\nMyNode.register(library)\n</code></pre> <p>Allows you to then use the node in templates like so:</p> <pre><code>{% load mylibrary %}\n{% mynode %}\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.render","title":"render","text":"<pre><code>render(context: Context, *_args: Any, **_kwargs: Any) -&gt; str\n</code></pre> <p>See source code</p> <p>Render the node. This method is meant to be overridden by subclasses.</p> <p>The signature of this function decides what input the template tag accepts.</p> <p>The <code>render()</code> method MUST accept a <code>context</code> argument. Any arguments after that will be part of the tag's input parameters.</p> <p>So if you define a <code>render</code> method like this:</p> <pre><code>def render(self, context: Context, name: str, **kwargs: Any) -&gt; str:\n</code></pre> <p>Then the tag will require the <code>name</code> parameter, and accept any extra keyword arguments:</p> <pre><code>{% component name=\"John\" age=20 %}\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.unregister","title":"unregister  <code>classmethod</code>","text":"<pre><code>unregister(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>Unregisters the node from the given library.</p>"},{"location":"reference/api/#django_components.CommandLiteralAction","title":"CommandLiteralAction  <code>module-attribute</code>","text":"<pre><code>CommandLiteralAction = Literal['append', 'append_const', 'count', 'extend', 'store', 'store_const', 'store_true', 'store_false', 'version']\n</code></pre> <p>See source code</p> <p>The basic type of action to be taken when this argument is encountered at the command line.</p> <p>This is a subset of the values for <code>action</code> in <code>ArgumentParser.add_argument()</code>.</p>"},{"location":"reference/api/#django_components.Component","title":"Component","text":"<pre><code>Component(registered_name: Optional[str] = None, outer_context: Optional[Context] = None, registry: Optional[ComponentRegistry] = None, context: Optional[Context] = None, args: Optional[Any] = None, kwargs: Optional[Any] = None, slots: Optional[Any] = None, deps_strategy: Optional[DependenciesStrategy] = None, request: Optional[HttpRequest] = None, node: Optional[ComponentNode] = None, id: Optional[str] = None)\n</code></pre> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              </li> <li> <code>get_context_data</code>             \u2013              </li> <li> <code>get_css_data</code>             \u2013              </li> <li> <code>get_js_data</code>             \u2013              </li> <li> <code>get_template</code>             \u2013              </li> <li> <code>get_template_data</code>             \u2013              </li> <li> <code>get_template_name</code>             \u2013              </li> <li> <code>inject</code>             \u2013              </li> <li> <code>on_render</code>             \u2013              </li> <li> <code>on_render_after</code>             \u2013              </li> <li> <code>on_render_before</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>render_to_response</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>Args</code>               (<code>Optional[Type]</code>)           \u2013            </li> <li> <code>Cache</code>               (<code>Type[ComponentCache]</code>)           \u2013            </li> <li> <code>CssData</code>               (<code>Optional[Type]</code>)           \u2013            </li> <li> <code>DebugHighlight</code>               (<code>Type[ComponentDebugHighlight]</code>)           \u2013            </li> <li> <code>Defaults</code>               (<code>Type[ComponentDefaults]</code>)           \u2013            </li> <li> <code>JsData</code>               (<code>Optional[Type]</code>)           \u2013            </li> <li> <code>Kwargs</code>               (<code>Optional[Type]</code>)           \u2013            </li> <li> <code>Media</code>               (<code>Optional[Type[ComponentMediaInput]]</code>)           \u2013            </li> <li> <code>Slots</code>               (<code>Optional[Type]</code>)           \u2013            </li> <li> <code>TemplateData</code>               (<code>Optional[Type]</code>)           \u2013            </li> <li> <code>View</code>               (<code>Type[ComponentView]</code>)           \u2013            </li> <li> <code>args</code>               (<code>Any</code>)           \u2013            </li> <li> <code>cache</code>               (<code>ComponentCache</code>)           \u2013            </li> <li> <code>class_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            </li> <li> <code>context_processors_data</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>css_file</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>debug_highlight</code>               (<code>ComponentDebugHighlight</code>)           \u2013            </li> <li> <code>defaults</code>               (<code>ComponentDefaults</code>)           \u2013            </li> <li> <code>deps_strategy</code>               (<code>DependenciesStrategy</code>)           \u2013            </li> <li> <code>do_not_call_in_templates</code>               (<code>bool</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>input</code>               (<code>ComponentInput</code>)           \u2013            </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>js_file</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>kwargs</code>               (<code>Any</code>)           \u2013            </li> <li> <code>media</code>               (<code>Optional[Media]</code>)           \u2013            </li> <li> <code>media_class</code>               (<code>Type[Media]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>node</code>               (<code>Optional[ComponentNode]</code>)           \u2013            </li> <li> <code>outer_context</code>               (<code>Optional[Context]</code>)           \u2013            </li> <li> <code>raw_args</code>               (<code>List[Any]</code>)           \u2013            </li> <li> <code>raw_kwargs</code>               (<code>Dict[str, Any]</code>)           \u2013            </li> <li> <code>raw_slots</code>               (<code>Dict[str, Slot]</code>)           \u2013            </li> <li> <code>registered_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> <li> <code>request</code>               (<code>Optional[HttpRequest]</code>)           \u2013            </li> <li> <code>response_class</code>               (<code>Type[HttpResponse]</code>)           \u2013            </li> <li> <code>slots</code>               (<code>Any</code>)           \u2013            </li> <li> <code>template</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>template_file</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>view</code>               (<code>ComponentView</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.Component.Args","title":"Args  <code>class-attribute</code>","text":"<pre><code>Args: Optional[Type] = None\n</code></pre> <p>See source code</p> <p>Optional typing for positional arguments passed to the component.</p> <p>If set and not <code>None</code>, then the <code>args</code> parameter of the data methods (<code>get_template_data()</code>, <code>get_js_data()</code>, <code>get_css_data()</code>) will be the instance of this class:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class Args(NamedTuple):\n        color: str\n        size: int\n\n    def get_template_data(self, args: Args, kwargs, slots, context):\n        assert isinstance(args, Table.Args)\n\n        return {\n            \"color\": args.color,\n            \"size\": args.size,\n        }\n</code></pre> <p>The constructor of this class MUST accept positional arguments:</p> <pre><code>Args(*args)\n</code></pre> <p>As such, a good starting point is to set this field to a subclass of <code>NamedTuple</code>.</p> <p>Use <code>Args</code> to:</p> <ul> <li>Validate the input at runtime.</li> <li>Set type hints for the positional arguments for data methods like   <code>get_template_data()</code>.</li> <li>Document the component inputs.</li> </ul> <p>You can also use <code>Args</code> to validate the positional arguments for <code>Component.render()</code>:</p> <pre><code>Table.render(\n    args=Table.Args(color=\"red\", size=10),\n)\n</code></pre> <p>Read more on Typing and validation.</p>"},{"location":"reference/api/#django_components.Component.Cache","title":"Cache  <code>class-attribute</code>","text":"<pre><code>Cache: Type[ComponentCache]\n</code></pre> <p>See source code</p> <p>The fields of this class are used to configure the component caching.</p> <p>Read more about Component caching.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n        cache_name = \"my_cache\"\n</code></pre>"},{"location":"reference/api/#django_components.Component.CssData","title":"CssData  <code>class-attribute</code>","text":"<pre><code>CssData: Optional[Type] = None\n</code></pre> <p>See source code</p> <p>Optional typing for the data to be returned from <code>get_css_data()</code>.</p> <p>If set and not <code>None</code>, then this class will be instantiated with the dictionary returned from <code>get_css_data()</code> to validate the data.</p> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>CssData(**css_data)\n</code></pre> <p>You can also return an instance of <code>CssData</code> directly from <code>get_css_data()</code> to get type hints:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class CssData(NamedTuple):\n        color: str\n        size: int\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return Table.CssData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre> <p>A good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>CssData</code> to:</p> <ul> <li>Validate the data returned from   <code>get_css_data()</code> at runtime.</li> <li>Set type hints for this data.</li> <li>Document the component data.</li> </ul> <p>Read more on Typing and validation.</p> <p>Info</p> <p>If you use a custom class for <code>CssData</code>, this class needs to be convertable to a dictionary.</p> <p>You can implement either:</p> <ol> <li> <p><code>_asdict()</code> method     <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def _asdict(self):\n        return {'x': self.x, 'y': self.y}\n</code></pre></p> </li> <li> <p>Or make the class dict-like with <code>__iter__()</code> and <code>__getitem__()</code> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code></pre></p> </li> </ol>"},{"location":"reference/api/#django_components.Component.DebugHighlight","title":"DebugHighlight  <code>class-attribute</code>","text":"<pre><code>DebugHighlight: Type[ComponentDebugHighlight]\n</code></pre> <p>See source code</p> <p>The fields of this class are used to configure the component debug highlighting.</p> <p>Read more about Component debug highlighting.</p>"},{"location":"reference/api/#django_components.Component.Defaults","title":"Defaults  <code>class-attribute</code>","text":"<pre><code>Defaults: Type[ComponentDefaults]\n</code></pre> <p>See source code</p> <p>The fields of this class are used to set default values for the component's kwargs.</p> <p>Read more about Component defaults.</p> <p>Example:</p> <pre><code>from django_components import Component, Default\n\nclass MyComponent(Component):\n    class Defaults:\n        position = \"left\"\n        selected_items = Default(lambda: [1, 2, 3])\n</code></pre>"},{"location":"reference/api/#django_components.Component.JsData","title":"JsData  <code>class-attribute</code>","text":"<pre><code>JsData: Optional[Type] = None\n</code></pre> <p>See source code</p> <p>Optional typing for the data to be returned from <code>get_js_data()</code>.</p> <p>If set and not <code>None</code>, then this class will be instantiated with the dictionary returned from <code>get_js_data()</code> to validate the data.</p> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>JsData(**js_data)\n</code></pre> <p>You can also return an instance of <code>JsData</code> directly from <code>get_js_data()</code> to get type hints:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class JsData(NamedTuple):\n        color: str\n        size: int\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return Table.JsData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre> <p>A good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>JsData</code> to:</p> <ul> <li>Validate the data returned from   <code>get_js_data()</code> at runtime.</li> <li>Set type hints for this data.</li> <li>Document the component data.</li> </ul> <p>Read more on Typing and validation.</p> <p>Info</p> <p>If you use a custom class for <code>JsData</code>, this class needs to be convertable to a dictionary.</p> <p>You can implement either:</p> <ol> <li> <p><code>_asdict()</code> method     <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def _asdict(self):\n        return {'x': self.x, 'y': self.y}\n</code></pre></p> </li> <li> <p>Or make the class dict-like with <code>__iter__()</code> and <code>__getitem__()</code> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code></pre></p> </li> </ol>"},{"location":"reference/api/#django_components.Component.Kwargs","title":"Kwargs  <code>class-attribute</code>","text":"<pre><code>Kwargs: Optional[Type] = None\n</code></pre> <p>See source code</p> <p>Optional typing for keyword arguments passed to the component.</p> <p>If set and not <code>None</code>, then the <code>kwargs</code> parameter of the data methods (<code>get_template_data()</code>, <code>get_js_data()</code>, <code>get_css_data()</code>) will be the instance of this class:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class Kwargs(NamedTuple):\n        color: str\n        size: int\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        assert isinstance(kwargs, Table.Kwargs)\n\n        return {\n            \"color\": kwargs.color,\n            \"size\": kwargs.size,\n        }\n</code></pre> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>Kwargs(**kwargs)\n</code></pre> <p>As such, a good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>Kwargs</code> to:</p> <ul> <li>Validate the input at runtime.</li> <li>Set type hints for the keyword arguments for data methods like   <code>get_template_data()</code>.</li> <li>Document the component inputs.</li> </ul> <p>You can also use <code>Kwargs</code> to validate the keyword arguments for <code>Component.render()</code>:</p> <pre><code>Table.render(\n    kwargs=Table.Kwargs(color=\"red\", size=10),\n)\n</code></pre> <p>Read more on Typing and validation.</p>"},{"location":"reference/api/#django_components.Component.Media","title":"Media  <code>class-attribute</code>","text":"<pre><code>Media: Optional[Type[ComponentMediaInput]] = None\n</code></pre> <p>See source code</p> <p>Defines JS and CSS media files associated with this component.</p> <p>This <code>Media</code> class behaves similarly to Django's Media class:</p> <ul> <li>Paths are generally handled as static file paths, and resolved URLs are rendered to HTML with   <code>media_class.render_js()</code> or <code>media_class.render_css()</code>.</li> <li>A path that starts with <code>http</code>, <code>https</code>, or <code>/</code> is considered a URL, skipping the static file resolution.   This path is still rendered to HTML with <code>media_class.render_js()</code> or <code>media_class.render_css()</code>.</li> <li>A <code>SafeString</code> (with <code>__html__</code> method) is considered an already-formatted HTML tag, skipping both static file     resolution and rendering with <code>media_class.render_js()</code> or <code>media_class.render_css()</code>.</li> <li>You can set <code>extend</code> to configure   whether to inherit JS / CSS from parent components. See   Media inheritance.</li> </ul> <p>However, there's a few differences from Django's Media class:</p> <ol> <li>Our Media class accepts various formats for the JS and CSS files: either a single file, a list,    or (CSS-only) a dictionary (See <code>ComponentMediaInput</code>).</li> <li>Individual JS / CSS files can be any of <code>str</code>, <code>bytes</code>, <code>Path</code>,    <code>SafeString</code>, or a function    (See <code>ComponentMediaInputPath</code>).</li> </ol> <p>Example:</p> <pre><code>class MyTable(Component):\n    class Media:\n        js = [\n            \"path/to/script.js\",\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",  # AlpineJS\n        ]\n        css = {\n            \"all\": [\n                \"path/to/style.css\",\n                \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",  # TailwindCSS\n            ],\n            \"print\": [\"path/to/style2.css\"],\n        }\n</code></pre>"},{"location":"reference/api/#django_components.Component.Slots","title":"Slots  <code>class-attribute</code>","text":"<pre><code>Slots: Optional[Type] = None\n</code></pre> <p>See source code</p> <p>Optional typing for slots passed to the component.</p> <p>If set and not <code>None</code>, then the <code>slots</code> parameter of the data methods (<code>get_template_data()</code>, <code>get_js_data()</code>, <code>get_css_data()</code>) will be the instance of this class:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component, Slot, SlotInput\n\nclass Table(Component):\n    class Slots(NamedTuple):\n        header: SlotInput\n        footer: Slot\n\n    def get_template_data(self, args, kwargs, slots: Slots, context):\n        assert isinstance(slots, Table.Slots)\n\n        return {\n            \"header\": slots.header,\n            \"footer\": slots.footer,\n        }\n</code></pre> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>Slots(**slots)\n</code></pre> <p>As such, a good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>Slots</code> to:</p> <ul> <li>Validate the input at runtime.</li> <li>Set type hints for the slots for data methods like   <code>get_template_data()</code>.</li> <li>Document the component inputs.</li> </ul> <p>You can also use <code>Slots</code> to validate the slots for <code>Component.render()</code>:</p> <pre><code>Table.render(\n    slots=Table.Slots(\n        header=\"HELLO IM HEADER\",\n        footer=Slot(lambda ctx: ...),\n    ),\n)\n</code></pre> <p>Read more on Typing and validation.</p> <p>Info</p> <p>Components can receive slots as strings, functions, or instances of <code>Slot</code>.</p> <p>Internally these are all normalized to instances of <code>Slot</code>.</p> <p>Therefore, the <code>slots</code> dictionary available in data methods (like <code>get_template_data()</code>) will always be a dictionary of <code>Slot</code> instances.</p> <p>To correctly type this dictionary, you should set the fields of <code>Slots</code> to <code>Slot</code> or <code>SlotInput</code>:</p> <p><code>SlotInput</code> is a union of <code>Slot</code>, string, and function types.</p>"},{"location":"reference/api/#django_components.Component.TemplateData","title":"TemplateData  <code>class-attribute</code>","text":"<pre><code>TemplateData: Optional[Type] = None\n</code></pre> <p>See source code</p> <p>Optional typing for the data to be returned from <code>get_template_data()</code>.</p> <p>If set and not <code>None</code>, then this class will be instantiated with the dictionary returned from <code>get_template_data()</code> to validate the data.</p> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>TemplateData(**template_data)\n</code></pre> <p>You can also return an instance of <code>TemplateData</code> directly from <code>get_template_data()</code> to get type hints:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class TemplateData(NamedTuple):\n        color: str\n        size: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return Table.TemplateData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre> <p>A good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>TemplateData</code> to:</p> <ul> <li>Validate the data returned from   <code>get_template_data()</code> at runtime.</li> <li>Set type hints for this data.</li> <li>Document the component data.</li> </ul> <p>Read more on Typing and validation.</p> <p>Info</p> <p>If you use a custom class for <code>TemplateData</code>, this class needs to be convertable to a dictionary.</p> <p>You can implement either:</p> <ol> <li> <p><code>_asdict()</code> method     <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def _asdict(self):\n        return {'x': self.x, 'y': self.y}\n</code></pre></p> </li> <li> <p>Or make the class dict-like with <code>__iter__()</code> and <code>__getitem__()</code> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code></pre></p> </li> </ol>"},{"location":"reference/api/#django_components.Component.View","title":"View  <code>class-attribute</code>","text":"<pre><code>View: Type[ComponentView]\n</code></pre> <p>See source code</p> <p>The fields of this class are used to configure the component views and URLs.</p> <p>This class is a subclass of <code>django.views.View</code>. The <code>Component</code> instance is available via <code>self.component</code>.</p> <p>Override the methods of this class to define the behavior of the component.</p> <p>Read more about Component views and URLs.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class View:\n        def get(self, request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse:\n            return HttpResponse(\"Hello, world!\")\n</code></pre>"},{"location":"reference/api/#django_components.Component.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: Any\n</code></pre> <p>See source code</p> <p>Positional arguments passed to the component.</p> <p>This is part of the Render API.</p> <p><code>args</code> has the same behavior as the <code>args</code> argument of <code>Component.get_template_data()</code>:</p> <ul> <li>If you defined the <code>Component.Args</code> class,     then the <code>args</code> property will return an instance of that <code>Args</code> class.</li> <li>Otherwise, <code>args</code> will be a plain list.</li> </ul> <p>Example:</p> <p>With <code>Args</code> class:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    class Args(NamedTuple):\n        page: int\n        per_page: int\n\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.args.page == 123\n        assert self.args.per_page == 10\n\nrendered = Table.render(\n    args=[123, 10],\n)\n</code></pre> <p>Without <code>Args</code> class:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.args[0] == 123\n        assert self.args[1] == 10\n</code></pre>"},{"location":"reference/api/#django_components.Component.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache: ComponentCache\n</code></pre> <p>See source code</p> <p>Instance of <code>ComponentCache</code> available at component render time.</p>"},{"location":"reference/api/#django_components.Component.class_id","title":"class_id  <code>class-attribute</code>","text":"<pre><code>class_id: str\n</code></pre> <p>See source code</p> <p>Unique ID of the component class, e.g. <code>MyComponent_ab01f2</code>.</p> <p>This is derived from the component class' module import path, e.g. <code>path.to.my.MyComponent</code>.</p>"},{"location":"reference/api/#django_components.Component.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Context\n</code></pre> <p>See source code</p> <p>The <code>context</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>This is Django's Context with which the component template is rendered.</p> <p>If the root component or template was rendered with <code>RequestContext</code> then this will be an instance of <code>RequestContext</code>.</p> <p>Whether the context variables defined in <code>context</code> are available to the template depends on the context behavior mode:</p> <ul> <li> <p>In <code>\"django\"</code> context behavior mode, the template will have access to the keys of this context.</p> </li> <li> <p>In <code>\"isolated\"</code> context behavior mode, the template will NOT have access to this context,     and data MUST be passed via component's args and kwargs.</p> </li> </ul>"},{"location":"reference/api/#django_components.Component.context_processors_data","title":"context_processors_data  <code>property</code>","text":"<pre><code>context_processors_data: Dict\n</code></pre> <p>See source code</p> <p>Retrieve data injected by <code>context_processors</code>.</p> <p>This data is also available from within the component's template, without having to return this data from <code>get_template_data()</code>.</p> <p>In regular Django templates, you need to use <code>RequestContext</code> to apply context processors.</p> <p>In Components, the context processors are applied to components either when:</p> <ul> <li>The component is rendered with     <code>RequestContext</code>     (Regular Django behavior)</li> <li>The component is rendered with a regular     <code>Context</code> (or none),     but the <code>request</code> kwarg of <code>Component.render()</code> is set.</li> <li>The component is nested in another component that matches any of these conditions.</li> </ul> <p>See <code>Component.request</code> on how the <code>request</code> (HTTPRequest) object is passed to and within the components.</p> <p>NOTE: This dictionary is generated dynamically, so any changes to it will not be persisted.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        user = self.context_processors_data['user']\n        return {\n            'is_logged_in': user.is_authenticated,\n        }\n</code></pre>"},{"location":"reference/api/#django_components.Component.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Main CSS associated with this component inlined as string.</p> <p>Warning</p> <p>Only one of <code>css</code> or <code>css_file</code> must be defined.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    css = \"\"\"\n        .my-class {\n            color: red;\n        }\n    \"\"\"\n</code></pre> <p>Syntax highlighting</p> <p>When using the inlined template, you can enable syntax highlighting with <code>django_components.types.css</code>.</p> <p>Learn more about syntax highlighting.</p> <pre><code>from django_components import Component, types\n\nclass MyComponent(Component):\n    css: types.css = '''\n      .my-class {\n        color: red;\n      }\n    '''\n</code></pre>"},{"location":"reference/api/#django_components.Component.css_file","title":"css_file  <code>class-attribute</code>","text":"<pre><code>css_file: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Main CSS associated with this component as file path.</p> <p>The filepath must be either:</p> <ul> <li>Relative to the directory where the Component's Python file is defined.</li> <li>Relative to one of the component directories, as set by   <code>COMPONENTS.dirs</code>   or   <code>COMPONENTS.app_dirs</code>   (e.g. <code>&lt;root&gt;/components/</code>).</li> <li>Relative to the staticfiles directories, as set by Django's <code>STATICFILES_DIRS</code> setting (e.g. <code>&lt;root&gt;/static/</code>).</li> </ul> <p>When you create a Component class with <code>css_file</code>, these will happen:</p> <ol> <li>If the file path is relative to the directory where the component's Python file is,    the path is resolved.</li> <li>The file is read and its contents is set to <code>Component.css</code>.</li> </ol> <p>Warning</p> <p>Only one of <code>css</code> or <code>css_file</code> must be defined.</p> <p>Example:</p> path/to/style.css<pre><code>.my-class {\n    color: red;\n}\n</code></pre> path/to/component.py<pre><code>class MyComponent(Component):\n    css_file = \"path/to/style.css\"\n\nprint(MyComponent.css)\n# Output:\n# .my-class {\n#     color: red;\n# };\n</code></pre>"},{"location":"reference/api/#django_components.Component.debug_highlight","title":"debug_highlight  <code>instance-attribute</code>","text":"<pre><code>debug_highlight: ComponentDebugHighlight\n</code></pre>"},{"location":"reference/api/#django_components.Component.defaults","title":"defaults  <code>instance-attribute</code>","text":"<pre><code>defaults: ComponentDefaults\n</code></pre> <p>See source code</p> <p>Instance of <code>ComponentDefaults</code> available at component render time.</p>"},{"location":"reference/api/#django_components.Component.deps_strategy","title":"deps_strategy  <code>instance-attribute</code>","text":"<pre><code>deps_strategy: DependenciesStrategy\n</code></pre> <p>See source code</p> <p>Dependencies strategy defines how to handle JS and CSS dependencies of this and child components.</p> <p>Read more about Dependencies rendering.</p> <p>This is part of the Render API.</p> <p>There are six strategies:</p> <ul> <li><code>\"document\"</code> (default)<ul> <li>Smartly inserts JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Requires the HTML to be rendered in a JS-enabled browser.</li> <li>Inserts extra script for managing fragments.</li> </ul> </li> <li><code>\"fragment\"</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>Fragment will fetch its own JS / CSS dependencies when inserted into the page.</li> <li>Requires the HTML to be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>\"simple\"</code><ul> <li>Smartly insert JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"prepend\"</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"append\"</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"ignore\"</code><ul> <li>HTML is left as-is. You can still process it with a different strategy later with     <code>render_dependencies()</code>.</li> <li>Used for inserting rendered HTML into other components.</li> </ul> </li> </ul>"},{"location":"reference/api/#django_components.Component.do_not_call_in_templates","title":"do_not_call_in_templates  <code>class-attribute</code>","text":"<pre><code>do_not_call_in_templates: bool = True\n</code></pre> <p>See source code</p> <p>Django special property to prevent calling the instance as a function inside Django templates.</p> <p>Read more about Django's <code>do_not_call_in_templates</code>.</p>"},{"location":"reference/api/#django_components.Component.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>See source code</p> <p>This ID is unique for every time a <code>Component.render()</code> (or equivalent) is called (AKA \"render ID\").</p> <p>This is useful for logging or debugging.</p> <p>The ID is a 7-letter alphanumeric string in the format <code>cXXXXXX</code>, where <code>XXXXXX</code> is a random string of 6 alphanumeric characters (case-sensitive).</p> <p>E.g. <code>c1A2b3c</code>.</p> <p>A single render ID has a chance of collision 1 in 57 billion. However, due to birthday paradox, the chance of collision increases to 1% when approaching ~33K render IDs.</p> <p>Thus, there is currently a soft-cap of ~30K components rendered on a single page.</p> <p>If you need to expand this limit, please open an issue on GitHub.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        print(f\"Rendering '{self.id}'\")\n\nMyComponent.render()\n# Rendering 'ab3c4d'\n</code></pre>"},{"location":"reference/api/#django_components.Component.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: ComponentInput\n</code></pre> <p>See source code</p> <p>Deprecated. Will be removed in v1.</p> <p>Input holds the data that were passed to the current component at render time.</p> <p>This includes:</p> <ul> <li><code>args</code> - List of positional arguments</li> <li><code>kwargs</code> - Dictionary of keyword arguments</li> <li><code>slots</code> - Dictionary of slots. Values are normalized to     <code>Slot</code> instances</li> <li><code>context</code> -     <code>Context</code>     object that should be used to render the component</li> <li>And other kwargs passed to <code>Component.render()</code>     like <code>deps_strategy</code></li> </ul> <p>Example:</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's inputs, slots and context\n        assert self.args == [123, \"str\"]\n        assert self.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.slots[\"footer\"]\n        some_var = self.input.context[\"some_var\"]\n\nrendered = TestComponent.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=[123, \"str\"],\n    slots={\"footer\": \"MY_SLOT\"},\n)\n</code></pre>"},{"location":"reference/api/#django_components.Component.is_filled","title":"is_filled  <code>instance-attribute</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>See source code</p> <p>Deprecated. Will be removed in v1. Use <code>Component.slots</code> instead. Note that <code>Component.slots</code> no longer escapes the slot names.</p> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within:</p> <p>You can also access this variable from within the template as</p> <p><code>{{ component_vars.is_filled.slot_name }}</code></p>"},{"location":"reference/api/#django_components.Component.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Main JS associated with this component inlined as string.</p> <p>Warning</p> <p>Only one of <code>js</code> or <code>js_file</code> must be defined.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    js = \"console.log('Hello, World!');\"\n</code></pre> <p>Syntax highlighting</p> <p>When using the inlined template, you can enable syntax highlighting with <code>django_components.types.js</code>.</p> <p>Learn more about syntax highlighting.</p> <pre><code>from django_components import Component, types\n\nclass MyComponent(Component):\n    js: types.js = '''\n      console.log('Hello, World!');\n    '''\n</code></pre>"},{"location":"reference/api/#django_components.Component.js_file","title":"js_file  <code>class-attribute</code>","text":"<pre><code>js_file: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Main JS associated with this component as file path.</p> <p>The filepath must be either:</p> <ul> <li>Relative to the directory where the Component's Python file is defined.</li> <li>Relative to one of the component directories, as set by   <code>COMPONENTS.dirs</code>   or   <code>COMPONENTS.app_dirs</code>   (e.g. <code>&lt;root&gt;/components/</code>).</li> <li>Relative to the staticfiles directories, as set by Django's <code>STATICFILES_DIRS</code> setting (e.g. <code>&lt;root&gt;/static/</code>).</li> </ul> <p>When you create a Component class with <code>js_file</code>, these will happen:</p> <ol> <li>If the file path is relative to the directory where the component's Python file is,    the path is resolved.</li> <li>The file is read and its contents is set to <code>Component.js</code>.</li> </ol> <p>Warning</p> <p>Only one of <code>js</code> or <code>js_file</code> must be defined.</p> <p>Example:</p> path/to/script.js<pre><code>console.log('Hello, World!');\n</code></pre> path/to/component.py<pre><code>class MyComponent(Component):\n    js_file = \"path/to/script.js\"\n\nprint(MyComponent.js)\n# Output: console.log('Hello, World!');\n</code></pre>"},{"location":"reference/api/#django_components.Component.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: Any\n</code></pre> <p>See source code</p> <p>Keyword arguments passed to the component.</p> <p>This is part of the Render API.</p> <p><code>kwargs</code> has the same behavior as the <code>kwargs</code> argument of <code>Component.get_template_data()</code>:</p> <ul> <li>If you defined the <code>Component.Kwargs</code> class,     then the <code>kwargs</code> property will return an instance of that <code>Kwargs</code> class.</li> <li>Otherwise, <code>kwargs</code> will be a plain dict.</li> </ul> <p>Example:</p> <p>With <code>Kwargs</code> class:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    class Kwargs(NamedTuple):\n        page: int\n        per_page: int\n\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.kwargs.page == 123\n        assert self.kwargs.per_page == 10\n\nrendered = Table.render(\n    kwargs={\n        \"page\": 123,\n        \"per_page\": 10,\n    },\n)\n</code></pre> <p>Without <code>Kwargs</code> class:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.kwargs[\"page\"] == 123\n        assert self.kwargs[\"per_page\"] == 10\n</code></pre>"},{"location":"reference/api/#django_components.Component.media","title":"media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>media: Optional[Media] = None\n</code></pre> <p>See source code</p> <p>Normalized definition of JS and CSS media files associated with this component. <code>None</code> if <code>Component.Media</code> is not defined.</p> <p>This field is generated from <code>Component.media_class</code>.</p> <p>Read more on Accessing component's Media JS / CSS.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"path/to/script.js\"\n        css = \"path/to/style.css\"\n\nprint(MyComponent.media)\n# Output:\n# &lt;script src=\"/static/path/to/script.js\"&gt;&lt;/script&gt;\n# &lt;link href=\"/static/path/to/style.css\" media=\"all\" rel=\"stylesheet\"&gt;\n</code></pre>"},{"location":"reference/api/#django_components.Component.media_class","title":"media_class  <code>class-attribute</code>","text":"<pre><code>media_class: Type[Media] = Media\n</code></pre> <p>See source code</p> <p>Set the Media class that will be instantiated with the JS and CSS media files from <code>Component.Media</code>.</p> <p>This is useful when you want to customize the behavior of the media files, like customizing how the JS or CSS files are rendered into <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> HTML tags.</p> <p>Read more in Media class.</p> <p>Example:</p> <pre><code>class MyTable(Component):\n    class Media:\n        js = \"path/to/script.js\"\n        css = \"path/to/style.css\"\n\n    media_class = MyMediaClass\n</code></pre>"},{"location":"reference/api/#django_components.Component.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>The name of the component.</p> <p>If the component was registered, this will be the name under which the component was registered in the <code>ComponentRegistry</code>.</p> <p>Otherwise, this will be the name of the class.</p> <p>Example:</p> <pre><code>@register(\"my_component\")\nclass RegisteredComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"name\": self.name,  # \"my_component\"\n        }\n\nclass UnregisteredComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"name\": self.name,  # \"UnregisteredComponent\"\n        }\n</code></pre>"},{"location":"reference/api/#django_components.Component.node","title":"node  <code>instance-attribute</code>","text":"<pre><code>node: Optional[ComponentNode]\n</code></pre> <p>See source code</p> <p>The <code>ComponentNode</code> instance that was used to render the component.</p> <p>This will be set only if the component was rendered with the <code>{% component %}</code> tag.</p> <p>Accessing the <code>ComponentNode</code> is mostly useful for extensions, which can modify their behaviour based on the source of the Component.</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, context, template):\n        if self.node is not None:\n            assert self.node.name == \"my_component\"\n</code></pre> <p>For example, if <code>MyComponent</code> was used in another component - that is, with a <code>{% component \"my_component\" %}</code> tag in a template that belongs to another component - then you can use <code>self.node.template_component</code> to access the owner <code>Component</code> class.</p> <pre><code>class Parent(Component):\n    template: types.django_html = '''\n        &lt;div&gt;\n            {% component \"my_component\" / %}\n        &lt;/div&gt;\n    '''\n\n@register(\"my_component\")\nclass MyComponent(Component):\n    def get_template_data(self, context, template):\n        if self.node is not None:\n            assert self.node.template_component == Parent\n</code></pre> <p>Info</p> <p><code>Component.node</code> is <code>None</code> if the component is created by <code>Component.render()</code> (but you can pass in the <code>node</code> kwarg yourself).</p>"},{"location":"reference/api/#django_components.Component.outer_context","title":"outer_context  <code>instance-attribute</code>","text":"<pre><code>outer_context: Optional[Context]\n</code></pre> <p>See source code</p> <p>When a component is rendered with the <code>{% component %}</code> tag, this is the Django's <code>Context</code> object that was used just outside of the component.</p> <pre><code>{% with abc=123 %}\n    {{ abc }} {# &lt;--- This is in outer context #}\n    {% component \"my_component\" / %}\n{% endwith %}\n</code></pre> <p>This is relevant when your components are isolated, for example when using the \"isolated\" context behavior mode or when using the <code>only</code> flag.</p> <p>When components are isolated, each component has its own instance of Context, so <code>outer_context</code> is different from the <code>context</code> argument.</p>"},{"location":"reference/api/#django_components.Component.raw_args","title":"raw_args  <code>instance-attribute</code>","text":"<pre><code>raw_args: List[Any]\n</code></pre> <p>See source code</p> <p>Positional arguments passed to the component.</p> <p>This is part of the Render API.</p> <p>Unlike <code>Component.args</code>, this attribute is not typed and will remain as plain list even if you define the <code>Component.Args</code> class.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.raw_args[0] == 123\n        assert self.raw_args[1] == 10\n</code></pre>"},{"location":"reference/api/#django_components.Component.raw_kwargs","title":"raw_kwargs  <code>instance-attribute</code>","text":"<pre><code>raw_kwargs: Dict[str, Any]\n</code></pre> <p>See source code</p> <p>Keyword arguments passed to the component.</p> <p>This is part of the Render API.</p> <p>Unlike <code>Component.kwargs</code>, this attribute is not typed and will remain as plain dict even if you define the <code>Component.Kwargs</code> class.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.raw_kwargs[\"page\"] == 123\n        assert self.raw_kwargs[\"per_page\"] == 10\n</code></pre>"},{"location":"reference/api/#django_components.Component.raw_slots","title":"raw_slots  <code>instance-attribute</code>","text":"<pre><code>raw_slots: Dict[str, Slot]\n</code></pre> <p>See source code</p> <p>Slots passed to the component.</p> <p>This is part of the Render API.</p> <p>Unlike <code>Component.slots</code>, this attribute is not typed and will remain as plain dict even if you define the <code>Component.Slots</code> class.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.raw_slots[\"header\"] == \"MY_HEADER\"\n        assert self.raw_slots[\"footer\"] == \"FOOTER: \" + ctx.data[\"user_id\"]\n</code></pre>"},{"location":"reference/api/#django_components.Component.registered_name","title":"registered_name  <code>instance-attribute</code>","text":"<pre><code>registered_name: Optional[str]\n</code></pre> <p>See source code</p> <p>If the component was rendered with the <code>{% component %}</code> template tag, this will be the name under which the component was registered in the <code>ComponentRegistry</code>.</p> <p>Otherwise, this will be <code>None</code>.</p> <p>Example:</p> <pre><code>@register(\"my_component\")\nclass MyComponent(Component):\n    template = \"{{ name }}\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"name\": self.registered_name,\n        }\n</code></pre> <p>Will print <code>my_component</code> in the template:</p> <pre><code>{% component \"my_component\" / %}\n</code></pre> <p>And <code>None</code> when rendered in Python:</p> <pre><code>MyComponent.render()\n# None\n</code></pre>"},{"location":"reference/api/#django_components.Component.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The <code>ComponentRegistry</code> instance that was used to render the component.</p>"},{"location":"reference/api/#django_components.Component.request","title":"request  <code>instance-attribute</code>","text":"<pre><code>request: Optional[HttpRequest]\n</code></pre> <p>See source code</p> <p>HTTPRequest object passed to this component.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        user_id = self.request.GET['user_id']\n        return {\n            'user_id': user_id,\n        }\n</code></pre> <p>Passing <code>request</code> to a component:</p> <p>In regular Django templates, you have to use <code>RequestContext</code> to pass the <code>HttpRequest</code> object to the template.</p> <p>With Components, you can either use <code>RequestContext</code>, or pass the <code>request</code> object explicitly via <code>Component.render()</code> and <code>Component.render_to_response()</code>.</p> <p>When a component is nested in another, the child component uses parent's <code>request</code> object.</p>"},{"location":"reference/api/#django_components.Component.response_class","title":"response_class  <code>class-attribute</code>","text":"<pre><code>response_class: Type[HttpResponse] = HttpResponse\n</code></pre> <p>See source code</p> <p>This attribute configures what class is used to generate response from <code>Component.render_to_response()</code>.</p> <p>The response class should accept a string as the first argument.</p> <p>Defaults to <code>django.http.HttpResponse</code>.</p> <p>Example:</p> <pre><code>from django.http import HttpResponse\nfrom django_components import Component\n\nclass MyHttpResponse(HttpResponse):\n    ...\n\nclass MyComponent(Component):\n    response_class = MyHttpResponse\n\nresponse = MyComponent.render_to_response()\nassert isinstance(response, MyHttpResponse)\n</code></pre>"},{"location":"reference/api/#django_components.Component.slots","title":"slots  <code>instance-attribute</code>","text":"<pre><code>slots: Any\n</code></pre> <p>See source code</p> <p>Slots passed to the component.</p> <p>This is part of the Render API.</p> <p><code>slots</code> has the same behavior as the <code>slots</code> argument of <code>Component.get_template_data()</code>:</p> <ul> <li>If you defined the <code>Component.Slots</code> class,     then the <code>slots</code> property will return an instance of that class.</li> <li>Otherwise, <code>slots</code> will be a plain dict.</li> </ul> <p>Example:</p> <p>With <code>Slots</code> class:</p> <pre><code>from django_components import Component, Slot, SlotInput\n\nclass Table(Component):\n    class Slots(NamedTuple):\n        header: SlotInput\n        footer: SlotInput\n\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert isinstance(self.slots.header, Slot)\n        assert isinstance(self.slots.footer, Slot)\n\nrendered = Table.render(\n    slots={\n        \"header\": \"MY_HEADER\",\n        \"footer\": lambda ctx: \"FOOTER: \" + ctx.data[\"user_id\"],\n    },\n)\n</code></pre> <p>Without <code>Slots</code> class:</p> <pre><code>from django_components import Component, Slot, SlotInput\n\nclass Table(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert isinstance(self.slots[\"header\"], Slot)\n        assert isinstance(self.slots[\"footer\"], Slot)\n</code></pre>"},{"location":"reference/api/#django_components.Component.template","title":"template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Inlined Django template (as a plain string) associated with this component.</p> <p>Warning</p> <p>Only one of <code>template_file</code>, <code>template</code>, <code>get_template_name()</code>, or <code>get_template()</code> must be defined.</p> <p>Example:</p> <pre><code>class Table(Component):\n    template = '''\n      &lt;div&gt;\n        {{ my_var }}\n      &lt;/div&gt;\n    '''\n</code></pre> <p>Syntax highlighting</p> <p>When using the inlined template, you can enable syntax highlighting with <code>django_components.types.django_html</code>.</p> <p>Learn more about syntax highlighting.</p> <pre><code>from django_components import Component, types\n\nclass MyComponent(Component):\n    template: types.django_html = '''\n      &lt;div&gt;\n        {{ my_var }}\n      &lt;/div&gt;\n    '''\n</code></pre>"},{"location":"reference/api/#django_components.Component.template_file","title":"template_file  <code>class-attribute</code>","text":"<pre><code>template_file: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be either:</p> <ul> <li>Relative to the directory where the Component's Python file is defined.</li> <li>Relative to one of the component directories, as set by   <code>COMPONENTS.dirs</code>   or   <code>COMPONENTS.app_dirs</code>   (e.g. <code>&lt;root&gt;/components/</code>).</li> <li>Relative to the template directories, as set by Django's <code>TEMPLATES</code> setting (e.g. <code>&lt;root&gt;/templates/</code>).</li> </ul> <p>Warning</p> <p>Only one of <code>template_file</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> <p>Example:</p> <p>Assuming this project layout:</p> <pre><code>|- components/\n  |- table/\n    |- table.html\n    |- table.css\n    |- table.js\n</code></pre> <p>Template name can be either relative to the python file (<code>components/table/table.py</code>):</p> <pre><code>class Table(Component):\n    template_file = \"table.html\"\n</code></pre> <p>Or relative to one of the directories in <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> (<code>components/</code>):</p> <pre><code>class Table(Component):\n    template_file = \"table/table.html\"\n</code></pre>"},{"location":"reference/api/#django_components.Component.template_name","title":"template_name  <code>class-attribute</code>","text":"<pre><code>template_name: Optional[str]\n</code></pre> <p>See source code</p> <p>Alias for <code>template_file</code>.</p> <p>For historical reasons, django-components used <code>template_name</code> to align with Django's TemplateView.</p> <p><code>template_file</code> was introduced to align with <code>js</code>/<code>js_file</code> and <code>css</code>/<code>css_file</code>.</p> <p>Setting and accessing this attribute is proxied to <code>template_file</code>.</p>"},{"location":"reference/api/#django_components.Component.view","title":"view  <code>instance-attribute</code>","text":"<pre><code>view: ComponentView\n</code></pre> <p>See source code</p> <p>Instance of <code>ComponentView</code> available at component render time.</p>"},{"location":"reference/api/#django_components.Component.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>See source code</p> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> <p>Read more on Component views and URLs.</p>"},{"location":"reference/api/#django_components.Component.get_context_data","title":"get_context_data","text":"<pre><code>get_context_data(*_args: Any, **_kwargs: Any) -&gt; Optional[Mapping]\n</code></pre> <p>See source code</p> <p>DEPRECATED: Use <code>get_template_data()</code> instead. Will be removed in v2.</p> <p>Use this method to define variables that will be available in the template.</p> <p>Receives the args and kwargs as they were passed to the Component.</p> <p>This method has access to the Render API.</p> <p>Read more about Template variables.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_context_data(self, name, *args, **kwargs):\n        return {\n            \"name\": name,\n            \"id\": self.id,\n        }\n\n    template = \"Hello, {{ name }}!\"\n\nMyComponent.render(name=\"World\")\n</code></pre> <p>Warning</p> <p><code>get_context_data()</code> and <code>get_template_data()</code> are mutually exclusive.</p> <p>If both methods return non-empty dictionaries, an error will be raised.</p>"},{"location":"reference/api/#django_components.Component.get_css_data","title":"get_css_data","text":"<pre><code>get_css_data(args: Any, kwargs: Any, slots: Any, context: Context) -&gt; Optional[Mapping]\n</code></pre> <p>See source code</p> <p>Use this method to define variables that will be available from within the component's CSS code.</p> <p>This method has access to the Render API.</p> <p>The data returned from this method will be serialized to string.</p> <p>Read more about CSS variables.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs[\"color\"],\n        }\n\n    css = '''\n        .my-class {\n            color: var(--color);\n        }\n    '''\n\nMyComponent.render(color=\"red\")\n</code></pre> <p>Args:</p> <ul> <li><code>args</code>: Positional arguments passed to the component.</li> <li><code>kwargs</code>: Keyword arguments passed to the component.</li> <li><code>slots</code>: Slots passed to the component.</li> <li><code>context</code>: <code>Context</code>    used for rendering the component template.</li> </ul> <p>Pass-through kwargs:</p> <p>It's best practice to explicitly define what args and kwargs a component accepts.</p> <p>However, if you want a looser setup, you can easily write components that accept any number of kwargs, and pass them all to the CSS code.</p> <p>To do that, simply return the <code>kwargs</code> dictionary itself from <code>get_css_data()</code>:</p> <pre><code>class MyComponent(Component):\n    def get_css_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre> <p>Type hints:</p> <p>To get type hints for the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters, you can define the <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes on the component class, and then directly reference them in the function signature of <code>get_css_data()</code>.</p> <p>When you set these classes, the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as instances of these (<code>args</code> instance of <code>Args</code>, etc).</p> <p>When you omit these classes, or set them to <code>None</code>, then the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as plain lists / dictionaries, unmodified.</p> <p>Read more on Typing and validation.</p> <p>Example:</p> <pre><code>from typing import NamedTuple\nfrom django.template import Context\nfrom django_components import Component, SlotInput\n\nclass MyComponent(Component):\n    class Args(NamedTuple):\n        color: str\n\n    class Kwargs(NamedTuple):\n        size: int\n\n    class Slots(NamedTuple):\n        footer: SlotInput\n\n    def get_css_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        assert isinstance(args, MyComponent.Args)\n        assert isinstance(kwargs, MyComponent.Kwargs)\n        assert isinstance(slots, MyComponent.Slots)\n\n        return {\n            \"color\": args.color,\n            \"size\": kwargs.size,\n        }\n</code></pre> <p>You can also add typing to the data returned from <code>get_css_data()</code> by defining the <code>CssData</code> class on the component class.</p> <p>When you set this class, you can return either the data as a plain dictionary, or an instance of <code>CssData</code>.</p> <p>If you return plain dictionary, the data will be validated against the <code>CssData</code> class by instantiating it with the dictionary.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class CssData(NamedTuple):\n        color: str\n        size: int\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs[\"color\"],\n            \"size\": kwargs[\"size\"],\n        }\n        # or\n        return MyComponent.CssData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre>"},{"location":"reference/api/#django_components.Component.get_js_data","title":"get_js_data","text":"<pre><code>get_js_data(args: Any, kwargs: Any, slots: Any, context: Context) -&gt; Optional[Mapping]\n</code></pre> <p>See source code</p> <p>Use this method to define variables that will be available from within the component's JavaScript code.</p> <p>This method has access to the Render API.</p> <p>The data returned from this method will be serialized to JSON.</p> <p>Read more about JavaScript variables.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"name\": kwargs[\"name\"],\n            \"id\": self.id,\n        }\n\n    js = '''\n        $onLoad(({ name, id }) =&gt; {\n            console.log(name, id);\n        });\n    '''\n\nMyComponent.render(name=\"World\")\n</code></pre> <p>Args:</p> <ul> <li><code>args</code>: Positional arguments passed to the component.</li> <li><code>kwargs</code>: Keyword arguments passed to the component.</li> <li><code>slots</code>: Slots passed to the component.</li> <li><code>context</code>: <code>Context</code>    used for rendering the component template.</li> </ul> <p>Pass-through kwargs:</p> <p>It's best practice to explicitly define what args and kwargs a component accepts.</p> <p>However, if you want a looser setup, you can easily write components that accept any number of kwargs, and pass them all to the JavaScript code.</p> <p>To do that, simply return the <code>kwargs</code> dictionary itself from <code>get_js_data()</code>:</p> <pre><code>class MyComponent(Component):\n    def get_js_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre> <p>Type hints:</p> <p>To get type hints for the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters, you can define the <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes on the component class, and then directly reference them in the function signature of <code>get_js_data()</code>.</p> <p>When you set these classes, the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as instances of these (<code>args</code> instance of <code>Args</code>, etc).</p> <p>When you omit these classes, or set them to <code>None</code>, then the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as plain lists / dictionaries, unmodified.</p> <p>Read more on Typing and validation.</p> <p>Example:</p> <pre><code>from typing import NamedTuple\nfrom django.template import Context\nfrom django_components import Component, SlotInput\n\nclass MyComponent(Component):\n    class Args(NamedTuple):\n        color: str\n\n    class Kwargs(NamedTuple):\n        size: int\n\n    class Slots(NamedTuple):\n        footer: SlotInput\n\n    def get_js_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        assert isinstance(args, MyComponent.Args)\n        assert isinstance(kwargs, MyComponent.Kwargs)\n        assert isinstance(slots, MyComponent.Slots)\n\n        return {\n            \"color\": args.color,\n            \"size\": kwargs.size,\n            \"id\": self.id,\n        }\n</code></pre> <p>You can also add typing to the data returned from <code>get_js_data()</code> by defining the <code>JsData</code> class on the component class.</p> <p>When you set this class, you can return either the data as a plain dictionary, or an instance of <code>JsData</code>.</p> <p>If you return plain dictionary, the data will be validated against the <code>JsData</code> class by instantiating it with the dictionary.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class JsData(NamedTuple):\n        color: str\n        size: int\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs[\"color\"],\n            \"size\": kwargs[\"size\"],\n        }\n        # or\n        return MyComponent.JsData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre>"},{"location":"reference/api/#django_components.Component.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>See source code</p> <p>DEPRECATED: Use instead <code>Component.template_file</code>, <code>Component.template</code> or <code>Component.on_render()</code>. Will be removed in v1.</p> <p>Same as <code>Component.template</code>, but allows to dynamically resolve the template at render time.</p> <p>The template can be either plain string or a <code>Template</code> instance.</p> <p>See <code>Component.template</code> for more info and examples.</p> <p>Warning</p> <p>Only one of <code>template</code> <code>template_file</code>, <code>get_template_name()</code>, or <code>get_template()</code> must be defined.</p> <p>Warning</p> <p>The context is not fully populated at the point when this method is called.</p> <p>If you need to access the context, either use <code>Component.on_render_before()</code> or <code>Component.on_render()</code>.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The Django template            <code>Context</code>            in which the component is rendered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[str, Template]]</code>           \u2013            <p>Optional[Union[str, Template]]: The inlined Django template string or            a <code>Template</code> instance.</p> </li> </ul>"},{"location":"reference/api/#django_components.Component.get_template_data","title":"get_template_data","text":"<pre><code>get_template_data(args: Any, kwargs: Any, slots: Any, context: Context) -&gt; Optional[Mapping]\n</code></pre> <p>See source code</p> <p>Use this method to define variables that will be available in the template.</p> <p>This method has access to the Render API.</p> <p>Read more about Template variables.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"name\": kwargs[\"name\"],\n            \"id\": self.id,\n        }\n\n    template = \"Hello, {{ name }}!\"\n\nMyComponent.render(name=\"World\")\n</code></pre> <p>Args:</p> <ul> <li><code>args</code>: Positional arguments passed to the component.</li> <li><code>kwargs</code>: Keyword arguments passed to the component.</li> <li><code>slots</code>: Slots passed to the component.</li> <li><code>context</code>: <code>Context</code>    used for rendering the component template.</li> </ul> <p>Pass-through kwargs:</p> <p>It's best practice to explicitly define what args and kwargs a component accepts.</p> <p>However, if you want a looser setup, you can easily write components that accept any number of kwargs, and pass them all to the template (similar to django-cotton).</p> <p>To do that, simply return the <code>kwargs</code> dictionary itself from <code>get_template_data()</code>:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre> <p>Type hints:</p> <p>To get type hints for the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters, you can define the <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes on the component class, and then directly reference them in the function signature of <code>get_template_data()</code>.</p> <p>When you set these classes, the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as instances of these (<code>args</code> instance of <code>Args</code>, etc).</p> <p>When you omit these classes, or set them to <code>None</code>, then the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as plain lists / dictionaries, unmodified.</p> <p>Read more on Typing and validation.</p> <p>Example:</p> <pre><code>from typing import NamedTuple\nfrom django.template import Context\nfrom django_components import Component, SlotInput\n\nclass MyComponent(Component):\n    class Args(NamedTuple):\n        color: str\n\n    class Kwargs(NamedTuple):\n        size: int\n\n    class Slots(NamedTuple):\n        footer: SlotInput\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        assert isinstance(args, MyComponent.Args)\n        assert isinstance(kwargs, MyComponent.Kwargs)\n        assert isinstance(slots, MyComponent.Slots)\n\n        return {\n            \"color\": args.color,\n            \"size\": kwargs.size,\n            \"id\": self.id,\n        }\n</code></pre> <p>You can also add typing to the data returned from <code>get_template_data()</code> by defining the <code>TemplateData</code> class on the component class.</p> <p>When you set this class, you can return either the data as a plain dictionary, or an instance of <code>TemplateData</code>.</p> <p>If you return plain dictionary, the data will be validated against the <code>TemplateData</code> class by instantiating it with the dictionary.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class TemplateData(NamedTuple):\n        color: str\n        size: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs[\"color\"],\n            \"size\": kwargs[\"size\"],\n        }\n        # or\n        return MyComponent.TemplateData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre> <p>Warning</p> <p><code>get_template_data()</code> and <code>get_context_data()</code> are mutually exclusive.</p> <p>If both methods return non-empty dictionaries, an error will be raised.</p>"},{"location":"reference/api/#django_components.Component.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>DEPRECATED: Use instead <code>Component.template_file</code>, <code>Component.template</code> or <code>Component.on_render()</code>. Will be removed in v1.</p> <p>Same as <code>Component.template_file</code>, but allows to dynamically resolve the template name at render time.</p> <p>See <code>Component.template_file</code> for more info and examples.</p> <p>Warning</p> <p>The context is not fully populated at the point when this method is called.</p> <p>If you need to access the context, either use <code>Component.on_render_before()</code> or <code>Component.on_render()</code>.</p> <p>Warning</p> <p>Only one of <code>template_file</code>, <code>get_template_name()</code>, <code>template</code> or <code>get_template()</code> must be defined.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The Django template                <code>Context</code>                in which the component is rendered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[str]</code>           \u2013            <p>Optional[str]: The filepath to the template.</p> </li> </ul>"},{"location":"reference/api/#django_components.Component.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>See source code</p> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>{% provide %}</code> tag with given key was NOT found.</p> <p>This method is part of the Render API, and raises an error if called from outside the rendering execution.</p> <p>Read more about Provide / Inject.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"my_provide\" message=\"hello\" %}\n    {% component \"my_comp\" / %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ message }}!\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        data = self.inject(\"my_provide\")\n        message = data.message\n        return {\"message\": message}\n</code></pre></p> <p>This renders into: <pre><code>hi hello!\n</code></pre></p> <p>As the <code>{{ message }}</code> is taken from the \"my_provide\" provider.</p>"},{"location":"reference/api/#django_components.Component.on_render","title":"on_render","text":"<pre><code>on_render(context: Context, template: Optional[Template]) -&gt; Union[SlotResult, OnRenderGenerator, None]\n</code></pre> <p>See source code</p> <p>This method does the actual rendering.</p> <p>Read more about this hook in Component hooks.</p> <p>You can override this method to:</p> <ul> <li>Change what template gets rendered</li> <li>Modify the context</li> <li>Modify the rendered output after it has been rendered</li> <li>Handle errors</li> </ul> <p>The default implementation renders the component's Template with the given Context.</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        if template is None:\n            return None\n        else:\n            return template.render(context)\n</code></pre> <p>The <code>template</code> argument is <code>None</code> if the component has no template.</p> <p>Modifying rendered template</p> <p>To change what gets rendered, you can:</p> <ul> <li>Render a different template</li> <li>Render a component</li> <li>Return a different string or SafeString</li> </ul> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        return \"Hello\"\n</code></pre> <p>Post-processing rendered template</p> <p>To access the final output, you can <code>yield</code> the result instead of returning it.</p> <p>This will return a tuple of (rendered HTML, error). The error is <code>None</code> if the rendering succeeded.</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n\n        if error is None:\n            # The rendering succeeded\n            return html\n        else:\n            # The rendering failed\n            print(f\"Error: {error}\")\n</code></pre> <p>At this point you can do 3 things:</p> <ol> <li> <p>Return a new HTML</p> <p>The new HTML will be used as the final output.</p> <p>If the original template raised an error, it will be ignored.</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n\n        return \"NEW HTML\"\n</code></pre> </li> <li> <p>Raise a new exception</p> <p>The new exception is what will bubble up from the component.</p> <p>The original HTML and original error will be ignored.</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n\n        raise Exception(\"Error message\")\n</code></pre> </li> <li> <p>Return nothing (or <code>None</code>) to handle the result as usual</p> <p>If you don't raise an exception, and neither return a new HTML, then original HTML / error will be used:</p> <ul> <li>If rendering succeeded, the original HTML will be used as the final output.</li> <li>If rendering failed, the original error will be propagated.</li> </ul> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n\n        if error is not None:\n            # The rendering failed\n            print(f\"Error: {error}\")\n</code></pre> </li> </ol> <p>Multiple yields</p> <p>You can yield multiple times within the same <code>on_render</code> method. This is useful for complex rendering scenarios where you need to render different templates or handle multiple rendering operations:</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        # First yield - render with one context\n        with context.push({\"mode\": \"header\"}):\n            header_html, header_error = yield lambda: template.render(context)\n\n        # Second yield - render with different context\n        with context.push({\"mode\": \"body\"}):\n            body_html, body_error = yield lambda: template.render(context)\n\n        # Third yield - render a string directly\n        footer_html, footer_error = yield \"Footer content\"\n\n        # Process all results and return final output\n        if header_error or body_error or footer_error:\n            return \"Error occurred during rendering\"\n\n        return f\"{header_html}{body_html}{footer_html}\"\n</code></pre> <p>Each yield operation is independent and returns its own <code>(html, error)</code> tuple, allowing you to handle each rendering result separately.</p>"},{"location":"reference/api/#django_components.Component.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Optional[Template], result: Optional[str], error: Optional[Exception]) -&gt; Optional[SlotResult]\n</code></pre> <p>See source code</p> <p>Hook that runs when the component was fully rendered, including all its children.</p> <p>It receives the same arguments as <code>on_render_before()</code>, plus the outcome of the rendering:</p> <ul> <li><code>result</code>: The rendered output of the component. <code>None</code> if the rendering failed.</li> <li><code>error</code>: The error that occurred during the rendering, or <code>None</code> if the rendering succeeded.</li> </ul> <p><code>on_render_after()</code> behaves the same way as the second part of <code>on_render()</code> (after the <code>yield</code>).</p> <pre><code>class MyTable(Component):\n    def on_render_after(self, context, template, result, error):\n        if error is None:\n            # The rendering succeeded\n            return result\n        else:\n            # The rendering failed\n            print(f\"Error: {error}\")\n</code></pre> <p>Same as <code>on_render()</code>, you can return a new HTML, raise a new exception, or return nothing:</p> <ol> <li> <p>Return a new HTML</p> <p>The new HTML will be used as the final output.</p> <p>If the original template raised an error, it will be ignored.</p> <pre><code>class MyTable(Component):\n    def on_render_after(self, context, template, result, error):\n        return \"NEW HTML\"\n</code></pre> </li> <li> <p>Raise a new exception</p> <p>The new exception is what will bubble up from the component.</p> <p>The original HTML and original error will be ignored.</p> <pre><code>class MyTable(Component):\n    def on_render_after(self, context, template, result, error):\n        raise Exception(\"Error message\")\n</code></pre> </li> <li> <p>Return nothing (or <code>None</code>) to handle the result as usual</p> <p>If you don't raise an exception, and neither return a new HTML, then original HTML / error will be used:</p> <ul> <li>If rendering succeeded, the original HTML will be used as the final output.</li> <li>If rendering failed, the original error will be propagated.</li> </ul> <pre><code>class MyTable(Component):\n    def on_render_after(self, context, template, result, error):\n        if error is not None:\n            # The rendering failed\n            print(f\"Error: {error}\")\n</code></pre> </li> </ol>"},{"location":"reference/api/#django_components.Component.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Optional[Template]) -&gt; None\n</code></pre> <p>See source code</p> <p>Runs just before the component's template is rendered.</p> <p>It is called for every component, including nested ones, as part of the component render lifecycle.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The Django Context that will be used to render the component's template.</p> </li> <li> <code>template</code>               (<code>Optional[Template]</code>)           \u2013            <p>The Django Template instance that will be rendered, or <code>None</code> if no template.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None. This hook is for side effects only.</p> </li> </ul> <p>Example:</p> <p>You can use this hook to access the context or the template:</p> <pre><code>from django.template import Context, Template\nfrom django_components import Component\n\nclass MyTable(Component):\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        # Insert value into the Context\n        context[\"from_on_before\"] = \":)\"\n\n        assert isinstance(template, Template)\n</code></pre> <p>Warning</p> <p>If you want to pass data to the template, prefer using <code>get_template_data()</code> instead of this hook.</p> <p>Warning</p> <p>Do NOT modify the template in this hook. The template is reused across renders.</p> <p>Since this hook is called for every component, this means that the template would be modified every time a component is rendered.</p>"},{"location":"reference/api/#django_components.Component.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(context: Optional[Union[Dict[str, Any], Context]] = None, args: Optional[Any] = None, kwargs: Optional[Any] = None, slots: Optional[Any] = None, deps_strategy: DependenciesStrategy = 'document', type: Optional[DependenciesStrategy] = None, render_dependencies: bool = True, request: Optional[HttpRequest] = None, outer_context: Optional[Context] = None, registry: Optional[ComponentRegistry] = None, registered_name: Optional[str] = None, node: Optional[ComponentNode] = None) -&gt; str\n</code></pre> <p>See source code</p> <p>Render the component into a string. This is the equivalent of calling the <code>{% component %}</code> tag.</p> <pre><code>Button.render(\n    args=[\"John\"],\n    kwargs={\n        \"surname\": \"Doe\",\n        \"age\": 30,\n    },\n    slots={\n        \"footer\": \"i AM A SLOT\",\n    },\n)\n</code></pre> <p>Inputs:</p> <ul> <li> <p><code>args</code> - Optional. A list of positional args for the component. This is the same as calling the component   as:</p> <pre><code>{% component \"button\" arg1 arg2 ... %}\n</code></pre> </li> <li> <p><code>kwargs</code> - Optional. A dictionary of keyword arguments for the component. This is the same as calling   the component as:</p> <pre><code>{% component \"button\" key1=val1 key2=val2 ... %}\n</code></pre> </li> <li> <p><code>slots</code> - Optional. A dictionary of slot fills. This is the same as passing <code>{% fill %}</code>     tags to the component.</p> <pre><code>{% component \"button\" %}\n    {% fill \"content\" %}\n        Click me!\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Dictionary keys are the slot names. Dictionary values are the slot fills.</p> <p>Slot fills can be strings, render functions, or <code>Slot</code> instances:</p> <pre><code>Button.render(\n    slots={\n        \"content\": \"Click me!\"\n        \"content2\": lambda ctx: \"Click me!\",\n        \"content3\": Slot(lambda ctx: \"Click me!\"),\n    },\n)\n</code></pre> </li> <li> <p><code>context</code> - Optional. Plain dictionary or Django's     Context.     The context within which the component is rendered.</p> <p>When a component is rendered within a template with the <code>{% component %}</code> tag, this will be set to the Context instance that is used for rendering the template.</p> <p>When you call <code>Component.render()</code> directly from Python, you can ignore this input most of the time. Instead use <code>args</code>, <code>kwargs</code>, and <code>slots</code> to pass data to the component.</p> <p>You can pass <code>RequestContext</code> to the <code>context</code> argument, so that the component will gain access to the request object and will use context processors. Read more on Working with HTTP requests.</p> <pre><code>Button.render(\n    context=RequestContext(request),\n)\n</code></pre> <p>For advanced use cases, you can use <code>context</code> argument to \"pre-render\" the component in Python, and then pass the rendered output as plain string to the template. With this, the inner component is rendered as if it was within the template with <code>{% component %}</code>.</p> <pre><code>class Button(Component):\n    def render(self, context, template):\n        # Pass `context` to Icon component so it is rendered\n        # as if nested within Button.\n        icon = Icon.render(\n            context=context,\n            args=[\"icon-name\"],\n            deps_strategy=\"ignore\",\n        )\n        # Update context with icon\n        with context.update({\"icon\": icon}):\n            return template.render(context)\n</code></pre> <p>Whether the variables defined in <code>context</code> are available to the template depends on the context behavior mode:</p> <ul> <li> <p>In <code>\"django\"</code> context behavior mode, the template will have access to the keys of this context.</p> </li> <li> <p>In <code>\"isolated\"</code> context behavior mode, the template will NOT have access to this context,     and data MUST be passed via component's args and kwargs.</p> </li> </ul> </li> <li> <p><code>deps_strategy</code> - Optional. Configure how to handle JS and CSS dependencies. Read more about     Dependencies rendering.</p> <p>There are six strategies:</p> <ul> <li><code>\"document\"</code> (default)<ul> <li>Smartly inserts JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Requires the HTML to be rendered in a JS-enabled browser.</li> <li>Inserts extra script for managing fragments.</li> </ul> </li> <li><code>\"fragment\"</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>Fragment will fetch its own JS / CSS dependencies when inserted into the page.</li> <li>Requires the HTML to be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>\"simple\"</code><ul> <li>Smartly insert JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"prepend\"</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"append\"</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"ignore\"</code><ul> <li>HTML is left as-is. You can still process it with a different strategy later with   <code>render_dependencies()</code>.</li> <li>Used for inserting rendered HTML into other components.</li> </ul> </li> </ul> </li> <li> <p><code>request</code> - Optional. HTTPRequest object. Pass a request object directly to the component to apply     context processors.</p> <p>Read more about Working with HTTP requests.</p> </li> </ul> <p>Type hints:</p> <p><code>Component.render()</code> is NOT typed. To add type hints, you can wrap the inputs in component's <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes.</p> <p>Read more on Typing and validation.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, Slot, SlotInput\n\n# Define the component with the types\nclass Button(Component):\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        footer: SlotInput\n\n# Add type hints to the render call\nButton.render(\n    args=Button.Args(\n        name=\"John\",\n    ),\n    kwargs=Button.Kwargs(\n        surname=\"Doe\",\n        age=30,\n    ),\n    slots=Button.Slots(\n        footer=Slot(lambda ctx: \"Click me!\"),\n    ),\n)\n</code></pre>"},{"location":"reference/api/#django_components.Component.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(context: Optional[Union[Dict[str, Any], Context]] = None, args: Optional[Any] = None, kwargs: Optional[Any] = None, slots: Optional[Any] = None, deps_strategy: DependenciesStrategy = 'document', type: Optional[DependenciesStrategy] = None, render_dependencies: bool = True, request: Optional[HttpRequest] = None, outer_context: Optional[Context] = None, registry: Optional[ComponentRegistry] = None, registered_name: Optional[str] = None, node: Optional[ComponentNode] = None, **response_kwargs: Any) -&gt; HttpResponse\n</code></pre> <p>See source code</p> <p>Render the component and wrap the content in an HTTP response class.</p> <p><code>render_to_response()</code> takes the same inputs as <code>Component.render()</code>. See that method for more information.</p> <p>After the component is rendered, the HTTP response class is instantiated with the rendered content.</p> <p>Any additional kwargs are passed to the response class.</p> <p>Example:</p> <pre><code>Button.render_to_response(\n    args=[\"John\"],\n    kwargs={\n        \"surname\": \"Doe\",\n        \"age\": 30,\n    },\n    slots={\n        \"footer\": \"i AM A SLOT\",\n    },\n    # HttpResponse kwargs\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre> <p>Custom response class:</p> <p>You can set a custom response class on the component via <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <pre><code>from django.http import HttpResponse\nfrom django_components import Component\n\nclass MyHttpResponse(HttpResponse):\n    ...\n\nclass MyComponent(Component):\n    response_class = MyHttpResponse\n\nresponse = MyComponent.render_to_response()\nassert isinstance(response, MyHttpResponse)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache","title":"ComponentCache","text":"<pre><code>ComponentCache(component: Component)\n</code></pre> <p>Bases: <code>django_components.extension.ExtensionComponentConfig</code></p> <p>See source code</p> <p>The interface for <code>Component.Cache</code>.</p> <p>The fields of this class are used to configure the component caching.</p> <p>Read more about Component caching.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n        cache_name = \"my_cache\"\n</code></pre> <p>Methods:</p> <ul> <li> <code>get_cache</code>             \u2013              </li> <li> <code>get_cache_key</code>             \u2013              </li> <li> <code>get_entry</code>             \u2013              </li> <li> <code>hash</code>             \u2013              </li> <li> <code>hash_slots</code>             \u2013              </li> <li> <code>set_entry</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cache_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_class</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>enabled</code>               (<code>bool</code>)           \u2013            </li> <li> <code>include_slots</code>               (<code>bool</code>)           \u2013            </li> <li> <code>ttl</code>               (<code>Optional[int]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentCache.cache_name","title":"cache_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The name of the cache to use. If <code>None</code>, the default cache will be used.</p>"},{"location":"reference/api/#django_components.ComponentCache.component","title":"component  <code>property</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>When a <code>Component</code> is instantiated, also the nested extension classes (such as <code>Component.View</code>) are instantiated, receiving the component instance as an argument.</p> <p>This attribute holds the owner <code>Component</code> instance that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentCache.component_class","title":"component_class  <code>instance-attribute</code>","text":"<pre><code>component_class: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentCache.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentCache.enabled","title":"enabled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enabled: bool = False\n</code></pre> <p>See source code</p> <p>Whether this Component should be cached. Defaults to <code>False</code>.</p>"},{"location":"reference/api/#django_components.ComponentCache.include_slots","title":"include_slots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>include_slots: bool = False\n</code></pre> <p>See source code</p> <p>Whether the slots should be hashed into the cache key.</p> <p>If enabled, the following two cases will be treated as different entries:</p> <pre><code>{% component \"mycomponent\" name=\"foo\" %}\n    FILL ONE\n{% endcomponent %}\n\n{% component \"mycomponent\" name=\"foo\" %}\n    FILL TWO\n{% endcomponent %}\n</code></pre> <p>Warning</p> <p>Passing slots as functions to cached components with <code>include_slots=True</code> will raise an error.</p> <p>Warning</p> <p>Slot caching DOES NOT account for context variables within the <code>{% fill %}</code> tag.</p> <p>For example, the following two cases will be treated as the same entry:</p> <pre><code>{% with my_var=\"foo\" %}\n    {% component \"mycomponent\" name=\"foo\" %}\n        {{ my_var }}\n    {% endcomponent %}\n{% endwith %}\n\n{% with my_var=\"bar\" %}\n    {% component \"mycomponent\" name=\"bar\" %}\n        {{ my_var }}\n    {% endcomponent %}\n{% endwith %}\n</code></pre> <p>Currently it's impossible to capture used variables. This will be addressed in v2. Read more about it in https://github.com/django-components/django-components/issues/1164.</p>"},{"location":"reference/api/#django_components.ComponentCache.ttl","title":"ttl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ttl: Optional[int] = None\n</code></pre> <p>See source code</p> <p>The time-to-live (TTL) in seconds, i.e. for how long should an entry be valid in the cache.</p> <ul> <li>If <code>&gt; 0</code>, the entries will be cached for the given number of seconds.</li> <li>If <code>-1</code>, the entries will be cached indefinitely.</li> <li>If <code>0</code>, the entries won't be cached.</li> <li>If <code>None</code>, the default TTL will be used.</li> </ul>"},{"location":"reference/api/#django_components.ComponentCache.get_cache","title":"get_cache","text":"<pre><code>get_cache() -&gt; BaseCache\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache.get_cache_key","title":"get_cache_key","text":"<pre><code>get_cache_key(args: List, kwargs: Dict, slots: Dict) -&gt; str\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache.get_entry","title":"get_entry","text":"<pre><code>get_entry(cache_key: str) -&gt; Any\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache.hash","title":"hash","text":"<pre><code>hash(args: List, kwargs: Dict) -&gt; str\n</code></pre> <p>See source code</p> <p>Defines how the input (both args and kwargs) is hashed into a cache key.</p> <p>By default, <code>hash()</code> serializes the input into a string. As such, the default implementation might NOT be suitable if you need to hash complex objects.</p>"},{"location":"reference/api/#django_components.ComponentCache.hash_slots","title":"hash_slots","text":"<pre><code>hash_slots(slots: Dict[str, Slot]) -&gt; str\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache.set_entry","title":"set_entry","text":"<pre><code>set_entry(cache_key: str, value: Any) -&gt; None\n</code></pre>"},{"location":"reference/api/#django_components.ComponentDebugHighlight","title":"ComponentDebugHighlight","text":"<pre><code>ComponentDebugHighlight(component: Component)\n</code></pre> <p>Bases: <code>django_components.extension.ExtensionComponentConfig</code></p> <p>See source code</p> <p>The interface for <code>Component.DebugHighlight</code>.</p> <p>The fields of this class are used to configure the component debug highlighting for this component and its direct slots.</p> <p>Read more about Component debug highlighting.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class DebugHighlight:\n        highlight_components = True\n        highlight_slots = True\n</code></pre> <p>To highlight ALL components and slots, set extension defaults in your settings:</p> <pre><code>from django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    extensions_defaults={\n        \"debug_highlight\": {\n            \"highlight_components\": True,\n            \"highlight_slots\": True,\n        },\n    },\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_class</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>highlight_components</code>           \u2013            </li> <li> <code>highlight_slots</code>           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentDebugHighlight.component","title":"component  <code>property</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>When a <code>Component</code> is instantiated, also the nested extension classes (such as <code>Component.View</code>) are instantiated, receiving the component instance as an argument.</p> <p>This attribute holds the owner <code>Component</code> instance that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentDebugHighlight.component_class","title":"component_class  <code>instance-attribute</code>","text":"<pre><code>component_class: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentDebugHighlight.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentDebugHighlight.highlight_components","title":"highlight_components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_components = HighlightComponentsDescriptor()\n</code></pre> <p>See source code</p> <p>Whether to highlight this component in the rendered output.</p>"},{"location":"reference/api/#django_components.ComponentDebugHighlight.highlight_slots","title":"highlight_slots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlight_slots = HighlightSlotsDescriptor()\n</code></pre> <p>See source code</p> <p>Whether to highlight slots of this component in the rendered output.</p>"},{"location":"reference/api/#django_components.ComponentDefaults","title":"ComponentDefaults","text":"<pre><code>ComponentDefaults(component: Component)\n</code></pre> <p>Bases: <code>django_components.extension.ExtensionComponentConfig</code></p> <p>See source code</p> <p>The interface for <code>Component.Defaults</code>.</p> <p>The fields of this class are used to set default values for the component's kwargs.</p> <p>Read more about Component defaults.</p> <p>Example:</p> <pre><code>from django_components import Component, Default\n\nclass MyComponent(Component):\n    class Defaults:\n        position = \"left\"\n        selected_items = Default(lambda: [1, 2, 3])\n</code></pre> <p>Attributes:</p> <ul> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_class</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentDefaults.component","title":"component  <code>property</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>When a <code>Component</code> is instantiated, also the nested extension classes (such as <code>Component.View</code>) are instantiated, receiving the component instance as an argument.</p> <p>This attribute holds the owner <code>Component</code> instance that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentDefaults.component_class","title":"component_class  <code>instance-attribute</code>","text":"<pre><code>component_class: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentDefaults.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentExtension","title":"ComponentExtension","text":"<p>Bases: <code>object</code></p> <p>See source code</p> <p>Base class for all extensions.</p> <p>Read more on Extensions.</p> <p>Example:</p> <pre><code>class ExampleExtension(ComponentExtension):\n    name = \"example\"\n\n    # Component-level behavior and settings. User will be able to override\n    # the attributes and methods defined here on the component classes.\n    class ComponentConfig(ComponentExtension.ComponentConfig):\n        foo = \"1\"\n        bar = \"2\"\n\n        def baz(cls):\n            return \"3\"\n\n    # URLs\n    urls = [\n        URLRoute(path=\"dummy-view/\", handler=dummy_view, name=\"dummy\"),\n        URLRoute(path=\"dummy-view-2/&lt;int:id&gt;/&lt;str:name&gt;/\", handler=dummy_view_2, name=\"dummy-2\"),\n    ]\n\n    # Commands\n    commands = [\n        HelloWorldCommand,\n    ]\n\n    # Hooks\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext) -&gt; None:\n        print(ctx.component_cls.__name__)\n\n    def on_component_class_deleted(self, ctx: OnComponentClassDeletedContext) -&gt; None:\n        print(ctx.component_cls.__name__)\n</code></pre> <p>Which users then can override on a per-component basis. E.g.:</p> <pre><code>class MyComp(Component):\n    class Example:\n        foo = \"overridden\"\n\n        def baz(self):\n            return \"overridden baz\"\n</code></pre> <p>Methods:</p> <ul> <li> <code>on_component_class_created</code>             \u2013              </li> <li> <code>on_component_class_deleted</code>             \u2013              </li> <li> <code>on_component_data</code>             \u2013              </li> <li> <code>on_component_input</code>             \u2013              </li> <li> <code>on_component_registered</code>             \u2013              </li> <li> <code>on_component_rendered</code>             \u2013              </li> <li> <code>on_component_unregistered</code>             \u2013              </li> <li> <code>on_css_loaded</code>             \u2013              </li> <li> <code>on_js_loaded</code>             \u2013              </li> <li> <code>on_registry_created</code>             \u2013              </li> <li> <code>on_registry_deleted</code>             \u2013              </li> <li> <code>on_slot_rendered</code>             \u2013              </li> <li> <code>on_template_compiled</code>             \u2013              </li> <li> <code>on_template_loaded</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>ComponentConfig</code>               (<code>Type[ExtensionComponentConfig]</code>)           \u2013            </li> <li> <code>class_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>commands</code>               (<code>List[Type[ComponentCommand]]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>urls</code>               (<code>List[URLRoute]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentExtension.ComponentConfig","title":"ComponentConfig  <code>class-attribute</code>","text":"<pre><code>ComponentConfig: Type[ExtensionComponentConfig] = ExtensionComponentConfig\n</code></pre> <p>See source code</p> <p>Base class that the \"component-level\" extension config nested within a <code>Component</code> class will inherit from.</p> <p>This is where you can define new methods and attributes that will be available to the component instance.</p> <p>Background:</p> <p>The extension may add new features to the <code>Component</code> class by allowing users to define and access a nested class in the <code>Component</code> class. E.g.:</p> <pre><code>class MyComp(Component):\n    class MyExtension:\n        ...\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"my_extension\": self.my_extension.do_something(),\n        }\n</code></pre> <p>When rendering a component, the nested extension class will be set as a subclass of <code>ComponentConfig</code>. So it will be same as if the user had directly inherited from extension's <code>ComponentConfig</code>. E.g.:</p> <pre><code>class MyComp(Component):\n    class MyExtension(ComponentExtension.ComponentConfig):\n        ...\n</code></pre> <p>This setting decides what the extension class will inherit from.</p>"},{"location":"reference/api/#django_components.ComponentExtension.class_name","title":"class_name  <code>class-attribute</code>","text":"<pre><code>class_name: str\n</code></pre> <p>See source code</p> <p>Name of the extension class.</p> <p>By default, this is set automatically at class creation. The class name is the same as the <code>name</code> attribute, but with snake_case converted to PascalCase.</p> <p>So if the extension name is <code>\"my_extension\"</code>, then the extension class name will be <code>\"MyExtension\"</code>.</p> <pre><code>class MyComp(Component):\n    class MyExtension:  # &lt;--- This is the extension class\n        ...\n</code></pre> <p>To customize the class name, you can manually set the <code>class_name</code> attribute.</p> <p>The class name must be a valid Python identifier.</p> <p>Example:</p> <pre><code>class MyExt(ComponentExtension):\n    name = \"my_extension\"\n    class_name = \"MyCustomExtension\"\n</code></pre> <p>This will make the extension class name <code>\"MyCustomExtension\"</code>.</p> <pre><code>class MyComp(Component):\n    class MyCustomExtension:  # &lt;--- This is the extension class\n        ...\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.commands","title":"commands  <code>class-attribute</code>","text":"<pre><code>commands: List[Type[ComponentCommand]] = []\n</code></pre> <p>See source code</p> <p>List of commands that can be run by the extension.</p> <p>These commands will be available to the user as <code>components ext run &lt;extension&gt; &lt;command&gt;</code>.</p> <p>Commands are defined as subclasses of <code>ComponentCommand</code>.</p> <p>Example:</p> <p>This example defines an extension with a command that prints \"Hello world\". To run the command, the user would run <code>components ext run hello_world hello</code>.</p> <pre><code>from django_components import ComponentCommand, ComponentExtension, CommandArg, CommandArgGroup\n\nclass HelloWorldCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Hello world command.\"\n\n    # Allow to pass flags `--foo`, `--bar` and `--baz`.\n    # Argument parsing is managed by `argparse`.\n    arguments = [\n        CommandArg(\n            name_or_flags=\"--foo\",\n            help=\"Foo description.\",\n        ),\n        # When printing the command help message, `bar` and `baz`\n        # will be grouped under \"group bar\".\n        CommandArgGroup(\n            title=\"group bar\",\n            description=\"Group description.\",\n            arguments=[\n                CommandArg(\n                    name_or_flags=\"--bar\",\n                    help=\"Bar description.\",\n                ),\n                CommandArg(\n                    name_or_flags=\"--baz\",\n                    help=\"Baz description.\",\n                ),\n            ],\n        ),\n    ]\n\n    # Callback that receives the parsed arguments and options.\n    def handle(self, *args, **kwargs):\n        print(f\"HelloWorldCommand.handle: args={args}, kwargs={kwargs}\")\n\n# Associate the command with the extension\nclass HelloWorldExtension(ComponentExtension):\n    name = \"hello_world\"\n\n    commands = [\n        HelloWorldCommand,\n    ]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>Name of the extension.</p> <p>Name must be lowercase, and must be a valid Python identifier (e.g. <code>\"my_extension\"</code>).</p> <p>The extension may add new features to the <code>Component</code> class by allowing users to define and access a nested class in the <code>Component</code> class.</p> <p>The extension name determines the name of the nested class in the <code>Component</code> class, and the attribute under which the extension will be accessible.</p> <p>E.g. if the extension name is <code>\"my_extension\"</code>, then the nested class in the <code>Component</code> class will be <code>MyExtension</code>, and the extension will be accessible as <code>MyComp.my_extension</code>.</p> <pre><code>class MyComp(Component):\n    class MyExtension:\n        ...\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"my_extension\": self.my_extension.do_something(),\n        }\n</code></pre> <p>Info</p> <p>The extension class name can be customized by setting the <code>class_name</code> attribute.</p>"},{"location":"reference/api/#django_components.ComponentExtension.urls","title":"urls  <code>class-attribute</code>","text":"<pre><code>urls: List[URLRoute] = []\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_class_created","title":"on_component_class_created","text":"<pre><code>on_component_class_created(ctx: OnComponentClassCreatedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a new <code>Component</code> class is created.</p> <p>This hook is called after the <code>Component</code> class is fully defined but before it's registered.</p> <p>Use this hook to perform any initialization or validation of the <code>Component</code> class.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentClassCreatedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext) -&gt; None:\n        # Add a new attribute to the Component class\n        ctx.component_cls.my_attr = \"my_value\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_class_deleted","title":"on_component_class_deleted","text":"<pre><code>on_component_class_deleted(ctx: OnComponentClassDeletedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is being deleted.</p> <p>This hook is called before the <code>Component</code> class is deleted from memory.</p> <p>Use this hook to perform any cleanup related to the <code>Component</code> class.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentClassDeletedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_class_deleted(self, ctx: OnComponentClassDeletedContext) -&gt; None:\n        # Remove Component class from the extension's cache on deletion\n        self.cache.pop(ctx.component_cls, None)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_data","title":"on_component_data","text":"<pre><code>on_component_data(ctx: OnComponentDataContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was triggered to render, after a component's context and data methods have been processed.</p> <p>This hook is called after <code>Component.get_template_data()</code>, <code>Component.get_js_data()</code> and <code>Component.get_css_data()</code>.</p> <p>This hook runs after <code>on_component_input</code>.</p> <p>Use this hook to modify or validate the component's data before rendering.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentDataContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_data(self, ctx: OnComponentDataContext) -&gt; None:\n        # Add extra template variable to all components when they are rendered\n        ctx.template_data[\"my_template_var\"] = \"my_value\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_input","title":"on_component_input","text":"<pre><code>on_component_input(ctx: OnComponentInputContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was triggered to render, but before a component's context and data methods are invoked.</p> <p>Use this hook to modify or validate component inputs before they're processed.</p> <p>This is the first hook that is called when rendering a component. As such this hook is called before <code>Component.get_template_data()</code>, <code>Component.get_js_data()</code>, and <code>Component.get_css_data()</code> methods, and the <code>on_component_data</code> hook.</p> <p>This hook also allows to skip the rendering of a component altogether. If the hook returns a non-null value, this value will be used instead of rendering the component.</p> <p>You can use this to implement a caching mechanism for components, or define components that will be rendered conditionally.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentInputContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_input(self, ctx: OnComponentInputContext) -&gt; None:\n        # Add extra kwarg to all components when they are rendered\n        ctx.kwargs[\"my_input\"] = \"my_value\"\n</code></pre> <p>Warning</p> <p>In this hook, the components' inputs are still mutable.</p> <p>As such, if a component defines <code>Args</code>, <code>Kwargs</code>, <code>Slots</code> types, these types are NOT yet instantiated.</p> <p>Instead, component fields like <code>Component.args</code>, <code>Component.kwargs</code>, <code>Component.slots</code> are plain <code>list</code> / <code>dict</code> objects.</p>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_registered","title":"on_component_registered","text":"<pre><code>on_component_registered(ctx: OnComponentRegisteredContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is registered with a <code>ComponentRegistry</code>.</p> <p>This hook is called after a <code>Component</code> class is successfully registered.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentRegisteredContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_registered(self, ctx: OnComponentRegisteredContext) -&gt; None:\n        print(f\"Component {ctx.component_cls} registered to {ctx.registry} as '{ctx.name}'\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_rendered","title":"on_component_rendered","text":"<pre><code>on_component_rendered(ctx: OnComponentRenderedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was rendered, including all its child components.</p> <p>Use this hook to access or post-process the component's rendered output.</p> <p>This hook works similarly to <code>Component.on_render_after()</code>:</p> <ol> <li> <p>To modify the output, return a new string from this hook. The original output or error will be ignored.</p> </li> <li> <p>To cause this component to return a new error, raise that error. The original output and error     will be ignored.</p> </li> <li> <p>If you neither raise nor return string, the original output or error will be used.</p> </li> </ol> <p>Examples:</p> <p>Change the final output of a component:</p> <pre><code>from django_components import ComponentExtension, OnComponentRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_rendered(self, ctx: OnComponentRenderedContext) -&gt; Optional[str]:\n        # Append a comment to the component's rendered output\n        return ctx.result + \"&lt;!-- MyExtension comment --&gt;\"\n</code></pre> <p>Cause the component to raise a new exception:</p> <pre><code>from django_components import ComponentExtension, OnComponentRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_rendered(self, ctx: OnComponentRenderedContext) -&gt; Optional[str]:\n        # Raise a new exception\n        raise Exception(\"Error message\")\n</code></pre> <p>Return nothing (or <code>None</code>) to handle the result as usual:</p> <pre><code>from django_components import ComponentExtension, OnComponentRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_rendered(self, ctx: OnComponentRenderedContext) -&gt; Optional[str]:\n        if ctx.error is not None:\n            # The component raised an exception\n            print(f\"Error: {ctx.error}\")\n        else:\n            # The component rendered successfully\n            print(f\"Result: {ctx.result}\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_unregistered","title":"on_component_unregistered","text":"<pre><code>on_component_unregistered(ctx: OnComponentUnregisteredContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is unregistered from a <code>ComponentRegistry</code>.</p> <p>This hook is called after a <code>Component</code> class is removed from the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentUnregisteredContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_unregistered(self, ctx: OnComponentUnregisteredContext) -&gt; None:\n        print(f\"Component {ctx.component_cls} unregistered from {ctx.registry} as '{ctx.name}'\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_css_loaded","title":"on_css_loaded","text":"<pre><code>on_css_loaded(ctx: OnCssLoadedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a Component's CSS is loaded as a string.</p> <p>This hook runs only once per <code>Component</code> class and works for both <code>Component.css</code> and <code>Component.css_file</code>.</p> <p>Use this hook to read or modify the CSS.</p> <p>To modify the CSS, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnCssLoadedContext\n\nclass MyExtension(ComponentExtension):\n    def on_css_loaded(self, ctx: OnCssLoadedContext) -&gt; Optional[str]:\n        # Modify the CSS\n        return ctx.content.replace(\"Hello\", \"Hi\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_js_loaded","title":"on_js_loaded","text":"<pre><code>on_js_loaded(ctx: OnJsLoadedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a Component's JS is loaded as a string.</p> <p>This hook runs only once per <code>Component</code> class and works for both <code>Component.js</code> and <code>Component.js_file</code>.</p> <p>Use this hook to read or modify the JS.</p> <p>To modify the JS, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnCssLoadedContext\n\nclass MyExtension(ComponentExtension):\n    def on_js_loaded(self, ctx: OnJsLoadedContext) -&gt; Optional[str]:\n        # Modify the JS\n        return ctx.content.replace(\"Hello\", \"Hi\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_registry_created","title":"on_registry_created","text":"<pre><code>on_registry_created(ctx: OnRegistryCreatedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a new <code>ComponentRegistry</code> is created.</p> <p>This hook is called after a new <code>ComponentRegistry</code> instance is initialized.</p> <p>Use this hook to perform any initialization needed for the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnRegistryCreatedContext\n\nclass MyExtension(ComponentExtension):\n    def on_registry_created(self, ctx: OnRegistryCreatedContext) -&gt; None:\n        # Add a new attribute to the registry\n        ctx.registry.my_attr = \"my_value\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_registry_deleted","title":"on_registry_deleted","text":"<pre><code>on_registry_deleted(ctx: OnRegistryDeletedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>ComponentRegistry</code> is being deleted.</p> <p>This hook is called before a <code>ComponentRegistry</code> instance is deleted.</p> <p>Use this hook to perform any cleanup related to the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnRegistryDeletedContext\n\nclass MyExtension(ComponentExtension):\n    def on_registry_deleted(self, ctx: OnRegistryDeletedContext) -&gt; None:\n        # Remove registry from the extension's cache on deletion\n        self.cache.pop(ctx.registry, None)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_slot_rendered","title":"on_slot_rendered","text":"<pre><code>on_slot_rendered(ctx: OnSlotRenderedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>{% slot %}</code> tag was rendered.</p> <p>Use this hook to access or post-process the slot's rendered output.</p> <p>To modify the output, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnSlotRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_slot_rendered(self, ctx: OnSlotRenderedContext) -&gt; Optional[str]:\n        # Append a comment to the slot's rendered output\n        return ctx.result + \"&lt;!-- MyExtension comment --&gt;\"\n</code></pre> <p>Access slot metadata:</p> <p>You can access the <code>{% slot %}</code> tag node (<code>SlotNode</code>) and its metadata using <code>ctx.slot_node</code>.</p> <p>For example, to find the <code>Component</code> class to which belongs the template where the <code>{% slot %}</code> tag is defined, you can use <code>ctx.slot_node.template_component</code>:</p> <pre><code>from django_components import ComponentExtension, OnSlotRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_slot_rendered(self, ctx: OnSlotRenderedContext) -&gt; Optional[str]:\n        # Access slot metadata\n        slot_node = ctx.slot_node\n        slot_owner = slot_node.template_component\n        print(f\"Slot owner: {slot_owner}\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_template_compiled","title":"on_template_compiled","text":"<pre><code>on_template_compiled(ctx: OnTemplateCompiledContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a Component's template is compiled into a <code>Template</code> object.</p> <p>This hook runs only once per <code>Component</code> class and works for both <code>Component.template</code> and <code>Component.template_file</code>.</p> <p>Use this hook to read or modify the template (in-place) after it's compiled.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnTemplateCompiledContext\n\nclass MyExtension(ComponentExtension):\n    def on_template_compiled(self, ctx: OnTemplateCompiledContext) -&gt; None:\n        print(f\"Template origin: {ctx.template.origin.name}\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_template_loaded","title":"on_template_loaded","text":"<pre><code>on_template_loaded(ctx: OnTemplateLoadedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a Component's template is loaded as a string.</p> <p>This hook runs only once per <code>Component</code> class and works for both <code>Component.template</code> and <code>Component.template_file</code>.</p> <p>Use this hook to read or modify the template before it's compiled.</p> <p>To modify the template, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnTemplateLoadedContext\n\nclass MyExtension(ComponentExtension):\n    def on_template_loaded(self, ctx: OnTemplateLoadedContext) -&gt; Optional[str]:\n        # Modify the template\n        return ctx.content.replace(\"Hello\", \"Hi\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentFileEntry","title":"ComponentFileEntry","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Result returned by <code>get_component_files()</code>.</p> <p>Attributes:</p> <ul> <li> <code>dot_path</code>               (<code>str</code>)           \u2013            </li> <li> <code>filepath</code>               (<code>Path</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentFileEntry.dot_path","title":"dot_path  <code>instance-attribute</code>","text":"<pre><code>dot_path: str\n</code></pre> <p>See source code</p> <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p>"},{"location":"reference/api/#django_components.ComponentFileEntry.filepath","title":"filepath  <code>instance-attribute</code>","text":"<pre><code>filepath: Path\n</code></pre> <p>See source code</p> <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p>"},{"location":"reference/api/#django_components.ComponentInput","title":"ComponentInput  <code>dataclass</code>","text":"<pre><code>ComponentInput(context: Context, args: List, kwargs: Dict, slots: Dict[SlotName, Slot], deps_strategy: DependenciesStrategy, type: DependenciesStrategy, render_dependencies: bool)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Deprecated. Will be removed in v1.</p> <p>Object holding the inputs that were passed to <code>Component.render()</code> or the <code>{% component %}</code> template tag.</p> <p>This object is available only during render under <code>Component.input</code>.</p> <p>Read more about the Render API.</p> <p>Attributes:</p> <ul> <li> <code>args</code>               (<code>List</code>)           \u2013            </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            </li> <li> <code>deps_strategy</code>               (<code>DependenciesStrategy</code>)           \u2013            </li> <li> <code>kwargs</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>render_dependencies</code>               (<code>bool</code>)           \u2013            </li> <li> <code>slots</code>               (<code>Dict[SlotName, Slot]</code>)           \u2013            </li> <li> <code>type</code>               (<code>DependenciesStrategy</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentInput.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: List\n</code></pre> <p>See source code</p> <p>Positional arguments (as list) passed to <code>Component.render()</code></p>"},{"location":"reference/api/#django_components.ComponentInput.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Context\n</code></pre> <p>See source code</p> <p>Django's <code>Context</code> passed to <code>Component.render()</code></p>"},{"location":"reference/api/#django_components.ComponentInput.deps_strategy","title":"deps_strategy  <code>instance-attribute</code>","text":"<pre><code>deps_strategy: DependenciesStrategy\n</code></pre> <p>See source code</p> <p>Dependencies strategy passed to <code>Component.render()</code></p>"},{"location":"reference/api/#django_components.ComponentInput.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: Dict\n</code></pre> <p>See source code</p> <p>Keyword arguments (as dict) passed to <code>Component.render()</code></p>"},{"location":"reference/api/#django_components.ComponentInput.render_dependencies","title":"render_dependencies  <code>instance-attribute</code>","text":"<pre><code>render_dependencies: bool\n</code></pre> <p>See source code</p> <p>Deprecated. Will be removed in v1. Use <code>deps_strategy=\"ignore\"</code> instead.</p>"},{"location":"reference/api/#django_components.ComponentInput.slots","title":"slots  <code>instance-attribute</code>","text":"<pre><code>slots: Dict[SlotName, Slot]\n</code></pre> <p>See source code</p> <p>Slots (as dict) passed to <code>Component.render()</code></p>"},{"location":"reference/api/#django_components.ComponentInput.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: DependenciesStrategy\n</code></pre> <p>See source code</p> <p>Deprecated. Will be removed in v1. Use <code>deps_strategy</code> instead.</p>"},{"location":"reference/api/#django_components.ComponentMediaInput","title":"ComponentMediaInput","text":"<p>Bases: <code>typing.Protocol</code></p> <p>See source code</p> <p>Defines JS and CSS media files associated with a <code>Component</code>.</p> <pre><code>class MyTable(Component):\n    class Media:\n        js = [\n            \"path/to/script.js\",\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",  # AlpineJS\n        ]\n        css = {\n            \"all\": [\n                \"path/to/style.css\",\n                \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",  # TailwindCSS\n            ],\n            \"print\": [\"path/to/style2.css\"],\n        }\n</code></pre> <p>Attributes:</p> <ul> <li> <code>css</code>               (<code>Optional[Union[ComponentMediaInputPath, List[ComponentMediaInputPath], Dict[str, ComponentMediaInputPath], Dict[str, List[ComponentMediaInputPath]]]]</code>)           \u2013            </li> <li> <code>extend</code>               (<code>Union[bool, List[Type[Component]]]</code>)           \u2013            </li> <li> <code>js</code>               (<code>Optional[Union[ComponentMediaInputPath, List[ComponentMediaInputPath]]]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentMediaInput.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[Union[ComponentMediaInputPath, List[ComponentMediaInputPath], Dict[str, ComponentMediaInputPath], Dict[str, List[ComponentMediaInputPath]]]] = None\n</code></pre> <p>See source code</p> <p>CSS files associated with a <code>Component</code>.</p> <ul> <li> <p>If a string, it's assumed to be a path to a CSS file.</p> </li> <li> <p>If a list, each entry is assumed to be a path to a CSS file.</p> </li> <li> <p>If a dict, the keys are media types (e.g. \"all\", \"print\", \"screen\", etc.), and the values are either:</p> <ul> <li>A string, assumed to be a path to a CSS file.</li> <li>A list, each entry is assumed to be a path to a CSS file.</li> </ul> </li> </ul> <p>Each entry can be a string, bytes, SafeString, PathLike, or a callable that returns one of the former (see <code>ComponentMediaInputPath</code>).</p> <p>Examples: <pre><code>class MyComponent(Component):\n    class Media:\n        css = \"path/to/style.css\"\n</code></pre></p> <pre><code>class MyComponent(Component):\n    class Media:\n        css = [\"path/to/style1.css\", \"path/to/style2.css\"]\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": \"path/to/style.css\",\n            \"print\": \"path/to/print.css\",\n        }\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": [\"path/to/style1.css\", \"path/to/style2.css\"],\n            \"print\": \"path/to/print.css\",\n        }\n</code></pre>"},{"location":"reference/api/#django_components.ComponentMediaInput.extend","title":"extend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extend: Union[bool, List[Type[Component]]] = True\n</code></pre> <p>See source code</p> <p>Configures whether the component should inherit the media files from the parent component.</p> <ul> <li>If <code>True</code>, the component inherits the media files from the parent component.</li> <li>If <code>False</code>, the component does not inherit the media files from the parent component.</li> <li>If a list of components classes, the component inherits the media files ONLY from these specified components.</li> </ul> <p>Read more in Media inheritance section.</p> <p>Example:</p> <p>Disable media inheritance:</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        extend = False  # Don't inherit parent media\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"script.js\"]\n</code></pre> <p>Specify which components to inherit from. In this case, the media files are inherited ONLY from the specified components, and NOT from the original parent components:</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        # Only inherit from these, ignoring the files from the parent\n        extend = [OtherComponent1, OtherComponent2]\n\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"script.js\", \"other1.js\", \"other2.js\"]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentMediaInput.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[Union[ComponentMediaInputPath, List[ComponentMediaInputPath]]] = None\n</code></pre> <p>See source code</p> <p>JS files associated with a <code>Component</code>.</p> <ul> <li> <p>If a string, it's assumed to be a path to a JS file.</p> </li> <li> <p>If a list, each entry is assumed to be a path to a JS file.</p> </li> </ul> <p>Each entry can be a string, bytes, SafeString, PathLike, or a callable that returns one of the former (see <code>ComponentMediaInputPath</code>).</p> <p>Examples: <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"path/to/script.js\"\n</code></pre></p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = [\"path/to/script1.js\", \"path/to/script2.js\"]\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        js = lambda: [\"path/to/script1.js\", \"path/to/script2.js\"]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentMediaInputPath","title":"ComponentMediaInputPath  <code>module-attribute</code>","text":"<pre><code>ComponentMediaInputPath = Union[str, bytes, SafeData, Path, PathLike, Callable[[], Union[str, bytes, SafeData, Path, PathLike]]]\n</code></pre> <p>See source code</p> <p>A type representing an entry in Media.js or Media.css.</p> <p>If an entry is a SafeString (or has <code>__html__</code> method), then entry is assumed to be a formatted HTML tag. Otherwise, it's assumed to be a path to a file.</p> <p>Example:</p> <pre><code>class MyComponent\n    class Media:\n        js = [\n            \"path/to/script.js\",\n            b\"script.js\",\n            SafeString(\"&lt;script src='path/to/script.js'&gt;&lt;/script&gt;\"),\n        ]\n        css = [\n            Path(\"path/to/style.css\"),\n            lambda: \"path/to/style.css\",\n            lambda: Path(\"path/to/style.css\"),\n        ]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode","title":"ComponentNode","text":"<pre><code>ComponentNode(name: str, registry: ComponentRegistry, params: List[TagAttr], flags: Optional[Dict[str, bool]] = None, nodelist: Optional[NodeList] = None, node_id: Optional[str] = None, contents: Optional[str] = None, template_name: Optional[str] = None, template_component: Optional[Type[Component]] = None)\n</code></pre> <p>Bases: <code>django_components.node.BaseNode</code></p> <p>See source code</p> <p>Renders one of the components that was previously registered with <code>@register()</code> decorator.</p> <p>The <code>{% component %}</code> tag takes:</p> <ul> <li>Component's registered name as the first positional argument,</li> <li>Followed by any number of positional and keyword arguments.</li> </ul> <pre><code>{% load component_tags %}\n&lt;div&gt;\n    {% component \"button\" name=\"John\" job=\"Developer\" / %}\n&lt;/div&gt;\n</code></pre> <p>The component name must be a string literal.</p>"},{"location":"reference/api/#django_components.ComponentNode--inserting-slot-fills","title":"Inserting slot fills","text":"<p>If the component defined any slots, you can \"fill\" these slots by placing the <code>{% fill %}</code> tags within the <code>{% component %}</code> tag:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>You can even nest <code>{% fill %}</code> tags within <code>{% if %}</code>, <code>{% for %}</code> and other tags:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n    {% if rows %}\n        {% fill \"pagination\" %}\n            &lt; 1 | 2 | 3 &gt;\n        {% endfill %}\n    {% endif %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode--isolating-components","title":"Isolating components","text":"<p>By default, components behave similarly to Django's <code>{% include %}</code>, and the template inside the component has access to the variables defined in the outer template.</p> <p>You can selectively isolate a component, using the <code>only</code> flag, so that the inner template can access only the data that was explicitly passed to it:</p> <pre><code>{% component \"name\" positional_arg keyword_arg=value ... only %}\n</code></pre> <p>Alternatively, you can set all components to be isolated by default, by setting <code>context_behavior</code> to <code>\"isolated\"</code> in your settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"context_behavior\": \"isolated\",\n}\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode--omitting-the-component-keyword","title":"Omitting the component keyword","text":"<p>If you would like to omit the <code>component</code> keyword, and simply refer to your components by their registered names:</p> <pre><code>{% button name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>You can do so by setting the \"shorthand\" Tag formatter in the settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\",\n}\n</code></pre> <p>Methods:</p> <ul> <li> <code>parse</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>unregister</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>active_flags</code>               (<code>List[str]</code>)           \u2013            </li> <li> <code>allowed_flags</code>           \u2013            </li> <li> <code>contents</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>end_tag</code>           \u2013            </li> <li> <code>flags</code>               (<code>Dict[str, bool]</code>)           \u2013            </li> <li> <code>name</code>           \u2013            </li> <li> <code>node_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>nodelist</code>               (<code>NodeList</code>)           \u2013            </li> <li> <code>params</code>               (<code>List[TagAttr]</code>)           \u2013            </li> <li> <code>registry</code>           \u2013            </li> <li> <code>tag</code>           \u2013            </li> <li> <code>template_component</code>               (<code>Optional[Type[Component]]</code>)           \u2013            </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentNode.active_flags","title":"active_flags  <code>property</code>","text":"<pre><code>active_flags: List[str]\n</code></pre> <p>See source code</p> <p>Flags that were set for this specific instance as a list of strings.</p> <p>E.g. the following tag:</p> <pre><code>{% slot \"content\" default required / %}\n</code></pre> <p>Will have the following flags:</p> <pre><code>[\"default\", \"required\"]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.allowed_flags","title":"allowed_flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_flags = (COMP_ONLY_FLAG,)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.contents","title":"contents  <code>instance-attribute</code>","text":"<pre><code>contents: Optional[str] = contents\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The contents of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>contents</code> will be <code>\"&lt;div&gt; ... &lt;/div&gt;\"</code>.</p>"},{"location":"reference/api/#django_components.ComponentNode.end_tag","title":"end_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_tag = 'endcomponent'\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.flags","title":"flags  <code>instance-attribute</code>","text":"<pre><code>flags: Dict[str, bool] = flags or {flag: Falsefor flag in (allowed_flags or [])}\n</code></pre> <p>See source code</p> <p>See source code</p> <p>Dictionary of all <code>allowed_flags</code> that were set on the tag.</p> <p>Flags that were set are <code>True</code>, and the rest are <code>False</code>.</p> <p>E.g. the following tag:</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n    allowed_flags = [\"default\", \"required\"]\n</code></pre> <pre><code>{% slot \"content\" default %}\n</code></pre> <p>Has 2 flags, <code>default</code> and <code>required</code>, but only <code>default</code> was set.</p> <p>The <code>flags</code> dictionary will be:</p> <pre><code>{\n    \"default\": True,\n    \"required\": False,\n}\n</code></pre> <p>You can check if a flag is set by doing:</p> <pre><code>if node.flags[\"default\"]:\n    ...\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.node_id","title":"node_id  <code>instance-attribute</code>","text":"<pre><code>node_id: str = node_id or gen_id()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The unique ID of the node.</p> <p>Extensions can use this ID to store additional information.</p>"},{"location":"reference/api/#django_components.ComponentNode.nodelist","title":"nodelist  <code>instance-attribute</code>","text":"<pre><code>nodelist: NodeList = nodelist or NodeList()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The nodelist of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>nodelist</code> will contain the <code>&lt;div&gt; ... &lt;/div&gt;</code> part.</p> <p>Unlike <code>contents</code>, the <code>nodelist</code> contains the actual Nodes, not just the text.</p>"},{"location":"reference/api/#django_components.ComponentNode.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: List[TagAttr] = params\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The parameters to the tag in the template.</p> <p>A single param represents an arg or kwarg of the template tag.</p> <p>E.g. the following tag:</p> <pre><code>{% component \"my_comp\" key=val key2='val2 two' %}\n</code></pre> <p>Has 3 params:</p> <ul> <li>Posiitonal arg <code>\"my_comp\"</code></li> <li>Keyword arg <code>key=val</code></li> <li>Keyword arg <code>key2='val2 two'</code></li> </ul>"},{"location":"reference/api/#django_components.ComponentNode.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry = registry\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag = 'component'\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.template_component","title":"template_component  <code>instance-attribute</code>","text":"<pre><code>template_component: Optional[Type[Component]] = template_component\n</code></pre> <p>See source code</p> <p>See source code</p> <p>If the template that contains this node belongs to a <code>Component</code>, then this will be the <code>Component</code> class.</p>"},{"location":"reference/api/#django_components.ComponentNode.template_name","title":"template_name  <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = template_name\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The name of the <code>Template</code> that contains this node.</p> <p>The template name is set by Django's template loaders.</p> <p>For example, the filesystem template loader will set this to the absolute path of the template file.</p> <pre><code>\"/home/user/project/templates/my_template.html\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(parser: Parser, token: Token, registry: ComponentRegistry, name: str, start_tag: str, end_tag: str) -&gt; ComponentNode\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>A convenience method for registering the tag with the given library.</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mynode\"\n\nMyNode.register(library)\n</code></pre> <p>Allows you to then use the node in templates like so:</p> <pre><code>{% load mylibrary %}\n{% mynode %}\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.render","title":"render","text":"<pre><code>render(context: Context, *args: Any, **kwargs: Any) -&gt; str\n</code></pre>"},{"location":"reference/api/#django_components.ComponentNode.unregister","title":"unregister  <code>classmethod</code>","text":"<pre><code>unregister(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>Unregisters the node from the given library.</p>"},{"location":"reference/api/#django_components.ComponentRegistry","title":"ComponentRegistry","text":"<pre><code>ComponentRegistry(library: Optional[Library] = None, settings: Optional[Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]] = None)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Manages components and makes them available in the template, by default as <code>{% component %}</code> tags.</p> <pre><code>{% component \"my_comp\" key=value %}\n{% endcomponent %}\n</code></pre> <p>To enable a component to be used in a template, the component must be registered with a component registry.</p> <p>When you register a component to a registry, behind the scenes the registry automatically adds the component's template tag (e.g. <code>{% component %}</code> to the <code>Library</code>. And the opposite happens when you unregister a component - the tag is removed.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>, default:                   <code>None</code> )           \u2013            <p>Django            <code>Library</code>            associated with this registry. If omitted, the default Library instance from django_components is used.</p> </li> <li> <code>settings</code>               (<code>Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]</code>, default:                   <code>None</code> )           \u2013            <p>Configure            how the components registered with this registry will behave when rendered.            See <code>RegistrySettings</code>. Can be either            a static value or a callable that returns the settings. If omitted, the settings from            <code>COMPONENTS</code> are used.</p> </li> </ul> <p>Notes:</p> <ul> <li>The default registry is available as <code>django_components.registry</code>.</li> <li>The default registry is used when registering components with <code>@register</code> decorator.</li> </ul> <p>Example:</p> <pre><code># Use with default Library\nregistry = ComponentRegistry()\n\n# Or a custom one\nmy_lib = Library()\nregistry = ComponentRegistry(library=my_lib)\n\n# Usage\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\nregistry.all()\nregistry.clear()\nregistry.get(\"button\")\nregistry.has(\"button\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry--using-registry-to-share-components","title":"Using registry to share components","text":"<p>You can use component registry for isolating or \"packaging\" components:</p> <ol> <li> <p>Create new instance of <code>ComponentRegistry</code> and Library:     <pre><code>my_comps = Library()\nmy_comps_reg = ComponentRegistry(library=my_comps)\n</code></pre></p> </li> <li> <p>Register components to the registry:     <pre><code>my_comps_reg.register(\"my_button\", ButtonComponent)\nmy_comps_reg.register(\"my_card\", CardComponent)\n</code></pre></p> </li> <li> <p>In your target project, load the Library associated with the registry:     <pre><code>{% load my_comps %}\n</code></pre></p> </li> <li> <p>Use the registered components in your templates:     <pre><code>{% component \"button\" %}\n{% endcomponent %}\n</code></pre></p> </li> </ol> <p>Methods:</p> <ul> <li> <code>all</code>             \u2013              </li> <li> <code>clear</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>has</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> <li> <code>unregister</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>settings</code>               (<code>InternalRegistrySettings</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentRegistry.library","title":"library  <code>property</code>","text":"<pre><code>library: Library\n</code></pre> <p>See source code</p> <p>The template tag <code>Library</code> that is associated with the registry.</p>"},{"location":"reference/api/#django_components.ComponentRegistry.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: InternalRegistrySettings\n</code></pre> <p>See source code</p> <p>Registry settings configured for this registry.</p>"},{"location":"reference/api/#django_components.ComponentRegistry.all","title":"all","text":"<pre><code>all() -&gt; Dict[str, Type[Component]]\n</code></pre> <p>See source code</p> <p>Retrieve all registered <code>Component</code> classes.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Type[Component]]</code>           \u2013            <p>Dict[str, Type[Component]]: A dictionary of component names to component classes</p> </li> </ul> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then get all\nregistry.all()\n# &gt; {\n# &gt;   \"button\": ButtonComponent,\n# &gt;   \"card\": CardComponent,\n# &gt; }\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>See source code</p> <p>Clears the registry, unregistering all components.</p> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then clear\nregistry.clear()\n# Then get all\nregistry.all()\n# &gt; {}\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.get","title":"get","text":"<pre><code>get(name: str) -&gt; Type[Component]\n</code></pre> <p>See source code</p> <p>Retrieve a <code>Component</code> class registered under the given name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component was registered. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Component]</code>           \u2013            <p>Type[Component]: The component class registered under the given name.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code>   if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then get\nregistry.get(\"button\")\n# &gt; ButtonComponent\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.has","title":"has","text":"<pre><code>has(name: str) -&gt; bool\n</code></pre> <p>See source code</p> <p>Check if a <code>Component</code> class is registered under the given name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component was registered. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p><code>True</code> if the component is registered, <code>False</code> otherwise.</p> </li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then check\nregistry.has(\"button\")\n# &gt; True\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.register","title":"register","text":"<pre><code>register(name: str, component: Type[Component]) -&gt; None\n</code></pre> <p>See source code</p> <p>Register a <code>Component</code> class with this registry under the given name.</p> <p>A component MUST be registered before it can be used in a template such as: <pre><code>{% component \"my_comp\" %}\n{% endcomponent %}\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component will be registered. Required.</p> </li> <li> <code>component</code>               (<code>Type[Component]</code>)           \u2013            <p>The component class to register. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>AlreadyRegistered</code> if a different component was already registered under the same name.</li> </ul> <p>Example:</p> <pre><code>registry.register(\"button\", ButtonComponent)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.unregister","title":"unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>See source code</p> <p>Unregister the <code>Component</code> class that was registered under the given name.</p> <p>Once a component is unregistered, it is no longer available in the templates.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component is registered. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code> if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then unregister\nregistry.unregister(\"button\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentVars","title":"ComponentVars","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Type for the variables available inside the component templates.</p> <p>All variables here are scoped under <code>component_vars.</code>, so e.g. attribute <code>kwargs</code> on this class is accessible inside the template as:</p> <pre><code>{{ component_vars.kwargs }}\n</code></pre> <p>Attributes:</p> <ul> <li> <code>args</code>               (<code>Any</code>)           \u2013            </li> <li> <code>is_filled</code>               (<code>Dict[str, bool]</code>)           \u2013            </li> <li> <code>kwargs</code>               (<code>Any</code>)           \u2013            </li> <li> <code>slots</code>               (<code>Any</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentVars.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: Any\n</code></pre> <p>See source code</p> <p>The <code>args</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>This is the same <code>Component.args</code> that's available on the component instance.</p> <p>If you defined the <code>Component.Args</code> class, then the <code>args</code> property will return an instance of that class.</p> <p>Otherwise, <code>args</code> will be a plain list.</p> <p>Example:</p> <p>With <code>Args</code> class:</p> <pre><code>from django_components import Component, register\n\n@register(\"table\")\nclass Table(Component):\n    class Args(NamedTuple):\n        page: int\n        per_page: int\n\n    template = '''\n        &lt;div&gt;\n            &lt;h1&gt;Table&lt;/h1&gt;\n            &lt;p&gt;Page: {{ component_vars.args.page }}&lt;/p&gt;\n            &lt;p&gt;Per page: {{ component_vars.args.per_page }}&lt;/p&gt;\n        &lt;/div&gt;\n    '''\n</code></pre> <p>Without <code>Args</code> class:</p> <pre><code>from django_components import Component, register\n\n@register(\"table\")\nclass Table(Component):\n    template = '''\n        &lt;div&gt;\n            &lt;h1&gt;Table&lt;/h1&gt;\n            &lt;p&gt;Page: {{ component_vars.args.0 }}&lt;/p&gt;\n            &lt;p&gt;Per page: {{ component_vars.args.1 }}&lt;/p&gt;\n        &lt;/div&gt;\n    '''\n</code></pre>"},{"location":"reference/api/#django_components.ComponentVars.is_filled","title":"is_filled  <code>instance-attribute</code>","text":"<pre><code>is_filled: Dict[str, bool]\n</code></pre> <p>See source code</p> <p>Deprecated. Will be removed in v1. Use <code>component_vars.slots</code> instead. Note that <code>component_vars.slots</code> no longer escapes the slot names.</p> <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> <p>New in version 0.70</p> <p>Use as <code>{{ component_vars.is_filled }}</code></p> <p>Example:</p> <pre><code>{# Render wrapping HTML only if the slot is defined #}\n{% if component_vars.is_filled.my_slot %}\n    &lt;div class=\"slot-wrapper\"&gt;\n        {% slot \"my_slot\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre> <p>This is equivalent to checking if a given key is among the slot fills:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"my_slot_filled\": \"my_slot\" in slots\n        }\n</code></pre>"},{"location":"reference/api/#django_components.ComponentVars.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: Any\n</code></pre> <p>See source code</p> <p>The <code>kwargs</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>This is the same <code>Component.kwargs</code> that's available on the component instance.</p> <p>If you defined the <code>Component.Kwargs</code> class, then the <code>kwargs</code> property will return an instance of that class.</p> <p>Otherwise, <code>kwargs</code> will be a plain dict.</p> <p>Example:</p> <p>With <code>Kwargs</code> class:</p> <pre><code>from django_components import Component, register\n\n@register(\"table\")\nclass Table(Component):\n    class Kwargs(NamedTuple):\n        page: int\n        per_page: int\n\n    template = '''\n        &lt;div&gt;\n            &lt;h1&gt;Table&lt;/h1&gt;\n            &lt;p&gt;Page: {{ component_vars.kwargs.page }}&lt;/p&gt;\n            &lt;p&gt;Per page: {{ component_vars.kwargs.per_page }}&lt;/p&gt;\n        &lt;/div&gt;\n    '''\n</code></pre> <p>Without <code>Kwargs</code> class:</p> <pre><code>from django_components import Component, register\n\n@register(\"table\")\nclass Table(Component):\n    template = '''\n        &lt;div&gt;\n            &lt;h1&gt;Table&lt;/h1&gt;\n            &lt;p&gt;Page: {{ component_vars.kwargs.page }}&lt;/p&gt;\n            &lt;p&gt;Per page: {{ component_vars.kwargs.per_page }}&lt;/p&gt;\n        &lt;/div&gt;\n    '''\n</code></pre>"},{"location":"reference/api/#django_components.ComponentVars.slots","title":"slots  <code>instance-attribute</code>","text":"<pre><code>slots: Any\n</code></pre> <p>See source code</p> <p>The <code>slots</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>This is the same <code>Component.slots</code> that's available on the component instance.</p> <p>If you defined the <code>Component.Slots</code> class, then the <code>slots</code> property will return an instance of that class.</p> <p>Otherwise, <code>slots</code> will be a plain dict.</p> <p>Example:</p> <p>With <code>Slots</code> class:</p> <pre><code>from django_components import Component, SlotInput, register\n\n@register(\"table\")\nclass Table(Component):\n    class Slots(NamedTuple):\n        footer: SlotInput\n\n    template = '''\n        &lt;div&gt;\n            {% component \"pagination\" %}\n                {% fill \"footer\" body=component_vars.slots.footer / %}\n            {% endcomponent %}\n        &lt;/div&gt;\n    '''\n</code></pre> <p>Without <code>Slots</code> class:</p> <pre><code>from django_components import Component, SlotInput, register\n\n@register(\"table\")\nclass Table(Component):\n    template = '''\n        &lt;div&gt;\n            {% component \"pagination\" %}\n                {% fill \"footer\" body=component_vars.slots.footer / %}\n            {% endcomponent %}\n        &lt;/div&gt;\n    '''\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView","title":"ComponentView","text":"<pre><code>ComponentView(component: Component, **kwargs: Any)\n</code></pre> <p>Bases: <code>django_components.extension.ExtensionComponentConfig</code>, <code>django.views.generic.base.View</code></p> <p>See source code</p> <p>The interface for <code>Component.View</code>.</p> <p>The fields of this class are used to configure the component views and URLs.</p> <p>This class is a subclass of <code>django.views.View</code>. The <code>Component</code> class is available via <code>self.component_cls</code>.</p> <p>Override the methods of this class to define the behavior of the component.</p> <p>Read more about Component views and URLs.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class View:\n        def get(self, request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse:\n            return HttpResponse(\"Hello, world!\")\n</code></pre> <p>Component URL:</p> <p>If the <code>public</code> attribute is set to <code>True</code>, the component will have its own URL that will point to the Component's View.</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class View:\n        public = True\n\n        def get(self, request, *args, **kwargs):\n            return HttpResponse(\"Hello, world!\")\n</code></pre> <p>Will create a URL route like <code>/components/ext/view/components/a1b2c3/</code>.</p> <p>To get the URL for the component, use <code>get_component_url()</code>:</p> <pre><code>url = get_component_url(MyComponent)\n</code></pre> <p>Methods:</p> <ul> <li> <code>delete</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>head</code>             \u2013              </li> <li> <code>options</code>             \u2013              </li> <li> <code>patch</code>             \u2013              </li> <li> <code>post</code>             \u2013              </li> <li> <code>put</code>             \u2013              </li> <li> <code>trace</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>component</code>           \u2013            </li> <li> <code>component_class</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_cls</code>           \u2013            </li> <li> <code>public</code>               (<code>bool</code>)           \u2013            </li> <li> <code>url</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentView.component","title":"component  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>component = component\n</code></pre> <p>See source code</p> <p>See source code</p> <p>DEPRECATED: Will be removed in v1.0. Use <code>component_cls</code> instead.</p> <p>This is a dummy instance created solely for the View methods.</p> <p>It is the same as if you instantiated the component class directly:</p> <pre><code>component = Calendar()\ncomponent.render_to_response(request=request)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.component_class","title":"component_class  <code>instance-attribute</code>","text":"<pre><code>component_class: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ComponentView.component_cls","title":"component_cls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>component_cls = cast('Type[Component]', None)\n</code></pre> <p>See source code</p> <p>The parent component class.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class View:\n        def get(self, request):\n            return self.component_cls.render_to_response(request=request)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.public","title":"public  <code>class-attribute</code>","text":"<pre><code>public: bool = False\n</code></pre> <p>See source code</p> <p>Whether the component should be available via a URL.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class View:\n        public = True\n</code></pre> <p>Will create a URL route like <code>/components/ext/view/components/a1b2c3/</code>.</p> <p>To get the URL for the component, use <code>get_component_url()</code>:</p> <pre><code>url = get_component_url(MyComponent)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>See source code</p> <p>The URL for the component.</p> <p>Raises <code>RuntimeError</code> if the component is not public.</p> <p>This is the same as calling <code>get_component_url()</code> with the parent <code>Component</code> class:</p> <pre><code>class MyComponent(Component):\n    class View:\n        def get(self, request):\n            assert self.url == get_component_url(self.component_cls)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.delete","title":"delete","text":"<pre><code>delete(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.get","title":"get","text":"<pre><code>get(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.head","title":"head","text":"<pre><code>head(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.options","title":"options","text":"<pre><code>options(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.patch","title":"patch","text":"<pre><code>patch(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.post","title":"post","text":"<pre><code>post(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.put","title":"put","text":"<pre><code>put(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.trace","title":"trace","text":"<pre><code>trace(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings","title":"ComponentsSettings","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Settings available for django_components.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n    dirs = [BASE_DIR / \"components\"],\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>app_dirs</code>               (<code>Optional[Sequence[str]]</code>)           \u2013            </li> <li> <code>autodiscover</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>cache</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            </li> <li> <code>debug_highlight_components</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>debug_highlight_slots</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>dirs</code>               (<code>Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]]</code>)           \u2013            </li> <li> <code>dynamic_component_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>extensions</code>               (<code>Optional[Sequence[Union[Type[ComponentExtension], str]]]</code>)           \u2013            </li> <li> <code>extensions_defaults</code>               (<code>Optional[Dict[str, Any]]</code>)           \u2013            </li> <li> <code>forbidden_static_files</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            </li> <li> <code>libraries</code>               (<code>Optional[List[str]]</code>)           \u2013            </li> <li> <code>multiline_tags</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>reload_on_file_change</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>reload_on_template_change</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>static_files_allowed</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            </li> <li> <code>static_files_forbidden</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            </li> <li> <code>template_cache_size</code>               (<code>Optional[int]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentsSettings.app_dirs","title":"app_dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_dirs: Optional[Sequence[str]] = None\n</code></pre> <p>See source code</p> <p>Specify the app-level directories that contain your components.</p> <p>Defaults to <code>[\"components\"]</code>. That is, for each Django app, we search <code>&lt;app&gt;/components/</code> for components.</p> <p>The paths must be relative to app, e.g.:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[\"my_comps\"],\n)\n</code></pre> <p>To search for <code>&lt;app&gt;/my_comps/</code>.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <p>Set to empty list to disable app-level components:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[],\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.autodiscover","title":"autodiscover  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autodiscover: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Toggle whether to run autodiscovery at the Django server startup.</p> <p>Defaults to <code>True</code></p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.cache","title":"cache  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the Django cache to be used for storing component's JS and CSS files.</p> <p>If <code>None</code>, a <code>LocMemCache</code> is used with default settings.</p> <p>Defaults to <code>None</code>.</p> <p>Read more about caching.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    cache=\"my_cache\",\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>See source code</p> <p>Configure whether, inside a component template, you can use variables from the outside (<code>\"django\"</code>) or not (<code>\"isolated\"</code>). This also affects what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Defaults to <code>\"django\"</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    context_behavior=\"isolated\",\n)\n</code></pre> <p>NOTE: <code>context_behavior</code> and <code>slot_context_behavior</code> options were merged in v0.70.</p> <p>If you are migrating from BEFORE v0.67, set <code>context_behavior</code> to <code>\"django\"</code>. From v0.67 to v0.78 (incl) the default value was <code>\"isolated\"</code>.</p> <p>For v0.79 and later, the default is again <code>\"django\"</code>. See the rationale for change here.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.debug_highlight_components","title":"debug_highlight_components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_highlight_components: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>DEPRECATED. Use <code>extensions_defaults</code> instead. Will be removed in v1.</p> <p>Enable / disable component highlighting. See Troubleshooting for more details.</p> <p>Defaults to <code>False</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_components=True,\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.debug_highlight_slots","title":"debug_highlight_slots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_highlight_slots: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>DEPRECATED. Use <code>extensions_defaults</code> instead. Will be removed in v1.</p> <p>Enable / disable slot highlighting. See Troubleshooting for more details.</p> <p>Defaults to <code>False</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_slots=True,\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.dirs","title":"dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirs: Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]] = None\n</code></pre> <p>See source code</p> <p>Specify the directories that contain your components.</p> <p>Defaults to <code>[Path(settings.BASE_DIR) / \"components\"]</code>. That is, the root <code>components/</code> app.</p> <p>Directories must be full paths, same as with STATICFILES_DIRS.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[BASE_DIR / \"components\"],\n)\n</code></pre> <p>Set to empty list to disable global components directories:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[],\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.dynamic_component_name","title":"dynamic_component_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dynamic_component_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>.</p> <p>In case of a conflict, you can use this setting to change the component name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Optional[Sequence[Union[Type[ComponentExtension], str]]] = None\n</code></pre> <p>See source code</p> <p>List of extensions to be loaded.</p> <p>The extensions can be specified as:</p> <ul> <li>Python import path, e.g. <code>\"path.to.my_extension.MyExtension\"</code>.</li> <li>Extension class, e.g. <code>my_extension.MyExtension</code>.</li> </ul> <p>Read more about extensions.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    extensions=[\n        \"path.to.my_extension.MyExtension\",\n        StorybookExtension,\n    ],\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.extensions_defaults","title":"extensions_defaults  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions_defaults: Optional[Dict[str, Any]] = None\n</code></pre> <p>See source code</p> <p>Global defaults for the extension classes.</p> <p>Read more about Extension defaults.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    extensions_defaults={\n        \"my_extension\": {\n            \"my_setting\": \"my_value\",\n        },\n        \"cache\": {\n            \"enabled\": True,\n            \"ttl\": 60,\n        },\n    },\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.forbidden_static_files","title":"forbidden_static_files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forbidden_static_files: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>COMPONENTS.static_files_forbidden</code> instead.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.libraries","title":"libraries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>libraries: Optional[List[str]] = None\n</code></pre> <p>See source code</p> <p>Configure extra python modules that should be loaded.</p> <p>This may be useful if you are not using the autodiscovery feature, or you need to load components from non-standard locations. Thus you can have a structure of components that is independent from your apps.</p> <p>Expects a list of python module paths. Defaults to empty list.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    libraries=[\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n)\n</code></pre> <p>This would be the equivalent of importing these modules from within Django's <code>AppConfig.ready()</code>:</p> <pre><code>class MyAppConfig(AppConfig):\n    def ready(self):\n        import \"mysite.components.forms\"\n        import \"mysite.components.buttons\"\n        import \"mysite.components.cards\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.libraries--manually-loading-libraries","title":"Manually loading libraries","text":"<p>In the rare case that you need to manually trigger the import of libraries, you can use the <code>import_libraries()</code> function:</p> <pre><code>from django_components import import_libraries\n\nimport_libraries()\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.multiline_tags","title":"multiline_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>multiline_tags: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Enable / disable multiline support for template tags. If <code>True</code>, template tags like <code>{% component %}</code> or <code>{{ my_var }}</code> can span multiple lines.</p> <p>Defaults to <code>True</code>.</p> <p>Disable this setting if you are making custom modifications to Django's regular expression for parsing templates at <code>django.template.base.tag_re</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    multiline_tags=False,\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.reload_on_file_change","title":"reload_on_file_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_file_change: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>This is relevant if you are using the project structure where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>Django's native live reload logic handles only Python files and HTML template files. It does NOT reload when other file types change or when template files are nested more than one level deep.</p> <p>The setting <code>reload_on_file_change</code> fixes this, reloading the dev server even when your component's HTML, JS, or CSS changes.</p> <p>If <code>True</code>, django_components configures Django to reload when files inside <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> change.</p> <p>See Reload dev server on component file changes.</p> <p>Defaults to <code>False</code>.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"reference/api/#django_components.ComponentsSettings.reload_on_template_change","title":"reload_on_template_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_template_change: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>COMPONENTS.reload_on_file_change</code> instead.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.static_files_allowed","title":"static_files_allowed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_allowed: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> are treated as static files.</p> <p>If a file is matched against any of the patterns, it's considered a static file. Such files are collected when running <code>collectstatic</code>, and can be accessed under the static file endpoint.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, JS, CSS, and common image and font file formats are considered static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\",  \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.static_files_forbidden","title":"static_files_forbidden  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_forbidden: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> will NEVER be treated as static files.</p> <p>If a file is matched against any of the patterns, it will never be considered a static file, even if the file matches a pattern in <code>static_files_allowed</code>.</p> <p>Use this setting together with <code>static_files_allowed</code> for a fine control over what file types will be exposed.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, any HTML and Python are considered NOT static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_forbidden=[\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>See source code</p> <p>Configure what syntax is used inside Django templates to render components. See the available tag formatters.</p> <p>Defaults to <code>\"django_components.component_formatter\"</code>.</p> <p>Learn more about Customizing component tags with TagFormatter.</p> <p>Can be set either as direct reference:</p> <pre><code>from django_components import component_formatter\n\nCOMPONENTS = ComponentsSettings(\n    \"tag_formatter\": component_formatter\n)\n</code></pre> <p>Or as an import string;</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>Examples:</p> <ul> <li> <p><code>\"django_components.component_formatter\"</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    Click me!\n{% endcomponent %}\n</code></pre> </li> <li> <p><code>django_components.component_shorthand_formatter</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"reference/api/#django_components.ComponentsSettings.template_cache_size","title":"template_cache_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_cache_size: Optional[int] = None\n</code></pre> <p>See source code</p> <p>DEPRECATED. Template caching will be removed in v1.</p> <p>Configure the maximum amount of Django templates to be cached.</p> <p>Defaults to <code>128</code>.</p> <p>Each time a Django template is rendered, it is cached to a global in-memory cache (using Python's <code>lru_cache</code> decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up.</p> <p>By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are overriding <code>Component.get_template()</code> to render many dynamic templates, you can increase this number.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=256,\n)\n</code></pre> <p>To remove the cache limit altogether and cache everything, set <code>template_cache_size</code> to <code>None</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=None,\n)\n</code></pre> <p>If you want to add templates to the cache yourself, you can use <code>cached_template()</code>:</p> <pre><code>from django_components import cached_template\n\ncached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ncached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/api/#django_components.ContextBehavior","title":"ContextBehavior","text":"<p>Bases: <code>str</code>, <code>enum.Enum</code></p> <p>See source code</p> <p>Configure how (and whether) the context is passed to the component fills and what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Options:</p> <ul> <li><code>django</code>: With this setting, component fills behave as usual Django tags.</li> <li><code>isolated</code>: This setting makes the component fills behave similar to Vue or React.</li> </ul> <p>Attributes:</p> <ul> <li> <code>DJANGO</code>           \u2013            </li> <li> <code>ISOLATED</code>           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ContextBehavior.DJANGO","title":"DJANGO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DJANGO = 'django'\n</code></pre> <p>See source code</p> <p>With this setting, component fills behave as usual Django tags. That is, they enrich the context, and pass it along.</p> <ol> <li>Component fills use the context of the component they are within.</li> <li>Variables from <code>Component.get_template_data()</code> are available to the component fill.</li> </ol> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>Component.get_template_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>456   # my_var\nfeta  # cheese\n</code></pre></p> <p>Because \"my_comp\" overrides the variable \"my_var\", so <code>{{ my_var }}</code> equals <code>456</code>.</p> <p>And variable \"cheese\" will equal <code>feta</code>, because the fill CAN access the current context.</p>"},{"location":"reference/api/#django_components.ContextBehavior.ISOLATED","title":"ISOLATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ISOLATED = 'isolated'\n</code></pre> <p>See source code</p> <p>This setting makes the component fills behave similar to Vue or React, where the fills use EXCLUSIVELY the context variables defined in <code>Component.get_template_data()</code>.</p> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>get_template_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>123   # my_var\n      # cheese\n</code></pre></p> <p>Because both variables \"my_var\" and \"cheese\" are taken from the root context. Since \"cheese\" is not defined in root context, it's empty.</p>"},{"location":"reference/api/#django_components.Default","title":"Default  <code>dataclass</code>","text":"<pre><code>Default(value: Callable[[], Any])\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Use this class to mark a field on the <code>Component.Defaults</code> class as a factory.</p> <p>Read more about Component defaults.</p> <p>Example:</p> <pre><code>from django_components import Default\n\nclass MyComponent(Component):\n    class Defaults:\n        # Plain value doesn't need a factory\n        position = \"left\"\n        # Lists and dicts need to be wrapped in `Default`\n        # Otherwise all instances will share the same value\n        selected_items = Default(lambda: [1, 2, 3])\n</code></pre> <p>Attributes:</p> <ul> <li> <code>value</code>               (<code>Callable[[], Any]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.Default.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Callable[[], Any]\n</code></pre>"},{"location":"reference/api/#django_components.DependenciesStrategy","title":"DependenciesStrategy  <code>module-attribute</code>","text":"<pre><code>DependenciesStrategy = Literal['document', 'fragment', 'simple', 'prepend', 'append', 'ignore']\n</code></pre> <p>See source code</p> <p>Type for the available strategies for rendering JS and CSS dependencies.</p> <p>Read more about the dependencies strategies.</p>"},{"location":"reference/api/#django_components.Empty","title":"Empty","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Type for an object with no members.</p> <p>You can use this to define Component types that accept NO args, kwargs, slots, etc:</p> <pre><code>from django_components import Component, Empty\n\nclass Table(Component):\n    Args = Empty\n    Kwargs = Empty\n    ...\n</code></pre> <p>This class is a shorthand for:</p> <pre><code>class Empty(NamedTuple):\n    pass\n</code></pre> <p>Read more about Typing and validation.</p>"},{"location":"reference/api/#django_components.ExtensionComponentConfig","title":"ExtensionComponentConfig","text":"<pre><code>ExtensionComponentConfig(component: Component)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p><code>ExtensionComponentConfig</code> is the base class for all extension component configs.</p> <p>Extensions can define nested classes on the component class, such as <code>Component.View</code> or <code>Component.Cache</code>:</p> <pre><code>class MyComp(Component):\n    class View:\n        def get(self, request):\n            ...\n\n    class Cache:\n        ttl = 60\n</code></pre> <p>This allows users to configure extension behavior per component.</p> <p>Behind the scenes, the nested classes that users define on their components are merged with the extension's \"base\" class.</p> <p>So the example above is the same as:</p> <pre><code>class MyComp(Component):\n    class View(ViewExtension.ComponentConfig):\n        def get(self, request):\n            ...\n\n    class Cache(CacheExtension.ComponentConfig):\n        ttl = 60\n</code></pre> <p>Where both <code>ViewExtension.ComponentConfig</code> and <code>CacheExtension.ComponentConfig</code> are subclasses of <code>ExtensionComponentConfig</code>.</p> <p>Attributes:</p> <ul> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_class</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ExtensionComponentConfig.component","title":"component  <code>property</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>When a <code>Component</code> is instantiated, also the nested extension classes (such as <code>Component.View</code>) are instantiated, receiving the component instance as an argument.</p> <p>This attribute holds the owner <code>Component</code> instance that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ExtensionComponentConfig.component_class","title":"component_class  <code>instance-attribute</code>","text":"<pre><code>component_class: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.ExtensionComponentConfig.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The <code>Component</code> class that this extension is defined on.</p>"},{"location":"reference/api/#django_components.FillNode","title":"FillNode","text":"<pre><code>FillNode(params: List[TagAttr], flags: Optional[Dict[str, bool]] = None, nodelist: Optional[NodeList] = None, node_id: Optional[str] = None, contents: Optional[str] = None, template_name: Optional[str] = None, template_component: Optional[Type[Component]] = None)\n</code></pre> <p>Bases: <code>django_components.node.BaseNode</code></p> <p>See source code</p> <p>Use <code>{% fill %}</code> tag to insert content into component's slots.</p> <p><code>{% fill %}</code> tag may be used only within a <code>{% component %}..{% endcomponent %}</code> block, and raises a <code>TemplateSyntaxError</code> if used outside of a component.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Name of the slot to insert this content into. Use <code>\"default\"</code> for     the default slot.</li> <li><code>data</code> (str, optional): This argument allows you to access the data passed to the slot     under the specified variable name. See Slot data.</li> <li><code>fallback</code> (str, optional): This argument allows you to access the original content of the slot     under the specified variable name. See Slot fallback.</li> </ul> <p>Example:</p> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/api/#django_components.FillNode--access-slot-fallback","title":"Access slot fallback","text":"<p>Use the <code>fallback</code> kwarg to access the original content of the slot.</p> <p>The <code>fallback</code> kwarg defines the name of the variable that will contain the slot's fallback content.</p> <p>Read more about Slot fallback.</p> <p>Component template:</p> <pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <p>Fill:</p> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" fallback=\"fallback\" %}\n    &lt;div class=\"my-class\"&gt;\n      {{ fallback }}\n    &lt;/div&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/api/#django_components.FillNode--access-slot-data","title":"Access slot data","text":"<p>Use the <code>data</code> kwarg to access the data passed to the slot.</p> <p>The <code>data</code> kwarg defines the name of the variable that will contain the slot's data.</p> <p>Read more about Slot data.</p> <p>Component template:</p> <pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" pages=pages %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <p>Fill:</p> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" data=\"slot_data\" %}\n    {% for page in slot_data.pages %}\n        &lt;a href=\"{{ page.link }}\"&gt;\n          {{ page.index }}\n        &lt;/a&gt;\n    {% endfor %}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/api/#django_components.FillNode--using-default-slot","title":"Using default slot","text":"<p>To access slot data and the fallback slot content on the default slot, use <code>{% fill %}</code> with <code>name</code> set to <code>\"default\"</code>:</p> <pre><code>{% component \"button\" %}\n  {% fill name=\"default\" data=\"slot_data\" fallback=\"slot_fallback\" %}\n    You clicked me {{ slot_data.count }} times!\n    {{ slot_fallback }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/api/#django_components.FillNode--slot-fills-from-python","title":"Slot fills from Python","text":"<p>You can pass a slot fill from Python to a component by setting the <code>body</code> kwarg on the <code>{% fill %}</code> tag.</p> <p>First pass a <code>Slot</code> instance to the template with the <code>get_template_data()</code> method:</p> <pre><code>from django_components import component, Slot\n\nclass Table(Component):\n  def get_template_data(self, args, kwargs, slots, context):\n    return {\n        \"my_slot\": Slot(lambda ctx: \"Hello, world!\"),\n    }\n</code></pre> <p>Then pass the slot to the <code>{% fill %}</code> tag:</p> <pre><code>{% component \"table\" %}\n  {% fill \"pagination\" body=my_slot / %}\n{% endcomponent %}\n</code></pre> <p>Warning</p> <p>If you define both the <code>body</code> kwarg and the <code>{% fill %}</code> tag's body, an error will be raised.</p> <pre><code>{% component \"table\" %}\n  {% fill \"pagination\" body=my_slot %}\n    ...\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Methods:</p> <ul> <li> <code>parse</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>unregister</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>active_flags</code>               (<code>List[str]</code>)           \u2013            </li> <li> <code>allowed_flags</code>           \u2013            </li> <li> <code>contents</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>end_tag</code>           \u2013            </li> <li> <code>flags</code>               (<code>Dict[str, bool]</code>)           \u2013            </li> <li> <code>node_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>nodelist</code>               (<code>NodeList</code>)           \u2013            </li> <li> <code>params</code>               (<code>List[TagAttr]</code>)           \u2013            </li> <li> <code>tag</code>           \u2013            </li> <li> <code>template_component</code>               (<code>Optional[Type[Component]]</code>)           \u2013            </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.FillNode.active_flags","title":"active_flags  <code>property</code>","text":"<pre><code>active_flags: List[str]\n</code></pre> <p>See source code</p> <p>Flags that were set for this specific instance as a list of strings.</p> <p>E.g. the following tag:</p> <pre><code>{% slot \"content\" default required / %}\n</code></pre> <p>Will have the following flags:</p> <pre><code>[\"default\", \"required\"]\n</code></pre>"},{"location":"reference/api/#django_components.FillNode.allowed_flags","title":"allowed_flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_flags = ()\n</code></pre>"},{"location":"reference/api/#django_components.FillNode.contents","title":"contents  <code>instance-attribute</code>","text":"<pre><code>contents: Optional[str] = contents\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The contents of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>contents</code> will be <code>\"&lt;div&gt; ... &lt;/div&gt;\"</code>.</p>"},{"location":"reference/api/#django_components.FillNode.end_tag","title":"end_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_tag = 'endfill'\n</code></pre>"},{"location":"reference/api/#django_components.FillNode.flags","title":"flags  <code>instance-attribute</code>","text":"<pre><code>flags: Dict[str, bool] = flags or {flag: Falsefor flag in (allowed_flags or [])}\n</code></pre> <p>See source code</p> <p>See source code</p> <p>Dictionary of all <code>allowed_flags</code> that were set on the tag.</p> <p>Flags that were set are <code>True</code>, and the rest are <code>False</code>.</p> <p>E.g. the following tag:</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n    allowed_flags = [\"default\", \"required\"]\n</code></pre> <pre><code>{% slot \"content\" default %}\n</code></pre> <p>Has 2 flags, <code>default</code> and <code>required</code>, but only <code>default</code> was set.</p> <p>The <code>flags</code> dictionary will be:</p> <pre><code>{\n    \"default\": True,\n    \"required\": False,\n}\n</code></pre> <p>You can check if a flag is set by doing:</p> <pre><code>if node.flags[\"default\"]:\n    ...\n</code></pre>"},{"location":"reference/api/#django_components.FillNode.node_id","title":"node_id  <code>instance-attribute</code>","text":"<pre><code>node_id: str = node_id or gen_id()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The unique ID of the node.</p> <p>Extensions can use this ID to store additional information.</p>"},{"location":"reference/api/#django_components.FillNode.nodelist","title":"nodelist  <code>instance-attribute</code>","text":"<pre><code>nodelist: NodeList = nodelist or NodeList()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The nodelist of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>nodelist</code> will contain the <code>&lt;div&gt; ... &lt;/div&gt;</code> part.</p> <p>Unlike <code>contents</code>, the <code>nodelist</code> contains the actual Nodes, not just the text.</p>"},{"location":"reference/api/#django_components.FillNode.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: List[TagAttr] = params\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The parameters to the tag in the template.</p> <p>A single param represents an arg or kwarg of the template tag.</p> <p>E.g. the following tag:</p> <pre><code>{% component \"my_comp\" key=val key2='val2 two' %}\n</code></pre> <p>Has 3 params:</p> <ul> <li>Posiitonal arg <code>\"my_comp\"</code></li> <li>Keyword arg <code>key=val</code></li> <li>Keyword arg <code>key2='val2 two'</code></li> </ul>"},{"location":"reference/api/#django_components.FillNode.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag = 'fill'\n</code></pre>"},{"location":"reference/api/#django_components.FillNode.template_component","title":"template_component  <code>instance-attribute</code>","text":"<pre><code>template_component: Optional[Type[Component]] = template_component\n</code></pre> <p>See source code</p> <p>See source code</p> <p>If the template that contains this node belongs to a <code>Component</code>, then this will be the <code>Component</code> class.</p>"},{"location":"reference/api/#django_components.FillNode.template_name","title":"template_name  <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = template_name\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The name of the <code>Template</code> that contains this node.</p> <p>The template name is set by Django's template loaders.</p> <p>For example, the filesystem template loader will set this to the absolute path of the template file.</p> <pre><code>\"/home/user/project/templates/my_template.html\"\n</code></pre>"},{"location":"reference/api/#django_components.FillNode.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(parser: Parser, token: Token, **kwargs: Any) -&gt; BaseNode\n</code></pre> <p>See source code</p> <p>This function is what is passed to Django's <code>Library.tag()</code> when registering the tag.</p> <p>In other words, this method is called by Django's template parser when we encounter a tag that matches this node's tag, e.g. <code>{% component %}</code> or <code>{% slot %}</code>.</p> <p>To register the tag, you can use <code>BaseNode.register()</code>.</p>"},{"location":"reference/api/#django_components.FillNode.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>A convenience method for registering the tag with the given library.</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mynode\"\n\nMyNode.register(library)\n</code></pre> <p>Allows you to then use the node in templates like so:</p> <pre><code>{% load mylibrary %}\n{% mynode %}\n</code></pre>"},{"location":"reference/api/#django_components.FillNode.render","title":"render","text":"<pre><code>render(context: Context, name: str, *, data: Optional[str] = None, fallback: Optional[str] = None, body: Optional[SlotInput] = None, default: Optional[str] = None) -&gt; str\n</code></pre>"},{"location":"reference/api/#django_components.FillNode.unregister","title":"unregister  <code>classmethod</code>","text":"<pre><code>unregister(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>Unregisters the node from the given library.</p>"},{"location":"reference/api/#django_components.OnRenderGenerator","title":"OnRenderGenerator  <code>module-attribute</code>","text":"<pre><code>OnRenderGenerator = Generator[Optional[Union[SlotResult, Callable[[], SlotResult]]], Tuple[Optional[SlotResult], Optional[Exception]], Optional[SlotResult]]\n</code></pre> <p>See source code</p> <p>This is the signature of the <code>Component.on_render()</code> method if it yields (and thus returns a generator).</p> <p>When <code>on_render()</code> is a generator then it:</p> <ul> <li> <p>Yields a rendered template (string or <code>None</code>) or a lambda function to be called later.</p> </li> <li> <p>Receives back a tuple of <code>(final_output, error)</code>.</p> <p>The final output is the rendered template that now has all its children rendered too. May be <code>None</code> if you yielded <code>None</code> earlier.</p> <p>The error is <code>None</code> if the rendering was successful. Otherwise the error is set and the output is <code>None</code>.</p> </li> <li> <p>Can yield multiple times within the same method for complex rendering scenarios</p> </li> <li> <p>At the end it may return a new string to override the final rendered output.</p> </li> </ul> <p>Example:</p> <pre><code>from django_components import Component, OnRenderGenerator\n\nclass MyTable(Component):\n    def on_render(\n        self,\n        context: Context,\n        template: Optional[Template],\n    ) -&gt; OnRenderGenerator:\n        # Do something BEFORE rendering template\n        # Same as `Component.on_render_before()`\n        context[\"hello\"] = \"world\"\n\n        # Yield a function that renders the template\n        # to receive fully-rendered template or error.\n        html, error = yield lambda: template.render(context)\n\n        # Do something AFTER rendering template, or post-process\n        # the rendered template.\n        # Same as `Component.on_render_after()`\n        if html is not None:\n            return html + \"&lt;p&gt;Hello&lt;/p&gt;\"\n</code></pre> <p>Multiple yields example:</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template) -&gt; OnRenderGenerator:\n        # First yield\n        with context.push({\"mode\": \"header\"}):\n            header_html, header_error = yield lambda: template.render(context)\n\n        # Second yield\n        with context.push({\"mode\": \"body\"}):\n            body_html, body_error = yield lambda: template.render(context)\n\n        # Third yield\n        footer_html, footer_error = yield \"Footer content\"\n\n        # Process all results\n        if header_error or body_error or footer_error:\n            return \"Error occurred during rendering\"\n\n        return f\"{header_html}\n{body_html}\n{footer_html}\"\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode","title":"ProvideNode","text":"<pre><code>ProvideNode(params: List[TagAttr], flags: Optional[Dict[str, bool]] = None, nodelist: Optional[NodeList] = None, node_id: Optional[str] = None, contents: Optional[str] = None, template_name: Optional[str] = None, template_component: Optional[Type[Component]] = None)\n</code></pre> <p>Bases: <code>django_components.node.BaseNode</code></p> <p>See source code</p> <p>The <code>{% provide %}</code> tag is part of the \"provider\" part of the provide / inject feature.</p> <p>Pass kwargs to this tag to define the provider's data.</p> <p>Any components defined within the <code>{% provide %}..{% endprovide %}</code> tags will be able to access this data with <code>Component.inject()</code>.</p> <p>This is similar to React's <code>ContextProvider</code>, or Vue's <code>provide()</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Provider name. This is the name you will then use in     <code>Component.inject()</code>.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the provided data.</li> </ul> <p>Example:</p> <p>Provide the \"user_data\" in parent component:</p> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% provide \"user_data\" user=user %}\n          {% component \"child\" / %}\n        {% endprovide %}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"user\": kwargs[\"user\"],\n        }\n</code></pre> <p>Since the \"child\" component is used within the <code>{% provide %} / {% endprovide %}</code> tags, we can request the \"user_data\" using <code>Component.inject(\"user_data\")</code>:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        User is: {{ user }}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        user = self.inject(\"user_data\").user\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Notice that the keys defined on the <code>{% provide %}</code> tag are then accessed as attributes when accessing them with <code>Component.inject()</code>.</p> <p>\u2705 Do this <pre><code>user = self.inject(\"user_data\").user\n</code></pre></p> <p>\u274c Don't do this <pre><code>user = self.inject(\"user_data\")[\"user\"]\n</code></pre></p> <p>Methods:</p> <ul> <li> <code>parse</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>unregister</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>active_flags</code>               (<code>List[str]</code>)           \u2013            </li> <li> <code>allowed_flags</code>           \u2013            </li> <li> <code>contents</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>end_tag</code>           \u2013            </li> <li> <code>flags</code>               (<code>Dict[str, bool]</code>)           \u2013            </li> <li> <code>node_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>nodelist</code>               (<code>NodeList</code>)           \u2013            </li> <li> <code>params</code>               (<code>List[TagAttr]</code>)           \u2013            </li> <li> <code>tag</code>           \u2013            </li> <li> <code>template_component</code>               (<code>Optional[Type[Component]]</code>)           \u2013            </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ProvideNode.active_flags","title":"active_flags  <code>property</code>","text":"<pre><code>active_flags: List[str]\n</code></pre> <p>See source code</p> <p>Flags that were set for this specific instance as a list of strings.</p> <p>E.g. the following tag:</p> <pre><code>{% slot \"content\" default required / %}\n</code></pre> <p>Will have the following flags:</p> <pre><code>[\"default\", \"required\"]\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode.allowed_flags","title":"allowed_flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_flags = ()\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode.contents","title":"contents  <code>instance-attribute</code>","text":"<pre><code>contents: Optional[str] = contents\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The contents of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>contents</code> will be <code>\"&lt;div&gt; ... &lt;/div&gt;\"</code>.</p>"},{"location":"reference/api/#django_components.ProvideNode.end_tag","title":"end_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_tag = 'endprovide'\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode.flags","title":"flags  <code>instance-attribute</code>","text":"<pre><code>flags: Dict[str, bool] = flags or {flag: Falsefor flag in (allowed_flags or [])}\n</code></pre> <p>See source code</p> <p>See source code</p> <p>Dictionary of all <code>allowed_flags</code> that were set on the tag.</p> <p>Flags that were set are <code>True</code>, and the rest are <code>False</code>.</p> <p>E.g. the following tag:</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n    allowed_flags = [\"default\", \"required\"]\n</code></pre> <pre><code>{% slot \"content\" default %}\n</code></pre> <p>Has 2 flags, <code>default</code> and <code>required</code>, but only <code>default</code> was set.</p> <p>The <code>flags</code> dictionary will be:</p> <pre><code>{\n    \"default\": True,\n    \"required\": False,\n}\n</code></pre> <p>You can check if a flag is set by doing:</p> <pre><code>if node.flags[\"default\"]:\n    ...\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode.node_id","title":"node_id  <code>instance-attribute</code>","text":"<pre><code>node_id: str = node_id or gen_id()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The unique ID of the node.</p> <p>Extensions can use this ID to store additional information.</p>"},{"location":"reference/api/#django_components.ProvideNode.nodelist","title":"nodelist  <code>instance-attribute</code>","text":"<pre><code>nodelist: NodeList = nodelist or NodeList()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The nodelist of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>nodelist</code> will contain the <code>&lt;div&gt; ... &lt;/div&gt;</code> part.</p> <p>Unlike <code>contents</code>, the <code>nodelist</code> contains the actual Nodes, not just the text.</p>"},{"location":"reference/api/#django_components.ProvideNode.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: List[TagAttr] = params\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The parameters to the tag in the template.</p> <p>A single param represents an arg or kwarg of the template tag.</p> <p>E.g. the following tag:</p> <pre><code>{% component \"my_comp\" key=val key2='val2 two' %}\n</code></pre> <p>Has 3 params:</p> <ul> <li>Posiitonal arg <code>\"my_comp\"</code></li> <li>Keyword arg <code>key=val</code></li> <li>Keyword arg <code>key2='val2 two'</code></li> </ul>"},{"location":"reference/api/#django_components.ProvideNode.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag = 'provide'\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode.template_component","title":"template_component  <code>instance-attribute</code>","text":"<pre><code>template_component: Optional[Type[Component]] = template_component\n</code></pre> <p>See source code</p> <p>See source code</p> <p>If the template that contains this node belongs to a <code>Component</code>, then this will be the <code>Component</code> class.</p>"},{"location":"reference/api/#django_components.ProvideNode.template_name","title":"template_name  <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = template_name\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The name of the <code>Template</code> that contains this node.</p> <p>The template name is set by Django's template loaders.</p> <p>For example, the filesystem template loader will set this to the absolute path of the template file.</p> <pre><code>\"/home/user/project/templates/my_template.html\"\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(parser: Parser, token: Token, **kwargs: Any) -&gt; BaseNode\n</code></pre> <p>See source code</p> <p>This function is what is passed to Django's <code>Library.tag()</code> when registering the tag.</p> <p>In other words, this method is called by Django's template parser when we encounter a tag that matches this node's tag, e.g. <code>{% component %}</code> or <code>{% slot %}</code>.</p> <p>To register the tag, you can use <code>BaseNode.register()</code>.</p>"},{"location":"reference/api/#django_components.ProvideNode.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>A convenience method for registering the tag with the given library.</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mynode\"\n\nMyNode.register(library)\n</code></pre> <p>Allows you to then use the node in templates like so:</p> <pre><code>{% load mylibrary %}\n{% mynode %}\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode.render","title":"render","text":"<pre><code>render(context: Context, name: str, **kwargs: Any) -&gt; SafeString\n</code></pre>"},{"location":"reference/api/#django_components.ProvideNode.unregister","title":"unregister  <code>classmethod</code>","text":"<pre><code>unregister(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>Unregisters the node from the given library.</p>"},{"location":"reference/api/#django_components.RegistrySettings","title":"RegistrySettings","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Configuration for a <code>ComponentRegistry</code>.</p> <p>These settings define how the components registered with this registry will behave when rendered.</p> <pre><code>from django_components import ComponentRegistry, RegistrySettings\n\nregistry_settings = RegistrySettings(\n    context_behavior=\"django\",\n    tag_formatter=\"django_components.component_shorthand_formatter\",\n)\n\nregistry = ComponentRegistry(settings=registry_settings)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>CONTEXT_BEHAVIOR</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            </li> <li> <code>TAG_FORMATTER</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.RegistrySettings.CONTEXT_BEHAVIOR","title":"CONTEXT_BEHAVIOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTEXT_BEHAVIOR: Optional[ContextBehaviorType] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>context_behavior</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/api/#django_components.RegistrySettings.TAG_FORMATTER","title":"TAG_FORMATTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAG_FORMATTER: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>tag_formatter</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/api/#django_components.RegistrySettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>See source code</p> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/api/#django_components.RegistrySettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>See source code</p> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/api/#django_components.Slot","title":"Slot  <code>dataclass</code>","text":"<pre><code>Slot(contents: Any, content_func: SlotFunc[TSlotData] = cast('SlotFunc[TSlotData]', None), component_name: Optional[str] = None, slot_name: Optional[str] = None, nodelist: Optional[NodeList] = None, fill_node: Optional[Union[FillNode, ComponentNode]] = None, extra: Dict[str, Any] = dict())\n</code></pre> <p>Bases: <code>typing.Generic</code></p> <p>See source code</p> <p>This class is the main way for defining and handling slots.</p> <p>It holds the slot content function along with related metadata.</p> <p>Read more about Slot class.</p> <p>Example:</p> <p>Passing slots to components:</p> <pre><code>from django_components import Slot\n\nslot = Slot(lambda ctx: f\"Hello, {ctx.data['name']}!\")\n\nMyComponent.render(\n    slots={\n        \"my_slot\": slot,\n    },\n)\n</code></pre> <p>Accessing slots inside the components:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        my_slot = slots[\"my_slot\"]\n        return {\n            \"my_slot\": my_slot,\n        }\n</code></pre> <p>Rendering slots:</p> <pre><code>from django_components import Slot\n\nslot = Slot(lambda ctx: f\"Hello, {ctx.data['name']}!\")\nhtml = slot({\"name\": \"John\"})  # Output: Hello, John!\n</code></pre> <p>Attributes:</p> <ul> <li> <code>component_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>content_func</code>               (<code>SlotFunc[TSlotData]</code>)           \u2013            </li> <li> <code>contents</code>               (<code>Any</code>)           \u2013            </li> <li> <code>do_not_call_in_templates</code>               (<code>bool</code>)           \u2013            </li> <li> <code>extra</code>               (<code>Dict[str, Any]</code>)           \u2013            </li> <li> <code>fill_node</code>               (<code>Optional[Union[FillNode, ComponentNode]]</code>)           \u2013            </li> <li> <code>nodelist</code>               (<code>Optional[NodeList]</code>)           \u2013            </li> <li> <code>slot_name</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.Slot.component_name","title":"component_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>component_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the component that originally received this slot fill.</p> <p>See Slot metadata.</p>"},{"location":"reference/api/#django_components.Slot.content_func","title":"content_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content_func: SlotFunc[TSlotData] = cast('SlotFunc[TSlotData]', None)\n</code></pre> <p>See source code</p> <p>The actual slot function.</p> <p>Do NOT call this function directly, instead call the <code>Slot</code> instance as a function.</p> <p>Read more about Rendering slot functions.</p>"},{"location":"reference/api/#django_components.Slot.contents","title":"contents  <code>instance-attribute</code>","text":"<pre><code>contents: Any\n</code></pre> <p>See source code</p> <p>The original value that was passed to the <code>Slot</code> constructor.</p> <ul> <li>If Slot was created from <code>{% fill %}</code> tag, <code>Slot.contents</code> will contain   the body (string) of that <code>{% fill %}</code> tag.</li> <li>If Slot was created from string as <code>Slot(\"...\")</code>, <code>Slot.contents</code> will contain that string.</li> <li>If Slot was created from a function, <code>Slot.contents</code> will contain that function.</li> </ul> <p>Read more about Slot contents.</p>"},{"location":"reference/api/#django_components.Slot.do_not_call_in_templates","title":"do_not_call_in_templates  <code>property</code>","text":"<pre><code>do_not_call_in_templates: bool\n</code></pre> <p>See source code</p> <p>Django special property to prevent calling the instance as a function inside Django templates.</p>"},{"location":"reference/api/#django_components.Slot.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra: Dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>See source code</p> <p>Dictionary that can be used to store arbitrary metadata about the slot.</p> <p>See Slot metadata.</p> <p>See Pass slot metadata for usage for extensions.</p> <p>Example:</p> <pre><code># Either at slot creation\nslot = Slot(lambda ctx: \"Hello, world!\", extra={\"foo\": \"bar\"})\n\n# Or later\nslot.extra[\"baz\"] = \"qux\"\n</code></pre>"},{"location":"reference/api/#django_components.Slot.fill_node","title":"fill_node  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fill_node: Optional[Union[FillNode, ComponentNode]] = None\n</code></pre> <p>See source code</p> <p>If the slot was created from a <code>{% fill %}</code> tag, this will be the <code>FillNode</code> instance.</p> <p>If the slot was a default slot created from a <code>{% component %}</code> tag, this will be the <code>ComponentNode</code> instance.</p> <p>Otherwise, this will be <code>None</code>.</p> <p>Extensions can use this info to handle slots differently based on their source.</p> <p>See Slot metadata.</p> <p>Example:</p> <p>You can use this to find the <code>Component</code> in whose template the <code>{% fill %}</code> tag was defined:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        footer_slot = slots.get(\"footer\")\n        if footer_slot is not None and footer_slot.fill_node is not None:\n            owner_component = footer_slot.fill_node.template_component\n            # ...\n</code></pre>"},{"location":"reference/api/#django_components.Slot.nodelist","title":"nodelist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nodelist: Optional[NodeList] = None\n</code></pre> <p>See source code</p> <p>If the slot was defined with <code>{% fill %}</code> tag, this will be the Nodelist of the fill's content.</p> <p>See Slot metadata.</p>"},{"location":"reference/api/#django_components.Slot.slot_name","title":"slot_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slot_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Slot name to which this Slot was initially assigned.</p> <p>See Slot metadata.</p>"},{"location":"reference/api/#django_components.SlotContent","title":"SlotContent  <code>module-attribute</code>","text":"<pre><code>SlotContent = SlotInput[TSlotData]\n</code></pre> <p>See source code</p> <p>DEPRECATED: Use <code>SlotInput</code> instead. Will be removed in v1.</p>"},{"location":"reference/api/#django_components.SlotContext","title":"SlotContext  <code>dataclass</code>","text":"<pre><code>SlotContext(data: TSlotData, fallback: Optional[Union[str, SlotFallback]] = None, context: Optional[Context] = None)\n</code></pre> <p>Bases: <code>typing.Generic</code></p> <p>See source code</p> <p>Metadata available inside slot functions.</p> <p>Read more about Slot functions.</p> <p>Example:</p> <pre><code>from django_components import SlotContext, SlotResult\n\ndef my_slot(ctx: SlotContext) -&gt; SlotResult:\n    return f\"Hello, {ctx.data['name']}!\"\n</code></pre> <p>You can pass a type parameter to the <code>SlotContext</code> to specify the type of the data passed to the slot:</p> <pre><code>class MySlotData(TypedDict):\n    name: str\n\ndef my_slot(ctx: SlotContext[MySlotData]):\n    return f\"Hello, {ctx.data['name']}!\"\n</code></pre> <p>Attributes:</p> <ul> <li> <code>context</code>               (<code>Optional[Context]</code>)           \u2013            </li> <li> <code>data</code>               (<code>TSlotData</code>)           \u2013            </li> <li> <code>fallback</code>               (<code>Optional[Union[str, SlotFallback]]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.SlotContext.context","title":"context  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context: Optional[Context] = None\n</code></pre> <p>See source code</p> <p>Django template <code>Context</code> available inside the <code>{% fill %}</code> tag.</p> <p>May be <code>None</code> if you call the slot fill directly, without using <code>{% slot %}</code> tags.</p>"},{"location":"reference/api/#django_components.SlotContext.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: TSlotData\n</code></pre> <p>See source code</p> <p>Data passed to the slot.</p> <p>Read more about Slot data.</p> <p>Example:</p> <pre><code>def my_slot(ctx: SlotContext):\n    return f\"Hello, {ctx.data['name']}!\"\n</code></pre>"},{"location":"reference/api/#django_components.SlotContext.fallback","title":"fallback  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fallback: Optional[Union[str, SlotFallback]] = None\n</code></pre> <p>See source code</p> <p>Slot's fallback content. Lazily-rendered - coerce this value to string to force it to render.</p> <p>Read more about Slot fallback.</p> <p>Example:</p> <pre><code>def my_slot(ctx: SlotContext):\n    return f\"Hello, {ctx.fallback}!\"\n</code></pre> <p>May be <code>None</code> if you call the slot fill directly, without using <code>{% slot %}</code> tags.</p>"},{"location":"reference/api/#django_components.SlotFallback","title":"SlotFallback","text":"<pre><code>SlotFallback(slot: SlotNode, context: Context)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>The content between the <code>{% slot %}..{% endslot %}</code> tags is the fallback content that will be rendered if no fill is given for the slot.</p> <pre><code>{% slot \"name\" %}\n    Hello, my name is {{ name }}  &lt;!-- Fallback content --&gt;\n{% endslot %}\n</code></pre> <p>Because the fallback is defined as a piece of the template (<code>NodeList</code>), we want to lazily render it only when needed.</p> <p><code>SlotFallback</code> type allows to pass around the slot fallback as a variable.</p> <p>To force the fallback to render, coerce it to string to trigger the <code>__str__()</code> method.</p> <p>Example:</p> <pre><code>def slot_function(self, ctx: SlotContext):\n    return f\"Hello, {ctx.fallback}!\"\n</code></pre>"},{"location":"reference/api/#django_components.SlotFunc","title":"SlotFunc","text":"<p>Bases: <code>typing.Protocol</code></p> <p>See source code</p> <p>When rendering components with <code>Component.render()</code> or <code>Component.render_to_response()</code>, the slots can be given either as strings or as functions.</p> <p>If a slot is given as a function, it will have the signature of <code>SlotFunc</code>.</p> <p>Read more about Slot functions.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>SlotContext</code>)           \u2013            <p>Single named tuple that holds the slot data and metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | SafeString</code>           \u2013            <p>The rendered slot content.</p> </li> </ul> <p>Example:</p> <pre><code>from django_components import SlotContext, SlotResult\n\ndef header(ctx: SlotContext) -&gt; SlotResult:\n    if ctx.data.get(\"name\"):\n        return f\"Hello, {ctx.data['name']}!\"\n    else:\n        return ctx.fallback\n\nhtml = MyTable.render(\n    slots={\n        \"header\": header,\n    },\n)\n</code></pre>"},{"location":"reference/api/#django_components.SlotInput","title":"SlotInput  <code>module-attribute</code>","text":"<pre><code>SlotInput = Union[SlotResult, SlotFunc[TSlotData], Slot[TSlotData]]\n</code></pre> <p>See source code</p> <p>Type representing all forms in which slot content can be passed to a component.</p> <p>When rendering a component with <code>Component.render()</code> or <code>Component.render_to_response()</code>, the slots may be given a strings, functions, or <code>Slot</code> instances. This type describes that union.</p> <p>Use this type when typing the slots in your component.</p> <p><code>SlotInput</code> accepts an optional type parameter to specify the data dictionary that will be passed to the slot content function.</p> <p>Example:</p> <pre><code>from typing import NamedTuple\nfrom typing_extensions import TypedDict\nfrom django_components import Component, SlotInput\n\nclass TableFooterSlotData(TypedDict):\n    page_number: int\n\nclass Table(Component):\n    class Slots(NamedTuple):\n        header: SlotInput\n        footer: SlotInput[TableFooterSlotData]\n\n    template = \"&lt;div&gt;{% slot 'footer' %}&lt;/div&gt;\"\n\nhtml = Table.render(\n    slots={\n        # As a string\n        \"header\": \"Hello, World!\",\n\n        # Safe string\n        \"header\": mark_safe(\"&lt;i&gt;&lt;am&gt;&lt;safe&gt;\"),\n\n        # Function\n        \"footer\": lambda ctx: f\"Page: {ctx.data['page_number']}!\",\n\n        # Slot instance\n        \"footer\": Slot(lambda ctx: f\"Page: {ctx.data['page_number']}!\"),\n\n        # None (Same as no slot)\n        \"header\": None,\n    },\n)\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode","title":"SlotNode","text":"<pre><code>SlotNode(params: List[TagAttr], flags: Optional[Dict[str, bool]] = None, nodelist: Optional[NodeList] = None, node_id: Optional[str] = None, contents: Optional[str] = None, template_name: Optional[str] = None, template_component: Optional[Type[Component]] = None)\n</code></pre> <p>Bases: <code>django_components.node.BaseNode</code></p> <p>See source code</p> <p><code>{% slot %}</code> tag marks a place inside a component where content can be inserted from outside.</p> <p>Learn more about using slots.</p> <p>This is similar to slots as seen in Web components, Vue or React's <code>children</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li><code>default</code>: Optional flag. If there is a default slot, you can pass the component slot content     without using the <code>{% fill %}</code> tag. See     Default slot</li> <li><code>required</code>: Optional flag. Will raise an error if a slot is required but not given.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the slot data.</li> </ul> <p>Example:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" default %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n      &lt;aside&gt;\n        {% slot \"sidebar\" required / %}\n      &lt;/aside&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% fill \"content\" %}\n            \ud83d\uddde\ufe0f\ud83d\udcf0\n          {% endfill %}\n\n          {% fill \"sidebar\" %}\n            \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n          {% endfill %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode--slot-data","title":"Slot data","text":"<p>Any extra kwargs will be considered as slot data, and will be accessible in the <code>{% fill %}</code> tag via fill's <code>data</code> kwarg:</p> <p>Read more about Slot data.</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {# Passing data to the slot #}\n        {% slot \"content\" user=user %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot data #}\n      {% component \"child\" %}\n        {% fill \"content\" data=\"data\" %}\n          &lt;div class=\"wrapper-class\"&gt;\n            {{ data.user }}\n          &lt;/div&gt;\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode--slot-fallback","title":"Slot fallback","text":"<p>The content between the <code>{% slot %}..{% endslot %}</code> tags is the fallback content that will be rendered if no fill is given for the slot.</p> <p>This fallback content can then be accessed from within the <code>{% fill %}</code> tag using the fill's <code>fallback</code> kwarg. This is useful if you need to wrap / prepend / append the original slot's content.</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" %}\n          This is fallback content!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot's fallback content #}\n      {% component \"child\" %}\n        {% fill \"content\" fallback=\"fallback\" %}\n          {{ fallback }}\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre> <p>Methods:</p> <ul> <li> <code>parse</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>unregister</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>active_flags</code>               (<code>List[str]</code>)           \u2013            </li> <li> <code>allowed_flags</code>           \u2013            </li> <li> <code>contents</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>end_tag</code>           \u2013            </li> <li> <code>flags</code>               (<code>Dict[str, bool]</code>)           \u2013            </li> <li> <code>node_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>nodelist</code>               (<code>NodeList</code>)           \u2013            </li> <li> <code>params</code>               (<code>List[TagAttr]</code>)           \u2013            </li> <li> <code>tag</code>           \u2013            </li> <li> <code>template_component</code>               (<code>Optional[Type[Component]]</code>)           \u2013            </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.SlotNode.active_flags","title":"active_flags  <code>property</code>","text":"<pre><code>active_flags: List[str]\n</code></pre> <p>See source code</p> <p>Flags that were set for this specific instance as a list of strings.</p> <p>E.g. the following tag:</p> <pre><code>{% slot \"content\" default required / %}\n</code></pre> <p>Will have the following flags:</p> <pre><code>[\"default\", \"required\"]\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode.allowed_flags","title":"allowed_flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_flags = (SLOT_DEFAULT_FLAG, SLOT_REQUIRED_FLAG)\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode.contents","title":"contents  <code>instance-attribute</code>","text":"<pre><code>contents: Optional[str] = contents\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The contents of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>contents</code> will be <code>\"&lt;div&gt; ... &lt;/div&gt;\"</code>.</p>"},{"location":"reference/api/#django_components.SlotNode.end_tag","title":"end_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_tag = 'endslot'\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode.flags","title":"flags  <code>instance-attribute</code>","text":"<pre><code>flags: Dict[str, bool] = flags or {flag: Falsefor flag in (allowed_flags or [])}\n</code></pre> <p>See source code</p> <p>See source code</p> <p>Dictionary of all <code>allowed_flags</code> that were set on the tag.</p> <p>Flags that were set are <code>True</code>, and the rest are <code>False</code>.</p> <p>E.g. the following tag:</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n    allowed_flags = [\"default\", \"required\"]\n</code></pre> <pre><code>{% slot \"content\" default %}\n</code></pre> <p>Has 2 flags, <code>default</code> and <code>required</code>, but only <code>default</code> was set.</p> <p>The <code>flags</code> dictionary will be:</p> <pre><code>{\n    \"default\": True,\n    \"required\": False,\n}\n</code></pre> <p>You can check if a flag is set by doing:</p> <pre><code>if node.flags[\"default\"]:\n    ...\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode.node_id","title":"node_id  <code>instance-attribute</code>","text":"<pre><code>node_id: str = node_id or gen_id()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The unique ID of the node.</p> <p>Extensions can use this ID to store additional information.</p>"},{"location":"reference/api/#django_components.SlotNode.nodelist","title":"nodelist  <code>instance-attribute</code>","text":"<pre><code>nodelist: NodeList = nodelist or NodeList()\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The nodelist of the tag.</p> <p>This is the text between the opening and closing tags, e.g.</p> <pre><code>{% slot \"content\" default required %}\n  &lt;div&gt;\n    ...\n  &lt;/div&gt;\n{% endslot %}\n</code></pre> <p>The <code>nodelist</code> will contain the <code>&lt;div&gt; ... &lt;/div&gt;</code> part.</p> <p>Unlike <code>contents</code>, the <code>nodelist</code> contains the actual Nodes, not just the text.</p>"},{"location":"reference/api/#django_components.SlotNode.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: List[TagAttr] = params\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The parameters to the tag in the template.</p> <p>A single param represents an arg or kwarg of the template tag.</p> <p>E.g. the following tag:</p> <pre><code>{% component \"my_comp\" key=val key2='val2 two' %}\n</code></pre> <p>Has 3 params:</p> <ul> <li>Posiitonal arg <code>\"my_comp\"</code></li> <li>Keyword arg <code>key=val</code></li> <li>Keyword arg <code>key2='val2 two'</code></li> </ul>"},{"location":"reference/api/#django_components.SlotNode.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag = 'slot'\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode.template_component","title":"template_component  <code>instance-attribute</code>","text":"<pre><code>template_component: Optional[Type[Component]] = template_component\n</code></pre> <p>See source code</p> <p>See source code</p> <p>If the template that contains this node belongs to a <code>Component</code>, then this will be the <code>Component</code> class.</p>"},{"location":"reference/api/#django_components.SlotNode.template_name","title":"template_name  <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = template_name\n</code></pre> <p>See source code</p> <p>See source code</p> <p>The name of the <code>Template</code> that contains this node.</p> <p>The template name is set by Django's template loaders.</p> <p>For example, the filesystem template loader will set this to the absolute path of the template file.</p> <pre><code>\"/home/user/project/templates/my_template.html\"\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(parser: Parser, token: Token, **kwargs: Any) -&gt; BaseNode\n</code></pre> <p>See source code</p> <p>This function is what is passed to Django's <code>Library.tag()</code> when registering the tag.</p> <p>In other words, this method is called by Django's template parser when we encounter a tag that matches this node's tag, e.g. <code>{% component %}</code> or <code>{% slot %}</code>.</p> <p>To register the tag, you can use <code>BaseNode.register()</code>.</p>"},{"location":"reference/api/#django_components.SlotNode.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>A convenience method for registering the tag with the given library.</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mynode\"\n\nMyNode.register(library)\n</code></pre> <p>Allows you to then use the node in templates like so:</p> <pre><code>{% load mylibrary %}\n{% mynode %}\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode.render","title":"render","text":"<pre><code>render(context: Context, name: str, **kwargs: Any) -&gt; SafeString\n</code></pre>"},{"location":"reference/api/#django_components.SlotNode.unregister","title":"unregister  <code>classmethod</code>","text":"<pre><code>unregister(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>Unregisters the node from the given library.</p>"},{"location":"reference/api/#django_components.SlotRef","title":"SlotRef  <code>module-attribute</code>","text":"<pre><code>SlotRef = SlotFallback\n</code></pre> <p>See source code</p> <p>DEPRECATED: Use <code>SlotFallback</code> instead. Will be removed in v1.</p>"},{"location":"reference/api/#django_components.SlotResult","title":"SlotResult  <code>module-attribute</code>","text":"<pre><code>SlotResult = Union[str, SafeString]\n</code></pre> <p>See source code</p> <p>Type representing the result of a slot render function.</p> <p>Example:</p> <pre><code>from django_components import SlotContext, SlotResult\n\ndef my_slot_fn(ctx: SlotContext) -&gt; SlotResult:\n    return \"Hello, world!\"\n\nmy_slot = Slot(my_slot_fn)\nhtml = my_slot()  # Output: Hello, world!\n</code></pre> <p>Read more about Slot functions.</p>"},{"location":"reference/api/#django_components.TagFormatterABC","title":"TagFormatterABC","text":"<p>Bases: <code>abc.ABC</code></p> <p>See source code</p> <p>Abstract base class for defining custom tag formatters.</p> <p>Tag formatters define how the component tags are used in the template.</p> <p>Read more about Tag formatter.</p> <p>For example, with the default tag formatter (<code>ComponentFormatter</code>), components are written as:</p> <pre><code>{% component \"comp_name\" %}\n{% endcomponent %}\n</code></pre> <p>While with the shorthand tag formatter (<code>ShorthandComponentFormatter</code>), components are written as: <pre><code>{% comp_name %}\n{% endcomp_name %}\n</code></pre></p> <p>Example:</p> <p>Implementation for <code>ShorthandComponentFormatter</code>:</p> <pre><code>from djagno_components import TagFormatterABC, TagResult\n\nclass ShorthandComponentFormatter(TagFormatterABC):\n    def start_tag(self, name: str) -&gt; str:\n        return name\n\n    def end_tag(self, name: str) -&gt; str:\n        return f\"end{name}\"\n\n    def parse(self, tokens: List[str]) -&gt; TagResult:\n        tokens = [*tokens]\n        name = tokens.pop(0)\n        return TagResult(name, tokens)\n</code></pre> <p>Methods:</p> <ul> <li> <code>end_tag</code>             \u2013              </li> <li> <code>parse</code>             \u2013              </li> <li> <code>start_tag</code>             \u2013              </li> </ul>"},{"location":"reference/api/#django_components.TagFormatterABC.end_tag","title":"end_tag  <code>abstractmethod</code>","text":"<pre><code>end_tag(name: str) -&gt; str\n</code></pre> <p>See source code</p> <p>Formats the end tag of a block component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted end tag.</p> </li> </ul>"},{"location":"reference/api/#django_components.TagFormatterABC.parse","title":"parse  <code>abstractmethod</code>","text":"<pre><code>parse(tokens: List[str]) -&gt; TagResult\n</code></pre> <p>See source code</p> <p>Given the tokens (words) passed to a component start tag, this function extracts the component name from the tokens list, and returns <code>TagResult</code>, which is a tuple of <code>(component_name, remaining_tokens)</code>.</p> <p>Parameters:</p> <ul> <li> <code>tokens</code>               (<code>List[str]</code>)           \u2013            <p>List of tokens passed to the component tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TagResult</code> (              <code>TagResult</code> )          \u2013            <p>Parsed component name and remaining tokens.</p> </li> </ul> <p>Example:</p> <p>Assuming we used a component in a template like this:</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n{% endcomponent %}\n</code></pre> <p>This function receives a list of tokens:</p> <pre><code>['component', '\"my_comp\"', 'key=val', 'key2=val2']\n</code></pre> <ul> <li><code>component</code> is the tag name, which we drop.</li> <li><code>\"my_comp\"</code> is the component name, but we must remove the extra quotes.</li> <li>The remaining tokens we pass unmodified, as that's the input to the component.</li> </ul> <p>So in the end, we return:</p> <pre><code>TagResult('my_comp', ['key=val', 'key2=val2'])\n</code></pre>"},{"location":"reference/api/#django_components.TagFormatterABC.start_tag","title":"start_tag  <code>abstractmethod</code>","text":"<pre><code>start_tag(name: str) -&gt; str\n</code></pre> <p>See source code</p> <p>Formats the start tag of a component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted start tag.</p> </li> </ul>"},{"location":"reference/api/#django_components.TagResult","title":"TagResult","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>The return value from <code>TagFormatter.parse()</code>.</p> <p>Read more about Tag formatter.</p> <p>Attributes:</p> <ul> <li> <code>component_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>tokens</code>               (<code>List[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.TagResult.component_name","title":"component_name  <code>instance-attribute</code>","text":"<pre><code>component_name: str\n</code></pre> <p>See source code</p> <p>Component name extracted from the template tag</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>component_name</code> would be <code>my_comp</code>.</p>"},{"location":"reference/api/#django_components.TagResult.tokens","title":"tokens  <code>instance-attribute</code>","text":"<pre><code>tokens: List[str]\n</code></pre> <p>See source code</p> <p>Remaining tokens (words) that were passed to the tag, with component name removed</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>tokens</code> would be <code>['key=val', 'key2=val2']</code>.</p>"},{"location":"reference/api/#django_components.all_components","title":"all_components","text":"<pre><code>all_components() -&gt; List[Type[Component]]\n</code></pre> <p>See source code</p> <p>Get a list of all created <code>Component</code> classes.</p>"},{"location":"reference/api/#django_components.all_registries","title":"all_registries","text":"<pre><code>all_registries() -&gt; List[ComponentRegistry]\n</code></pre> <p>See source code</p> <p>Get a list of all created <code>ComponentRegistry</code> instances.</p>"},{"location":"reference/api/#django_components.autodiscover","title":"autodiscover","text":"<pre><code>autodiscover(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>See source code</p> <p>Search for all python files in <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> and import them.</p> <p>See Autodiscovery.</p> <p>NOTE: Subdirectories and files starting with an underscore <code>_</code> (except for <code>__init__.py</code> are ignored.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>To get the same list of modules that <code>autodiscover()</code> would return, but without importing them, use <code>get_component_files()</code>:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre>"},{"location":"reference/api/#django_components.cached_template","title":"cached_template","text":"<pre><code>cached_template(template_string: str, template_cls: Optional[Type[Template]] = None, origin: Optional[Origin] = None, name: Optional[str] = None, engine: Optional[Any] = None) -&gt; Template\n</code></pre> <p>See source code</p> <p>DEPRECATED. Template caching will be removed in v1.</p> <p>Create a Template instance that will be cached as per the <code>COMPONENTS.template_cache_size</code> setting.</p> <p>Parameters:</p> <ul> <li> <code>template_string</code>               (<code>str</code>)           \u2013            <p>Template as a string, same as the first argument to Django's            <code>Template</code>. Required.</p> </li> <li> <code>template_cls</code>               (<code>Type[Template]</code>, default:                   <code>None</code> )           \u2013            <p>Specify the Template class that should be instantiated.            Defaults to Django's <code>Template</code> class.</p> </li> <li> <code>origin</code>               (<code>Type[Origin]</code>, default:                   <code>None</code> )           \u2013            <p>Sets             <code>Template.Origin</code>.</p> </li> <li> <code>name</code>               (<code>Type[str]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.name</code></p> </li> <li> <code>engine</code>               (<code>Type[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.engine</code></p> </li> </ul> <pre><code>from django_components import cached_template\n\ntemplate = cached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ntemplate = cached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/api/#django_components.format_attributes","title":"format_attributes","text":"<pre><code>format_attributes(attributes: Mapping[str, Any]) -&gt; str\n</code></pre> <p>See source code</p> <p>Format a dict of attributes into an HTML attributes string.</p> <p>Read more about HTML attributes.</p> <p>Example:</p> <pre><code>format_attributes({\"class\": \"my-class\", \"data-id\": \"123\"})\n</code></pre> <p>will return</p> <pre><code>'class=\"my-class\" data-id=\"123\"'\n</code></pre>"},{"location":"reference/api/#django_components.get_component_by_class_id","title":"get_component_by_class_id","text":"<pre><code>get_component_by_class_id(comp_cls_id: str) -&gt; Type[Component]\n</code></pre> <p>See source code</p> <p>Get a component class by its unique ID.</p> <p>Each component class is associated with a unique hash that's derived from its module import path.</p> <p>E.g. <code>path.to.my.secret.MyComponent</code> -&gt; <code>MyComponent_ab01f32</code></p> <p>This hash is available under <code>class_id</code> on the component class.</p> <p>Raises <code>KeyError</code> if the component class is not found.</p> <p>NOTE: This is mainly intended for extensions.</p>"},{"location":"reference/api/#django_components.get_component_dirs","title":"get_component_dirs","text":"<pre><code>get_component_dirs(include_apps: bool = True) -&gt; List[Path]\n</code></pre> <p>See source code</p> <p>Get directories that may contain component files.</p> <p>This is the heart of all features that deal with filesystem and file lookup. Autodiscovery, Django template resolution, static file resolution - They all use this.</p> <p>Parameters:</p> <ul> <li> <code>include_apps</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Include directories from installed Django apps.            Defaults to <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Path]</code>           \u2013            <p>List[Path]: A list of directories that may contain component files.</p> </li> </ul> <p><code>get_component_dirs()</code> searches for dirs set in <code>COMPONENTS.dirs</code> settings. If none set, defaults to searching for a <code>\"components\"</code> app.</p> <p>In addition to that, also all installed Django apps are checked whether they contain directories as set in <code>COMPONENTS.app_dirs</code> (e.g. <code>[app]/components</code>).</p> <p>Notes:</p> <ul> <li> <p>Paths that do not point to directories are ignored.</p> </li> <li> <p><code>BASE_DIR</code> setting is required.</p> </li> <li> <p>The paths in <code>COMPONENTS.dirs</code>     must be absolute paths.</p> </li> </ul>"},{"location":"reference/api/#django_components.get_component_files","title":"get_component_files","text":"<pre><code>get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]\n</code></pre> <p>See source code</p> <p>Search for files within the component directories (as defined in <code>get_component_dirs()</code>).</p> <p>Requires <code>BASE_DIR</code> setting to be set.</p> <p>Subdirectories and files starting with an underscore <code>_</code> (except <code>__init__.py</code>) are ignored.</p> <p>Parameters:</p> <ul> <li> <code>suffix</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The suffix to search for. E.g. <code>.py</code>, <code>.js</code>, <code>.css</code>.            Defaults to <code>None</code>, which will search for all files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ComponentFileEntry]</code>           \u2013            <p>List[ComponentFileEntry] A list of entries that contain both the filesystem path and             the python import path (dot path).</p> </li> </ul> <p>Example:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre>"},{"location":"reference/api/#django_components.get_component_url","title":"get_component_url","text":"<pre><code>get_component_url(component: Union[Type[Component], Component], query: Optional[Dict] = None, fragment: Optional[str] = None) -&gt; str\n</code></pre> <p>See source code</p> <p>Get the URL for a <code>Component</code>.</p> <p>Raises <code>RuntimeError</code> if the component is not public.</p> <p>Read more about Component views and URLs.</p> <p><code>get_component_url()</code> optionally accepts <code>query</code> and <code>fragment</code> arguments.</p> <p>Query parameter handling:</p> <ul> <li><code>True</code> values are rendered as flag parameters without values (e.g., <code>?enabled</code>)</li> <li><code>False</code> and <code>None</code> values are omitted from the URL</li> <li>Other values are rendered normally (e.g., <code>?foo=bar</code>)</li> </ul> <p>Example:</p> <pre><code>from django_components import Component, get_component_url\n\nclass MyComponent(Component):\n    class View:\n        public = True\n\n# Get the URL for the component\nurl = get_component_url(\n    MyComponent,\n    query={\"foo\": \"bar\", \"enabled\": True, \"debug\": False, \"unused\": None},\n    fragment=\"baz\",\n)\n# /components/ext/view/components/c1ab2c3?foo=bar&amp;enabled#baz\n</code></pre>"},{"location":"reference/api/#django_components.import_libraries","title":"import_libraries","text":"<pre><code>import_libraries(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>See source code</p> <p>Import modules set in <code>COMPONENTS.libraries</code> setting.</p> <p>See Autodiscovery.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>Examples:</p> <p>Normal usage - load libraries after Django has loaded <pre><code>from django_components import import_libraries\n\nclass MyAppConfig(AppConfig):\n    def ready(self):\n        import_libraries()\n</code></pre></p> <p>Potential usage in tests <pre><code>from django_components import import_libraries\n\nimport_libraries(lambda path: path.replace(\"tests.\", \"myapp.\"))\n</code></pre></p>"},{"location":"reference/api/#django_components.merge_attributes","title":"merge_attributes","text":"<pre><code>merge_attributes(*attrs: Dict) -&gt; Dict\n</code></pre> <p>See source code</p> <p>Merge a list of dictionaries into a single dictionary.</p> <p>The dictionaries are treated as HTML attributes and are merged accordingly:</p> <ul> <li>If a same key is present in multiple dictionaries, the values are joined with a space   character.</li> <li>The <code>class</code> and <code>style</code> keys are handled specially, similar to   how Vue does it.</li> </ul> <p>Read more about HTML attributes.</p> <p>Example:</p> <pre><code>merge_attributes(\n    {\"my-attr\": \"my-value\", \"class\": \"my-class\"},\n    {\"my-attr\": \"extra-value\", \"data-id\": \"123\"},\n)\n</code></pre> <p>will result in</p> <pre><code>{\n    \"my-attr\": \"my-value extra-value\",\n    \"class\": \"my-class\",\n    \"data-id\": \"123\",\n}\n</code></pre> <p>The <code>class</code> attribute</p> <p>The <code>class</code> attribute can be given as a string, or a dictionary.</p> <ul> <li>If given as a string, it is used as is.</li> <li>If given as a dictionary, only the keys with a truthy value are used.</li> </ul> <p>Example:</p> <pre><code>merge_attributes(\n    {\"class\": \"my-class extra-class\"},\n    {\"class\": {\"truthy\": True, \"falsy\": False}},\n)\n</code></pre> <p>will result in</p> <pre><code>{\n    \"class\": \"my-class extra-class truthy\",\n}\n</code></pre> <p>The <code>style</code> attribute</p> <p>The <code>style</code> attribute can be given as a string, a list, or a dictionary.</p> <ul> <li>If given as a string, it is used as is.</li> <li>If given as a dictionary, it is converted to a style attribute string.</li> </ul> <p>Example:</p> <pre><code>merge_attributes(\n    {\"style\": \"color: red; background-color: blue;\"},\n    {\"style\": {\"background-color\": \"green\", \"color\": False}},\n)\n</code></pre> <p>will result in</p> <pre><code>{\n    \"style\": \"color: red; background-color: blue; background-color: green;\",\n}\n</code></pre>"},{"location":"reference/api/#django_components.register","title":"register","text":"<pre><code>register(name: str, registry: Optional[ComponentRegistry] = None) -&gt; Callable[[Type[TComponent]], Type[TComponent]]\n</code></pre> <p>See source code</p> <p>Class decorator for registering a component to a component registry.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Registered name. This is the name by which the component will be accessed            from within a template when using the <code>{% component %}</code> tag. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to which to register this component. If omitted, component is registered to the default registry.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AlreadyRegistered</code>             \u2013            <p>If there is already a component registered under the same name.</p> </li> </ul> <p>Examples:</p> <pre><code>from django_components import Component, register\n\n@register(\"my_component\")\nclass MyComponent(Component):\n    ...\n</code></pre> <p>Specifing <code>ComponentRegistry</code> the component should be registered to by setting the <code>registry</code> kwarg:</p> <pre><code>from django.template import Library\nfrom django_components import Component, ComponentRegistry, register\n\nmy_lib = Library()\nmy_reg = ComponentRegistry(library=my_lib)\n\n@register(\"my_component\", registry=my_reg)\nclass MyComponent(Component):\n    ...\n</code></pre>"},{"location":"reference/api/#django_components.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry: ComponentRegistry = ComponentRegistry()\n</code></pre> <p>See source code</p> <p>The default and global component registry. Use this instance to directly register or remove components:</p> <p>See Registering components.</p> <pre><code># Register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n\n# Get single\nregistry.get(\"button\")\n\n# Get all\nregistry.all()\n\n# Check if component is registered\nregistry.has(\"button\")\n\n# Unregister single\nregistry.unregister(\"button\")\n\n# Unregister all\nregistry.clear()\n</code></pre>"},{"location":"reference/api/#django_components.render_dependencies","title":"render_dependencies","text":"<pre><code>render_dependencies(content: TContent, strategy: DependenciesStrategy = 'document') -&gt; TContent\n</code></pre> <p>See source code</p> <p>Given a string that contains parts that were rendered by components, this function inserts all used JS and CSS.</p> <p>By default, the string is parsed as an HTML and: - CSS is inserted at the end of <code>&lt;head&gt;</code> (if present) - JS is inserted at the end of <code>&lt;body&gt;</code> (if present)</p> <p>If you used <code>{% component_js_dependencies %}</code> or <code>{% component_css_dependencies %}</code>, then the JS and CSS will be inserted only at these locations.</p> <p>Example: <pre><code>def my_view(request):\n    template = Template('''\n        {% load components %}\n        &lt;!doctype html&gt;\n        &lt;html&gt;\n            &lt;head&gt;&lt;/head&gt;\n            &lt;body&gt;\n                &lt;h1&gt;{{ table_name }}&lt;/h1&gt;\n                {% component \"table\" name=table_name / %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    ''')\n\n    html = template.render(\n        Context({\n            \"table_name\": request.GET[\"name\"],\n        })\n    )\n\n    # This inserts components' JS and CSS\n    processed_html = render_dependencies(html)\n\n    return HttpResponse(processed_html)\n</code></pre></p>"},{"location":"reference/api/#django_components.template_tag","title":"template_tag","text":"<pre><code>template_tag(library: Library, tag: str, end_tag: Optional[str] = None, allowed_flags: Optional[List[str]] = None) -&gt; Callable[[Callable], Callable]\n</code></pre> <p>See source code</p> <p>A simplified version of creating a template tag based on <code>BaseNode</code>.</p> <p>Instead of defining the whole class, you can just define the <code>render()</code> method.</p> <pre><code>from django.template import Context, Library\nfrom django_components import BaseNode, template_tag\n\nlibrary = Library()\n\n@template_tag(\n    library,\n    tag=\"mytag\",\n    end_tag=\"endmytag\",\n    allowed_flags=[\"required\"],\n)\ndef mytag(node: BaseNode, context: Context, name: str, **kwargs: Any) -&gt; str:\n    return f\"Hello, {name}!\"\n</code></pre> <p>This will allow the template tag <code>{% mytag %}</code> to be used like this:</p> <pre><code>{% mytag name=\"John\" %}\n{% mytag name=\"John\" required %} ... {% endmytag %}\n</code></pre> <p>The given function will be wrapped in a class that inherits from <code>BaseNode</code>.</p> <p>And this class will be registered with the given library.</p> <p>The function MUST accept at least two positional arguments: <code>node</code> and <code>context</code></p> <ul> <li><code>node</code> is the <code>BaseNode</code> instance.</li> <li><code>context</code> is the <code>Context</code>     of the template.</li> </ul> <p>Any extra parameters defined on this function will be part of the tag's input parameters.</p> <p>For more info, see <code>BaseNode.render()</code>.</p>"},{"location":"reference/commands/","title":"CLI commands","text":""},{"location":"reference/commands/#commands","title":"Commands","text":"<p>These are all the Django management commands that will be added by installing <code>django_components</code>:</p>"},{"location":"reference/commands/#components","title":"<code>components</code>","text":"<pre><code>usage: python manage.py  components [-h] {create,upgrade,ext,list} ...\n</code></pre> <p>See source code</p> <p>The entrypoint for the 'components' commands.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> </ul> <p>Subcommands:</p> <ul> <li><code>create</code><ul> <li>Create a new django component.</li> </ul> </li> <li><code>upgrade</code><ul> <li>Upgrade django components syntax from '{% component_block ... %}' to '{% component ... %}'.</li> </ul> </li> <li><code>ext</code><ul> <li>Run extension commands.</li> </ul> </li> <li><code>list</code><ul> <li>List all components created in this project.</li> </ul> </li> </ul> <p>The entrypoint for the \"components\" commands.</p> <pre><code>python manage.py components list\npython manage.py components create &lt;name&gt;\npython manage.py components upgrade\npython manage.py components ext list\npython manage.py components ext run &lt;extension&gt; &lt;command&gt;\n</code></pre>"},{"location":"reference/commands/#components-create","title":"<code>components create</code>","text":"<pre><code>usage: python manage.py components create [-h] [--path PATH] [--js JS] [--css CSS] [--template TEMPLATE] [--force] [--verbose]\n              [--dry-run]\n              name\n</code></pre> <p>See source code</p> <p>Create a new django component.</p> <p>Positional Arguments:</p> <ul> <li><code>name</code><ul> <li>The name of the component to create. This is a required argument.</li> </ul> </li> </ul> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--path PATH</code><ul> <li>The path to the component's directory. This is an optional argument. If not provided, the command will use the <code>COMPONENTS.dirs</code> setting from your Django settings.</li> </ul> </li> <li><code>--js JS</code><ul> <li>The name of the JavaScript file. This is an optional argument. The default value is <code>script.js</code>.</li> </ul> </li> <li><code>--css CSS</code><ul> <li>The name of the CSS file. This is an optional argument. The default value is <code>style.css</code>.</li> </ul> </li> <li><code>--template TEMPLATE</code><ul> <li>The name of the template file. This is an optional argument. The default value is <code>template.html</code>.</li> </ul> </li> <li><code>--force</code><ul> <li>This option allows you to overwrite existing files if they exist. This is an optional argument.</li> </ul> </li> <li><code>--verbose</code><ul> <li>This option allows the command to print additional information during component creation. This is an optional argument.</li> </ul> </li> <li><code>--dry-run</code><ul> <li>This option allows you to simulate component creation without actually creating any files. This is an optional argument. The default value is <code>False</code>.</li> </ul> </li> </ul>"},{"location":"reference/commands/#usage","title":"Usage","text":"<p>To use the command, run the following command in your terminal:</p> <pre><code>python manage.py components create &lt;name&gt; --path &lt;path&gt; --js &lt;js_filename&gt; --css &lt;css_filename&gt; --template &lt;template_filename&gt; --force --verbose --dry-run\n</code></pre> <p>Replace <code>&lt;name&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;js_filename&gt;</code>, <code>&lt;css_filename&gt;</code>, and <code>&lt;template_filename&gt;</code> with your desired values.</p>"},{"location":"reference/commands/#examples","title":"Examples","text":"<p>Here are some examples of how you can use the command:</p> <p>Creating a Component with Default Settings</p> <p>To create a component with the default settings, you only need to provide the name of the component:</p> <pre><code>python manage.py components create my_component\n</code></pre> <p>This will create a new component named <code>my_component</code> in the <code>components</code> directory of your Django project. The JavaScript, CSS, and template files will be named <code>script.js</code>, <code>style.css</code>, and <code>template.html</code>, respectively.</p> <p>Creating a Component with Custom Settings</p> <p>You can also create a component with custom settings by providing additional arguments:</p> <pre><code>python manage.py components create new_component --path my_components --js my_script.js --css my_style.css --template my_template.html\n</code></pre> <p>This will create a new component named <code>new_component</code> in the <code>my_components</code> directory. The JavaScript, CSS, and template files will be named <code>my_script.js</code>, <code>my_style.css</code>, and <code>my_template.html</code>, respectively.</p> <p>Overwriting an Existing Component</p> <p>If you want to overwrite an existing component, you can use the <code>--force</code> option:</p> <pre><code>python manage.py components create my_component --force\n</code></pre> <p>This will overwrite the existing <code>my_component</code> if it exists.</p> <p>Simulating Component Creation</p> <p>If you want to simulate the creation of a component without actually creating any files, you can use the <code>--dry-run</code> option:</p> <pre><code>python manage.py components create my_component --dry-run\n</code></pre> <p>This will simulate the creation of <code>my_component</code> without creating any files.</p>"},{"location":"reference/commands/#components-upgrade","title":"<code>components upgrade</code>","text":"<pre><code>usage: python manage.py components upgrade [-h] [--path PATH]\n</code></pre> <p>See source code</p> <p>Upgrade django components syntax from '{% component_block ... %}' to '{% component ... %}'.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--path PATH</code><ul> <li>Path to search for components</li> </ul> </li> </ul>"},{"location":"reference/commands/#components-ext","title":"<code>components ext</code>","text":"<pre><code>usage: python manage.py components ext [-h] {list,run} ...\n</code></pre> <p>See source code</p> <p>Run extension commands.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> </ul> <p>Subcommands:</p> <ul> <li><code>list</code><ul> <li>List all extensions.</li> </ul> </li> <li><code>run</code><ul> <li>Run a command added by an extension.</li> </ul> </li> </ul> <p>Run extension commands.</p> <pre><code>python manage.py components ext list\npython manage.py components ext run &lt;extension&gt; &lt;command&gt;\n</code></pre>"},{"location":"reference/commands/#components-ext-list","title":"<code>components ext list</code>","text":"<pre><code>usage: python manage.py components ext list [-h] [--all] [--columns COLUMNS] [-s]\n</code></pre> <p>See source code</p> <p>List all extensions.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--all</code><ul> <li>Show all columns. Same as <code>--columns name</code>.</li> </ul> </li> <li><code>--columns COLUMNS</code><ul> <li>Comma-separated list of columns to show. Available columns: name. Defaults to <code>--columns name</code>.</li> </ul> </li> <li><code>-s</code>, <code>--simple</code><ul> <li>Only show table data, without headers. Use this option for generating machine- readable output.</li> </ul> </li> </ul> <p>List all extensions.</p> <pre><code>python manage.py components ext list\n</code></pre> <p>Prints the list of installed extensions:</p> <pre><code>name\n==============\nview\nmy_extension\n</code></pre> <p>To specify which columns to show, use the <code>--columns</code> flag:</p> <pre><code>python manage.py components ext list --columns name\n</code></pre> <p>Which prints:</p> <pre><code>name\n==============\nview\nmy_extension\n</code></pre> <p>To print out all columns, use the <code>--all</code> flag:</p> <pre><code>python manage.py components ext list --all\n</code></pre> <p>If you need to omit the title in order to programmatically post-process the output, you can use the <code>--simple</code> (or <code>-s</code>) flag:</p> <pre><code>python manage.py components ext list --simple\n</code></pre> <p>Which prints just:</p> <pre><code>view\nmy_extension\n</code></pre>"},{"location":"reference/commands/#components-ext-run","title":"<code>components ext run</code>","text":"<pre><code>usage: python manage.py components ext run [-h]\n</code></pre> <p>See source code</p> <p>Run a command added by an extension.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> </ul> <p>Run a command added by an extension.</p> <p>Each extension can add its own commands, which will be available to run with this command.</p> <p>For example, if you define and install the following extension:</p> <pre><code>from django_components import ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n    def handle(self, *args, **kwargs):\n        print(\"Hello, world!\")\n\nclass MyExt(ComponentExtension):\n    name = \"my_ext\"\n    commands = [HelloCommand]\n</code></pre> <p>You can run the <code>hello</code> command with:</p> <pre><code>python manage.py components ext run my_ext hello\n</code></pre> <p>You can also define arguments for the command, which will be passed to the command's <code>handle</code> method.</p> <pre><code>from django_components import CommandArg, ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n    arguments = [\n        CommandArg(name=\"name\", help=\"The name to say hello to\"),\n        CommandArg(name=[\"--shout\", \"-s\"], action=\"store_true\"),\n    ]\n\n    def handle(self, name: str, *args, **kwargs):\n        shout = kwargs.get(\"shout\", False)\n        msg = f\"Hello, {name}!\"\n        if shout:\n            msg = msg.upper()\n        print(msg)\n</code></pre> <p>You can run the command with:</p> <pre><code>python manage.py components ext run my_ext hello --name John --shout\n</code></pre> <p>Note</p> <p>Command arguments and options are based on Python's <code>argparse</code> module.</p> <p>For more information, see the argparse documentation.</p>"},{"location":"reference/commands/#components-list","title":"<code>components list</code>","text":"<pre><code>usage: python manage.py components list [-h] [--all] [--columns COLUMNS] [-s]\n</code></pre> <p>See source code</p> <p>List all components created in this project.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--all</code><ul> <li>Show all columns. Same as <code>--columns name,full_name,path</code>.</li> </ul> </li> <li><code>--columns COLUMNS</code><ul> <li>Comma-separated list of columns to show. Available columns: name, full_name, path. Defaults to <code>--columns full_name,path</code>.</li> </ul> </li> <li><code>-s</code>, <code>--simple</code><ul> <li>Only show table data, without headers. Use this option for generating machine- readable output.</li> </ul> </li> </ul> <p>List all components.</p> <pre><code>python manage.py components list\n</code></pre> <p>Prints the list of available components:</p> <pre><code>full_name                                                     path\n==================================================================================================\nproject.pages.project.ProjectPage                             ./project/pages/project\nproject.components.dashboard.ProjectDashboard                 ./project/components/dashboard\nproject.components.dashboard_action.ProjectDashboardAction    ./project/components/dashboard_action\n</code></pre> <p>To specify which columns to show, use the <code>--columns</code> flag:</p> <pre><code>python manage.py components list --columns name,full_name,path\n</code></pre> <p>Which prints:</p> <pre><code>name                      full_name                                                     path\n==================================================================================================\nProjectPage               project.pages.project.ProjectPage                             ./project/pages/project\nProjectDashboard          project.components.dashboard.ProjectDashboard                 ./project/components/dashboard\nProjectDashboardAction    project.components.dashboard_action.ProjectDashboardAction    ./project/components/dashboard_action\n</code></pre> <p>To print out all columns, use the <code>--all</code> flag:</p> <pre><code>python manage.py components list --all\n</code></pre> <p>If you need to omit the title in order to programmatically post-process the output, you can use the <code>--simple</code> (or <code>-s</code>) flag:</p> <pre><code>python manage.py components list --simple\n</code></pre> <p>Which prints just:</p> <pre><code>ProjectPage               project.pages.project.ProjectPage                             ./project/pages/project\nProjectDashboard          project.components.dashboard.ProjectDashboard                 ./project/components/dashboard\nProjectDashboardAction    project.components.dashboard_action.ProjectDashboardAction    ./project/components/dashboard_action\n</code></pre>"},{"location":"reference/commands/#upgradecomponent","title":"<code>upgradecomponent</code>","text":"<pre><code>usage: upgradecomponent [-h] [--path PATH] [--version] [-v {0,1,2,3}] [--settings SETTINGS]\n                        [--pythonpath PYTHONPATH] [--traceback] [--no-color] [--force-color]\n                        [--skip-checks]\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>components upgrade</code> instead.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--path PATH</code><ul> <li>Path to search for components</li> </ul> </li> <li><code>--version</code><ul> <li>Show program's version number and exit.</li> </ul> </li> <li><code>-v {0,1,2,3}</code>, <code>--verbosity {0,1,2,3}</code><ul> <li>Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output</li> </ul> </li> <li><code>--settings SETTINGS</code><ul> <li>The Python path to a settings module, e.g. \"myproject.settings.main\". If this isn't provided, the DJANGO_SETTINGS_MODULE environment variable will be used.</li> </ul> </li> <li><code>--pythonpath PYTHONPATH</code><ul> <li>A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".</li> </ul> </li> <li><code>--traceback</code><ul> <li>Raise on CommandError exceptions.</li> </ul> </li> <li><code>--no-color</code><ul> <li>Don't colorize the command output.</li> </ul> </li> <li><code>--force-color</code><ul> <li>Force colorization of the command output.</li> </ul> </li> <li><code>--skip-checks</code><ul> <li>Skip system checks.</li> </ul> </li> </ul> <p>Deprecated. Use <code>components upgrade</code> instead.</p>"},{"location":"reference/commands/#startcomponent","title":"<code>startcomponent</code>","text":"<pre><code>usage: startcomponent [-h] [--path PATH] [--js JS] [--css CSS] [--template TEMPLATE] [--force]\n                      [--verbose] [--dry-run] [--version] [-v {0,1,2,3}] [--settings SETTINGS]\n                      [--pythonpath PYTHONPATH] [--traceback] [--no-color] [--force-color]\n                      [--skip-checks]\n                      name\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>components create</code> instead.</p> <p>Positional Arguments:</p> <ul> <li><code>name</code><ul> <li>The name of the component to create. This is a required argument.</li> </ul> </li> </ul> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--path PATH</code><ul> <li>The path to the component's directory. This is an optional argument. If not provided, the command will use the <code>COMPONENTS.dirs</code> setting from your Django settings.</li> </ul> </li> <li><code>--js JS</code><ul> <li>The name of the JavaScript file. This is an optional argument. The default value is <code>script.js</code>.</li> </ul> </li> <li><code>--css CSS</code><ul> <li>The name of the CSS file. This is an optional argument. The default value is <code>style.css</code>.</li> </ul> </li> <li><code>--template TEMPLATE</code><ul> <li>The name of the template file. This is an optional argument. The default value is <code>template.html</code>.</li> </ul> </li> <li><code>--force</code><ul> <li>This option allows you to overwrite existing files if they exist. This is an optional argument.</li> </ul> </li> <li><code>--verbose</code><ul> <li>This option allows the command to print additional information during component creation. This is an optional argument.</li> </ul> </li> <li><code>--dry-run</code><ul> <li>This option allows you to simulate component creation without actually creating any files. This is an optional argument. The default value is <code>False</code>.</li> </ul> </li> <li><code>--version</code><ul> <li>Show program's version number and exit.</li> </ul> </li> <li><code>-v {0,1,2,3}</code>, <code>--verbosity {0,1,2,3}</code><ul> <li>Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output</li> </ul> </li> <li><code>--settings SETTINGS</code><ul> <li>The Python path to a settings module, e.g. \"myproject.settings.main\". If this isn't provided, the DJANGO_SETTINGS_MODULE environment variable will be used.</li> </ul> </li> <li><code>--pythonpath PYTHONPATH</code><ul> <li>A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".</li> </ul> </li> <li><code>--traceback</code><ul> <li>Raise on CommandError exceptions.</li> </ul> </li> <li><code>--no-color</code><ul> <li>Don't colorize the command output.</li> </ul> </li> <li><code>--force-color</code><ul> <li>Force colorization of the command output.</li> </ul> </li> <li><code>--skip-checks</code><ul> <li>Skip system checks.</li> </ul> </li> </ul> <p>Deprecated. Use <code>components create</code> instead.</p>"},{"location":"reference/components/","title":"Components","text":""},{"location":"reference/components/#components","title":"Components","text":"<p>These are the components provided by django_components.</p>"},{"location":"reference/components/#django_components.components.dynamic.DynamicComponent","title":"<code>DynamicComponent</code>","text":"<p>Bases: <code>django_components.component.Component</code></p> <p>See source code</p> <p>This component is given a registered name or a reference to another component, and behaves as if the other component was in its place.</p> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>Parameters:</p> <ul> <li> <code>is</code>               (<code>str | Type[Component]</code>)           \u2013            <p>Component that should be rendered. Either a registered name of a component, or a Component class directly. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to search for the registered name. If omitted, all registries are searched until the first match.</p> </li> <li> <code>*args</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Additional data passed to the component.</p> </li> <li> <code>**kwargs</code>               (<code>Optional[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Additional data passed to the component.</p> </li> </ul> <p>Slots:</p> <ul> <li>Any slots, depending on the actual component.</li> </ul> <p>Examples:</p> <p>Django <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Or in case you use the <code>django_components.component_shorthand_formatter</code> tag formatter:</p> <pre><code>{% dynamic is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% enddynamic %}\n</code></pre> <p>Python <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            deps_strategy=\"ignore\",\n        ),\n    },\n)\n</code></pre></p>"},{"location":"reference/components/#django_components.components.dynamic.DynamicComponent--use-cases","title":"Use cases","text":"<p>Dynamic components are suitable if you are writing something like a form component. You may design it such that users give you a list of input types, and you render components depending on the input types.</p> <p>While you could handle this with a series of if / else statements, that's not an extensible approach. Instead, you can use the dynamic component in place of normal components.</p>"},{"location":"reference/components/#django_components.components.dynamic.DynamicComponent--component-name","title":"Component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name: <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p>"},{"location":"reference/components/#django_components.components.error_fallback.ErrorFallback","title":"<code>ErrorFallback</code>","text":"<p>Bases: <code>django_components.component.Component</code></p> <p>See source code</p> <p>Use <code>ErrorFallback</code> to catch errors and display a fallback content instead.</p> <p>This is similar to React's <code>ErrorBoundary</code> component.</p> <p>Example:</p> <p>Given this template:</p> <pre><code>{% component \"error_fallback\" fallback=\"Oops, something went wrong\" %}\n    {% component \"table\" / %}\n{% endcomponent %}\n</code></pre> <p>Then:</p> <ul> <li>If the <code>table</code> component does NOT raise an error, then the table is rendered as normal.</li> <li>If the <code>table</code> component DOES raise an error, then <code>error_fallback</code> renders <code>Oops, something went wrong</code>.</li> </ul> <p>To have more control over the fallback content, you can use the <code>fallback</code> slot instead of the <code>fallback</code> kwarg.</p> <pre><code>{% component \"error_fallback\" %}\n    {% fill \"content\" %}\n        {% component \"table\" / %}\n    {% endfill %}\n    {% fill \"fallback\" %}\n        &lt;p&gt;Oops, something went wrong&lt;/p&gt;\n        {% button href=\"/report-error\" %}\n            Report error\n        {% endbutton %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>If you want to print the error, you can access the <code>error</code> variable as slot data.</p> <pre><code>{% component \"error_fallback\" %}\n    {% fill \"content\" %}\n        {% component \"table\" / %}\n    {% endfill %}\n    {% fill \"fallback\" data=\"data\" %}\n        Oops, something went wrong:\n        &lt;pre&gt;{{ data.error }}&lt;/pre&gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Python:</p> <p>With fallback kwarg:</p> <pre><code>from django_components import ErrorFallback\n\nErrorFallback.render(\n    slots={\n        # Main content\n        \"content\": lambda ctx: TableComponent.render(\n            deps_strategy=\"ignore\",\n        ),\n    },\n    kwargs={\n        # Fallback content\n        \"fallback\": \"Oops, something went wrong\",\n    },\n)\n</code></pre> <p>With fallback slot:</p> <pre><code>from django_components import ErrorFallback\n\nErrorFallback.render(\n    slots={\n        # Main content\n        \"content\": lambda ctx: TableComponent.render(\n            deps_strategy=\"ignore\",\n        ),\n        # Fallback content\n        \"fallback\": lambda ctx: mark_safe(\"Oops, something went wrong: \" + ctx.error),\n    },\n)\n</code></pre> <p>Info</p> <p>Remember to define the <code>content</code> slot as function, so it's evaluated from inside of <code>ErrorFallback</code>.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#exceptions","title":"Exceptions","text":""},{"location":"reference/exceptions/#django_components.AlreadyRegistered","title":"AlreadyRegistered","text":"<p>Bases: <code>Exception</code></p> <p>See source code</p> <p>Raised when you try to register a Component, but it's already registered with given ComponentRegistry.</p>"},{"location":"reference/exceptions/#django_components.NotRegistered","title":"NotRegistered","text":"<p>Bases: <code>Exception</code></p> <p>See source code</p> <p>Raised when you try to access a Component, but it's NOT registered with given ComponentRegistry.</p>"},{"location":"reference/exceptions/#django_components.TagProtectedError","title":"TagProtectedError","text":"<p>Bases: <code>Exception</code></p> <p>See source code</p> <p>The way the <code>TagFormatter</code> works is that, based on which start and end tags are used for rendering components, the <code>ComponentRegistry</code> behind the scenes un-/registers the template tags with the associated instance of Django's <code>Library</code>.</p> <p>In other words, if I have registered a component <code>\"table\"</code>, and I use the shorthand syntax:</p> <pre><code>{% table ... %}\n{% endtable %}\n</code></pre> <p>Then <code>ComponentRegistry</code> registers the tag <code>table</code> onto the Django's Library instance.</p> <p>However, that means that if we registered a component <code>\"slot\"</code>, then we would overwrite the <code>{% slot %}</code> tag from django_components.</p> <p>Thus, this exception is raised when a component is attempted to be registered under a forbidden name, such that it would overwrite one of django_component's own template tags.</p>"},{"location":"reference/extension_commands/","title":"Extension commands API","text":""},{"location":"reference/extension_commands/#extension-commands-api","title":"Extension commands API","text":"<p>Overview of all classes, functions, and other objects related to defining extension commands.</p> <p>Read more on Extensions.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg","title":"CommandArg  <code>dataclass</code>","text":"<pre><code>CommandArg(name_or_flags: Union[str, Sequence[str]], action: Optional[Union[CommandLiteralAction, Action]] = None, nargs: Optional[Union[int, Literal['*', '+', '?']]] = None, const: Any = None, default: Any = None, type: Optional[Union[Type, Callable[[str], Any]]] = None, choices: Optional[Sequence[Any]] = None, required: Optional[bool] = None, help: Optional[str] = None, metavar: Optional[str] = None, dest: Optional[str] = None, version: Optional[str] = None, deprecated: Optional[bool] = None)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Define a single positional argument or an option for a command.</p> <p>Fields on this class correspond to the arguments for <code>ArgumentParser.add_argument()</code></p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>action</code>               (<code>Optional[Union[CommandLiteralAction, Action]]</code>)           \u2013            </li> <li> <code>choices</code>               (<code>Optional[Sequence[Any]]</code>)           \u2013            </li> <li> <code>const</code>               (<code>Any</code>)           \u2013            </li> <li> <code>default</code>               (<code>Any</code>)           \u2013            </li> <li> <code>deprecated</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>dest</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>help</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>metavar</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>name_or_flags</code>               (<code>Union[str, Sequence[str]]</code>)           \u2013            </li> <li> <code>nargs</code>               (<code>Optional[Union[int, Literal['*', '+', '?']]]</code>)           \u2013            </li> <li> <code>required</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>type</code>               (<code>Optional[Union[Type, Callable[[str], Any]]]</code>)           \u2013            </li> <li> <code>version</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.CommandArg.action","title":"action  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>action: Optional[Union[CommandLiteralAction, Action]] = None\n</code></pre> <p>See source code</p> <p>The basic type of action to be taken when this argument is encountered at the command line.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.choices","title":"choices  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>choices: Optional[Sequence[Any]] = None\n</code></pre> <p>See source code</p> <p>A sequence of the allowable values for the argument.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.const","title":"const  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>const: Any = None\n</code></pre> <p>See source code</p> <p>A constant value required by some action and nargs selections.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.default","title":"default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default: Any = None\n</code></pre> <p>See source code</p> <p>The value produced if the argument is absent from the command line and if it is absent from the namespace object.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.deprecated","title":"deprecated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deprecated: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Whether or not use of the argument is deprecated.</p> <p>NOTE: This is supported only in Python 3.13+</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.dest","title":"dest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dest: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The name of the attribute to be added to the object returned by parse_args().</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.help","title":"help  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help: Optional[str] = None\n</code></pre> <p>See source code</p> <p>A brief description of what the argument does.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.metavar","title":"metavar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metavar: Optional[str] = None\n</code></pre> <p>See source code</p> <p>A name for the argument in usage messages.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.name_or_flags","title":"name_or_flags  <code>instance-attribute</code>","text":"<pre><code>name_or_flags: Union[str, Sequence[str]]\n</code></pre> <p>See source code</p> <p>Either a name or a list of option strings, e.g. 'foo' or '-f', '--foo'.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.nargs","title":"nargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nargs: Optional[Union[int, Literal['*', '+', '?']]] = None\n</code></pre> <p>See source code</p> <p>The number of command-line arguments that should be consumed.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Whether or not the command-line option may be omitted (optionals only).</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: Optional[Union[Type, Callable[[str], Any]]] = None\n</code></pre> <p>See source code</p> <p>The type to which the command-line argument should be converted.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The version string to be added to the object returned by parse_args().</p> <p>MUST be used with <code>action='version'</code>.</p> <p>See https://docs.python.org/3/library/argparse.html#action</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict\n</code></pre> <p>See source code</p> <p>Convert the dataclass to a dictionary, stripping out fields with <code>None</code> values</p>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup","title":"CommandArgGroup  <code>dataclass</code>","text":"<pre><code>CommandArgGroup(title: Optional[str] = None, description: Optional[str] = None, arguments: Sequence[CommandArg] = ())\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Define a group of arguments for a command.</p> <p>Fields on this class correspond to the arguments for <code>ArgumentParser.add_argument_group()</code></p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>arguments</code>               (<code>Sequence[CommandArg]</code>)           \u2013            </li> <li> <code>description</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>title</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Sequence[CommandArg] = ()\n</code></pre>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Description for the argument group in help output, by default None</p>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Title for the argument group in help output; by default \u201cpositional arguments\u201d if description is provided, otherwise uses title for positional arguments.</p>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict\n</code></pre> <p>See source code</p> <p>Convert the dataclass to a dictionary, stripping out fields with <code>None</code> values</p>"},{"location":"reference/extension_commands/#django_components.CommandHandler","title":"CommandHandler","text":""},{"location":"reference/extension_commands/#django_components.CommandParserInput","title":"CommandParserInput  <code>dataclass</code>","text":"<pre><code>CommandParserInput(prog: Optional[str] = None, usage: Optional[str] = None, description: Optional[str] = None, epilog: Optional[str] = None, parents: Optional[Sequence[ArgumentParser]] = None, formatter_class: Optional[Type[_FormatterClass]] = None, prefix_chars: Optional[str] = None, fromfile_prefix_chars: Optional[str] = None, argument_default: Optional[Any] = None, conflict_handler: Optional[str] = None, add_help: Optional[bool] = None, allow_abbrev: Optional[bool] = None, exit_on_error: Optional[bool] = None)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Typing for the input to the <code>ArgumentParser</code> constructor.</p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>add_help</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>allow_abbrev</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>argument_default</code>               (<code>Optional[Any]</code>)           \u2013            </li> <li> <code>conflict_handler</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>description</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>epilog</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>exit_on_error</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>formatter_class</code>               (<code>Optional[Type[_FormatterClass]]</code>)           \u2013            </li> <li> <code>fromfile_prefix_chars</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>parents</code>               (<code>Optional[Sequence[ArgumentParser]]</code>)           \u2013            </li> <li> <code>prefix_chars</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>prog</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>usage</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.add_help","title":"add_help  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>add_help: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Add a -h/--help option to the parser (default: <code>True</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.allow_abbrev","title":"allow_abbrev  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_abbrev: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Allows long options to be abbreviated if the abbreviation is unambiguous. (default: <code>True</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.argument_default","title":"argument_default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>argument_default: Optional[Any] = None\n</code></pre> <p>See source code</p> <p>The global default value for arguments (default: <code>None</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.conflict_handler","title":"conflict_handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_handler: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The strategy for resolving conflicting optionals (usually unnecessary)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Text to display before the argument help (by default, no text)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.epilog","title":"epilog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>epilog: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Text to display after the argument help (by default, no text)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.exit_on_error","title":"exit_on_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_on_error: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Determines whether or not ArgumentParser exits with error info when an error occurs. (default: <code>True</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.formatter_class","title":"formatter_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>formatter_class: Optional[Type[_FormatterClass]] = None\n</code></pre> <p>See source code</p> <p>A class for customizing the help output</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.fromfile_prefix_chars","title":"fromfile_prefix_chars  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fromfile_prefix_chars: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The set of characters that prefix files from which additional arguments should be read (default: <code>None</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.parents","title":"parents  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parents: Optional[Sequence[ArgumentParser]] = None\n</code></pre> <p>See source code</p> <p>A list of ArgumentParser objects whose arguments should also be included</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.prefix_chars","title":"prefix_chars  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix_chars: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The set of characters that prefix optional arguments (default: <code>-</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.prog","title":"prog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prog: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The name of the program (default: <code>os.path.basename(sys.argv[0])</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.usage","title":"usage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>usage: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The string describing the program usage (default: generated from arguments added to parser)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict\n</code></pre> <p>See source code</p> <p>Convert the dataclass to a dictionary, stripping out fields with <code>None</code> values</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand","title":"CommandSubcommand  <code>dataclass</code>","text":"<pre><code>CommandSubcommand(title: Optional[str] = None, description: Optional[str] = None, prog: Optional[str] = None, parser_class: Optional[Type[ArgumentParser]] = None, action: Optional[Union[CommandLiteralAction, Action]] = None, dest: Optional[str] = None, required: Optional[bool] = None, help: Optional[str] = None, metavar: Optional[str] = None)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Define a subcommand for a command.</p> <p>Fields on this class correspond to the arguments for <code>ArgumentParser.add_subparsers.add_parser()</code></p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>action</code>               (<code>Optional[Union[CommandLiteralAction, Action]]</code>)           \u2013            </li> <li> <code>description</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>dest</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>help</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>metavar</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>parser_class</code>               (<code>Optional[Type[ArgumentParser]]</code>)           \u2013            </li> <li> <code>prog</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>required</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>title</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.action","title":"action  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>action: Optional[Union[CommandLiteralAction, Action]] = None\n</code></pre> <p>See source code</p> <p>The basic type of action to be taken when this argument is encountered at the command line.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Description for the sub-parser group in help output, by default <code>None</code>.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.dest","title":"dest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dest: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the attribute under which sub-command name will be stored; by default <code>None</code> and no value is stored.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.help","title":"help  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Help for sub-parser group in help output, by default <code>None</code>.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.metavar","title":"metavar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metavar: Optional[str] = None\n</code></pre> <p>See source code</p> <p>String presenting available subcommands in help; by default it is None and presents subcommands in form <code>{cmd1, cmd2, ..}</code>.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.parser_class","title":"parser_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_class: Optional[Type[ArgumentParser]] = None\n</code></pre> <p>See source code</p> <p>Class which will be used to create sub-parser instances, by default the class of the current parser (e.g. <code>ArgumentParser</code>).</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.prog","title":"prog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prog: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Usage information that will be displayed with sub-command help, by default the name of the program and any positional arguments before the subparser argument.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Whether or not a subcommand must be provided, by default <code>False</code> (added in 3.7)</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Title for the sub-parser group in help output; by default \u201csubcommands\u201d if description is provided, otherwise uses title for positional arguments.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict\n</code></pre> <p>See source code</p> <p>Convert the dataclass to a dictionary, stripping out fields with <code>None</code> values</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand","title":"ComponentCommand","text":"<p>Bases: <code>object</code></p> <p>See source code</p> <p>Definition of a CLI command.</p> <p>This class is based on Python's <code>argparse</code> module and Django's <code>BaseCommand</code> class. <code>ComponentCommand</code> allows you to define:</p> <ul> <li>Command name, description, and help text</li> <li>Arguments and options (e.g. <code>--name John</code>)</li> <li>Group arguments (see argparse groups)</li> <li>Subcommands (e.g. <code>components ext run my_ext hello</code>)</li> <li>Handler behavior</li> </ul> <p>Each extension can add its own commands, which will be available to run with <code>components ext run</code>.</p> <p>Extensions use the <code>ComponentCommand</code> class to define their commands.</p> <p>For example, if you define and install the following extension:</p> <pre><code>from django_components ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n    def handle(self, *args, **kwargs):\n        print(\"Hello, world!\")\n\nclass MyExt(ComponentExtension):\n    name = \"my_ext\"\n    commands = [HelloCommand]\n</code></pre> <p>You can run the <code>hello</code> command with:</p> <pre><code>python manage.py components ext run my_ext hello\n</code></pre> <p>You can also define arguments for the command, which will be passed to the command's <code>handle</code> method.</p> <pre><code>from django_components import CommandArg, ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n    arguments = [\n        CommandArg(name=\"name\", help=\"The name to say hello to\"),\n        CommandArg(name=[\"--shout\", \"-s\"], action=\"store_true\"),\n    ]\n\n    def handle(self, name: str, *args, **kwargs):\n        shout = kwargs.get(\"shout\", False)\n        msg = f\"Hello, {name}!\"\n        if shout:\n            msg = msg.upper()\n        print(msg)\n</code></pre> <p>You can run the command with:</p> <pre><code>python manage.py components ext run my_ext hello --name John --shout\n</code></pre> <p>Note</p> <p>Command arguments and options are based on Python's <code>argparse</code> module.</p> <p>For more information, see the argparse documentation.</p> <p>Attributes:</p> <ul> <li> <code>arguments</code>               (<code>Sequence[Union[CommandArg, CommandArgGroup]]</code>)           \u2013            </li> <li> <code>handle</code>               (<code>Optional[CommandHandler]</code>)           \u2013            </li> <li> <code>help</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>parser_input</code>               (<code>Optional[CommandParserInput]</code>)           \u2013            </li> <li> <code>subcommands</code>               (<code>Sequence[Type[ComponentCommand]]</code>)           \u2013            </li> <li> <code>subparser_input</code>               (<code>Optional[CommandSubcommand]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Sequence[Union[CommandArg, CommandArgGroup]] = ()\n</code></pre> <p>See source code</p> <p>argparse arguments for the command</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.handle","title":"handle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>handle: Optional[CommandHandler] = None\n</code></pre> <p>See source code</p> <p>The function that is called when the command is run. If <code>None</code>, the command will print the help message.</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.help","title":"help  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The help text for the command</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>The name of the command - this is what is used to call the command</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.parser_input","title":"parser_input  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_input: Optional[CommandParserInput] = None\n</code></pre> <p>See source code</p> <p>The input to use when creating the <code>ArgumentParser</code> for this command. If <code>None</code>, the default values will be used.</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.subcommands","title":"subcommands  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subcommands: Sequence[Type[ComponentCommand]] = ()\n</code></pre> <p>See source code</p> <p>Subcommands for the command</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.subparser_input","title":"subparser_input  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subparser_input: Optional[CommandSubcommand] = None\n</code></pre> <p>See source code</p> <p>The input to use when this command is a subcommand installed with <code>add_subparser()</code>. If <code>None</code>, the default values will be used.</p>"},{"location":"reference/extension_hooks/","title":"Extension hooks","text":""},{"location":"reference/extension_hooks/#extension-hooks","title":"Extension hooks","text":"<p>Overview of all the extension hooks available in Django Components.</p> <p>Read more on Extensions.</p>"},{"location":"reference/extension_hooks/#hooks","title":"Hooks","text":"<p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The created Component class <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The to-be-deleted Component class <p>Available data:</p> name type description <code>component</code> <code>Component</code> The Component instance that is being rendered <code>component_cls</code> <code>Type[Component]</code> The Component class <code>component_id</code> <code>str</code> The unique identifier for this component instance <code>context_data</code> <code>Dict</code> Deprecated. Use <code>template_data</code> instead. Will be removed in v1.0. <code>css_data</code> <code>Dict</code> Dictionary of CSS data from <code>Component.get_css_data()</code> <code>js_data</code> <code>Dict</code> Dictionary of JavaScript data from <code>Component.get_js_data()</code> <code>template_data</code> <code>Dict</code> Dictionary of template data from <code>Component.get_template_data()</code> <p>Available data:</p> name type description <code>args</code> <code>List</code> List of positional arguments passed to the component <code>component</code> <code>Component</code> The Component instance that received the input and is being rendered <code>component_cls</code> <code>Type[Component]</code> The Component class <code>component_id</code> <code>str</code> The unique identifier for this component instance <code>context</code> <code>Context</code> The Django template Context object <code>kwargs</code> <code>Dict</code> Dictionary of keyword arguments passed to the component <code>slots</code> <code>Dict[str, Slot]</code> Dictionary of slot definitions <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The registered Component class <code>name</code> <code>str</code> The name the component was registered under <code>registry</code> <code>ComponentRegistry</code> The registry the component was registered to <p>Available data:</p> name type description <code>component</code> <code>Component</code> The Component instance that is being rendered <code>component_cls</code> <code>Type[Component]</code> The Component class <code>component_id</code> <code>str</code> The unique identifier for this component instance <code>error</code> <code>Optional[Exception]</code> The error that occurred during rendering, or <code>None</code> if rendering was successful <code>result</code> <code>Optional[str]</code> The rendered component, or <code>None</code> if rendering failed <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The unregistered Component class <code>name</code> <code>str</code> The name the component was registered under <code>registry</code> <code>ComponentRegistry</code> The registry the component was unregistered from <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The Component class whose CSS was loaded <code>content</code> <code>str</code> The CSS content (string) <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The Component class whose JS was loaded <code>content</code> <code>str</code> The JS content (string) <p>Available data:</p> name type description <code>registry</code> <code>ComponentRegistry</code> The created ComponentRegistry instance <p>Available data:</p> name type description <code>registry</code> <code>ComponentRegistry</code> The to-be-deleted ComponentRegistry instance <p>Available data:</p> name type description <code>component</code> <code>Component</code> The Component instance that contains the <code>{% slot %}</code> tag <code>component_cls</code> <code>Type[Component]</code> The Component class that contains the <code>{% slot %}</code> tag <code>component_id</code> <code>str</code> The unique identifier for this component instance <code>result</code> <code>SlotResult</code> The rendered result of the slot <code>slot</code> <code>Slot</code> The Slot instance that was rendered <code>slot_is_default</code> <code>bool</code> Whether the slot is default <code>slot_is_required</code> <code>bool</code> Whether the slot is required <code>slot_name</code> <code>str</code> The name of the <code>{% slot %}</code> tag <code>slot_node</code> <code>SlotNode</code> The node instance of the <code>{% slot %}</code> tag <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The Component class whose template was loaded <code>template</code> <code>django.template.base.Template</code> The compiled template object <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The Component class whose template was loaded <code>content</code> <code>str</code> The template string <code>name</code> <code>Optional[str]</code> The name of the template <code>origin</code> <code>Optional[django.template.base.Origin]</code> The origin of the template"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_class_created","title":"on_component_class_created","text":"<pre><code>on_component_class_created(ctx: OnComponentClassCreatedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a new <code>Component</code> class is created.</p> <p>This hook is called after the <code>Component</code> class is fully defined but before it's registered.</p> <p>Use this hook to perform any initialization or validation of the <code>Component</code> class.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentClassCreatedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext) -&gt; None:\n        # Add a new attribute to the Component class\n        ctx.component_cls.my_attr = \"my_value\"\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_class_deleted","title":"on_component_class_deleted","text":"<pre><code>on_component_class_deleted(ctx: OnComponentClassDeletedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is being deleted.</p> <p>This hook is called before the <code>Component</code> class is deleted from memory.</p> <p>Use this hook to perform any cleanup related to the <code>Component</code> class.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentClassDeletedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_class_deleted(self, ctx: OnComponentClassDeletedContext) -&gt; None:\n        # Remove Component class from the extension's cache on deletion\n        self.cache.pop(ctx.component_cls, None)\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_data","title":"on_component_data","text":"<pre><code>on_component_data(ctx: OnComponentDataContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was triggered to render, after a component's context and data methods have been processed.</p> <p>This hook is called after <code>Component.get_template_data()</code>, <code>Component.get_js_data()</code> and <code>Component.get_css_data()</code>.</p> <p>This hook runs after <code>on_component_input</code>.</p> <p>Use this hook to modify or validate the component's data before rendering.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentDataContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_data(self, ctx: OnComponentDataContext) -&gt; None:\n        # Add extra template variable to all components when they are rendered\n        ctx.template_data[\"my_template_var\"] = \"my_value\"\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_input","title":"on_component_input","text":"<pre><code>on_component_input(ctx: OnComponentInputContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was triggered to render, but before a component's context and data methods are invoked.</p> <p>Use this hook to modify or validate component inputs before they're processed.</p> <p>This is the first hook that is called when rendering a component. As such this hook is called before <code>Component.get_template_data()</code>, <code>Component.get_js_data()</code>, and <code>Component.get_css_data()</code> methods, and the <code>on_component_data</code> hook.</p> <p>This hook also allows to skip the rendering of a component altogether. If the hook returns a non-null value, this value will be used instead of rendering the component.</p> <p>You can use this to implement a caching mechanism for components, or define components that will be rendered conditionally.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentInputContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_input(self, ctx: OnComponentInputContext) -&gt; None:\n        # Add extra kwarg to all components when they are rendered\n        ctx.kwargs[\"my_input\"] = \"my_value\"\n</code></pre> <p>Warning</p> <p>In this hook, the components' inputs are still mutable.</p> <p>As such, if a component defines <code>Args</code>, <code>Kwargs</code>, <code>Slots</code> types, these types are NOT yet instantiated.</p> <p>Instead, component fields like <code>Component.args</code>, <code>Component.kwargs</code>, <code>Component.slots</code> are plain <code>list</code> / <code>dict</code> objects.</p>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_registered","title":"on_component_registered","text":"<pre><code>on_component_registered(ctx: OnComponentRegisteredContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is registered with a <code>ComponentRegistry</code>.</p> <p>This hook is called after a <code>Component</code> class is successfully registered.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentRegisteredContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_registered(self, ctx: OnComponentRegisteredContext) -&gt; None:\n        print(f\"Component {ctx.component_cls} registered to {ctx.registry} as '{ctx.name}'\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_rendered","title":"on_component_rendered","text":"<pre><code>on_component_rendered(ctx: OnComponentRenderedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was rendered, including all its child components.</p> <p>Use this hook to access or post-process the component's rendered output.</p> <p>This hook works similarly to <code>Component.on_render_after()</code>:</p> <ol> <li> <p>To modify the output, return a new string from this hook. The original output or error will be ignored.</p> </li> <li> <p>To cause this component to return a new error, raise that error. The original output and error     will be ignored.</p> </li> <li> <p>If you neither raise nor return string, the original output or error will be used.</p> </li> </ol> <p>Examples:</p> <p>Change the final output of a component:</p> <pre><code>from django_components import ComponentExtension, OnComponentRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_rendered(self, ctx: OnComponentRenderedContext) -&gt; Optional[str]:\n        # Append a comment to the component's rendered output\n        return ctx.result + \"&lt;!-- MyExtension comment --&gt;\"\n</code></pre> <p>Cause the component to raise a new exception:</p> <pre><code>from django_components import ComponentExtension, OnComponentRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_rendered(self, ctx: OnComponentRenderedContext) -&gt; Optional[str]:\n        # Raise a new exception\n        raise Exception(\"Error message\")\n</code></pre> <p>Return nothing (or <code>None</code>) to handle the result as usual:</p> <pre><code>from django_components import ComponentExtension, OnComponentRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_rendered(self, ctx: OnComponentRenderedContext) -&gt; Optional[str]:\n        if ctx.error is not None:\n            # The component raised an exception\n            print(f\"Error: {ctx.error}\")\n        else:\n            # The component rendered successfully\n            print(f\"Result: {ctx.result}\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_unregistered","title":"on_component_unregistered","text":"<pre><code>on_component_unregistered(ctx: OnComponentUnregisteredContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is unregistered from a <code>ComponentRegistry</code>.</p> <p>This hook is called after a <code>Component</code> class is removed from the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentUnregisteredContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_unregistered(self, ctx: OnComponentUnregisteredContext) -&gt; None:\n        print(f\"Component {ctx.component_cls} unregistered from {ctx.registry} as '{ctx.name}'\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_css_loaded","title":"on_css_loaded","text":"<pre><code>on_css_loaded(ctx: OnCssLoadedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a Component's CSS is loaded as a string.</p> <p>This hook runs only once per <code>Component</code> class and works for both <code>Component.css</code> and <code>Component.css_file</code>.</p> <p>Use this hook to read or modify the CSS.</p> <p>To modify the CSS, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnCssLoadedContext\n\nclass MyExtension(ComponentExtension):\n    def on_css_loaded(self, ctx: OnCssLoadedContext) -&gt; Optional[str]:\n        # Modify the CSS\n        return ctx.content.replace(\"Hello\", \"Hi\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_js_loaded","title":"on_js_loaded","text":"<pre><code>on_js_loaded(ctx: OnJsLoadedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a Component's JS is loaded as a string.</p> <p>This hook runs only once per <code>Component</code> class and works for both <code>Component.js</code> and <code>Component.js_file</code>.</p> <p>Use this hook to read or modify the JS.</p> <p>To modify the JS, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnCssLoadedContext\n\nclass MyExtension(ComponentExtension):\n    def on_js_loaded(self, ctx: OnJsLoadedContext) -&gt; Optional[str]:\n        # Modify the JS\n        return ctx.content.replace(\"Hello\", \"Hi\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_registry_created","title":"on_registry_created","text":"<pre><code>on_registry_created(ctx: OnRegistryCreatedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a new <code>ComponentRegistry</code> is created.</p> <p>This hook is called after a new <code>ComponentRegistry</code> instance is initialized.</p> <p>Use this hook to perform any initialization needed for the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnRegistryCreatedContext\n\nclass MyExtension(ComponentExtension):\n    def on_registry_created(self, ctx: OnRegistryCreatedContext) -&gt; None:\n        # Add a new attribute to the registry\n        ctx.registry.my_attr = \"my_value\"\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_registry_deleted","title":"on_registry_deleted","text":"<pre><code>on_registry_deleted(ctx: OnRegistryDeletedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>ComponentRegistry</code> is being deleted.</p> <p>This hook is called before a <code>ComponentRegistry</code> instance is deleted.</p> <p>Use this hook to perform any cleanup related to the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnRegistryDeletedContext\n\nclass MyExtension(ComponentExtension):\n    def on_registry_deleted(self, ctx: OnRegistryDeletedContext) -&gt; None:\n        # Remove registry from the extension's cache on deletion\n        self.cache.pop(ctx.registry, None)\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_slot_rendered","title":"on_slot_rendered","text":"<pre><code>on_slot_rendered(ctx: OnSlotRenderedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>{% slot %}</code> tag was rendered.</p> <p>Use this hook to access or post-process the slot's rendered output.</p> <p>To modify the output, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnSlotRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_slot_rendered(self, ctx: OnSlotRenderedContext) -&gt; Optional[str]:\n        # Append a comment to the slot's rendered output\n        return ctx.result + \"&lt;!-- MyExtension comment --&gt;\"\n</code></pre> <p>Access slot metadata:</p> <p>You can access the <code>{% slot %}</code> tag node (<code>SlotNode</code>) and its metadata using <code>ctx.slot_node</code>.</p> <p>For example, to find the <code>Component</code> class to which belongs the template where the <code>{% slot %}</code> tag is defined, you can use <code>ctx.slot_node.template_component</code>:</p> <pre><code>from django_components import ComponentExtension, OnSlotRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_slot_rendered(self, ctx: OnSlotRenderedContext) -&gt; Optional[str]:\n        # Access slot metadata\n        slot_node = ctx.slot_node\n        slot_owner = slot_node.template_component\n        print(f\"Slot owner: {slot_owner}\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_template_compiled","title":"on_template_compiled","text":"<pre><code>on_template_compiled(ctx: OnTemplateCompiledContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a Component's template is compiled into a <code>Template</code> object.</p> <p>This hook runs only once per <code>Component</code> class and works for both <code>Component.template</code> and <code>Component.template_file</code>.</p> <p>Use this hook to read or modify the template (in-place) after it's compiled.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnTemplateCompiledContext\n\nclass MyExtension(ComponentExtension):\n    def on_template_compiled(self, ctx: OnTemplateCompiledContext) -&gt; None:\n        print(f\"Template origin: {ctx.template.origin.name}\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_template_loaded","title":"on_template_loaded","text":"<pre><code>on_template_loaded(ctx: OnTemplateLoadedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a Component's template is loaded as a string.</p> <p>This hook runs only once per <code>Component</code> class and works for both <code>Component.template</code> and <code>Component.template_file</code>.</p> <p>Use this hook to read or modify the template before it's compiled.</p> <p>To modify the template, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnTemplateLoadedContext\n\nclass MyExtension(ComponentExtension):\n    def on_template_loaded(self, ctx: OnTemplateLoadedContext) -&gt; Optional[str]:\n        # Modify the template\n        return ctx.content.replace(\"Hello\", \"Hi\")\n</code></pre>"},{"location":"reference/extension_hooks/#objects","title":"Objects","text":""},{"location":"reference/extension_hooks/#django_components.extension.OnComponentClassCreatedContext","title":"OnComponentClassCreatedContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentClassCreatedContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The created Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentClassDeletedContext","title":"OnComponentClassDeletedContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentClassDeletedContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The to-be-deleted Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext","title":"OnComponentDataContext","text":"<p>Attributes:</p> <ul> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>context_data</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>css_data</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>js_data</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>template_data</code>               (<code>Dict</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.component","title":"component  <code>instance-attribute</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>The Component instance that is being rendered</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: str\n</code></pre> <p>See source code</p> <p>The unique identifier for this component instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.context_data","title":"context_data  <code>instance-attribute</code>","text":"<pre><code>context_data: Dict\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>template_data</code> instead. Will be removed in v1.0.</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.css_data","title":"css_data  <code>instance-attribute</code>","text":"<pre><code>css_data: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of CSS data from <code>Component.get_css_data()</code></p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.js_data","title":"js_data  <code>instance-attribute</code>","text":"<pre><code>js_data: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of JavaScript data from <code>Component.get_js_data()</code></p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.template_data","title":"template_data  <code>instance-attribute</code>","text":"<pre><code>template_data: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of template data from <code>Component.get_template_data()</code></p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext","title":"OnComponentInputContext","text":"<p>Attributes:</p> <ul> <li> <code>args</code>               (<code>List</code>)           \u2013            </li> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            </li> <li> <code>kwargs</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>slots</code>               (<code>Dict[str, Slot]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: List\n</code></pre> <p>See source code</p> <p>List of positional arguments passed to the component</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.component","title":"component  <code>instance-attribute</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>The Component instance that received the input and is being rendered</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: str\n</code></pre> <p>See source code</p> <p>The unique identifier for this component instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Context\n</code></pre> <p>See source code</p> <p>The Django template Context object</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of keyword arguments passed to the component</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.slots","title":"slots  <code>instance-attribute</code>","text":"<pre><code>slots: Dict[str, Slot]\n</code></pre> <p>See source code</p> <p>Dictionary of slot definitions</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRegisteredContext","title":"OnComponentRegisteredContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRegisteredContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The registered Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRegisteredContext.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>The name the component was registered under</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRegisteredContext.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The registry the component was registered to</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRenderedContext","title":"OnComponentRenderedContext","text":"<p>Attributes:</p> <ul> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>error</code>               (<code>Optional[Exception]</code>)           \u2013            </li> <li> <code>result</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRenderedContext.component","title":"component  <code>instance-attribute</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>The Component instance that is being rendered</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRenderedContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRenderedContext.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: str\n</code></pre> <p>See source code</p> <p>The unique identifier for this component instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRenderedContext.error","title":"error  <code>instance-attribute</code>","text":"<pre><code>error: Optional[Exception]\n</code></pre> <p>See source code</p> <p>The error that occurred during rendering, or <code>None</code> if rendering was successful</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRenderedContext.result","title":"result  <code>instance-attribute</code>","text":"<pre><code>result: Optional[str]\n</code></pre> <p>See source code</p> <p>The rendered component, or <code>None</code> if rendering failed</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentUnregisteredContext","title":"OnComponentUnregisteredContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentUnregisteredContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The unregistered Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentUnregisteredContext.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>The name the component was registered under</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentUnregisteredContext.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The registry the component was unregistered from</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnRegistryCreatedContext","title":"OnRegistryCreatedContext","text":"<p>Attributes:</p> <ul> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnRegistryCreatedContext.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The created ComponentRegistry instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnRegistryDeletedContext","title":"OnRegistryDeletedContext","text":"<p>Attributes:</p> <ul> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnRegistryDeletedContext.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The to-be-deleted ComponentRegistry instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext","title":"OnSlotRenderedContext","text":"<p>Attributes:</p> <ul> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>result</code>               (<code>SlotResult</code>)           \u2013            </li> <li> <code>slot</code>               (<code>Slot</code>)           \u2013            </li> <li> <code>slot_is_default</code>               (<code>bool</code>)           \u2013            </li> <li> <code>slot_is_required</code>               (<code>bool</code>)           \u2013            </li> <li> <code>slot_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>slot_node</code>               (<code>SlotNode</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.component","title":"component  <code>instance-attribute</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>The Component instance that contains the <code>{% slot %}</code> tag</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The Component class that contains the <code>{% slot %}</code> tag</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: str\n</code></pre> <p>See source code</p> <p>The unique identifier for this component instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.result","title":"result  <code>instance-attribute</code>","text":"<pre><code>result: SlotResult\n</code></pre> <p>See source code</p> <p>The rendered result of the slot</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.slot","title":"slot  <code>instance-attribute</code>","text":"<pre><code>slot: Slot\n</code></pre> <p>See source code</p> <p>The Slot instance that was rendered</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.slot_is_default","title":"slot_is_default  <code>instance-attribute</code>","text":"<pre><code>slot_is_default: bool\n</code></pre> <p>See source code</p> <p>Whether the slot is default</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.slot_is_required","title":"slot_is_required  <code>instance-attribute</code>","text":"<pre><code>slot_is_required: bool\n</code></pre> <p>See source code</p> <p>Whether the slot is required</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.slot_name","title":"slot_name  <code>instance-attribute</code>","text":"<pre><code>slot_name: str\n</code></pre> <p>See source code</p> <p>The name of the <code>{% slot %}</code> tag</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnSlotRenderedContext.slot_node","title":"slot_node  <code>instance-attribute</code>","text":"<pre><code>slot_node: SlotNode\n</code></pre> <p>See source code</p> <p>The node instance of the <code>{% slot %}</code> tag</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnTemplateCompiledContext","title":"OnTemplateCompiledContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>template</code>               (<code>Template</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnTemplateCompiledContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The Component class whose template was loaded</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnTemplateCompiledContext.template","title":"template  <code>instance-attribute</code>","text":"<pre><code>template: Template\n</code></pre> <p>See source code</p> <p>The compiled template object</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnTemplateLoadedContext","title":"OnTemplateLoadedContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>content</code>               (<code>str</code>)           \u2013            </li> <li> <code>name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>origin</code>               (<code>Optional[Origin]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnTemplateLoadedContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The Component class whose template was loaded</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnTemplateLoadedContext.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre> <p>See source code</p> <p>The template string</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnTemplateLoadedContext.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Optional[str]\n</code></pre> <p>See source code</p> <p>The name of the template</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnTemplateLoadedContext.origin","title":"origin  <code>instance-attribute</code>","text":"<pre><code>origin: Optional[Origin]\n</code></pre> <p>See source code</p> <p>The origin of the template</p>"},{"location":"reference/extension_urls/","title":"Extension URLs API","text":""},{"location":"reference/extension_urls/#extension-urls-api","title":"Extension URLs API","text":"<p>Overview of all classes, functions, and other objects related to defining extension URLs.</p> <p>Read more on Extensions.</p>"},{"location":"reference/extension_urls/#django_components.URLRoute","title":"URLRoute  <code>dataclass</code>","text":"<pre><code>URLRoute(path: str, handler: Optional[URLRouteHandler] = None, children: Iterable[URLRoute] = list(), name: Optional[str] = None, extra: Dict[str, Any] = dict())\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Framework-agnostic route definition.</p> <p>This is similar to Django's <code>URLPattern</code> object created with <code>django.urls.path()</code>.</p> <p>The <code>URLRoute</code> must either define a <code>handler</code> function or have a list of child routes <code>children</code>. If both are defined, an error will be raised.</p> <p>Example:</p> <pre><code>URLRoute(\"/my/path\", handler=my_handler, name=\"my_name\", extra={\"kwargs\": {\"my_extra\": \"my_value\"}})\n</code></pre> <p>Is equivalent to:</p> <pre><code>django.urls.path(\"/my/path\", my_handler, name=\"my_name\", kwargs={\"my_extra\": \"my_value\"})\n</code></pre> <p>With children:</p> <pre><code>URLRoute(\n    \"/my/path\",\n    name=\"my_name\",\n    extra={\"kwargs\": {\"my_extra\": \"my_value\"}},\n    children=[\n        URLRoute(\n            \"/child/&lt;str:name&gt;/\",\n            handler=my_handler,\n            name=\"my_name\",\n            extra={\"kwargs\": {\"my_extra\": \"my_value\"}},\n        ),\n        URLRoute(\"/other/&lt;int:id&gt;/\", handler=other_handler),\n    ],\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>Iterable[URLRoute]</code>)           \u2013            </li> <li> <code>extra</code>               (<code>Dict[str, Any]</code>)           \u2013            </li> <li> <code>handler</code>               (<code>Optional[URLRouteHandler]</code>)           \u2013            </li> <li> <code>name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>path</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_urls/#django_components.URLRoute.children","title":"children  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>children: Iterable[URLRoute] = field(default_factory=list)\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRoute.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRoute.handler","title":"handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>handler: Optional[URLRouteHandler] = None\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRoute.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRoute.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRouteHandler","title":"URLRouteHandler","text":"<p>Bases: <code>typing.Protocol</code></p> <p>See source code</p> <p>Framework-agnostic 'view' function for routes</p>"},{"location":"reference/settings/","title":"Settings","text":""},{"location":"reference/settings/#settings","title":"Settings","text":"<p>You can configure django_components with a global <code>COMPONENTS</code> variable in your Django settings file, e.g. <code>settings.py</code>. By default you don't need it set, there are resonable defaults.</p> <p>To configure the settings you can instantiate <code>ComponentsSettings</code> for validation and type hints. Or, for backwards compatibility, you can also use plain dictionary:</p> <pre><code># settings.py\nfrom django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    autodiscover=True,\n    ...\n)\n\n# or\n\nCOMPONENTS = {\n    \"autodiscover\": True,\n    ...\n}\n</code></pre>"},{"location":"reference/settings/#settings-defaults","title":"Settings defaults","text":"<p>Here's overview of all available settings and their defaults:</p> <pre><code>defaults = ComponentsSettings(\n    autodiscover=True,\n    cache=None,\n    context_behavior=ContextBehavior.DJANGO.value,  # \"django\" | \"isolated\"\n    # Root-level \"components\" dirs, e.g. `/path/to/proj/components/`\n    dirs=[Path(settings.BASE_DIR) / \"components\"],\n    # App-level \"components\" dirs, e.g. `[app]/components/`\n    app_dirs=[\"components\"],\n    debug_highlight_components=False,\n    debug_highlight_slots=False,\n    dynamic_component_name=\"dynamic\",\n    extensions=[],\n    extensions_defaults={},\n    libraries=[],  # E.g. [\"mysite.components.forms\", ...]\n    multiline_tags=True,\n    reload_on_file_change=False,\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\", \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n    static_files_forbidden=[\n        # See https://marketplace.visualstudio.com/items?itemName=junstyle.vscode-django-support\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n    tag_formatter=\"django_components.component_formatter\",\n    template_cache_size=128,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.app_dirs","title":"app_dirs","text":"<pre><code>app_dirs: Optional[Sequence[str]] = None\n</code></pre> <p>See source code</p> <p>Specify the app-level directories that contain your components.</p> <p>Defaults to <code>[\"components\"]</code>. That is, for each Django app, we search <code>&lt;app&gt;/components/</code> for components.</p> <p>The paths must be relative to app, e.g.:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[\"my_comps\"],\n)\n</code></pre> <p>To search for <code>&lt;app&gt;/my_comps/</code>.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <p>Set to empty list to disable app-level components:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[],\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.autodiscover","title":"autodiscover","text":"<pre><code>autodiscover: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Toggle whether to run autodiscovery at the Django server startup.</p> <p>Defaults to <code>True</code></p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.cache","title":"cache","text":"<pre><code>cache: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the Django cache to be used for storing component's JS and CSS files.</p> <p>If <code>None</code>, a <code>LocMemCache</code> is used with default settings.</p> <p>Defaults to <code>None</code>.</p> <p>Read more about caching.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    cache=\"my_cache\",\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.context_behavior","title":"context_behavior","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>See source code</p> <p>Configure whether, inside a component template, you can use variables from the outside (<code>\"django\"</code>) or not (<code>\"isolated\"</code>). This also affects what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Defaults to <code>\"django\"</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    context_behavior=\"isolated\",\n)\n</code></pre> <p>NOTE: <code>context_behavior</code> and <code>slot_context_behavior</code> options were merged in v0.70.</p> <p>If you are migrating from BEFORE v0.67, set <code>context_behavior</code> to <code>\"django\"</code>. From v0.67 to v0.78 (incl) the default value was <code>\"isolated\"</code>.</p> <p>For v0.79 and later, the default is again <code>\"django\"</code>. See the rationale for change here.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.debug_highlight_components","title":"debug_highlight_components","text":"<pre><code>debug_highlight_components: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>DEPRECATED. Use <code>extensions_defaults</code> instead. Will be removed in v1.</p> <p>Enable / disable component highlighting. See Troubleshooting for more details.</p> <p>Defaults to <code>False</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_components=True,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.debug_highlight_slots","title":"debug_highlight_slots","text":"<pre><code>debug_highlight_slots: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>DEPRECATED. Use <code>extensions_defaults</code> instead. Will be removed in v1.</p> <p>Enable / disable slot highlighting. See Troubleshooting for more details.</p> <p>Defaults to <code>False</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_slots=True,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.dirs","title":"dirs","text":"<pre><code>dirs: Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]] = None\n</code></pre> <p>See source code</p> <p>Specify the directories that contain your components.</p> <p>Defaults to <code>[Path(settings.BASE_DIR) / \"components\"]</code>. That is, the root <code>components/</code> app.</p> <p>Directories must be full paths, same as with STATICFILES_DIRS.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[BASE_DIR / \"components\"],\n)\n</code></pre> <p>Set to empty list to disable global components directories:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[],\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.dynamic_component_name","title":"dynamic_component_name","text":"<pre><code>dynamic_component_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>.</p> <p>In case of a conflict, you can use this setting to change the component name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.extensions","title":"extensions","text":"<pre><code>extensions: Optional[Sequence[Union[Type[ComponentExtension], str]]] = None\n</code></pre> <p>See source code</p> <p>List of extensions to be loaded.</p> <p>The extensions can be specified as:</p> <ul> <li>Python import path, e.g. <code>\"path.to.my_extension.MyExtension\"</code>.</li> <li>Extension class, e.g. <code>my_extension.MyExtension</code>.</li> </ul> <p>Read more about extensions.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    extensions=[\n        \"path.to.my_extension.MyExtension\",\n        StorybookExtension,\n    ],\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.extensions_defaults","title":"extensions_defaults","text":"<pre><code>extensions_defaults: Optional[Dict[str, Any]] = None\n</code></pre> <p>See source code</p> <p>Global defaults for the extension classes.</p> <p>Read more about Extension defaults.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    extensions_defaults={\n        \"my_extension\": {\n            \"my_setting\": \"my_value\",\n        },\n        \"cache\": {\n            \"enabled\": True,\n            \"ttl\": 60,\n        },\n    },\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.forbidden_static_files","title":"forbidden_static_files","text":"<pre><code>forbidden_static_files: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>COMPONENTS.static_files_forbidden</code> instead.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.libraries","title":"libraries","text":"<pre><code>libraries: Optional[List[str]] = None\n</code></pre> <p>See source code</p> <p>Configure extra python modules that should be loaded.</p> <p>This may be useful if you are not using the autodiscovery feature, or you need to load components from non-standard locations. Thus you can have a structure of components that is independent from your apps.</p> <p>Expects a list of python module paths. Defaults to empty list.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    libraries=[\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n)\n</code></pre> <p>This would be the equivalent of importing these modules from within Django's <code>AppConfig.ready()</code>:</p> <pre><code>class MyAppConfig(AppConfig):\n    def ready(self):\n        import \"mysite.components.forms\"\n        import \"mysite.components.buttons\"\n        import \"mysite.components.cards\"\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.libraries--manually-loading-libraries","title":"Manually loading libraries","text":"<p>In the rare case that you need to manually trigger the import of libraries, you can use the <code>import_libraries()</code> function:</p> <pre><code>from django_components import import_libraries\n\nimport_libraries()\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.multiline_tags","title":"multiline_tags","text":"<pre><code>multiline_tags: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Enable / disable multiline support for template tags. If <code>True</code>, template tags like <code>{% component %}</code> or <code>{{ my_var }}</code> can span multiple lines.</p> <p>Defaults to <code>True</code>.</p> <p>Disable this setting if you are making custom modifications to Django's regular expression for parsing templates at <code>django.template.base.tag_re</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    multiline_tags=False,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.reload_on_file_change","title":"reload_on_file_change","text":"<pre><code>reload_on_file_change: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>This is relevant if you are using the project structure where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>Django's native live reload logic handles only Python files and HTML template files. It does NOT reload when other file types change or when template files are nested more than one level deep.</p> <p>The setting <code>reload_on_file_change</code> fixes this, reloading the dev server even when your component's HTML, JS, or CSS changes.</p> <p>If <code>True</code>, django_components configures Django to reload when files inside <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> change.</p> <p>See Reload dev server on component file changes.</p> <p>Defaults to <code>False</code>.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.reload_on_template_change","title":"reload_on_template_change","text":"<pre><code>reload_on_template_change: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>COMPONENTS.reload_on_file_change</code> instead.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.static_files_allowed","title":"static_files_allowed","text":"<pre><code>static_files_allowed: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> are treated as static files.</p> <p>If a file is matched against any of the patterns, it's considered a static file. Such files are collected when running <code>collectstatic</code>, and can be accessed under the static file endpoint.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, JS, CSS, and common image and font file formats are considered static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\",  \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.static_files_forbidden","title":"static_files_forbidden","text":"<pre><code>static_files_forbidden: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> will NEVER be treated as static files.</p> <p>If a file is matched against any of the patterns, it will never be considered a static file, even if the file matches a pattern in <code>static_files_allowed</code>.</p> <p>Use this setting together with <code>static_files_allowed</code> for a fine control over what file types will be exposed.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, any HTML and Python are considered NOT static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_forbidden=[\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.tag_formatter","title":"tag_formatter","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>See source code</p> <p>Configure what syntax is used inside Django templates to render components. See the available tag formatters.</p> <p>Defaults to <code>\"django_components.component_formatter\"</code>.</p> <p>Learn more about Customizing component tags with TagFormatter.</p> <p>Can be set either as direct reference:</p> <pre><code>from django_components import component_formatter\n\nCOMPONENTS = ComponentsSettings(\n    \"tag_formatter\": component_formatter\n)\n</code></pre> <p>Or as an import string;</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>Examples:</p> <ul> <li> <p><code>\"django_components.component_formatter\"</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    Click me!\n{% endcomponent %}\n</code></pre> </li> <li> <p><code>django_components.component_shorthand_formatter</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.template_cache_size","title":"template_cache_size","text":"<pre><code>template_cache_size: Optional[int] = None\n</code></pre> <p>See source code</p> <p>DEPRECATED. Template caching will be removed in v1.</p> <p>Configure the maximum amount of Django templates to be cached.</p> <p>Defaults to <code>128</code>.</p> <p>Each time a Django template is rendered, it is cached to a global in-memory cache (using Python's <code>lru_cache</code> decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up.</p> <p>By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are overriding <code>Component.get_template()</code> to render many dynamic templates, you can increase this number.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=256,\n)\n</code></pre> <p>To remove the cache limit altogether and cache everything, set <code>template_cache_size</code> to <code>None</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=None,\n)\n</code></pre> <p>If you want to add templates to the cache yourself, you can use <code>cached_template()</code>:</p> <pre><code>from django_components import cached_template\n\ncached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ncached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/signals/","title":"Signals","text":""},{"location":"reference/signals/#signals","title":"Signals","text":"<p>Below are the signals that are sent by or during the use of django-components.</p>"},{"location":"reference/signals/#template_rendered","title":"template_rendered","text":"<p>Django's <code>template_rendered</code> signal. This signal is sent when a template is rendered.</p> <p>Django-components triggers this signal when a component is rendered. If there are nested components, the signal is triggered for each component.</p> <p>Import from django as <code>django.test.signals.template_rendered</code>.</p> <pre><code>from django.test.signals import template_rendered\n\n# Setup a callback function\ndef my_callback(sender, **kwargs):\n    ...\n\ntemplate_rendered.connect(my_callback)\n\nclass MyTable(Component):\n    template = \"\"\"\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;th&gt;Header&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;Cell&lt;/td&gt;\n        &lt;/tr&gt;\n    \"\"\"\n\n# This will trigger the signal\nMyTable().render()\n</code></pre>"},{"location":"reference/tag_formatters/","title":"Tag formatters","text":""},{"location":"reference/tag_formatters/#tag-formatters","title":"Tag Formatters","text":"<p>Tag formatters allow you to change the syntax for calling components from within the Django templates.</p> <p>Tag formatter are set via the tag_formatter setting.</p>"},{"location":"reference/tag_formatters/#available-tag-formatters","title":"Available tag formatters","text":"<ul> <li> <p><code>django_components.component_formatter</code> for ComponentFormatter</p> </li> <li> <p><code>django_components.component_shorthand_formatter</code> for ShorthandComponentFormatter </p> </li> </ul>"},{"location":"reference/tag_formatters/#django_components.tag_formatter.ComponentFormatter","title":"<code>ComponentFormatter</code>","text":"<p>Bases: <code>django_components.tag_formatter.TagFormatterABC</code></p> <p>See source code</p> <p>The original django_component's component tag formatter, it uses the <code>{% component %}</code> and <code>{% endcomponent %}</code> tags, and the component name is given as the first positional arg.</p> <p>Example as block: <pre><code>{% component \"mycomp\" abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% component \"mycomp\" abc=123 / %}\n</code></pre></p>"},{"location":"reference/tag_formatters/#django_components.tag_formatter.ShorthandComponentFormatter","title":"<code>ShorthandComponentFormatter</code>","text":"<p>Bases: <code>django_components.tag_formatter.TagFormatterABC</code></p> <p>See source code</p> <p>The component tag formatter that uses <code>{% &lt;name&gt; %}</code> / <code>{% end&lt;name&gt; %}</code> tags.</p> <p>This is similar to django-web-components and django-slippers syntax.</p> <p>Example as block: <pre><code>{% mycomp abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endmycomp %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% mycomp abc=123 / %}\n</code></pre></p>"},{"location":"reference/template_tags/","title":"Template tags","text":""},{"location":"reference/template_tags/#template-tags","title":"Template tags","text":"<p>All following template tags are defined in</p> <p><code>django_components.templatetags.component_tags</code></p> <p>Import as <pre><code>{% load component_tags %}\n</code></pre></p>"},{"location":"reference/template_tags/#component_css_dependencies","title":"component_css_dependencies","text":"<pre><code>{% component_css_dependencies  %}\n</code></pre> <p>See source code</p> <p>Marks location where CSS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted into the <code>&lt;head&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_css_dependencies %}</code> tags, CSS links are by default inserted into the <code>&lt;head&gt;</code> tag of the HTML. (See Default JS / CSS locations)</p> <p>Note that there should be only one <code>{% component_css_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL CSS links will be duplicately inserted into ALL these places.</p>"},{"location":"reference/template_tags/#component_js_dependencies","title":"component_js_dependencies","text":"<pre><code>{% component_js_dependencies  %}\n</code></pre> <p>See source code</p> <p>Marks location where JS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_js_dependencies %}</code> tags, JS scripts are by default inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML. (See Default JS / CSS locations)</p> <p>Note that there should be only one <code>{% component_js_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL JS scripts will be duplicately inserted into ALL these places.</p>"},{"location":"reference/template_tags/#component","title":"component","text":"<pre><code>{% component *args: Any, **kwargs: Any [only] %}\n{% endcomponent %}\n</code></pre> <p>See source code</p> <p>Renders one of the components that was previously registered with <code>@register()</code> decorator.</p> <p>The <code>{% component %}</code> tag takes:</p> <ul> <li>Component's registered name as the first positional argument,</li> <li>Followed by any number of positional and keyword arguments.</li> </ul> <pre><code>{% load component_tags %}\n&lt;div&gt;\n    {% component \"button\" name=\"John\" job=\"Developer\" / %}\n&lt;/div&gt;\n</code></pre> <p>The component name must be a string literal.</p>"},{"location":"reference/template_tags/#inserting-slot-fills","title":"Inserting slot fills","text":"<p>If the component defined any slots, you can \"fill\" these slots by placing the <code>{% fill %}</code> tags within the <code>{% component %}</code> tag:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>You can even nest <code>{% fill %}</code> tags within <code>{% if %}</code>, <code>{% for %}</code> and other tags:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n    {% if rows %}\n        {% fill \"pagination\" %}\n            &lt; 1 | 2 | 3 &gt;\n        {% endfill %}\n    {% endif %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#isolating-components","title":"Isolating components","text":"<p>By default, components behave similarly to Django's <code>{% include %}</code>, and the template inside the component has access to the variables defined in the outer template.</p> <p>You can selectively isolate a component, using the <code>only</code> flag, so that the inner template can access only the data that was explicitly passed to it:</p> <pre><code>{% component \"name\" positional_arg keyword_arg=value ... only %}\n</code></pre> <p>Alternatively, you can set all components to be isolated by default, by setting <code>context_behavior</code> to <code>\"isolated\"</code> in your settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"context_behavior\": \"isolated\",\n}\n</code></pre>"},{"location":"reference/template_tags/#omitting-the-component-keyword","title":"Omitting the component keyword","text":"<p>If you would like to omit the <code>component</code> keyword, and simply refer to your components by their registered names:</p> <pre><code>{% button name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>You can do so by setting the \"shorthand\" Tag formatter in the settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\",\n}\n</code></pre>"},{"location":"reference/template_tags/#fill","title":"fill","text":"<pre><code>{% fill name: str, *, data: Optional[str] = None, fallback: Optional[str] = None, body: Union[str, django.utils.safestring.SafeString, django_components.slots.SlotFunc[~TSlotData], django_components.slots.Slot[~TSlotData], NoneType] = None, default: Optional[str] = None %}\n{% endfill %}\n</code></pre> <p>See source code</p> <p>Use <code>{% fill %}</code> tag to insert content into component's slots.</p> <p><code>{% fill %}</code> tag may be used only within a <code>{% component %}..{% endcomponent %}</code> block, and raises a <code>TemplateSyntaxError</code> if used outside of a component.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Name of the slot to insert this content into. Use <code>\"default\"</code> for     the default slot.</li> <li><code>data</code> (str, optional): This argument allows you to access the data passed to the slot     under the specified variable name. See Slot data.</li> <li><code>fallback</code> (str, optional): This argument allows you to access the original content of the slot     under the specified variable name. See Slot fallback.</li> </ul> <p>Example:</p> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#access-slot-fallback","title":"Access slot fallback","text":"<p>Use the <code>fallback</code> kwarg to access the original content of the slot.</p> <p>The <code>fallback</code> kwarg defines the name of the variable that will contain the slot's fallback content.</p> <p>Read more about Slot fallback.</p> <p>Component template:</p> <pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <p>Fill:</p> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" fallback=\"fallback\" %}\n    &lt;div class=\"my-class\"&gt;\n      {{ fallback }}\n    &lt;/div&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#access-slot-data","title":"Access slot data","text":"<p>Use the <code>data</code> kwarg to access the data passed to the slot.</p> <p>The <code>data</code> kwarg defines the name of the variable that will contain the slot's data.</p> <p>Read more about Slot data.</p> <p>Component template:</p> <pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" pages=pages %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <p>Fill:</p> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" data=\"slot_data\" %}\n    {% for page in slot_data.pages %}\n        &lt;a href=\"{{ page.link }}\"&gt;\n          {{ page.index }}\n        &lt;/a&gt;\n    {% endfor %}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#using-default-slot","title":"Using default slot","text":"<p>To access slot data and the fallback slot content on the default slot, use <code>{% fill %}</code> with <code>name</code> set to <code>\"default\"</code>:</p> <pre><code>{% component \"button\" %}\n  {% fill name=\"default\" data=\"slot_data\" fallback=\"slot_fallback\" %}\n    You clicked me {{ slot_data.count }} times!\n    {{ slot_fallback }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#slot-fills-from-python","title":"Slot fills from Python","text":"<p>You can pass a slot fill from Python to a component by setting the <code>body</code> kwarg on the <code>{% fill %}</code> tag.</p> <p>First pass a <code>Slot</code> instance to the template with the <code>get_template_data()</code> method:</p> <pre><code>from django_components import component, Slot\n\nclass Table(Component):\n  def get_template_data(self, args, kwargs, slots, context):\n    return {\n        \"my_slot\": Slot(lambda ctx: \"Hello, world!\"),\n    }\n</code></pre> <p>Then pass the slot to the <code>{% fill %}</code> tag:</p> <pre><code>{% component \"table\" %}\n  {% fill \"pagination\" body=my_slot / %}\n{% endcomponent %}\n</code></pre> <p>Warning</p> <p>If you define both the <code>body</code> kwarg and the <code>{% fill %}</code> tag's body, an error will be raised.</p> <pre><code>{% component \"table\" %}\n  {% fill \"pagination\" body=my_slot %}\n    ...\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#html_attrs","title":"html_attrs","text":"<pre><code>{% html_attrs attrs: Optional[Dict] = None, defaults: Optional[Dict] = None, **kwargs: Any %}\n</code></pre> <p>See source code</p> <p>Generate HTML attributes (<code>key=\"value\"</code>), combining data from multiple sources, whether its template variables or static text.</p> <p>It is designed to easily merge HTML attributes passed from outside as well as inside the component.</p> <p>Args:</p> <ul> <li><code>attrs</code> (dict, optional): Optional dictionary that holds HTML attributes. On conflict, overrides     values in the <code>default</code> dictionary.</li> <li><code>default</code> (str, optional): Optional dictionary that holds HTML attributes. On conflict, is overriden     with values in the <code>attrs</code> dictionary.</li> <li>Any extra kwargs will be appended to the corresponding keys</li> </ul> <p>The attributes in <code>attrs</code> and <code>defaults</code> are merged and resulting dict is rendered as HTML attributes (<code>key=\"value\"</code>).</p> <p>Extra kwargs (<code>key=value</code>) are concatenated to existing keys. So if we have</p> <pre><code>attrs = {\"class\": \"my-class\"}\n</code></pre> <p>Then</p> <pre><code>{% html_attrs attrs class=\"extra-class\" %}\n</code></pre> <p>will result in <code>class=\"my-class extra-class\"</code>.</p> <p>Example: <pre><code>&lt;div {% html_attrs\n    attrs\n    defaults:class=\"default-class\"\n    class=\"extra-class\"\n    data-id=\"123\"\n%}&gt;\n</code></pre></p> <p>renders</p> <pre><code>&lt;div class=\"my-class extra-class\" data-id=\"123\"&gt;\n</code></pre> <p>See more usage examples in HTML attributes.</p>"},{"location":"reference/template_tags/#provide","title":"provide","text":"<pre><code>{% provide name: str, **kwargs: Any %}\n{% endprovide %}\n</code></pre> <p>See source code</p> <p>The <code>{% provide %}</code> tag is part of the \"provider\" part of the provide / inject feature.</p> <p>Pass kwargs to this tag to define the provider's data.</p> <p>Any components defined within the <code>{% provide %}..{% endprovide %}</code> tags will be able to access this data with <code>Component.inject()</code>.</p> <p>This is similar to React's <code>ContextProvider</code>, or Vue's <code>provide()</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Provider name. This is the name you will then use in     <code>Component.inject()</code>.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the provided data.</li> </ul> <p>Example:</p> <p>Provide the \"user_data\" in parent component:</p> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% provide \"user_data\" user=user %}\n          {% component \"child\" / %}\n        {% endprovide %}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"user\": kwargs[\"user\"],\n        }\n</code></pre> <p>Since the \"child\" component is used within the <code>{% provide %} / {% endprovide %}</code> tags, we can request the \"user_data\" using <code>Component.inject(\"user_data\")</code>:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        User is: {{ user }}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        user = self.inject(\"user_data\").user\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Notice that the keys defined on the <code>{% provide %}</code> tag are then accessed as attributes when accessing them with <code>Component.inject()</code>.</p> <p>\u2705 Do this <pre><code>user = self.inject(\"user_data\").user\n</code></pre></p> <p>\u274c Don't do this <pre><code>user = self.inject(\"user_data\")[\"user\"]\n</code></pre></p>"},{"location":"reference/template_tags/#slot","title":"slot","text":"<pre><code>{% slot name: str, **kwargs: Any [default] [required] %}\n{% endslot %}\n</code></pre> <p>See source code</p> <p><code>{% slot %}</code> tag marks a place inside a component where content can be inserted from outside.</p> <p>Learn more about using slots.</p> <p>This is similar to slots as seen in Web components, Vue or React's <code>children</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li><code>default</code>: Optional flag. If there is a default slot, you can pass the component slot content     without using the <code>{% fill %}</code> tag. See     Default slot</li> <li><code>required</code>: Optional flag. Will raise an error if a slot is required but not given.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the slot data.</li> </ul> <p>Example:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" default %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n      &lt;aside&gt;\n        {% slot \"sidebar\" required / %}\n      &lt;/aside&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% fill \"content\" %}\n            \ud83d\uddde\ufe0f\ud83d\udcf0\n          {% endfill %}\n\n          {% fill \"sidebar\" %}\n            \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n          {% endfill %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/template_tags/#slot-data","title":"Slot data","text":"<p>Any extra kwargs will be considered as slot data, and will be accessible in the <code>{% fill %}</code> tag via fill's <code>data</code> kwarg:</p> <p>Read more about Slot data.</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {# Passing data to the slot #}\n        {% slot \"content\" user=user %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot data #}\n      {% component \"child\" %}\n        {% fill \"content\" data=\"data\" %}\n          &lt;div class=\"wrapper-class\"&gt;\n            {{ data.user }}\n          &lt;/div&gt;\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre>"},{"location":"reference/template_tags/#slot-fallback","title":"Slot fallback","text":"<p>The content between the <code>{% slot %}..{% endslot %}</code> tags is the fallback content that will be rendered if no fill is given for the slot.</p> <p>This fallback content can then be accessed from within the <code>{% fill %}</code> tag using the fill's <code>fallback</code> kwarg. This is useful if you need to wrap / prepend / append the original slot's content.</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" %}\n          This is fallback content!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot's fallback content #}\n      {% component \"child\" %}\n        {% fill \"content\" fallback=\"fallback\" %}\n          {{ fallback }}\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre>"},{"location":"reference/template_variables/","title":"Template variables","text":""},{"location":"reference/template_variables/#template-variables","title":"Template variables","text":"<p>Here is a list of all variables that are automatically available from inside the component's template:</p>"},{"location":"reference/template_variables/#django_components.component.ComponentVars.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: Any\n</code></pre> <p>See source code</p> <p>The <code>args</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>This is the same <code>Component.args</code> that's available on the component instance.</p> <p>If you defined the <code>Component.Args</code> class, then the <code>args</code> property will return an instance of that class.</p> <p>Otherwise, <code>args</code> will be a plain list.</p> <p>Example:</p> <p>With <code>Args</code> class:</p> <pre><code>from django_components import Component, register\n\n@register(\"table\")\nclass Table(Component):\n    class Args(NamedTuple):\n        page: int\n        per_page: int\n\n    template = '''\n        &lt;div&gt;\n            &lt;h1&gt;Table&lt;/h1&gt;\n            &lt;p&gt;Page: {{ component_vars.args.page }}&lt;/p&gt;\n            &lt;p&gt;Per page: {{ component_vars.args.per_page }}&lt;/p&gt;\n        &lt;/div&gt;\n    '''\n</code></pre> <p>Without <code>Args</code> class:</p> <pre><code>from django_components import Component, register\n\n@register(\"table\")\nclass Table(Component):\n    template = '''\n        &lt;div&gt;\n            &lt;h1&gt;Table&lt;/h1&gt;\n            &lt;p&gt;Page: {{ component_vars.args.0 }}&lt;/p&gt;\n            &lt;p&gt;Per page: {{ component_vars.args.1 }}&lt;/p&gt;\n        &lt;/div&gt;\n    '''\n</code></pre>"},{"location":"reference/template_variables/#django_components.component.ComponentVars.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: Any\n</code></pre> <p>See source code</p> <p>The <code>kwargs</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>This is the same <code>Component.kwargs</code> that's available on the component instance.</p> <p>If you defined the <code>Component.Kwargs</code> class, then the <code>kwargs</code> property will return an instance of that class.</p> <p>Otherwise, <code>kwargs</code> will be a plain dict.</p> <p>Example:</p> <p>With <code>Kwargs</code> class:</p> <pre><code>from django_components import Component, register\n\n@register(\"table\")\nclass Table(Component):\n    class Kwargs(NamedTuple):\n        page: int\n        per_page: int\n\n    template = '''\n        &lt;div&gt;\n            &lt;h1&gt;Table&lt;/h1&gt;\n            &lt;p&gt;Page: {{ component_vars.kwargs.page }}&lt;/p&gt;\n            &lt;p&gt;Per page: {{ component_vars.kwargs.per_page }}&lt;/p&gt;\n        &lt;/div&gt;\n    '''\n</code></pre> <p>Without <code>Kwargs</code> class:</p> <pre><code>from django_components import Component, register\n\n@register(\"table\")\nclass Table(Component):\n    template = '''\n        &lt;div&gt;\n            &lt;h1&gt;Table&lt;/h1&gt;\n            &lt;p&gt;Page: {{ component_vars.kwargs.page }}&lt;/p&gt;\n            &lt;p&gt;Per page: {{ component_vars.kwargs.per_page }}&lt;/p&gt;\n        &lt;/div&gt;\n    '''\n</code></pre>"},{"location":"reference/template_variables/#django_components.component.ComponentVars.slots","title":"slots  <code>instance-attribute</code>","text":"<pre><code>slots: Any\n</code></pre> <p>See source code</p> <p>The <code>slots</code> argument as passed to <code>Component.get_template_data()</code>.</p> <p>This is the same <code>Component.slots</code> that's available on the component instance.</p> <p>If you defined the <code>Component.Slots</code> class, then the <code>slots</code> property will return an instance of that class.</p> <p>Otherwise, <code>slots</code> will be a plain dict.</p> <p>Example:</p> <p>With <code>Slots</code> class:</p> <pre><code>from django_components import Component, SlotInput, register\n\n@register(\"table\")\nclass Table(Component):\n    class Slots(NamedTuple):\n        footer: SlotInput\n\n    template = '''\n        &lt;div&gt;\n            {% component \"pagination\" %}\n                {% fill \"footer\" body=component_vars.slots.footer / %}\n            {% endcomponent %}\n        &lt;/div&gt;\n    '''\n</code></pre> <p>Without <code>Slots</code> class:</p> <pre><code>from django_components import Component, SlotInput, register\n\n@register(\"table\")\nclass Table(Component):\n    template = '''\n        &lt;div&gt;\n            {% component \"pagination\" %}\n                {% fill \"footer\" body=component_vars.slots.footer / %}\n            {% endcomponent %}\n        &lt;/div&gt;\n    '''\n</code></pre>"},{"location":"reference/template_variables/#django_components.component.ComponentVars.is_filled","title":"is_filled  <code>instance-attribute</code>","text":"<pre><code>is_filled: Dict[str, bool]\n</code></pre> <p>See source code</p> <p>Deprecated. Will be removed in v1. Use <code>component_vars.slots</code> instead. Note that <code>component_vars.slots</code> no longer escapes the slot names.</p> <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> <p>New in version 0.70</p> <p>Use as <code>{{ component_vars.is_filled }}</code></p> <p>Example:</p> <pre><code>{# Render wrapping HTML only if the slot is defined #}\n{% if component_vars.is_filled.my_slot %}\n    &lt;div class=\"slot-wrapper\"&gt;\n        {% slot \"my_slot\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre> <p>This is equivalent to checking if a given key is among the slot fills:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"my_slot_filled\": \"my_slot\" in slots\n        }\n</code></pre>"},{"location":"reference/testing_api/","title":"Testing API","text":""},{"location":"reference/testing_api/#testing-api","title":"Testing API","text":""},{"location":"reference/testing_api/#django_components.testing.djc_test","title":"djc_test","text":"<pre><code>djc_test(django_settings: Union[Optional[Dict], Callable, Type] = None, components_settings: Optional[Dict] = None, parametrize: Optional[Union[Tuple[Sequence[str], Sequence[Sequence[Any]]], Tuple[Sequence[str], Sequence[Sequence[Any]], Optional[Union[Iterable[Union[None, str, float, int, bool]], Callable[[Any], Optional[object]]]]]]] = None, gc_collect: bool = True) -&gt; Callable\n</code></pre> <p>See source code</p> <p>Decorator for testing components from django-components.</p> <p><code>@djc_test</code> manages the global state of django-components, ensuring that each test is properly isolated and that components registered in one test do not affect other tests.</p> <p>This decorator can be applied to a function, method, or a class. If applied to a class, it will search for all methods that start with <code>test_</code>, and apply the decorator to them. This is applied recursively to nested classes as well.</p> <p>Examples:</p> <p>Applying to a function: <pre><code>from django_components.testing import djc_test\n\n@djc_test\ndef test_my_component():\n    @register(\"my_component\")\n    class MyComponent(Component):\n        template = \"...\"\n    ...\n</code></pre></p> <p>Applying to a class: <pre><code>from django_components.testing import djc_test\n\n@djc_test\nclass TestMyComponent:\n    def test_something(self):\n        ...\n\n    class Nested:\n        def test_something_else(self):\n            ...\n</code></pre></p> <p>Applying to a class is the same as applying the decorator to each <code>test_</code> method individually: <pre><code>from django_components.testing import djc_test\n\nclass TestMyComponent:\n    @djc_test\n    def test_something(self):\n        ...\n\n    class Nested:\n        @djc_test\n        def test_something_else(self):\n            ...\n</code></pre></p> <p>To use <code>@djc_test</code>, Django must be set up first:</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\ndjango.setup()\n\n@djc_test\ndef test_my_component():\n    ...\n</code></pre> <p>Arguments:</p> <ul> <li> <p><code>django_settings</code>: Django settings, a dictionary passed to Django's   <code>@override_settings</code>.   The test runs within the context of these overridden settings.</p> <p>If <code>django_settings</code> contains django-components settings (<code>COMPONENTS</code> field), these are merged. Other Django settings are simply overridden.</p> </li> <li> <p><code>components_settings</code>: Instead of defining django-components settings under <code>django_settings[\"COMPONENTS\"]</code>,     you can simply set the Components settings here.</p> <p>These settings are merged with the django-components settings from <code>django_settings[\"COMPONENTS\"]</code>.</p> <p>Fields in <code>components_settings</code> override fields in <code>django_settings[\"COMPONENTS\"]</code>.</p> </li> <li> <p><code>parametrize</code>: Parametrize the test function with     <code>pytest.mark.parametrize</code>.     This requires pytest to be installed.</p> <p>The input is a tuple of:</p> <ul> <li><code>(param_names, param_values)</code> or</li> <li><code>(param_names, param_values, ids)</code></li> </ul> </li> </ul> Example <pre><code>from django_components.testing import djc_test\n\n@djc_test(\n    parametrize=(\n         [\"input\", \"expected\"],\n         [[1, \"&lt;div&gt;1&lt;/div&gt;\"], [2, \"&lt;div&gt;2&lt;/div&gt;\"]],\n         ids=[\"1\", \"2\"]\n     )\n)\ndef test_component(input, expected):\n    rendered = MyComponent(input=input).render()\n    assert rendered == expected\n</code></pre> <p>You can parametrize the Django or Components settings by setting up parameters called <code>django_settings</code> and <code>components_settings</code>. These will be merged with the respetive settings from the decorator.</p> <p>Example of parametrizing context_behavior: <pre><code>from django_components.testing import djc_test\n\n@djc_test(\n    components_settings={\n        # Settings shared by all tests\n        \"app_dirs\": [\"custom_dir\"],\n    },\n    parametrize=(\n        # Parametrized settings\n        [\"components_settings\"],\n        [\n            [{\"context_behavior\": \"django\"}],\n            [{\"context_behavior\": \"isolated\"}],\n        ],\n        [\"django\", \"isolated\"],\n    )\n)\ndef test_context_behavior(components_settings):\n    rendered = MyComponent.render()\n    ...\n</code></pre></p> <ul> <li><code>gc_collect</code>: By default <code>djc_test</code> runs garbage collection after each test to force the state cleanup.   Set this to <code>False</code> to skip this.</li> </ul> <p>Settings resolution:</p> <p><code>@djc_test</code> accepts settings from different sources. The settings are resolved in the following order:</p> <ul> <li> <p>Django settings:</p> <ol> <li>The defaults are the Django settings that Django was set up with.</li> <li>Those are then overriden with fields in the <code>django_settings</code> kwarg.</li> <li>The parametrized <code>django_settings</code> override the fields on the <code>django_settings</code> kwarg.</li> </ol> <p>Priority: <code>django_settings</code> (parametrized) &gt; <code>django_settings</code> &gt; <code>django.conf.settings</code></p> </li> <li> <p>Components settings:</p> <ol> <li>Same as above, except that the <code>django_settings[\"COMPONENTS\"]</code> field is merged instead of overridden.</li> <li>The <code>components_settings</code> kwarg is then merged with the <code>django_settings[\"COMPONENTS\"]</code> field.</li> <li>The parametrized <code>components_settings</code> override the fields on the <code>components_settings</code> kwarg.</li> </ol> <p>Priority: <code>components_settings</code> (parametrized) &gt; <code>components_settings</code> &gt; <code>django_settings[\"COMPONENTS\"]</code> &gt; <code>django.conf.settings.COMPONENTS</code></p> </li> </ul>"},{"location":"reference/urls/","title":"URLs","text":""},{"location":"reference/urls/#urls","title":"URLs","text":"<p>Below are all the URL patterns that will be added by adding <code>django_components.urls</code>.</p> <p>See Installation on how to add these URLs to your Django project.</p> <p>Django components already prefixes all URLs with <code>components/</code>. So when you are adding the URLs to <code>urlpatterns</code>, you can use an empty string as the first argument:</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    ...\n    path(\"\", include(\"django_components.urls\")),\n]\n</code></pre>"},{"location":"reference/urls/#list-of-urls","title":"List of URLs","text":"<ul> <li> <p><code>components/cache/&lt;str:comp_cls_id&gt;.&lt;str:input_hash&gt;.&lt;str:script_type&gt;</code></p> </li> <li> <p><code>components/cache/&lt;str:comp_cls_id&gt;.&lt;str:script_type&gt;</code></p> </li> </ul>"},{"location":"releases/","title":"Release Notes","text":"<p>Here you can find the release notes for all versions of Django-Components.</p> <ul> <li>v0.142.0</li> <li>v0.141.6 (2025-09-29)</li> <li>v0.141.5 (2025-09-10)</li> <li>v0.141.4 (2025-08-15)</li> <li>v0.141.3 (2025-08-14)</li> <li>v0.141.2 (2025-07-21)</li> <li>v0.141.1 (2025-07-03)</li> <li>v0.141.0 (2025-06-10)</li> <li>v0.140.1 (2025-06-05)</li> <li>v0.140.0 \ud83d\udea8\ud83d\udce2 (2025-06-05)</li> <li>v0.139.1 (2025-04-20)</li> <li>v0.139.0 (2025-04-12)</li> <li>v0.138 (2025-04-09)</li> <li>v0.137 (2025-04-09)</li> <li>v0.136 \ud83d\udea8\ud83d\udce2 (2025-04-05)</li> <li>v0.135 (2025-03-31)</li> <li>v0.134 (2025-03-23)</li> <li>v0.133 (2025-03-23)</li> <li>v0.132 (2025-03-22)</li> <li>v0.131 (2025-03-20)</li> <li>v0.130 (2025-02-20)</li> <li>v0.129 (2025-02-16)</li> <li>v0.128 (2025-02-04)</li> <li>v0.127 (2025-02-01)</li> <li>v0.126 (2025-01-29)</li> <li>v0.125 (2025-01-22)</li> <li>v0.124 (2025-01-07)</li> <li>v0.123 (2024-12-23)</li> <li>v0.122 (2024-12-19)</li> <li>v0.121 (2024-12-17)</li> <li>v0.120 (2024-12-15)</li> <li>v0.119 (2024-12-13)</li> <li>v0.118 (2024-12-10)</li> <li>v0.117 (2024-12-08)</li> <li>v0.116 (2024-12-06)</li> <li>v0.115 (2024-12-02)</li> <li>v0.114 (2024-11-27)</li> <li>v0.113 (2024-11-26)</li> <li>v0.112 (2024-11-26)</li> <li>v0.111 (2024-11-26)</li> <li>v0.110 \ud83d\udea8\ud83d\udce2 (2024-11-25)</li> <li>v0.100 \ud83d\udea8\ud83d\udce2 (2024-09-11)</li> <li>v0.97 (2024-09-06)</li> <li>v0.96 (2024-09-04)</li> <li>v0.95 (2024-08-29)</li> <li>v0.94 (2024-08-28)</li> <li>v0.93 (2024-08-27)</li> <li>v0.92 \ud83d\udea8\ud83d\udce2 (2024-08-22)</li> <li>v0.90 (2024-08-18)</li> <li>v0.85 \ud83d\udea8\ud83d\udce2 (2024-07-29)</li> <li>v0.81 \ud83d\udea8\ud83d\udce2 (2024-06-12)</li> <li>v0.80 (2024-06-01)</li> <li>v0.79 \ud83d\udea8\ud83d\udce2 (2024-06-01)</li> <li>v0.77 \ud83d\udea8\ud83d\udce2 (2024-05-23)</li> <li>v0.74 (2024-05-12)</li> <li>v0.70 \ud83d\udea8\ud83d\udce2 (2024-05-01)</li> <li>v0.67 (2024-04-17)</li> <li>v0.50 \ud83d\udea8\ud83d\udce2 (2024-02-26)</li> <li>v0.34 (2024-01-27)</li> <li>v0.28 (2023-05-18)</li> <li>v0.27 (2023-04-11)</li> <li>v0.26 \ud83d\udea8\ud83d\udce2 (2023-03-14)</li> <li>v0.22 (2022-07-26)</li> <li>v0.17 (2021-09-10)</li> </ul>"},{"location":"releases/v0.100/","title":"v0.100 \ud83d\udea8\ud83d\udce2 (2024-09-11)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.100/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>django_components.safer_staticfiles</code> app was removed. It is no longer needed.</p> </li> <li> <p>Installation changes:</p> <ul> <li>Instead of defining component directories in <code>STATICFILES_DIRS</code>, set them to <code>COMPONENTS.dirs</code>.</li> <li> <p>You now must define <code>STATICFILES_FINDERS</code></p> </li> <li> <p>See here how to migrate your settings.py</p> </li> </ul> </li> </ul>"},{"location":"releases/v0.100/#feat","title":"Feat","text":"<ul> <li>Beside the top-level <code>/components</code> directory, you can now define also app-level components dirs, e.g. <code>[app]/components</code>   (See <code>COMPONENTS.app_dirs</code>).</li> </ul>"},{"location":"releases/v0.100/#refactor","title":"Refactor","text":"<ul> <li>When you call <code>as_view()</code> on a component instance, that instance will be passed to <code>View.as_view()</code></li> </ul>"},{"location":"releases/v0.110/","title":"v0.110 \ud83d\udea8\ud83d\udce2 (2024-11-25)","text":"<p>__</p> <p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"releases/v0.110/#general","title":"General","text":""},{"location":"releases/v0.110/#breaking-changes","title":"BREAKING CHANGES \ud83d\udea8\ud83d\udce2","text":"<ul> <li> <p>Installation changes:</p> <ul> <li>If your components include JS or CSS, you now must use the middleware and add django-components' URLs to your <code>urlpatterns</code> (See \"Adding support for JS and CSS\")</li> </ul> </li> <li> <p>Component typing signature changed from</p> <pre><code>Component[Args, Kwargs, Data, Slots]\n</code></pre> <p>to</p> <pre><code>Component[Args, Kwargs, Slots, Data, JsData, CssData]\n</code></pre> </li> <li> <p>If you rendered a component A with <code>Component.render()</code> and then inserted that into another component B, now you must pass <code>render_dependencies=False</code> to component A:</p> <pre><code>prerendered_a = CompA.render(\n    args=[...],\n    kwargs={...},\n    render_dependencies=False,\n)\n\nhtml = CompB.render(\n    kwargs={\n        content=prerendered_a,\n    },\n)\n</code></pre> </li> </ul>"},{"location":"releases/v0.110/#feat","title":"Feat","text":"<ul> <li>Intellisense and mypy validation for settings:</li> </ul> <p>Instead of defining the <code>COMPONENTS</code> settings as a plain dict, you can use <code>ComponentsSettings</code>:</p> <pre><code># settings.py\nfrom django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    autodiscover=True,\n    ...\n)\n</code></pre> <ul> <li>Use <code>get_component_dirs()</code> and <code>get_component_files()</code> to get the same list of dirs / files that would be imported by <code>autodiscover()</code>, but without actually importing them.</li> </ul>"},{"location":"releases/v0.110/#refactor","title":"Refactor","text":"<ul> <li> <p>For advanced use cases, use can omit the middleware and instead manage component JS and CSS dependencies yourself with <code>render_dependencies</code></p> </li> <li> <p>The <code>ComponentRegistry</code> settings <code>RegistrySettings</code>   were lowercased to align with the global settings:</p> </li> <li><code>RegistrySettings.CONTEXT_BEHAVIOR</code> -&gt; <code>RegistrySettings.context_behavior</code></li> <li><code>RegistrySettings.TAG_FORMATTER</code> -&gt; <code>RegistrySettings.tag_formatter</code></li> </ul> <p>The old uppercase settings <code>CONTEXT_BEHAVIOR</code> and <code>TAG_FORMATTER</code> are deprecated and will be removed in v1.</p> <ul> <li> <p>The setting <code>reload_on_template_change</code> was renamed to   <code>reload_on_file_change</code>.   And now it properly triggers server reload when any file in the component dirs change. The old name <code>reload_on_template_change</code>   is deprecated and will be removed in v1.</p> </li> <li> <p>The setting <code>forbidden_static_files</code> was renamed to   <code>static_files_forbidden</code>   to align with <code>static_files_allowed</code>   The old name <code>forbidden_static_files</code> is deprecated and will be removed in v1.</p> </li> </ul>"},{"location":"releases/v0.110/#tags","title":"Tags","text":""},{"location":"releases/v0.110/#breaking-changes_1","title":"BREAKING CHANGES \ud83d\udea8\ud83d\udce2","text":"<ul> <li> <p><code>{% component_dependencies %}</code> tag was removed. Instead, use <code>{% component_js_dependencies %}</code> and <code>{% component_css_dependencies %}</code></p> <ul> <li> <p>The combined tag was removed to encourage the best practice of putting JS scripts at the end of <code>&lt;body&gt;</code>, and CSS styles inside <code>&lt;head&gt;</code>.</p> <p>On the other hand, co-locating JS script and CSS styles can lead to a flash of unstyled content, as either JS scripts will block the rendering, or CSS will load too late.</p> </li> </ul> </li> <li> <p>The undocumented keyword arg <code>preload</code> of <code>{% component_js_dependencies %}</code> and <code>{% component_css_dependencies %}</code> tags was removed.   This will be replaced with HTML fragment support.</p> </li> </ul>"},{"location":"releases/v0.110/#fix","title":"Fix","text":"<ul> <li>Allow using forward slash (<code>/</code>) when defining custom TagFormatter,   e.g. <code>{% MyComp %}..{% /MyComp %}</code>.</li> </ul>"},{"location":"releases/v0.110/#refactor_1","title":"Refactor","text":"<ul> <li><code>{% component_dependencies %}</code> tags are now OPTIONAL - If your components use JS and CSS, but you don't use <code>{% component_dependencies %}</code> tags, the JS and CSS will now be, by default, inserted at the end of <code>&lt;body&gt;</code> and at the end of <code>&lt;head&gt;</code> respectively.</li> </ul>"},{"location":"releases/v0.110/#slots","title":"Slots","text":""},{"location":"releases/v0.110/#feat_1","title":"Feat","text":"<ul> <li>Fills can now be defined within loops (<code>{% for %}</code>) or other tags (like <code>{% with %}</code>),   or even other templates using <code>{% include %}</code>.</li> </ul> <p>Following is now possible</p> <pre><code>{% component \"table\" %}\n  {% for slot_name in slots %}\n    {% fill name=slot_name %}\n    {% endfill %}\n  {% endfor %}\n{% endcomponent %}\n</code></pre> <ul> <li>If you need to access the data or the default content of a default fill, you can   set the <code>name</code> kwarg to <code>\"default\"</code>.</li> </ul> <p>Previously, a default fill would be defined simply by omitting the <code>{% fill %}</code> tags:</p> <pre><code>{% component \"child\" %}\n  Hello world\n{% endcomponent %}\n</code></pre> <p>But in that case you could not access the slot data or the default content, like it's possible   for named fills:</p> <pre><code>{% component \"child\" %}\n  {% fill name=\"header\" data=\"data\" %}\n    Hello {{ data.user.name }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Now, you can specify default tag by using <code>name=\"default\"</code>:</p> <pre><code>{% component \"child\" %}\n  {% fill name=\"default\" data=\"data\" %}\n    Hello {{ data.user.name }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <ul> <li>When inside <code>get_context_data()</code> or other component methods, the default fill   can now be accessed as <code>Component.input.slots[\"default\"]</code>, e.g.:</li> </ul> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        default_slot = self.input.slots[\"default\"]\n        ...\n</code></pre> <ul> <li>You can now dynamically pass all slots to a child component. This is similar to   passing all slots in Vue:</li> </ul> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        return {\n            \"slots\": self.input.slots,\n        }\n\n    template: \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% for slot_name in slots %}\n            {% fill name=slot_name data=\"data\" %}\n              {% slot name=slot_name ...data / %}\n            {% endfill %}\n          {% endfor %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"releases/v0.110/#fix_1","title":"Fix","text":"<ul> <li> <p>Slots defined with <code>{% fill %}</code> tags are now properly accessible via <code>self.input.slots</code> in <code>get_context_data()</code></p> </li> <li> <p>Do not raise error if multiple slots with same name are flagged as default</p> </li> <li> <p>Slots can now be defined within loops (<code>{% for %}</code>) or other tags (like <code>{% with %}</code>),   or even other templates using <code>{% include %}</code>.</p> </li> </ul> <p>Previously, following would cause the kwarg <code>name</code> to be an empty string:</p> <pre><code>{% for slot_name in slots %}\n  {% slot name=slot_name %}\n{% endfor %}\n</code></pre>"},{"location":"releases/v0.110/#refactor_2","title":"Refactor","text":"<ul> <li>When you define multiple slots with the same name inside a template,   you now have to set the <code>default</code> and <code>required</code> flags individually.</li> </ul> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>This means you can also have multiple slots with the same name but   different conditions.</p> <p>E.g. in this example, we have a component that renders a user avatar   - a small circular image with a profile picture of name initials.</p> <p>If the component is given <code>image_src</code> or <code>name_initials</code> variables,   the <code>image</code> slot is optional. But if neither of those are provided,   you MUST fill the <code>image</code> slot.</p> <pre><code>&lt;div class=\"avatar\"&gt;\n    {% if image_src %}\n        {% slot \"image\" default %}\n            &lt;img src=\"{{ image_src }}\" /&gt;\n        {% endslot %}\n    {% elif name_initials %}\n        {% slot \"image\" default required %}\n            &lt;div style=\"\n                border-radius: 25px;\n                width: 50px;\n                height: 50px;\n                background: blue;\n            \"&gt;\n                {{ name_initials }}\n            &lt;/div&gt;\n        {% endslot %}\n    {% else %}\n        {% slot \"image\" default required / %}\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <ul> <li>The slot fills that were passed to a component and which can be accessed as <code>Component.input.slots</code>   can now be passed through the Django template, e.g. as inputs to other tags.</li> </ul> <p>Internally, django-components handles slot fills as functions.</p> <p>Previously, if you tried to pass a slot fill within a template, Django would try to call it as a function.</p> <p>Now, something like this is possible:</p> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        return {\n            \"child_slot\": self.input.slots[\"child_slot\"],\n        }\n\n    template: \"\"\"\n      &lt;div&gt;\n        {% component \"child\" content=child_slot / %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <p>NOTE: Using <code>{% slot %}</code> and <code>{% fill %}</code> tags is still the preferred method, but the approach above   may be necessary in some complex or edge cases.</p> <ul> <li>The <code>is_filled</code> variable (and the <code>{{ component_vars.is_filled }}</code> context variable) now returns   <code>False</code> when you try to access a slot name which has not been defined:</li> </ul> <p>Before:</p> <pre><code>{{ component_vars.is_filled.header }} -&gt; True\n{{ component_vars.is_filled.footer }} -&gt; False\n{{ component_vars.is_filled.nonexist }} -&gt; \"\" (empty string)\n</code></pre> <p>After:   <pre><code>{{ component_vars.is_filled.header }} -&gt; True\n{{ component_vars.is_filled.footer }} -&gt; False\n{{ component_vars.is_filled.nonexist }} -&gt; False\n</code></pre></p> <ul> <li> <p>Components no longer raise an error if there are extra slot fills</p> </li> <li> <p>Components will raise error when a slot is doubly-filled. </p> </li> </ul> <p>E.g. if we have a component with a default slot:</p> <pre><code>{% slot name=\"content\" default / %}\n</code></pre> <p>Now there is two ways how we can target this slot: Either using <code>name=\"default\"</code>   or <code>name=\"content\"</code>.</p> <p>In case you specify BOTH, the component will raise an error:</p> <pre><code>{% component \"child\" %}\n  {% fill slot=\"default\" %}\n    Hello from default slot\n  {% endfill %}\n  {% fill slot=\"content\" data=\"data\" %}\n    Hello from content slot\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"releases/v0.111/","title":"v0.111 (2024-11-26)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"releases/v0.111/#fix","title":"Fix","text":"<ul> <li>Prevent rendering Component tags during fill discovery stage to fix a case when a component inside the default slot   tried to access provided data too early.</li> </ul>"},{"location":"releases/v0.112/","title":"v0.112 (2024-11-26)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"releases/v0.112/#fix","title":"Fix","text":"<ul> <li>Allow components to accept default fill even if no default slot was encountered during rendering</li> </ul>"},{"location":"releases/v0.113/","title":"v0.113 (2024-11-26)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"releases/v0.113/#fix","title":"Fix","text":"<ul> <li>Ensure consistent order of scripts in <code>Component.Media.js</code></li> </ul>"},{"location":"releases/v0.114/","title":"v0.114 (2024-11-27)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"releases/v0.114/#fix","title":"Fix","text":"<ul> <li>Prevent rendering Slot tags during fill discovery stage to fix a case when a component inside a slot   fill tried to access provided data too early.</li> </ul>"},{"location":"releases/v0.115/","title":"v0.115 (2024-12-02)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"releases/v0.115/#fix","title":"Fix","text":"<ul> <li>Fix integration with ManifestStaticFilesStorage on Windows by resolving component filepaths   (like <code>Component.template_name</code>) to POSIX paths.</li> </ul>"},{"location":"releases/v0.116/","title":"v0.116 (2024-12-06)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"releases/v0.116/#fix","title":"Fix","text":"<ul> <li>Fix the order of execution of JS scripts:</li> <li>Scripts in <code>Component.Media.js</code> are executed in the order they are defined</li> <li> <p>Scripts in <code>Component.js</code> are executed AFTER <code>Media.js</code> scripts</p> </li> <li> <p>Fix compatibility with AlpineJS</p> </li> <li>Scripts in <code>Component.Media.js</code> are now again inserted as <code>&lt;script&gt;</code> tags</li> <li>By default, <code>Component.Media.js</code> are inserted as synchronous <code>&lt;script&gt;</code> tags,     so the AlpineJS components registered in the <code>Media.js</code> scripts will now again     run BEFORE the core AlpineJS script.</li> </ul> <p>AlpineJS can be configured like so:</p> <p>Option 1 - AlpineJS loaded in <code>&lt;head&gt;</code> with <code>defer</code> attribute:   <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    {% component_css_dependencies %}\n    &lt;script defer src=\"https://unpkg.com/alpinejs\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component 'my_alpine_component' / %}\n    {% component_js_dependencies %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>Option 2 - AlpineJS loaded in <code>&lt;body&gt;</code> AFTER <code>{% component_js_depenencies %}</code>:   <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        {% component_css_dependencies %}\n    &lt;/head&gt;\n    &lt;body&gt;\n        {% component 'my_alpine_component' / %}\n        {% component_js_dependencies %}\n\n        &lt;script src=\"https://unpkg.com/alpinejs\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"releases/v0.117/","title":"v0.117 (2024-12-08)","text":"<p>__</p>"},{"location":"releases/v0.117/#fix","title":"Fix","text":"<ul> <li>The HTML parser no longer erronously inserts <code>&lt;html&gt;&lt;head&gt;&lt;body&gt;</code> on some occasions, and   no longer tries to close unclosed HTML tags.</li> </ul>"},{"location":"releases/v0.117/#refactor","title":"Refactor","text":"<ul> <li>Replaced Selectolax with BeautifulSoup4 as project dependencies.</li> </ul>"},{"location":"releases/v0.118/","title":"v0.118 (2024-12-10)","text":"<p>__</p>"},{"location":"releases/v0.118/#feat","title":"Feat","text":"<ul> <li>Add support for <code>context_processors</code> and <code>RenderContext</code> inside component templates</li> </ul> <p><code>Component.render()</code> and <code>Component.render_to_response()</code> now accept an extra kwarg <code>request</code>.</p> <pre><code>```py\ndef my_view(request)\n    return MyTable.render_to_response(\n        request=request\n    )\n```\n</code></pre> <ul> <li> <p>When you pass in <code>request</code>, the component will use <code>RenderContext</code> instead of <code>Context</code>.     Thus the context processors will be applied to the context.</p> </li> <li> <p>NOTE: When you pass in both <code>request</code> and <code>context</code> to <code>Component.render()</code>, and <code>context</code> is already an instance of <code>Context</code>, the <code>request</code> kwarg will be ignored.</p> </li> </ul>"},{"location":"releases/v0.119/","title":"v0.119 (2024-12-13)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - This release introduced bugs #849, #855. Please update to v0.121.</p>"},{"location":"releases/v0.119/#fix","title":"Fix","text":"<ul> <li>Fix compatibility with custom subclasses of Django's <code>Template</code> that need to access   <code>origin</code> or other initialization arguments. (https://github.com/django-components/django-components/pull/828)</li> </ul>"},{"location":"releases/v0.119/#refactor","title":"Refactor","text":"<ul> <li>Compatibility with <code>django-debug-toolbar-template-profiler</code>:</li> <li> <p>Monkeypatching of Django's <code>Template</code> now happens at <code>AppConfig.ready()</code> (https://github.com/django-components/django-components/pull/825)</p> </li> <li> <p>Internal parsing of template tags tag was updated. No API change. (https://github.com/django-components/django-components/pull/827)</p> </li> </ul>"},{"location":"releases/v0.120/","title":"v0.120 (2024-12-15)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.121 to fix bugs introduced in v0.119.</p>"},{"location":"releases/v0.120/#fix","title":"Fix","text":"<ul> <li>Fix the use of translation strings <code>_(\"bla\")</code> as inputs to components #849.</li> </ul>"},{"location":"releases/v0.121/","title":"v0.121 (2024-12-17)","text":"<p>__</p>"},{"location":"releases/v0.121/#fix","title":"Fix","text":"<ul> <li>Fix the use of Django template filters (<code>|lower:\"etc\"</code>) with component inputs #855.</li> </ul>"},{"location":"releases/v0.122/","title":"v0.122 (2024-12-19)","text":"<p>__</p>"},{"location":"releases/v0.122/#feat","title":"Feat","text":"<ul> <li>Add support for HTML fragments. HTML fragments can be rendered by passing <code>type=\"fragment\"</code> to <code>Component.render()</code> or <code>Component.render_to_response()</code>. Read more on how to use HTML fragments with HTMX, AlpineJS, or vanillaJS.</li> </ul>"},{"location":"releases/v0.123/","title":"v0.123 (2024-12-23)","text":"<p>__</p>"},{"location":"releases/v0.123/#fix","title":"Fix","text":"<ul> <li>Fix edge cases around rendering components whose templates used the <code>{% extends %}</code> template tag (#859)</li> </ul>"},{"location":"releases/v0.124/","title":"v0.124 (2025-01-07)","text":"<p>__</p>"},{"location":"releases/v0.124/#feat","title":"Feat","text":"<ul> <li> <p>Instead of inlining the JS and CSS under <code>Component.js</code> and <code>Component.css</code>, you can move     them to their own files, and link the JS/CSS files with <code>Component.js_file</code>  and <code>Component.css_file</code>.</p> <p>Even when you specify the JS/CSS with <code>Component.js_file</code> or <code>Component.css_file</code>, then you can still access the content under <code>Component.js</code> or <code>Component.css</code> - behind the scenes, the content of the JS/CSS files will be set to <code>Component.js</code> / <code>Component.css</code> upon first access.</p> <p>The same applies to <code>Component.template_file</code>, which will populate <code>Component.template</code> upon first access.</p> <p>With this change, the role of <code>Component.js/css</code> and the JS/CSS in <code>Component.Media</code> has changed:</p> <ul> <li>The JS/CSS defined in <code>Component.js/css</code> or <code>Component.js/css_file</code> is the \"main\" JS/CSS</li> <li>The JS/CSS defined in <code>Component.Media.js/css</code> are secondary or additional</li> </ul> <p>See the updated \"Getting Started\" tutorial</p> </li> </ul>"},{"location":"releases/v0.124/#refactor","title":"Refactor","text":"<ul> <li> <p>The canonical way to define a template file was changed from <code>template_name</code> to <code>template_file</code>, to align with the rest of the API.</p> <p><code>template_name</code> remains for backwards compatibility. When you get / set <code>template_name</code>, internally this is proxied to <code>template_file</code>.</p> </li> <li> <p>The undocumented <code>Component.component_id</code> was removed. Instead, use <code>Component.id</code>. Changes:</p> <ul> <li>While <code>component_id</code> was unique every time you instantiated <code>Component</code>, the new <code>id</code> is unique every time you render the component (e.g. with <code>Component.render()</code>)</li> <li>The new <code>id</code> is available only during render, so e.g. from within <code>get_context_data()</code></li> </ul> </li> <li> <p>Component's HTML / CSS / JS are now resolved and loaded lazily. That is, if you specify <code>template_name</code>/<code>template_file</code>,   <code>js_file</code>, <code>css_file</code>, or <code>Media.js/css</code>, the file paths will be resolved only once you:</p> <ol> <li>Try to access component's HTML / CSS / JS, or</li> <li>Render the component.</li> </ol> <p>Read more on Accessing component's HTML / JS / CSS.</p> </li> <li> <p>Component inheritance:</p> <ul> <li>When you subclass a component, the JS and CSS defined on parent's <code>Media</code> class is now inherited by the child component.</li> <li>You can disable or customize Media inheritance by setting <code>extend</code> attribute on the <code>Component.Media</code> nested class. This work similarly to Django's <code>Media.extend</code>.</li> <li>When child component defines either <code>template</code> or <code>template_file</code>, both of parent's <code>template</code> and <code>template_file</code> are ignored. The same applies to <code>js_file</code> and <code>css_file</code>.</li> </ul> </li> <li> <p>Autodiscovery now ignores files and directories that start with an underscore (<code>_</code>), except <code>__init__.py</code></p> </li> <li> <p>The Signals emitted by or during the use of django-components are now documented, together the <code>template_rendered</code> signal.</p> </li> </ul>"},{"location":"releases/v0.125/","title":"v0.125 (2025-01-22)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - We migrated from <code>EmilStenstrom/django-components</code> to <code>django-components/django-components</code>.</p> <p>Repo name and documentation URL changed. Package name remains the same.</p> <p>If you see any broken links or other issues, please report them in #922.</p>"},{"location":"releases/v0.125/#feat","title":"Feat","text":"<ul> <li><code>@template_tag</code> and <code>BaseNode</code> - A decorator and a class that allow you to define   custom template tags that will behave similarly to django-components' own template tags.</li> </ul> <p>Read more on Template tags.</p> <p>Template tags defined with <code>@template_tag</code> and <code>BaseNode</code> will have the following features:</p> <ul> <li> <p>Accepting args, kwargs, and flags.</p> </li> <li> <p>Allowing literal lists and dicts as inputs as:</p> <p><code>key=[1, 2, 3]</code> or <code>key={\"a\": 1, \"b\": 2}</code>   - Using template tags tag inputs as:</p> <p><code>{% my_tag key=\"{% lorem 3 w %}\" / %}</code>   - Supporting the flat dictionary definition:</p> <p><code>attr:key=value</code>   - Spreading args and kwargs with <code>...</code>:</p> <p><code>{% my_tag ...args ...kwargs / %}</code>   - Being able to call the template tag as:</p> <p><code>{% my_tag %} ... {% endmy_tag %}</code> or <code>{% my_tag / %}</code></p> </li> </ul>"},{"location":"releases/v0.125/#refactor","title":"Refactor","text":"<ul> <li> <p>Refactored template tag input validation. When you now call template tags like   <code>{% slot %}</code>, <code>{% fill %}</code>, <code>{% html_attrs %}</code>, and others, their inputs are now   validated the same way as Python function inputs are.</p> <p>So, for example</p> <pre><code>{% slot \"my_slot\" name=\"content\" / %}\n</code></pre> <p>will raise an error, because the positional argument <code>name</code> is given twice.</p> <p>NOTE: Special kwargs whose keys are not valid Python variable names are not affected by this change. So when you define:</p> <pre><code>{% component data-id=123 / %}\n</code></pre> <p>The <code>data-id</code> will still be accepted as a valid kwarg, assuming that your <code>get_context_data()</code> accepts <code>**kwargs</code>:</p> <pre><code>def get_context_data(self, **kwargs):\n    return {\n        \"data_id\": kwargs[\"data-id\"],\n    }\n</code></pre> </li> </ul>"},{"location":"releases/v0.126/","title":"v0.126 (2025-01-29)","text":"<p>__</p>"},{"location":"releases/v0.126/#refactor","title":"Refactor","text":"<ul> <li>Replaced BeautifulSoup4 with a custom HTML parser.</li> <li>The heuristic for inserting JS and CSS dependenies into the default place has changed.<ul> <li>JS is still inserted at the end of the <code>&lt;body&gt;</code>, and CSS at the end of <code>&lt;head&gt;</code>.</li> <li>However, we find end of <code>&lt;body&gt;</code> by searching for last occurrence of <code>&lt;/body&gt;</code></li> <li>And for the end of <code>&lt;head&gt;</code> we search for the first occurrence of <code>&lt;/head&gt;</code></li> </ul> </li> </ul>"},{"location":"releases/v0.127/","title":"v0.127 (2025-02-01)","text":"<p>__</p>"},{"location":"releases/v0.127/#fix","title":"Fix","text":"<ul> <li>Fix component rendering when using <code>{% cache %}</code> with remote cache and multiple web servers (#930)</li> </ul>"},{"location":"releases/v0.128/","title":"v0.128 (2025-02-04)","text":"<p>__</p>"},{"location":"releases/v0.128/#feat","title":"Feat","text":"<ul> <li> <p>Configurable cache - Set <code>COMPONENTS.cache</code> to change where and how django-components caches JS and CSS files. (#946)</p> <p>Read more on Caching.</p> </li> <li> <p>Highlight coponents and slots in the UI - We've added two boolean settings <code>COMPONENTS.debug_highlight_components</code> and <code>COMPONENTS.debug_highlight_slots</code>, which can be independently set to <code>True</code>. First will wrap components in a blue border, the second will wrap slots in a red border. (#942)</p> <p>Read more on Troubleshooting.</p> </li> </ul>"},{"location":"releases/v0.128/#refactor","title":"Refactor","text":"<ul> <li>Removed use of eval for node validation (#944)</li> </ul>"},{"location":"releases/v0.128/#perf","title":"Perf","text":"<ul> <li> <p>Components can now be infinitely nested. (#936)</p> </li> <li> <p>Component input validation is now 6-7x faster on CPython and PyPy. This previously made up 10-30% of the total render time. (#945)</p> </li> </ul>"},{"location":"releases/v0.129/","title":"v0.129 (2025-02-16)","text":"<p>__</p>"},{"location":"releases/v0.129/#fix","title":"Fix","text":"<ul> <li>Fix thread unsafe media resolve validation by moving it to ComponentMedia <code>__post_init</code> (#977</li> <li>Fix bug: Relative path in extends and include does not work when using template_file (#976</li> <li>Fix error when template cache setting (<code>template_cache_size</code>) is set to 0 (#974</li> </ul>"},{"location":"releases/v0.130/","title":"v0.130 (2025-02-20)","text":"<p>__</p>"},{"location":"releases/v0.130/#feat","title":"Feat","text":"<ul> <li> <p>Access the HttpRequest object under <code>Component.request</code>.</p> <p>To pass the request object to a component, either: - Render a template or component with <code>RequestContext</code>, - Or set the <code>request</code> kwarg to <code>Component.render()</code> or <code>Component.render_to_response()</code>.</p> <p>Read more on HttpRequest.</p> </li> <li> <p>Access the context processors data under <code>Component.context_processors_data</code>.</p> <p>Context processors data is available only when the component has access to the <code>request</code> object, either by: - Passing the request to <code>Component.render()</code> or <code>Component.render_to_response()</code>, - Or by rendering a template or component with <code>RequestContext</code>, - Or being nested in another component that has access to the request object.</p> <p>The data from context processors is automatically available within the component's template.</p> <p>Read more on HttpRequest.</p> </li> </ul>"},{"location":"releases/v0.131/","title":"v0.131 (2025-03-20)","text":"<p>__</p>"},{"location":"releases/v0.131/#feat","title":"Feat","text":"<ul> <li> <p>Support for extensions (plugins) for django-components!</p> <ul> <li>Hook into lifecycle events of django-components</li> <li>Pre-/post-process component inputs, outputs, and templates</li> <li>Add extra methods or attributes to Components</li> <li>Add custom extension-specific CLI commands</li> <li>Add custom extension-specific URL routes</li> </ul> <p>Read more on Extensions.</p> </li> <li> <p>New CLI commands:</p> <ul> <li><code>components list</code> - List all components</li> <li><code>components create &lt;name&gt;</code> - Create a new component (supersedes <code>startcomponent</code>)</li> <li><code>components upgrade</code> - Upgrade a component (supersedes <code>upgradecomponent</code>)</li> <li><code>components ext list</code> - List all extensions</li> <li><code>components ext run &lt;extension&gt; &lt;command&gt;</code> - Run a command added by an extension</li> </ul> </li> <li> <p><code>@djc_test</code> decorator for writing tests that involve Components.</p> <ul> <li>The decorator manages global state, ensuring that tests don't leak.</li> <li>If using <code>pytest</code>, the decorator allows you to parametrize Django or Components settings.</li> <li>The decorator also serves as a stand-in for Django's <code>@override_settings</code>.</li> </ul> <p>See the API reference for <code>@djc_test</code> for more details.</p> </li> <li> <p><code>ComponentRegistry</code> now has a <code>has()</code> method to check if a component is registered    without raising an error.</p> </li> <li> <p>Get all created <code>Component</code> classes with <code>all_components()</code>.</p> </li> <li> <p>Get all created <code>ComponentRegistry</code> instances with <code>all_registries()</code>.</p> </li> </ul>"},{"location":"releases/v0.131/#refactor","title":"Refactor","text":"<ul> <li> <p>The <code>startcomponent</code> and <code>upgradecomponent</code> commands are deprecated, and will be removed in v1.</p> <p>Instead, use <code>components create &lt;name&gt;</code> and <code>components upgrade</code>.</p> </li> </ul>"},{"location":"releases/v0.131/#internal","title":"Internal","text":"<ul> <li>Settings are now loaded only once, and thus are considered immutable once loaded. Previously,   django-components would load settings from <code>settings.COMPONENTS</code> on each access. The new behavior   aligns with Django's settings.</li> </ul>"},{"location":"releases/v0.132/","title":"v0.132 (2025-03-22)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.134 to fix bugs introduced in v0.132.</p>"},{"location":"releases/v0.132/#feat","title":"Feat","text":"<ul> <li> <p>Allow to use glob patterns as paths for additional JS / CSS in   <code>Component.Media.js</code> and <code>Component.Media.css</code></p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = [\"*.js\"]\n        css = [\"*.css\"]\n</code></pre> </li> </ul>"},{"location":"releases/v0.132/#fix","title":"Fix","text":"<ul> <li>Fix installation for Python 3.13 on Windows.</li> </ul>"},{"location":"releases/v0.133/","title":"v0.133 (2025-03-23)","text":"<p>__</p> <p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.134 to fix bugs introduced in v0.132.</p>"},{"location":"releases/v0.133/#fix","title":"Fix","text":"<ul> <li>HOTFIX: Fix the use of URLs in <code>Component.Media.js</code> and <code>Component.Media.css</code></li> </ul>"},{"location":"releases/v0.134/","title":"v0.134 (2025-03-23)","text":"<p>__</p>"},{"location":"releases/v0.134/#fix","title":"Fix","text":"<ul> <li>HOTFIX: Fix the use of URLs in <code>Component.Media.js</code> and <code>Component.Media.css</code></li> </ul>"},{"location":"releases/v0.135/","title":"v0.135 (2025-03-31)","text":"<p>__</p>"},{"location":"releases/v0.135/#feat","title":"Feat","text":"<ul> <li>Add defaults for the component inputs with the <code>Component.Defaults</code> nested class. Defaults   are applied if the argument is not given, or if it set to <code>None</code>.</li> </ul> <p>For lists, dictionaries, or other objects, wrap the value in <code>Default()</code> class to mark it as a factory   function:</p> <pre><code>```python\nfrom django_components import Default\n\nclass Table(Component):\n    class Defaults:\n        position = \"left\"\n        width = \"200px\"\n        options = Default(lambda: [\"left\", \"right\", \"center\"])\n\n    def get_context_data(self, position, width, options):\n        return {\n            \"position\": position,\n            \"width\": width,\n            \"options\": options,\n        }\n\n# `position` is used as given, `\"right\"`\n# `width` uses default because it's `None`\n# `options` uses default because it's missing\nTable.render(\n    kwargs={\n        \"position\": \"right\",\n        \"width\": None,\n    }\n)\n```\n</code></pre> <ul> <li> <p><code>{% html_attrs %}</code> now offers a Vue-like granular control over <code>class</code> and <code>style</code> HTML attributes, where each class name or style property can be managed separately.</p> <pre><code>{% html_attrs\n    class=\"foo bar\"\n    class={\"baz\": True, \"foo\": False}\n    class=\"extra\"\n%}\n</code></pre> <pre><code>{% html_attrs\n    style=\"text-align: center; background-color: blue;\"\n    style={\"background-color\": \"green\", \"color\": None, \"width\": False}\n    style=\"position: absolute; height: 12px;\"\n%}\n</code></pre> <p>Read more on HTML attributes.</p> </li> </ul>"},{"location":"releases/v0.135/#fix","title":"Fix","text":"<ul> <li>Fix compat with Windows when reading component files (#1074)</li> <li>Fix resolution of component media files edge case (#1073)</li> </ul>"},{"location":"releases/v0.136/","title":"v0.136 \ud83d\udea8\ud83d\udce2 (2025-04-05)","text":"<p>__</p>"},{"location":"releases/v0.136/#breaking-changes","title":"BREAKING CHANGES \ud83d\udea8\ud83d\udce2","text":"<ul> <li> <p>Component input validation was moved to a separate extension <code>djc-ext-pydantic</code>.</p> <p>If you relied on components raising errors when inputs were invalid, you need to install <code>djc-ext-pydantic</code> and add it to extensions:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"extensions\": [\n        \"djc_pydantic.PydanticExtension\",\n    ],\n}\n</code></pre> </li> </ul>"},{"location":"releases/v0.136/#fix","title":"Fix","text":"<ul> <li>Make it possible to resolve URLs added by extensions by their names</li> </ul>"},{"location":"releases/v0.137/","title":"v0.137 (2025-04-09)","text":"<p>__</p>"},{"location":"releases/v0.137/#feat","title":"Feat","text":"<ul> <li> <p>Each Component class now has a <code>class_id</code> attribute, which is unique to the component subclass.</p> <p>NOTE: This is different from <code>Component.id</code>, which is unique to each rendered instance.</p> <p>To look up a component class by its <code>class_id</code>, use <code>get_component_by_class_id()</code>.</p> </li> <li> <p>It's now easier to create URLs for component views.</p> <p>Before, you had to call <code>Component.as_view()</code> and pass that to <code>urlpatterns</code>.</p> <p>Now this can be done for you if you set <code>Component.Url.public</code> to <code>True</code>:</p> <pre><code>class MyComponent(Component):\n    class Url:\n        public = True\n    ...\n</code></pre> <p>Then, to get the URL for the component, use <code>get_component_url()</code>:</p> <pre><code>from django_components import get_component_url\n\nurl = get_component_url(MyComponent)\n</code></pre> <p>This way you don't have to mix your app URLs with component URLs.</p> <p>Read more on Component views and URLs.</p> </li> <li> <p>Per-component caching - Set <code>Component.Cache.enabled</code> to <code>True</code> to enable caching for a component.</p> <p>Component caching allows you to store the rendered output of a component. Next time the component is rendered with the same input, the cached output is returned instead of re-rendering the component.</p> <pre><code>class TestComponent(Component):\n    template = \"Hello\"\n\n    class Cache:\n        enabled = True\n        ttl = 0.1  # .1 seconds TTL\n        cache_name = \"custom_cache\"\n\n        # Custom hash method for args and kwargs\n        # NOTE: The default implementation simply serializes the input into a string.\n        #       As such, it might not be suitable for complex objects like Models.\n        def hash(self, *args, **kwargs):\n            return f\"{json.dumps(args)}:{json.dumps(kwargs)}\"\n</code></pre> <p>Read more on Component caching.</p> </li> <li> <p><code>@djc_test</code> can now be called without first calling <code>django.setup()</code>, in which case it does it for you.</p> </li> <li> <p>Expose <code>ComponentInput</code> class, which is a typing for <code>Component.input</code>.</p> </li> </ul>"},{"location":"releases/v0.137/#deprecation","title":"Deprecation","text":"<ul> <li> <p>Currently, view request handlers such as <code>get()</code> and <code>post()</code> methods can be defined   directly on the <code>Component</code> class:</p> <pre><code>class MyComponent(Component):\n    def get(self, request):\n        return self.render_to_response()\n</code></pre> <p>Or, nested within the <code>Component.View</code> class:</p> <pre><code>class MyComponent(Component):\n    class View:\n        def get(self, request):\n            return self.render_to_response()\n</code></pre> <p>In v1, these methods should be defined only on the <code>Component.View</code> class instead.</p> </li> </ul>"},{"location":"releases/v0.137/#refactor","title":"Refactor","text":"<ul> <li><code>Component.get_context_data()</code> can now omit a return statement or return <code>None</code>.</li> </ul>"},{"location":"releases/v0.138/","title":"v0.138 (2025-04-09)","text":"<p>__</p>"},{"location":"releases/v0.138/#fix","title":"Fix","text":"<ul> <li>Fix bug: Allow components with <code>Url.public = True</code> to be defined before <code>django.setup()</code></li> </ul>"},{"location":"releases/v0.139.0/","title":"v0.139.0 (2025-04-12)","text":"<p>__</p>"},{"location":"releases/v0.139.0/#fix","title":"Fix","text":"<ul> <li>Fix bug: Fix compatibility with <code>Finder.find()</code> in Django 5.2 (#1119)</li> </ul>"},{"location":"releases/v0.139.1/","title":"v0.139.1 (2025-04-20)","text":"<p>__</p>"},{"location":"releases/v0.139.1/#fix","title":"Fix","text":"<ul> <li>Fix compatibility of component caching with <code>{% extend %}</code> block (#1135)</li> </ul>"},{"location":"releases/v0.139.1/#refactor","title":"Refactor","text":"<ul> <li> <p>Component ID is now prefixed with <code>c</code>, e.g. <code>c123456</code>.</p> </li> <li> <p>When typing a Component, you can now specify as few or as many parameters as you want.</p> <pre><code>Component[Args]\nComponent[Args, Kwargs]\nComponent[Args, Kwargs, Slots]\nComponent[Args, Kwargs, Slots, Data]\nComponent[Args, Kwargs, Slots, Data, JsData]\nComponent[Args, Kwargs, Slots, Data, JsData, CssData]\n</code></pre> <p>All omitted parameters will default to <code>Any</code>.</p> </li> <li> <p>Added <code>typing_extensions</code> to the project as a dependency</p> </li> <li> <p>Multiple extensions with the same name (case-insensitive) now raise an error</p> </li> <li> <p>Extension names (case-insensitive) also MUST NOT conflict with existing Component class API.</p> <p>So if you name an extension <code>render</code>, it will conflict with the <code>render()</code> method of the <code>Component</code> class, and thus raise an error.</p> </li> </ul>"},{"location":"releases/v0.140.0/","title":"v0.140.0 \ud83d\udea8\ud83d\udce2 (2025-06-05)","text":"<p>__</p> <p>\u26a0\ufe0f Major release \u26a0\ufe0f - Please test thoroughly before / after upgrading.</p> <p>This is the biggest step towards v1. While this version introduces many small API changes, we don't expect to make further changes to the affected parts before v1.</p> <p>For more details see #433.</p> <p>Summary:</p> <ul> <li>Overhauled typing system</li> <li>Middleware removed, no longer needed</li> <li><code>get_template_data()</code> is the new canonical way to define template data.   <code>get_context_data()</code> is now deprecated but will remain until v2.</li> <li>Slots API polished and prepared for v1.</li> <li>Merged <code>Component.Url</code> with <code>Component.View</code></li> <li>Added <code>Component.args</code>, <code>Component.kwargs</code>, <code>Component.slots</code>, <code>Component.context</code></li> <li>Added <code>{{ component_vars.args }}</code>, <code>{{ component_vars.kwargs }}</code>, <code>{{ component_vars.slots }}</code></li> <li>You should no longer instantiate <code>Component</code> instances. Instead, call <code>Component.render()</code> or <code>Component.render_to_response()</code> directly.</li> <li>Component caching can now consider slots (opt-in)</li> <li>And lot more...</li> </ul>"},{"location":"releases/v0.140.0/#breaking-changes","title":"BREAKING CHANGES \ud83d\udea8\ud83d\udce2","text":"<p>Middleware</p> <ul> <li> <p>The middleware <code>ComponentDependencyMiddleware</code> was removed as it is no longer needed.</p> <p>The middleware served one purpose - to render the JS and CSS dependencies of components when you rendered templates with <code>Template.render()</code> or <code>django.shortcuts.render()</code> and those templates contained <code>{% component %}</code> tags.</p> <ul> <li>NOTE: If you rendered HTML with <code>Component.render()</code> or <code>Component.render_to_response()</code>, the JS and CSS were already rendered.</li> </ul> <p>Now, the JS and CSS dependencies of components are automatically rendered, even when you render Templates with <code>Template.render()</code> or <code>django.shortcuts.render()</code>.</p> <p>To disable this behavior, set the <code>DJC_DEPS_STRATEGY</code> context key to <code>\"ignore\"</code> when rendering the template:</p> <pre><code># With `Template.render()`:\ntemplate = Template(template_str)\nrendered = template.render(Context({\"DJC_DEPS_STRATEGY\": \"ignore\"}))\n\n# Or with django.shortcuts.render():\nfrom django.shortcuts import render\nrendered = render(\n    request,\n    \"my_template.html\",\n    context={\"DJC_DEPS_STRATEGY\": \"ignore\"},\n)\n</code></pre> <p>In fact, you can set the <code>DJC_DEPS_STRATEGY</code> context key to any of the strategies:</p> <ul> <li><code>\"document\"</code></li> <li><code>\"fragment\"</code></li> <li><code>\"simple\"</code></li> <li><code>\"prepend\"</code></li> <li><code>\"append\"</code></li> <li><code>\"ignore\"</code></li> </ul> <p>See Dependencies rendering for more info.</p> </li> </ul> <p>Typing</p> <ul> <li> <p>Component typing no longer uses generics. Instead, the types are now defined as class attributes of the component class.</p> <p>Before:</p> <pre><code>Args = Tuple[float, str]\n\nclass Button(Component[Args]):\n    pass\n</code></pre> <p>After:</p> <pre><code>class Button(Component):\n    class Args(NamedTuple):\n        size: float\n        text: str\n</code></pre> <p>See Migrating from generics to class attributes for more info. - Removed <code>EmptyTuple</code> and <code>EmptyDict</code> types. Instead, there is now a single <code>Empty</code> type.</p> <pre><code>from django_components import Component, Empty\n\nclass Button(Component):\n    template = \"Hello\"\n\n    Args = Empty\n    Kwargs = Empty\n</code></pre> </li> </ul> <p>Component API</p> <ul> <li> <p>The interface of the not-yet-released <code>get_js_data()</code> and <code>get_css_data()</code> methods has changed to   match <code>get_template_data()</code>.</p> <p>Before:</p> <pre><code>def get_js_data(self, *args, **kwargs):\ndef get_css_data(self, *args, **kwargs):\n</code></pre> <p>After:</p> <pre><code>def get_js_data(self, args, kwargs, slots, context):\ndef get_css_data(self, args, kwargs, slots, context):\n</code></pre> </li> <li> <p>Arguments in <code>Component.render_to_response()</code> have changed   to match that of <code>Component.render()</code>.</p> <p>Please ensure that you pass the parameters as kwargs, not as positional arguments, to avoid breaking changes.</p> <p>The signature changed, moving the <code>args</code> and <code>kwargs</code> parameters to 2nd and 3rd position.</p> <p>Next, the <code>render_dependencies</code> parameter was added to match <code>Component.render()</code>.</p> <p>Lastly:</p> <ul> <li>Previously, any extra ARGS and KWARGS were passed to the <code>response_class</code>.</li> <li>Now, only extra KWARGS will be passed to the <code>response_class</code>.</li> </ul> <p>Before:</p> <pre><code>  def render_to_response(\n      cls,\n      context: Optional[Union[Dict[str, Any], Context]] = None,\n      slots: Optional[SlotsType] = None,\n      escape_slots_content: bool = True,\n      args: Optional[ArgsType] = None,\n      kwargs: Optional[KwargsType] = None,\n      deps_strategy: DependenciesStrategy = \"document\",\n      request: Optional[HttpRequest] = None,\n      *response_args: Any,\n      **response_kwargs: Any,\n  ) -&gt; HttpResponse:\n</code></pre> <p>After:</p> <pre><code>def render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[Any] = None,\n    kwargs: Optional[Any] = None,\n    slots: Optional[Any] = None,\n    deps_strategy: DependenciesStrategy = \"document\",\n    type: Optional[DependenciesStrategy] = None,  # Deprecated, use `deps_strategy`\n    render_dependencies: bool = True,  # Deprecated, use `deps_strategy=\"ignore\"`\n    outer_context: Optional[Context] = None,\n    request: Optional[HttpRequest] = None,\n    registry: Optional[ComponentRegistry] = None,\n    registered_name: Optional[str] = None,\n    node: Optional[ComponentNode] = None,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n</code></pre> </li> <li> <p><code>Component.render()</code> and <code>Component.render_to_response()</code> NO LONGER accept <code>escape_slots_content</code> kwarg.</p> <p>Instead, slots are now always escaped.</p> <p>To disable escaping, wrap the result of <code>slots</code> in <code>mark_safe()</code>.</p> <p>Before:</p> <pre><code>html = component.render(\n    slots={\"my_slot\": \"CONTENT\"},\n    escape_slots_content=False,\n)\n</code></pre> <p>After:</p> <pre><code>html = component.render(\n    slots={\"my_slot\": mark_safe(\"CONTENT\")}\n)\n</code></pre> </li> <li> <p><code>Component.template</code> no longer accepts a Template instance, only plain string.</p> <p>Before:</p> <pre><code>class MyComponent(Component):\n    template = Template(\"{{ my_var }}\")\n</code></pre> <p>Instead, either:</p> <ol> <li> <p>Set <code>Component.template</code> to a plain string.</p> <pre><code>class MyComponent(Component):\n    template = \"{{ my_var }}\"\n</code></pre> </li> <li> <p>Move the template to it's own HTML file and set <code>Component.template_file</code>.</p> <pre><code>class MyComponent(Component):\n    template_file = \"my_template.html\"\n</code></pre> </li> <li> <p>Or, if you dynamically created the template, render the template inside <code>Component.on_render()</code>.</p> <pre><code>class MyComponent(Component):\n    def on_render(self, context, template):\n        dynamic_template = do_something_dynamic()\n        return dynamic_template.render(context)\n</code></pre> </li> </ol> </li> <li> <p>Subclassing of components with <code>None</code> values has changed:</p> <p>Previously, when a child component's template / JS / CSS attributes were set to <code>None</code>, the child component still inherited the parent's template / JS / CSS.</p> <p>Now, the child component will not inherit the parent's template / JS / CSS if it sets the attribute to <code>None</code>.</p> <p>Before:</p> <pre><code>class Parent(Component):\n    template = \"parent.html\"\n\nclass Child(Parent):\n    template = None\n\n# Child still inherited parent's template\nassert Child.template == Parent.template\n</code></pre> <p>After:</p> <pre><code>class Parent(Component):\n    template = \"parent.html\"\n\nclass Child(Parent):\n    template = None\n\n# Child does not inherit parent's template\nassert Child.template is None\n</code></pre> </li> <li> <p>The <code>Component.Url</code> class was merged with <code>Component.View</code>.</p> <p>Instead of <code>Component.Url.public</code>, use <code>Component.View.public</code>.</p> <p>If you imported <code>ComponentUrl</code> from <code>django_components</code>, you need to update your import to <code>ComponentView</code>.</p> <p>Before:</p> <pre><code>class MyComponent(Component):\n    class Url:\n        public = True\n\n    class View:\n        def get(self, request):\n            return self.render_to_response()\n</code></pre> <p>After:</p> <pre><code>class MyComponent(Component):\n    class View:\n        public = True\n\n        def get(self, request):\n            return self.render_to_response()\n</code></pre> </li> <li> <p>Caching - The function signatures of <code>Component.Cache.get_cache_key()</code> and <code>Component.Cache.hash()</code> have changed to enable passing slots.</p> <p>Args and kwargs are no longer spread, but passed as a list and a dict, respectively.</p> <p>Before:</p> <pre><code>def get_cache_key(self, *args: Any, **kwargs: Any) -&gt; str:\n\ndef hash(self, *args: Any, **kwargs: Any) -&gt; str:\n</code></pre> <p>After:</p> <pre><code>def get_cache_key(self, args: Any, kwargs: Any, slots: Any) -&gt; str:\n\ndef hash(self, args: Any, kwargs: Any) -&gt; str:\n</code></pre> </li> </ul> <p>Template tags</p> <ul> <li> <p>Component name in the <code>{% component %}</code> tag can no longer be set as a kwarg.</p> <p>Instead, the component name MUST be the first POSITIONAL argument only.</p> <p>Before, it was possible to set the component name as a kwarg and put it anywhere in the <code>{% component %}</code> tag:</p> <pre><code>{% component rows=rows headers=headers name=\"my_table\" ... / %}\n</code></pre> <p>Now, the component name MUST be the first POSITIONAL argument:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n</code></pre> <p>Thus, the <code>name</code> kwarg can now be used as a regular input.</p> <pre><code>{% component \"profile\" name=\"John\" job=\"Developer\" / %}\n</code></pre> </li> </ul> <p>Slots</p> <ul> <li> <p>If you instantiated <code>Slot</code> class with kwargs, you should now use <code>contents</code> instead of <code>content_func</code>.</p> <p>Before:</p> <pre><code>slot = Slot(content_func=lambda *a, **kw: \"CONTENT\")\n</code></pre> <p>After:</p> <pre><code>slot = Slot(contents=lambda ctx: \"CONTENT\")\n</code></pre> <p>Alternatively, pass the function / content as first positional argument:</p> <pre><code>slot = Slot(lambda ctx: \"CONTENT\")\n</code></pre> </li> <li> <p>The undocumented <code>Slot.escaped</code> attribute was removed.</p> <p>Instead, slots are now always escaped.</p> <p>To disable escaping, wrap the result of <code>slots</code> in <code>mark_safe()</code>.</p> </li> <li> <p>Slot functions behavior has changed. See the new Slots docs for more info.</p> <ul> <li> <p>Function signature:</p> <ol> <li> <p>All parameters are now passed under a single <code>ctx</code> argument.</p> <p>You can still access all the same parameters via <code>ctx.context</code>, <code>ctx.data</code>, and <code>ctx.fallback</code>.</p> </li> <li> <p><code>context</code> and <code>fallback</code> now may be <code>None</code> if the slot function was called outside of <code>{% slot %}</code> tag.</p> </li> </ol> <p>Before:</p> <pre><code>def slot_fn(context: Context, data: Dict, slot_ref: SlotRef):\n    isinstance(context, Context)\n    isinstance(data, Dict)\n    isinstance(slot_ref, SlotRef)\n\n    return \"CONTENT\"\n</code></pre> <p>After:</p> <pre><code>def slot_fn(ctx: SlotContext):\n    assert isinstance(ctx.context, Context) # May be None\n    assert isinstance(ctx.data, Dict)\n    assert isinstance(ctx.fallback, SlotFallback) # May be None\n\n    return \"CONTENT\"\n</code></pre> </li> <li> <p>Calling slot functions:</p> <ol> <li> <p>Rather than calling the slot functions directly, you should now call the <code>Slot</code> instances.</p> </li> <li> <p>All parameters are now optional.</p> </li> <li> <p>The order of parameters has changed.</p> </li> </ol> <p>Before:</p> <pre><code>def slot_fn(context: Context, data: Dict, slot_ref: SlotRef):\n    return \"CONTENT\"\n\nhtml = slot_fn(context, data, slot_ref)\n</code></pre> <p>After:</p> <pre><code>def slot_fn(ctx: SlotContext):\n    return \"CONTENT\"\n\nslot = Slot(slot_fn)\nhtml = slot()\nhtml = slot({\"data1\": \"abc\", \"data2\": \"hello\"})\nhtml = slot({\"data1\": \"abc\", \"data2\": \"hello\"}, fallback=\"FALLBACK\")\n</code></pre> </li> <li> <p>Usage in components:</p> <p>Before:</p> <pre><code>class MyComponent(Component):\n    def get_context_data(self, *args, **kwargs):\n        slots = self.input.slots\n        slot_fn = slots[\"my_slot\"]\n        html = slot_fn(context, data, slot_ref)\n        return {\n            \"html\": html,\n        }\n</code></pre> <p>After:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        slot_fn = slots[\"my_slot\"]\n        html = slot_fn(data)\n        return {\n            \"html\": html,\n        }\n</code></pre> </li> </ul> </li> </ul> <p>Miscellaneous</p> <ul> <li> <p>The second argument to <code>render_dependencies()</code> is now <code>strategy</code> instead of <code>type</code>.</p> <p>Before:</p> <pre><code>render_dependencies(content, type=\"document\")\n</code></pre> <p>After:</p> <pre><code>render_dependencies(content, strategy=\"document\")\n</code></pre> </li> </ul>"},{"location":"releases/v0.140.0/#deprecation","title":"Deprecation \ud83d\udea8\ud83d\udce2","text":"<p>Component API</p> <ul> <li> <p><code>Component.get_context_data()</code> is now deprecated. Use <code>Component.get_template_data()</code> instead.</p> <p><code>get_template_data()</code> behaves the same way, but has a different function signature to accept also slots and context.</p> <p>Since <code>get_context_data()</code> is widely used, it will remain available until v2.</p> </li> <li> <p><code>Component.get_template_name()</code> and <code>Component.get_template()</code> are now deprecated. Use <code>Component.template</code>, <code>Component.template_file</code> or <code>Component.on_render()</code> instead.</p> <p><code>Component.get_template_name()</code> and <code>Component.get_template()</code> will be removed in v1.</p> <p>In v1, each Component will have at most one static template. This is needed to enable support for Markdown, Pug, or other pre-processing of templates by extensions.</p> <p>If you are using the deprecated methods to point to different templates, there's 2 ways to migrate:</p> <ol> <li> <p>Split the single Component into multiple Components, each with its own template. Then switch between them in <code>Component.on_render()</code>:</p> <pre><code>class MyComponentA(Component):\n    template_file = \"a.html\"\n\nclass MyComponentB(Component):\n    template_file = \"b.html\"\n\nclass MyComponent(Component):\n    def on_render(self, context, template):\n        if context[\"a\"]:\n            return MyComponentA.render(context)\n        else:\n            return MyComponentB.render(context)\n</code></pre> </li> <li> <p>Alternatively, use <code>Component.on_render()</code> with Django's <code>get_template()</code> to dynamically render different templates:</p> <pre><code>from django.template.loader import get_template\n\nclass MyComponent(Component):\n    def on_render(self, context, template):\n        if context[\"a\"]:\n            template_name = \"a.html\"\n        else:\n            template_name = \"b.html\"\n\n        actual_template = get_template(template_name)\n        return actual_template.render(context)\n</code></pre> </li> </ol> <p>Read more in django-components#1204.</p> </li> <li> <p>The <code>type</code> kwarg in <code>Component.render()</code> and <code>Component.render_to_response()</code> is now deprecated. Use <code>deps_strategy</code> instead. The <code>type</code> kwarg will be removed in v1.</p> <p>Before:</p> <pre><code>Calendar.render_to_response(type=\"fragment\")\n</code></pre> <p>After:</p> <pre><code>Calendar.render_to_response(deps_strategy=\"fragment\")\n</code></pre> </li> <li> <p>The <code>render_dependencies</code> kwarg in <code>Component.render()</code> and <code>Component.render_to_response()</code> is now deprecated. Use <code>deps_strategy=\"ignore\"</code> instead. The <code>render_dependencies</code> kwarg will be removed in v1.</p> <p>Before:</p> <pre><code>Calendar.render_to_response(render_dependencies=False)\n</code></pre> <p>After:</p> <pre><code>Calendar.render_to_response(deps_strategy=\"ignore\")\n</code></pre> </li> <li> <p>Support for <code>Component</code> constructor kwargs <code>registered_name</code>, <code>outer_context</code>, and <code>registry</code> is deprecated, and will be removed in v1.</p> <p>Before, you could instantiate a standalone component, and then call <code>render()</code> on the instance:</p> <pre><code>comp = MyComponent(\n    registered_name=\"my_component\",\n    outer_context=my_context,\n    registry=my_registry,\n)\ncomp.render(\n    args=[1, 2, 3],\n    kwargs={\"a\": 1, \"b\": 2},\n    slots={\"my_slot\": \"CONTENT\"},\n)\n</code></pre> <p>Now you should instead pass all that data to <code>Component.render()</code> / <code>Component.render_to_response()</code>:</p> <pre><code>MyComponent.render(\n    args=[1, 2, 3],\n    kwargs={\"a\": 1, \"b\": 2},\n    slots={\"my_slot\": \"CONTENT\"},\n    # NEW\n    registered_name=\"my_component\",\n    outer_context=my_context,\n    registry=my_registry,\n)\n</code></pre> </li> <li> <p><code>Component.input</code> (and its type <code>ComponentInput</code>) is now deprecated. The <code>input</code> property will be removed in v1.</p> <p>Instead, use attributes directly on the Component instance.</p> <p>Before:</p> <pre><code>class MyComponent(Component):\n    def on_render(self, context, template):\n        assert self.input.args == [1, 2, 3]\n        assert self.input.kwargs == {\"a\": 1, \"b\": 2}\n        assert self.input.slots == {\"my_slot\": \"CONTENT\"}\n        assert self.input.context == {\"my_slot\": \"CONTENT\"}\n        assert self.input.deps_strategy == \"document\"\n        assert self.input.type == \"document\"\n        assert self.input.render_dependencies == True\n</code></pre> <p>After:</p> <pre><code>class MyComponent(Component):\n    def on_render(self, context, template):\n        assert self.args == [1, 2, 3]\n        assert self.kwargs == {\"a\": 1, \"b\": 2}\n        assert self.slots == {\"my_slot\": \"CONTENT\"}\n        assert self.context == {\"my_slot\": \"CONTENT\"}\n        assert self.deps_strategy == \"document\"\n        assert (self.deps_strategy != \"ignore\") is True\n</code></pre> </li> <li> <p>Component method <code>on_render_after</code> was updated to receive also <code>error</code> field.</p> <p>For backwards compatibility, the <code>error</code> field can be omitted until v1.</p> <p>Before:</p> <pre><code>def on_render_after(\n    self,\n    context: Context,\n    template: Template,\n    html: str,\n) -&gt; None:\n    pass\n</code></pre> <p>After:</p> <pre><code>def on_render_after(\n    self,\n    context: Context,\n    template: Template,\n    html: Optional[str],\n    error: Optional[Exception],\n) -&gt; None:\n    pass\n</code></pre> </li> <li> <p>If you are using the Components as views, the way to access the component class is now different.</p> <p>Instead of <code>self.component</code>, use <code>self.component_cls</code>. <code>self.component</code> will be removed in v1.</p> <p>Before:</p> <pre><code>class MyView(View):\n    def get(self, request):\n        return self.component.render_to_response(request=request)\n</code></pre> <p>After:</p> <pre><code>class MyView(View):\n    def get(self, request):\n        return self.component_cls.render_to_response(request=request)\n</code></pre> </li> </ul> <p>Extensions</p> <ul> <li> <p>In the <code>on_component_data()</code> extension hook, the <code>context_data</code> field of the context object was superseded by <code>template_data</code>.</p> <p>The <code>context_data</code> field will be removed in v1.0.</p> <p>Before:</p> <pre><code>class MyExtension(ComponentExtension):\n    def on_component_data(self, ctx: OnComponentDataContext) -&gt; None:\n        ctx.context_data[\"my_template_var\"] = \"my_value\"\n</code></pre> <p>After:</p> <pre><code>class MyExtension(ComponentExtension):\n    def on_component_data(self, ctx: OnComponentDataContext) -&gt; None:\n        ctx.template_data[\"my_template_var\"] = \"my_value\"\n</code></pre> </li> <li> <p>When creating extensions, the <code>ComponentExtension.ExtensionClass</code> attribute was renamed to <code>ComponentConfig</code>.</p> <p>The old name is deprecated and will be removed in v1.</p> <p>Before:</p> <pre><code>from django_components import ComponentExtension\n\nclass MyExtension(ComponentExtension):\n    class ExtensionClass(ComponentExtension.ExtensionClass):\n        pass\n</code></pre> <p>After:</p> <pre><code>from django_components import ComponentExtension, ExtensionComponentConfig\n\nclass MyExtension(ComponentExtension):\n    class ComponentConfig(ExtensionComponentConfig):\n        pass\n</code></pre> </li> <li> <p>When creating extensions, to access the Component class from within the methods of the extension nested classes,   use <code>component_cls</code>.</p> <p>Previously this field was named <code>component_class</code>. The old name is deprecated and will be removed in v1.</p> </li> </ul> <p><code>ComponentExtension.ExtensionClass</code> attribute was renamed to <code>ComponentConfig</code>.</p> <pre><code>The old name is deprecated and will be removed in v1.\n\nBefore:\n\n```py\nfrom django_components import ComponentExtension, ExtensionComponentConfig\n\nclass LoggerExtension(ComponentExtension):\n    name = \"logger\"\n\n    class ComponentConfig(ExtensionComponentConfig):\n        def log(self, msg: str) -&gt; None:\n            print(f\"{self.component_class.__name__}: {msg}\")\n```\n\nAfter:\n\n```py\nfrom django_components import ComponentExtension, ExtensionComponentConfig\n\nclass LoggerExtension(ComponentExtension):\n    name = \"logger\"\n\n    class ComponentConfig(ExtensionComponentConfig):\n        def log(self, msg: str) -&gt; None:\n            print(f\"{self.component_cls.__name__}: {msg}\")\n```\n</code></pre> <p>Slots</p> <ul> <li> <p><code>SlotContent</code> was renamed to <code>SlotInput</code>. The old name is deprecated and will be removed in v1.</p> </li> <li> <p><code>SlotRef</code> was renamed to <code>SlotFallback</code>. The old name is deprecated and will be removed in v1.</p> </li> <li> <p>The <code>default</code> kwarg in <code>{% fill %}</code> tag was renamed to <code>fallback</code>. The old name is deprecated and will be removed in v1.</p> <p>Before:</p> <pre><code>{% fill \"footer\" default=\"footer\" %}\n    {{ footer }}\n{% endfill %}\n</code></pre> <p>After:</p> <pre><code>{% fill \"footer\" fallback=\"footer\" %}\n    {{ footer }}\n{% endfill %}\n</code></pre> </li> <li> <p>The template variable <code>{{ component_vars.is_filled }}</code> is now deprecated. Will be removed in v1. Use <code>{{ component_vars.slots }}</code> instead.</p> <p>Before:</p> <pre><code>{% if component_vars.is_filled.footer %}\n    &lt;div&gt;\n        {% slot \"footer\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre> <p>After:</p> <pre><code>{% if component_vars.slots.footer %}\n    &lt;div&gt;\n        {% slot \"footer\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre> <p>NOTE: <code>component_vars.is_filled</code> automatically escaped slot names, so that even slot names that are not valid python identifiers could be set as slot names. <code>component_vars.slots</code> no longer does that.</p> </li> <li> <p>Component attribute <code>Component.is_filled</code> is now deprecated. Will be removed in v1. Use <code>Component.slots</code> instead.</p> <p>Before:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        if self.is_filled.footer:\n            color = \"red\"\n        else:\n            color = \"blue\"\n\n        return {\n            \"color\": color,\n        }\n</code></pre> <p>After:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        if \"footer\" in slots:\n            color = \"red\"\n        else:\n            color = \"blue\"\n\n        return {\n            \"color\": color,\n        }\n</code></pre> <p>NOTE: <code>Component.is_filled</code> automatically escaped slot names, so that even slot names that are not valid python identifiers could be set as slot names. <code>Component.slots</code> no longer does that.</p> </li> </ul> <p>Miscellaneous</p> <ul> <li> <p>Template caching with <code>cached_template()</code> helper and <code>template_cache_size</code> setting is deprecated.     These will be removed in v1.</p> <p>This feature made sense if you were dynamically generating templates for components using <code>Component.get_template_string()</code> and <code>Component.get_template()</code>.</p> <p>However, in v1, each Component will have at most one static template. This static template is cached internally per component class, and reused across renders.</p> <p>This makes the template caching feature obsolete.</p> <p>If you relied on <code>cached_template()</code>, you should either:</p> <ol> <li>Wrap the templates as Components.</li> <li>Manage the cache of Templates yourself.</li> </ol> </li> <li> <p>The <code>debug_highlight_components</code> and <code>debug_highlight_slots</code> settings are deprecated.     These will be removed in v1.</p> <p>The debug highlighting feature was re-implemented as an extension. As such, the recommended way for enabling it has changed:</p> <p>Before:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_components=True,\n    debug_highlight_slots=True,\n)\n</code></pre> <p>After:</p> <p>Set <code>extensions_defaults</code> in your <code>settings.py</code> file.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    extensions_defaults={\n        \"debug_highlight\": {\n            \"highlight_components\": True,\n            \"highlight_slots\": True,\n        },\n    },\n)\n</code></pre> <p>Alternatively, you can enable highlighting for specific components by setting <code>Component.DebugHighlight.highlight_components</code> to <code>True</code>:</p> <pre><code>class MyComponent(Component):\n    class DebugHighlight:\n        highlight_components = True\n        highlight_slots = True\n</code></pre> </li> </ul>"},{"location":"releases/v0.140.0/#feat","title":"Feat","text":"<ul> <li> <p>New method to render template variables - <code>get_template_data()</code></p> <p><code>get_template_data()</code> behaves the same way as <code>get_context_data()</code>, but has a different function signature to accept also slots and context.</p> <pre><code>class Button(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"val1\": args[0],\n            \"val2\": kwargs[\"field\"],\n        }\n</code></pre> <p>If you define <code>Component.Args</code>, <code>Component.Kwargs</code>, <code>Component.Slots</code>, then the <code>args</code>, <code>kwargs</code>, <code>slots</code> arguments will be instances of these classes:</p> <pre><code>class Button(Component):\n    class Args(NamedTuple):\n        field1: str\n\n    class Kwargs(NamedTuple):\n        field2: int\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots, context):\n        return {\n            \"val1\": args.field1,\n            \"val2\": kwargs.field2,\n        }\n</code></pre> </li> <li> <p>Input validation is now part of the render process.</p> <p>When you specify the input types (such as <code>Component.Args</code>, <code>Component.Kwargs</code>, etc), the actual inputs to data methods (<code>Component.get_template_data()</code>, etc) will be instances of the types you specified.</p> <p>This practically brings back input validation, because the instantiation of the types will raise an error if the inputs are not valid.</p> <p>Read more on Typing and validation</p> </li> <li> <p>Render emails or other non-browser HTML with new \"dependencies strategies\"</p> <p>When rendering a component with <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>deps_strategy</code> kwarg (previously <code>type</code>) now accepts additional options:</p> <ul> <li><code>\"simple\"</code></li> <li><code>\"prepend\"</code></li> <li><code>\"append\"</code></li> <li><code>\"ignore\"</code></li> </ul> <pre><code>Calendar.render_to_response(\n    request=request,\n    kwargs={\n        \"date\": request.GET.get(\"date\", \"\"),\n    },\n    deps_strategy=\"append\",\n)\n</code></pre> <p>Comparison of dependencies render strategies:</p> <ul> <li><code>\"document\"</code><ul> <li>Smartly inserts JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Inserts extra script to allow <code>fragment</code> strategy to work.</li> <li>Assumes the HTML will be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>\"fragment\"</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>Ignores placeholders and any <code>&lt;head&gt;</code> / <code>&lt;body&gt;</code> tags.</li> <li>No JS / CSS included.</li> </ul> </li> <li><code>\"simple\"</code><ul> <li>Smartly insert JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"prepend\"</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>Ignores placeholders and any <code>&lt;head&gt;</code> / <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"append\"</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>Ignores placeholders and any <code>&lt;head&gt;</code> / <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"ignore\"</code><ul> <li>Rendered HTML is left as-is. You can still process it with a different strategy later with <code>render_dependencies()</code>.</li> <li>Used for inserting rendered HTML into other components.</li> </ul> </li> </ul> <p>See Dependencies rendering for more info.</p> </li> <li> <p>New <code>Component.args</code>, <code>Component.kwargs</code>, <code>Component.slots</code> attributes available on the component class itself.</p> <p>These attributes are the same as the ones available in <code>Component.get_template_data()</code>.</p> <p>You can use these in other methods like <code>Component.on_render_before()</code> or <code>Component.on_render_after()</code>.</p> <pre><code>from django_components import Component, SlotInput\n\nclass Table(Component):\n    class Args(NamedTuple):\n        page: int\n\n    class Kwargs(NamedTuple):\n        per_page: int\n\n    class Slots(NamedTuple):\n        content: SlotInput\n\n    def on_render_before(self, context: Context, template: Optional[Template]) -&gt; None:\n        assert self.args.page == 123\n        assert self.kwargs.per_page == 10\n        content_html = self.slots.content()\n</code></pre> <p>Same as with the parameters in <code>Component.get_template_data()</code>, they will be instances of the <code>Args</code>, <code>Kwargs</code>, <code>Slots</code> classes if defined, or plain lists / dictionaries otherwise.</p> </li> <li> <p>4 attributes that were previously available only under the <code>Component.input</code> attribute     are now available directly on the Component instance:</p> <ul> <li><code>Component.raw_args</code></li> <li><code>Component.raw_kwargs</code></li> <li><code>Component.raw_slots</code></li> <li><code>Component.deps_strategy</code></li> </ul> <p>The first 3 attributes are the same as the deprecated <code>Component.input.args</code>, <code>Component.input.kwargs</code>, <code>Component.input.slots</code> properties.</p> <p>Compared to the <code>Component.args</code> / <code>Component.kwargs</code> / <code>Component.slots</code> attributes, these \"raw\" attributes are not typed and will remain as plain lists / dictionaries even if you define the <code>Args</code>, <code>Kwargs</code>, <code>Slots</code> classes.</p> <p>The <code>Component.deps_strategy</code> attribute is the same as the deprecated <code>Component.input.deps_strategy</code> property.</p> </li> <li> <p>New template variables <code>{{ component_vars.args }}</code>, <code>{{ component_vars.kwargs }}</code>, <code>{{ component_vars.slots }}</code></p> <p>These attributes are the same as the ones available in <code>Component.get_template_data()</code>.</p> <pre><code>{# Typed #}\n{% if component_vars.args.page == 123 %}\n    &lt;div&gt;\n        {% slot \"content\" / %}\n    &lt;/div&gt;\n{% endif %}\n\n{# Untyped #}\n{% if component_vars.args.0 == 123 %}\n    &lt;div&gt;\n        {% slot \"content\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre> <p>Same as with the parameters in <code>Component.get_template_data()</code>, they will be instances of the <code>Args</code>, <code>Kwargs</code>, <code>Slots</code> classes if defined, or plain lists / dictionaries otherwise.</p> </li> <li> <p>New component lifecycle hook <code>Component.on_render()</code>.</p> <p>This hook is called when the component is being rendered.</p> <p>You can override this method to:</p> <ul> <li>Change what template gets rendered</li> <li>Modify the context</li> <li>Modify the rendered output after it has been rendered</li> <li>Handle errors</li> </ul> <p>See on_render for more info.</p> </li> <li> <p><code>get_component_url()</code> now optionally accepts <code>query</code> and <code>fragment</code> arguments.</p> <pre><code>from django_components import get_component_url\n\nurl = get_component_url(\n    MyComponent,\n    query={\"foo\": \"bar\"},\n    fragment=\"baz\",\n)\n# /components/ext/view/components/c1ab2c3?foo=bar#baz\n</code></pre> </li> <li> <p>The <code>BaseNode</code> class has a new <code>contents</code> attribute, which contains the raw contents (string) of the tag body.</p> <p>This is relevant when you define custom template tags with <code>@template_tag</code> decorator or <code>BaseNode</code> class.</p> <p>When you define a custom template tag like so:</p> <pre><code>from django_components import BaseNode, template_tag\n\n@template_tag(\n    library,\n    tag=\"mytag\",\n    end_tag=\"endmytag\",\n    allowed_flags=[\"required\"]\n)\ndef mytag(node: BaseNode, context: Context, name: str, **kwargs) -&gt; str:\n    print(node.contents)\n    return f\"Hello, {name}!\"\n</code></pre> <p>And render it like so:</p> <pre><code>{% mytag name=\"John\" %}\n    Hello, world!\n{% endmytag %}\n</code></pre> <p>Then, the <code>contents</code> attribute of the <code>BaseNode</code> instance will contain the string <code>\"Hello, world!\"</code>.</p> </li> <li> <p>The <code>BaseNode</code> class also has two new metadata attributes:</p> <ul> <li><code>template_name</code> - the name of the template that rendered the node.</li> <li><code>template_component</code> - the component class that the template belongs to.</li> </ul> <p>This is useful for debugging purposes.</p> </li> <li> <p><code>Slot</code> class now has 3 new metadata fields:</p> <ol> <li> <p><code>Slot.contents</code> attribute contains the original contents:</p> <ul> <li>If <code>Slot</code> was created from <code>{% fill %}</code> tag, <code>Slot.contents</code> will contain the body of the <code>{% fill %}</code> tag.</li> <li>If <code>Slot</code> was created from string via <code>Slot(\"...\")</code>, <code>Slot.contents</code> will contain that string.</li> <li>If <code>Slot</code> was created from a function, <code>Slot.contents</code> will contain that function.</li> </ul> </li> <li> <p><code>Slot.extra</code> attribute where you can put arbitrary metadata about the slot.</p> </li> <li> <p><code>Slot.fill_node</code> attribute tells where the slot comes from:</p> <ul> <li><code>FillNode</code> instance if the slot was created from <code>{% fill %}</code> tag.</li> <li><code>ComponentNode</code> instance if the slot was created as a default slot from a <code>{% component %}</code> tag.</li> <li><code>None</code> if the slot was created from a string, function, or <code>Slot</code> instance.</li> </ul> </li> </ol> <p>See Slot metadata.</p> </li> <li> <p><code>{% fill %}</code> tag now accepts <code>body</code> kwarg to pass a Slot instance to fill.</p> <p>First pass a <code>Slot</code> instance to the template with the <code>get_template_data()</code> method:</p> <pre><code>from django_components import component, Slot\n\nclass Table(Component):\n  def get_template_data(self, args, kwargs, slots, context):\n    return {\n        \"my_slot\": Slot(lambda ctx: \"Hello, world!\"),\n    }\n</code></pre> <p>Then pass the slot to the <code>{% fill %}</code> tag:</p> <pre><code>{% component \"table\" %}\n  {% fill \"pagination\" body=my_slot / %}\n{% endcomponent %}\n</code></pre> </li> <li> <p>You can now access the <code>{% component %}</code> tag (<code>ComponentNode</code> instance) from which a Component     was created. Use <code>Component.node</code> to access it.</p> <p>This is mostly useful for extensions, which can use this to detect if the given Component comes from a <code>{% component %}</code> tag or from a different source (such as <code>Component.render()</code>).</p> <p><code>Component.node</code> is <code>None</code> if the component is created by <code>Component.render()</code> (but you can pass in the <code>node</code> kwarg yourself).</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, context, template):\n        if self.node is not None:\n            assert self.node.name == \"my_component\"\n</code></pre> </li> <li> <p>Node classes <code>ComponentNode</code>, <code>FillNode</code>, <code>ProvideNode</code>, and <code>SlotNode</code> are part of the public API.</p> <p>These classes are what is instantiated when you use <code>{% component %}</code>, <code>{% fill %}</code>, <code>{% provide %}</code>, and <code>{% slot %}</code> tags.</p> <p>You can for example use these for type hints:</p> <pre><code>from django_components import Component, ComponentNode\n\nclass MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        if kwargs.get(\"show_owner\"):\n            node: Optional[ComponentNode] = self.node\n            owner: Optional[Component] = self.node.template_component\n        else:\n            node = None\n            owner = None\n\n        return {\n            \"owner\": owner,\n            \"node\": node,\n        }\n</code></pre> </li> <li> <p>Component caching can now take slots into account, by setting <code>Component.Cache.include_slots</code> to <code>True</code>.</p> <pre><code>class MyComponent(Component):\n    class Cache:\n        enabled = True\n        include_slots = True\n</code></pre> <p>In which case the following two calls will generate separate cache entries:</p> <pre><code>{% component \"my_component\" position=\"left\" %}\n    Hello, Alice\n{% endcomponent %}\n\n{% component \"my_component\" position=\"left\" %}\n    Hello, Bob\n{% endcomponent %}\n</code></pre> <p>Same applies to <code>Component.render()</code> with string slots:</p> <pre><code>MyComponent.render(\n    kwargs={\"position\": \"left\"},\n    slots={\"content\": \"Hello, Alice\"}\n)\nMyComponent.render(\n    kwargs={\"position\": \"left\"},\n    slots={\"content\": \"Hello, Bob\"}\n)\n</code></pre> <p>Read more on Component caching.</p> </li> <li> <p>New extension hook <code>on_slot_rendered()</code></p> <p>This hook is called when a slot is rendered, and allows you to access and/or modify the rendered result.</p> <p>This is used by the \"debug highlight\" feature.</p> <p>To modify the rendered result, return the new value:</p> <pre><code>class MyExtension(ComponentExtension):\n    def on_slot_rendered(self, ctx: OnSlotRenderedContext) -&gt; Optional[str]:\n        return ctx.result + \"&lt;!-- Hello, world! --&gt;\"\n</code></pre> <p>If you don't want to modify the rendered result, return <code>None</code>.</p> <p>See all Extension hooks.</p> </li> <li> <p>When creating extensions, the previous syntax with <code>ComponentExtension.ExtensionClass</code> was causing   Mypy errors, because Mypy doesn't allow using class attributes as bases:</p> <p>Before:</p> <pre><code>from django_components import ComponentExtension\n\nclass MyExtension(ComponentExtension):\n    class ExtensionClass(ComponentExtension.ExtensionClass):  # Error!\n        pass\n</code></pre> <p>Instead, you can import <code>ExtensionComponentConfig</code> directly:</p> <p>After:</p> <pre><code>from django_components import ComponentExtension, ExtensionComponentConfig\n\nclass MyExtension(ComponentExtension):\n    class ComponentConfig(ExtensionComponentConfig):\n        pass\n</code></pre> </li> </ul>"},{"location":"releases/v0.140.0/#refactor","title":"Refactor","text":"<ul> <li> <p>When a component is being rendered, a proper <code>Component</code> instance is now created.</p> <p>Previously, the <code>Component</code> state was managed as half-instance, half-stack.</p> </li> <li> <p>Component's \"Render API\" (args, kwargs, slots, context, inputs, request, context data, etc)   can now be accessed also outside of the render call. So now its possible to take the component   instance out of <code>get_template_data()</code> (although this is not recommended).</p> </li> <li> <p>Components can now be defined without a template.</p> <p>Previously, the following would raise an error:</p> <pre><code>class MyComponent(Component):\n    pass\n</code></pre> <p>\"Template-less\" components can be used together with <code>Component.on_render()</code> to dynamically pick what to render:</p> <pre><code>class TableNew(Component):\n    template_file = \"table_new.html\"\n\nclass TableOld(Component):\n    template_file = \"table_old.html\"\n\nclass Table(Component):\n    def on_render(self, context, template):\n        if self.kwargs.get(\"feat_table_new_ui\"):\n            return TableNew.render(args=self.args, kwargs=self.kwargs, slots=self.slots)\n        else:\n            return TableOld.render(args=self.args, kwargs=self.kwargs, slots=self.slots)\n</code></pre> <p>\"Template-less\" components can be also used as a base class for other components, or as mixins.</p> </li> <li> <p>Passing <code>Slot</code> instance to <code>Slot</code> constructor raises an error.</p> </li> <li> <p>Extension hook <code>on_component_rendered</code> now receives <code>error</code> field.</p> <p><code>on_component_rendered</code> now behaves similar to <code>Component.on_render_after</code>:</p> <ul> <li>Raising error in this hook overrides what error will be returned from <code>Component.render()</code>.</li> <li>Returning new string overrides what will be returned from <code>Component.render()</code>.</li> </ul> <p>Before:</p> <pre><code>class OnComponentRenderedContext(NamedTuple):\n    component: \"Component\"\n    component_cls: Type[\"Component\"]\n    component_id: str\n    result: str\n</code></pre> <p>After:</p> <pre><code>class OnComponentRenderedContext(NamedTuple):\n    component: \"Component\"\n    component_cls: Type[\"Component\"]\n    component_id: str\n    result: Optional[str]\n    error: Optional[Exception]\n</code></pre> </li> </ul>"},{"location":"releases/v0.140.0/#fix","title":"Fix","text":"<ul> <li> <p>Fix bug: Context processors data was being generated anew for each component. Now the data is correctly created once and reused across components with the same request (#1165).</p> </li> <li> <p>Fix KeyError on <code>component_context_cache</code> when slots are rendered outside of the component's render context. (#1189)</p> </li> <li> <p>Component classes now have <code>do_not_call_in_templates=True</code> to prevent them from being called as functions in templates.</p> </li> </ul>"},{"location":"releases/v0.140.1/","title":"v0.140.1 (2025-06-05)","text":"<p>__</p>"},{"location":"releases/v0.140.1/#fix","title":"Fix","text":"<ul> <li>Fix typo preventing benchmarking (#1235)</li> </ul>"},{"location":"releases/v0.141.0/","title":"v0.141.0 (2025-06-10)","text":"<p>__</p>"},{"location":"releases/v0.141.0/#feat","title":"Feat","text":"<ul> <li> <p>New extension hooks <code>on_template_loaded</code>, <code>on_js_loaded</code>, <code>on_css_loaded</code>, and <code>on_template_compiled</code></p> <p>The first 3 hooks are called when Component's template / JS / CSS is loaded as a string.</p> <p>The <code>on_template_compiled</code> hook is called when Component's template is compiled to a Template.</p> <p>The <code>on_xx_loaded</code> hooks can modify the content by returning the new value.</p> <pre><code>class MyExtension(ComponentExtension):\n    def on_template_loaded(self, ctx: OnTemplateLoadedContext) -&gt; Optional[str]:\n        return ctx.content + \"&lt;!-- Hello! --&gt;\"\n\n    def on_js_loaded(self, ctx: OnJsLoadedContext) -&gt; Optional[str]:\n        return ctx.content + \"// Hello!\"\n\n    def on_css_loaded(self, ctx: OnCssLoadedContext) -&gt; Optional[str]:\n        return ctx.content + \"/* Hello! */\"\n</code></pre> <p>See all Extension hooks.</p> </li> </ul>"},{"location":"releases/v0.141.0/#fix","title":"Fix","text":"<ul> <li> <p>Subclassing - Previously, if a parent component defined <code>Component.template</code> or <code>Component.template_file</code>, it's subclass would use the same <code>Template</code> instance.</p> <p>This could lead to unexpected behavior, where a change to the template of the subclass would also change the template of the parent class.</p> <p>Now, each subclass has it's own <code>Template</code> instance, and changes to the template of the subclass do not affect the template of the parent class.</p> </li> <li> <p>Fix Django failing to restart due to \"TypeError: 'Dynamic' object is not iterable\" (#1232)</p> </li> <li> <p>Fix bug when error formatting failed when error value was not a string.</p> </li> </ul>"},{"location":"releases/v0.141.0/#refactor","title":"Refactor","text":"<ul> <li><code>components ext run</code> CLI command now allows to call only those extensions that actually have subcommands.</li> </ul>"},{"location":"releases/v0.141.1/","title":"v0.141.1 (2025-07-03)","text":"<p>__</p>"},{"location":"releases/v0.141.1/#fix","title":"Fix","text":"<ul> <li> <p>Components' JS and CSS scripts (e.g. from <code>Component.js</code> or <code>Component.js_file</code>) are now cached at class creation time.</p> <p>This means that when you now restart the server while having a page opened in the browser, the JS / CSS files are immediately available.</p> <p>Previously, the JS/CSS were cached only after the components were rendered. So you had to reload the page to trigger the rendering, in order to make the JS/CSS files available.</p> </li> <li> <p>Fix the default cache for JS / CSS scripts to be unbounded.</p> <p>Previously, the default cache for the JS/CSS scripts (<code>LocMemCache</code>) was accidentally limited to 300 entries (~150 components).</p> </li> <li> <p>Do not send <code>template_rendered</code> signal when rendering a component with no template. (#1277)</p> </li> </ul>"},{"location":"releases/v0.141.2/","title":"v0.141.2 (2025-07-21)","text":"<p>__</p>"},{"location":"releases/v0.141.2/#fix","title":"Fix","text":"<ul> <li>Fix bug where JS and CSS were missing when <code>{% component %}</code> tag was inside <code>{% include %}</code> tag (#1296)</li> </ul>"},{"location":"releases/v0.141.3/","title":"v0.141.3 (2025-08-14)","text":"<p>__</p>"},{"location":"releases/v0.141.3/#feat","title":"Feat","text":"<ul> <li> <p>You no longer need to render the whole page with the <code>document</code> strategy to use HTML fragments.</p> <p>Previously, if you wanted to insert rendered components as HTML fragments, you had to ensure that the HTML document it was being inserted into was rendered with the <code>document</code> strategy.</p> <p>Now, when you render components with <code>fragment</code> strategy, they know how to fetch their own JS / CSS dependencies.</p> </li> </ul>"},{"location":"releases/v0.141.3/#fix","title":"Fix","text":"<ul> <li>Fix compatibility with django-template-partials (#1322)</li> </ul>"},{"location":"releases/v0.141.4/","title":"v0.141.4 (2025-08-15)","text":"<p>__</p>"},{"location":"releases/v0.141.4/#fix","title":"Fix","text":"<ul> <li>Fix compatibility with Django's <code>{% include %}</code> and <code>{% extends %}</code> tags.   See #1325</li> </ul>"},{"location":"releases/v0.141.5/","title":"v0.141.5 (2025-09-10)","text":"<p>__</p>"},{"location":"releases/v0.141.5/#fix","title":"Fix","text":"<ul> <li>Tests - Fix bug when using <code>@djc_test</code> decorator and the <code>COMPONENTS</code>   settings are set with <code>ComponentsSettings</code>   See #1369</li> </ul>"},{"location":"releases/v0.141.6/","title":"v0.141.6 (2025-09-29)","text":"<p>__</p>"},{"location":"releases/v0.141.6/#fix","title":"Fix","text":"<ul> <li>Fix error that occured when calling <code>Component.inject()</code> inside loops:</li> </ul> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        data = self.inject(\"my_provide\")\n        return {\"data\": data}\n</code></pre> <pre><code>{% load component_tags %}\n{% provide \"my_provide\" key=\"hi\" data=data %}\n    {% for i in range(10) %}\n        {% component \"my_component\" / %}\n    {% endfor %}\n{% endprovide %}\n</code></pre> <ul> <li>Allow to call <code>Component.inject()</code> outside of the rendering:</li> </ul> <pre><code>comp = None\n\nclass MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        nonlocal comp\n        comp = self\n\ntemplate_str = \"\"\"\n    {% load component_tags %}\n    {% provide \"my_provide\" key=\"hi\" data=data %}\n        {% component \"my_component\" / %}\n    {% endprovide %}\n\"\"\"\ntemplate = Template(template_str)\nrendered = template.render(Context({}))\n\nassert comp is not None\n\ninjected = comp.inject(\"my_provide\")\nassert injected.key == \"hi\"\nassert injected.data == \"data\"\n</code></pre>"},{"location":"releases/v0.141.6/#refactor","title":"Refactor","text":"<ul> <li>Removed circular references to the Component instances. Component instances   are now garbage collected unless you keep a reference to them.</li> </ul>"},{"location":"releases/v0.142.0/","title":"v0.142.0","text":""},{"location":"releases/v0.142.0/#feat","title":"Feat","text":"<ul> <li> <p>New built-in component <code>ErrorFallback</code></p> <p>Use <code>ErrorFallback</code> to catch errors and display a fallback content instead.</p> <p>This is similar to React's <code>ErrorBoundary</code> component.</p> <p>Either pass the fallback as a kwarg:</p> <pre><code>{% component \"error_fallback\" fallback=\"Oops, something went wrong\" %}\n    {% component \"table\" / %}\n{% endcomponent %}\n</code></pre> <p>Or use the full <code>fallback</code> slot:</p> <pre><code>{% component \"error_fallback\" %}\n    {% fill \"content\" %}\n        {% component \"table\" / %}\n    {% endfill %}\n    {% fill \"fallback\" data=\"data\" %}\n        &lt;p&gt;Oops, something went wrong&lt;/p&gt;\n        {% button href=\"/report-error\" %}\n            Report error\n        {% endbutton %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> </li> <li> <p>Wrap the template rendering in <code>Component.on_render()</code> in a lambda function.</p> <p>When you wrap the rendering call in a lambda function, and the rendering fails, the error will be yielded back in the <code>(None, Exception)</code> tuple.</p> <p>Before:</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        try:\n            intermediate = template.render(context)\n            html, error = yield intermediate\n        except Exception as e:\n            html, error = None, e\n</code></pre> <p>After:</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        html, error = yield lambda: template.render(context)\n</code></pre> </li> <li> <p>Multiple yields in <code>Component.on_render()</code> - You can now yield multiple times within the same <code>on_render</code> method for complex rendering scenarios.</p> <pre><code>class MyTable(Component):\n    def on_render(self, context, template):\n        # First yield\n        with context.push({\"mode\": \"header\"}):\n            header_html, header_error = yield lambda: template.render(context)\n\n        # Second yield\n        with context.push({\"mode\": \"body\"}):\n            body_html, body_error = yield lambda: template.render(context)\n\n        # Third yield\n        footer_html, footer_error = yield \"Footer content\"\n\n        # Process all results\n        if header_error or body_error or footer_error:\n            return \"Error occurred during rendering\"\n\n        return f\"{header_html}\\n{body_html}\\n{footer_html}\"\n</code></pre> <p>Each yield operation is independent and returns its own <code>(html, error)</code> tuple, allowing you to handle each rendering result separately.</p> </li> </ul>"},{"location":"releases/v0.142.0/#fix","title":"Fix","text":"<ul> <li> <p>Improve formatting when an exception is raised while rendering components. Error messages with newlines should now be properly formatted.</p> </li> <li> <p>Add missing exports for <code>OnComponentRenderedContext</code>, <code>OnSlotRenderedContext</code>, <code>OnTemplateCompiledContext</code>, <code>OnTemplateLoadedContext</code>.</p> </li> </ul>"},{"location":"releases/v0.142.0/#refactor","title":"Refactor","text":"<ul> <li> <p>Changes to how <code>get_component_url()</code> handles query parameters:</p> <ul> <li><code>True</code> values are now converted to boolean flags (e.g. <code>?enabled</code> instead of <code>?enabled=True</code>).</li> <li><code>False</code> and <code>None</code> values are now filtered out.</li> </ul> <pre><code>url = get_component_url(\n    MyComponent,\n    query={\"abc\": 123, \"enabled\": True, \"debug\": False, \"none_key\": None},\n)\n# /components/ext/view/components/c1ab2c3?abc=123&amp;enabled\n</code></pre> </li> </ul>"},{"location":"releases/v0.17/","title":"v0.17 (2021-09-10)","text":"<p>__</p>"},{"location":"releases/v0.17/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li> <p>Renamed <code>Component.context</code> and <code>Component.template</code> to <code>get_context_data</code> and <code>get_template_name</code>. The old methods still work, but emit a deprecation warning.</p> <p>This change was done to sync naming with Django's class based views, and make using django-components more familiar to Django users. <code>Component.context</code> and <code>Component.template</code> will be removed when version 1.0 is released.</p> </li> </ul>"},{"location":"releases/v0.22/","title":"v0.22 (2022-07-26)","text":"<p>__</p>"},{"location":"releases/v0.22/#feat","title":"Feat","text":"<ul> <li> <p>All files inside components subdirectores are autoimported to simplify setup.</p> <p>An existing project might start to get <code>AlreadyRegistered</code> errors because of this. To solve this, either remove your custom loading of components, or set <code>\"autodiscover\": False</code> in <code>settings.COMPONENTS</code>.</p> </li> </ul>"},{"location":"releases/v0.26/","title":"v0.26 \ud83d\udea8\ud83d\udce2 (2023-03-14)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.26/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li> <p>Changed the syntax for <code>{% slot %}</code> tags. From now on, we separate defining a slot (<code>{% slot %}</code>) from filling a slot with content (<code>{% fill %}</code>). This means you will likely need to change a lot of slot tags to fill.</p> <p>We understand this is annoying, but it's the only way we can get support for nested slots that fill in other slots, which is a very nice feature to have access to. Hoping that this will feel worth it!</p> </li> </ul>"},{"location":"releases/v0.27/","title":"v0.27 (2023-04-11)","text":"<p>__</p>"},{"location":"releases/v0.27/#feat","title":"Feat","text":"<ul> <li>A second installable app <code>django_components.safer_staticfiles</code>. It provides the same behavior as <code>django.contrib.staticfiles</code> but with extra security guarantees (more info below in Security Notes).</li> </ul>"},{"location":"releases/v0.28/","title":"v0.28 (2023-05-18)","text":"<p>__</p>"},{"location":"releases/v0.28/#feat","title":"Feat","text":"<ul> <li>'implicit' slot filling and the <code>default</code> option for <code>slot</code> tags.</li> </ul>"},{"location":"releases/v0.34/","title":"v0.34 (2024-01-27)","text":"<p>__</p>"},{"location":"releases/v0.34/#feat","title":"Feat","text":"<ul> <li>Components as views, which allows you to handle requests and render responses from within a component. See the documentation for more details.</li> </ul>"},{"location":"releases/v0.50/","title":"v0.50 \ud83d\udea8\ud83d\udce2 (2024-02-26)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.50/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>{% component_block %}</code> is now <code>{% component %}</code>, and <code>{% component %}</code> blocks need an ending <code>{% endcomponent %}</code> tag.</p> <p>The new <code>python manage.py upgradecomponent</code> command can be used to upgrade a directory (use <code>--path</code> argument to point to each dir) of templates that use components to the new syntax automatically.</p> <p>This change is done to simplify the API in anticipation of a 1.0 release of django_components. After 1.0 we intend to be stricter with big changes like this in point releases.</p> </li> </ul>"},{"location":"releases/v0.67/","title":"v0.67 (2024-04-17)","text":"<p>__</p>"},{"location":"releases/v0.67/#refactor","title":"Refactor","text":"<ul> <li>Changed the default way how context variables are resolved in slots. See the documentation for more details.</li> </ul>"},{"location":"releases/v0.70/","title":"v0.70 \ud83d\udea8\ud83d\udce2 (2024-05-01)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.70/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>{% if_filled \"my_slot\" %}</code> tags were replaced with <code>{{ component_vars.is_filled.my_slot }}</code> variables.</p> </li> <li> <p>Simplified settings - <code>slot_context_behavior</code> and <code>context_behavior</code> were merged. See the documentation for more details.</p> </li> </ul>"},{"location":"releases/v0.74/","title":"v0.74 (2024-05-12)","text":"<p>__</p>"},{"location":"releases/v0.74/#feat","title":"Feat","text":"<ul> <li> <p><code>{% html_attrs %}</code> tag for formatting data as HTML attributes</p> </li> <li> <p><code>prefix:key=val</code> construct for passing dicts to components</p> </li> </ul>"},{"location":"releases/v0.77/","title":"v0.77 \ud83d\udea8\ud83d\udce2 (2024-05-23)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.77/#breaking","title":"BREAKING","text":"<ul> <li> <p>The syntax for accessing default slot content has changed from</p> <pre><code>{% fill \"my_slot\" as \"alias\" %}\n    {{ alias.default }}\n{% endfill %}\n</code></pre> <p>to</p> <pre><code>{% fill \"my_slot\" default=\"alias\" %}\n    {{ alias }}\n{% endfill %}\n</code></pre> </li> </ul>"},{"location":"releases/v0.79/","title":"v0.79 \ud83d\udea8\ud83d\udce2 (2024-06-01)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.79/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li>Default value for the <code>COMPONENTS.context_behavior</code> setting was changes from <code>\"isolated\"</code> to <code>\"django\"</code>. If you did not set this value explicitly before, this may be a breaking change. See the rationale for change here.</li> </ul>"},{"location":"releases/v0.80/","title":"v0.80 (2024-06-01)","text":"<p>__</p>"},{"location":"releases/v0.80/#feat","title":"Feat","text":"<ul> <li>Vue-like provide/inject with the <code>{% provide %}</code> tag and <code>inject()</code> method.</li> </ul>"},{"location":"releases/v0.81/","title":"v0.81 \ud83d\udea8\ud83d\udce2 (2024-06-12)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.81/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li>The order of arguments to <code>render_to_response</code> has changed, to align with the (now public) <code>render</code> method of <code>Component</code> class.</li> </ul>"},{"location":"releases/v0.81/#feat","title":"Feat","text":"<ul> <li> <p><code>Component.render()</code> is public and documented</p> </li> <li> <p>Slots passed <code>render_to_response</code> and <code>render</code> can now be rendered also as functions.</p> </li> </ul>"},{"location":"releases/v0.85/","title":"v0.85 \ud83d\udea8\ud83d\udce2 (2024-07-29)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.85/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li> <p>Autodiscovery module resolution changed. Following undocumented behavior was removed:</p> <ul> <li> <p>Previously, autodiscovery also imported any <code>[app]/components.py</code> files, and used <code>SETTINGS_MODULE</code> to search for component dirs.</p> <p>To migrate from:</p> <ul> <li> <p><code>[app]/components.py</code> - Define each module in <code>COMPONENTS.libraries</code> setting,     or import each module inside the <code>AppConfig.ready()</code> hook in respective <code>apps.py</code> files.</p> </li> <li> <p><code>SETTINGS_MODULE</code> - Define component dirs using <code>STATICFILES_DIRS</code></p> </li> </ul> </li> <li> <p>Previously, autodiscovery handled relative files in <code>STATICFILES_DIRS</code>. To align with Django, <code>STATICFILES_DIRS</code> now must be full paths (Django docs).</p> </li> </ul> </li> </ul>"},{"location":"releases/v0.90/","title":"v0.90 (2024-08-18)","text":"<p>__</p>"},{"location":"releases/v0.90/#feat","title":"Feat","text":"<ul> <li> <p>All tags (<code>component</code>, <code>slot</code>, <code>fill</code>, ...) now support \"self-closing\" or \"inline\" form, where you can omit the closing tag:</p> <pre><code>{# Before #}\n{% component \"button\" %}{% endcomponent %}\n{# After #}\n{% component \"button\" / %}\n</code></pre> </li> <li> <p>All tags now support the \"dictionary key\" or \"aggregate\" syntax (<code>kwarg:key=val</code>):</p> <pre><code>{% component \"button\" attrs:class=\"hidden\" %}\n</code></pre> </li> <li> <p>You can change how the components are written in the template with TagFormatter.</p> <p>The default is <code>django_components.component_formatter</code>:</p> <pre><code>{% component \"button\" href=\"...\" disabled %}\n    Click me!\n{% endcomponent %}\n</code></pre> <p>While <code>django_components.component_shorthand_formatter</code> allows you to write components like so:</p> <pre><code>{% button href=\"...\" disabled %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"releases/v0.92/","title":"v0.92 \ud83d\udea8\ud83d\udce2 (2024-08-22)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.92/#breaking-changes","title":"BREAKING CHANGES","text":"<ul> <li><code>Component</code> class is no longer a subclass of <code>View</code>. To configure the <code>View</code> class, set the <code>Component.View</code> nested class. HTTP methods like <code>get</code> or <code>post</code> can still be defined directly on <code>Component</code> class, and <code>Component.as_view()</code> internally calls <code>Component.View.as_view()</code>. (See Modifying the View class)</li> </ul>"},{"location":"releases/v0.92/#feat","title":"Feat","text":"<ul> <li> <p>The inputs (args, kwargs, slots, context, ...) that you pass to <code>Component.render()</code> can be accessed from within <code>get_context_data</code>, <code>get_template</code> and <code>get_template_name</code> via <code>self.input</code>. (See Accessing data passed to the component)</p> </li> <li> <p>Typing: <code>Component</code> class supports generics that specify types for <code>Component.render</code> (See Adding type hints with Generics)</p> </li> </ul>"},{"location":"releases/v0.93/","title":"v0.93 (2024-08-27)","text":"<p>__</p>"},{"location":"releases/v0.93/#feat","title":"Feat","text":"<ul> <li> <p>Spread operator <code>...dict</code> inside template tags. (See Spread operator)</p> </li> <li> <p>Use template tags inside string literals in component inputs. (See Use template tags inside component inputs)</p> </li> <li> <p>Dynamic slots, fills and provides - The <code>name</code> argument for these can now be a variable, a template expression, or via spread operator</p> </li> <li> <p>Component library authors can now configure <code>CONTEXT_BEHAVIOR</code> and <code>TAG_FORMATTER</code> settings independently from user settings.</p> </li> </ul>"},{"location":"releases/v0.94/","title":"v0.94 (2024-08-28)","text":"<p>__</p>"},{"location":"releases/v0.94/#feat","title":"Feat","text":"<ul> <li> <p>django_components now automatically configures Django to support multi-line tags. (See Multi-line tags)</p> </li> <li> <p>New setting <code>reload_on_template_change</code>. Set this to <code>True</code> to reload the dev server on changes to component template files. (See Reload dev server on component file changes)</p> </li> </ul>"},{"location":"releases/v0.95/","title":"v0.95 (2024-08-29)","text":"<p>__</p> <p>__</p>"},{"location":"releases/v0.95/#feat","title":"Feat","text":"<ul> <li>Added support for dynamic components, where the component name is passed as a variable. (See Dynamic components)</li> </ul>"},{"location":"releases/v0.95/#refactor","title":"Refactor","text":"<ul> <li>Changed <code>Component.input</code> to raise <code>RuntimeError</code> if accessed outside of render context. Previously it returned <code>None</code> if unset.</li> </ul>"},{"location":"releases/v0.96/","title":"v0.96 (2024-09-04)","text":"<p>__</p>"},{"location":"releases/v0.96/#feat","title":"Feat","text":"<ul> <li> <p>Run-time type validation for Python &gt;=3.11 - If the <code>Component</code> class is typed, e.g. <code>Component[Args, Kwargs, ...]</code>, the args, kwargs, slots, and data are validated against the given types. (See Runtime input validation with types)</p> </li> <li> <p>Render hooks - Set <code>on_render_before</code> and <code>on_render_after</code> methods on <code>Component</code> to intercept or modify the template or context before rendering, or the rendered result afterwards. (See Component hooks)</p> </li> <li> <p><code>component_vars.is_filled</code> context variable can be accessed from within <code>on_render_before</code> and <code>on_render_after</code> hooks as <code>self.is_filled.my_slot</code></p> </li> </ul>"},{"location":"releases/v0.97/","title":"v0.97 (2024-09-06)","text":"<p>__</p>"},{"location":"releases/v0.97/#fix","title":"Fix","text":"<ul> <li>Fixed template caching. You can now also manually create cached templates with <code>cached_template()</code></li> </ul>"},{"location":"releases/v0.97/#refactor","title":"Refactor","text":"<ul> <li> <p>The previously undocumented <code>get_template</code> was made private.</p> </li> <li> <p>In it's place, there's a new <code>get_template</code>, which supersedes <code>get_template_string</code> (will be removed in v1). The new <code>get_template</code> is the same as <code>get_template_string</code>, except   it allows to return either a string or a Template instance.</p> </li> <li> <p>You now must use only one of <code>template</code>, <code>get_template</code>, <code>template_name</code>, or <code>get_template_name</code>.</p> </li> </ul>"},{"location":"upgrading/v0/","title":"Upgrading in pre-v1.0","text":"<p>Django-components is still in active development.</p> <p>Since django-components is in pre-1.0 development, the public API is not yet frozen. This means that there may be breaking changes between minor versions. We try to minimize the number of breaking changes, but sometimes it's unavoidable.</p> <p>When upgrading, please read the Release notes.</p> <p>If you're on older pre-v1.0 versions of django-components, we recommend doing step-wise upgrades in the following order:</p> <ul> <li>v0.26</li> <li>v0.50</li> <li>v0.70</li> <li>v0.77</li> <li>v0.81</li> <li>v0.85</li> <li>v0.92</li> <li>v0.100</li> <li>v0.110</li> <li>v0.140</li> </ul> <p>These versions introduced breaking changes that are not backwards compatible.</p>"}]}