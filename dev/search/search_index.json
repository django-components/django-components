{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Django Components","text":"<p><code>django-components</code> combines Django's templating system with the modularity seen in modern frontend frameworks like Vue or React.</p> <p>With <code>django-components</code> you can support Django projects small and large without leaving the Django ecosystem.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>A component in django-components can be as simple as a Django template and Python code to declare the component:</p> components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n</code></pre> <p>Or a combination of Django template, Python, CSS, and Javascript:</p> components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> components/calendar/calendar.css<pre><code>.calendar {\n  width: 200px;\n  background: pink;\n}\n</code></pre> components/calendar/calendar.js<pre><code>document.querySelector(\".calendar\").onclick = () =&gt; {\n  alert(\"Clicked calendar!\");\n};\n</code></pre> components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"date\": kwargs[\"date\"]}\n</code></pre> <p>Use the component like this:</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}{% endcomponent %}\n</code></pre> <p>And this is what gets rendered:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n  Today's date is &lt;span&gt;2024-11-06&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>Read on to learn about all the exciting details and configuration possibilities!</p> <p>(If you instead prefer to jump right into the code, check out the example project)</p>"},{"location":"#features","title":"Features","text":""},{"location":"#modern-and-modular-ui","title":"Modern and modular UI","text":"<ul> <li>Create self-contained, reusable UI elements.</li> <li>Each component can include its own HTML, CSS, and JS, or additional third-party JS and CSS.</li> <li>HTML, CSS, and JS can be defined on the component class, or loaded from files.</li> </ul> <pre><code>from django_components import Component\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar\"&gt;\n            Today's date is\n            &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n        .calendar {\n            width: 200px;\n            background: pink;\n        }\n    \"\"\"\n\n    js = \"\"\"\n        document.querySelector(\".calendar\")\n            .addEventListener(\"click\", () =&gt; {\n                alert(\"Clicked calendar!\");\n            });\n    \"\"\"\n\n    # Additional JS and CSS\n    class Media:\n        js = [\"https://cdn.jsdelivr.net/npm/htmx.org@2.1.1/dist/htmx.min.js\"]\n        css = [\"bootstrap/dist/css/bootstrap.min.css\"]\n\n    # Variables available in the template\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"]\n        }\n</code></pre>"},{"location":"#composition-with-slots","title":"Composition with slots","text":"<ul> <li>Render components inside templates with   <code>{% component %}</code> tag.</li> <li>Compose them with <code>{% slot %}</code>   and <code>{% fill %}</code> tags.</li> <li>Vue-like slot system, including scoped slots.</li> </ul> <pre><code>{% component \"Layout\"\n    bookmarks=bookmarks\n    breadcrumbs=breadcrumbs\n%}\n    {% fill \"header\" %}\n        &lt;div class=\"flex justify-between gap-x-12\"&gt;\n            &lt;div class=\"prose\"&gt;\n                &lt;h3&gt;{{ project.name }}&lt;/h3&gt;\n            &lt;/div&gt;\n            &lt;div class=\"font-semibold text-gray-500\"&gt;\n                {{ project.start_date }} - {{ project.end_date }}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    {% endfill %}\n\n    {# Access data passed to `{% slot %}` with `data` #}\n    {% fill \"tabs\" data=\"tabs_data\" %}\n        {% component \"TabItem\" header=\"Project Info\" %}\n            {% component \"ProjectInfo\"\n                project=project\n                project_tags=project_tags\n                attrs:class=\"py-5\"\n                attrs:width=tabs_data.width\n            / %}\n        {% endcomponent %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"#extended-template-tags","title":"Extended template tags","text":"<p><code>django-components</code> is designed for flexibility, making working with templates a breeze.</p> <p>It extends Django's template tags syntax with:</p> <ul> <li>Literal lists and dictionaries in the template</li> <li>Self-closing tags <code>{% mytag / %}</code></li> <li>Multi-line template tags</li> <li>Spread operator <code>...</code> to dynamically pass args or kwargs into the template tag</li> <li>Template tags inside literal strings like <code>\"{{ first_name }} {{ last_name }}\"</code></li> <li>Pass dictonaries by their key-value pairs <code>attr:key=val</code></li> </ul> <pre><code>{% component \"table\"\n    ...default_attrs\n    title=\"Friend list for {{ user.name }}\"\n    headers=[\"Name\", \"Age\", \"Email\"]\n    data=[\n        {\n            \"name\": \"John\"|upper,\n            \"age\": 30|add:1,\n            \"email\": \"john@example.com\",\n            \"hobbies\": [\"reading\"],\n        },\n        {\n            \"name\": \"Jane\"|upper,\n            \"age\": 25|add:1,\n            \"email\": \"jane@example.com\",\n            \"hobbies\": [\"reading\", \"coding\"],\n        },\n    ],\n    attrs:class=\"py-4 ma-2 border-2 border-gray-300 rounded-md\"\n/ %}\n</code></pre> <p>You too can define template tags with these features by using <code>@template_tag()</code> or <code>BaseNode</code>.</p> <p>Read more on Custom template tags.</p>"},{"location":"#full-programmatic-access","title":"Full programmatic access","text":"<p>When you render a component, you can access everything about the component:</p> <ul> <li>Component input: args, kwargs, slots and context</li> <li>Component's template, CSS and JS</li> <li>Django's context processors</li> <li>Unique render ID</li> </ul> <pre><code>class Table(Component):\n    js_file = \"table.js\"\n    css_file = \"table.css\"\n\n    template = \"\"\"\n        &lt;div class=\"table\"&gt;\n            &lt;span&gt;{{ variable }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's ID\n        assert self.id == \"djc1A2b3c\"\n\n        # Access component's inputs and slots\n        assert self.input.args == (123, \"str\")\n        assert self.input.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.input.slots[\"footer\"]\n        some_var = self.input.context[\"some_var\"]\n\n        # Access the request object and Django's context processors, if available\n        assert self.request.GET == {\"query\": \"something\"}\n        assert self.context_processors_data['user'].username == \"admin\"\n\n        return {\n            \"variable\": kwargs[\"variable\"],\n        }\n\n# Access component's HTML / JS / CSS\nTable.template\nTable.js\nTable.css\n\n# Render the component\nrendered = Table.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"footer\": \"MY_FOOTER\"},\n)\n</code></pre>"},{"location":"#granular-html-attributes","title":"Granular HTML attributes","text":"<p>Use the <code>{% html_attrs %}</code> template tag to render HTML attributes.</p> <p>It supports:</p> <ul> <li>Defining attributes as whole dictionaries or keyword arguments</li> <li>Merging attributes from multiple sources</li> <li>Boolean attributes</li> <li>Appending attributes</li> <li>Removing attributes</li> <li>Defining default attributes</li> </ul> <pre><code>&lt;div\n    {% html_attrs\n        attrs\n        defaults:class=\"default-class\"\n        class=\"extra-class\"\n    %}\n&gt;\n</code></pre> <p><code>{% html_attrs %}</code> offers a Vue-like granular control for <code>class</code> and <code>style</code> HTML attributes, where you can use a dictionary to manage each class name or style property separately.</p> <pre><code>{% html_attrs\n    class=\"foo bar\"\n    class={\n        \"baz\": True,\n        \"foo\": False,\n    }\n    class=\"extra\"\n%}\n</code></pre> <pre><code>{% html_attrs\n    style=\"text-align: center; background-color: blue;\"\n    style={\n        \"background-color\": \"green\",\n        \"color\": None,\n        \"width\": False,\n    }\n    style=\"position: absolute; height: 12px;\"\n%}\n</code></pre> <p>Read more about HTML attributes.</p>"},{"location":"#html-fragment-support","title":"HTML fragment support","text":"<p><code>django-components</code> makes integration with HTMX, AlpineJS or jQuery easy by allowing components to be rendered as HTML fragments:</p> <ul> <li> <p>Components's JS and CSS files are loaded automatically when the fragment is inserted into the DOM.</p> </li> <li> <p>Components can be exposed as Django Views with <code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code> methods</p> </li> <li> <p>Automatically create an endpoint for a component with <code>Component.View.public</code></p> </li> </ul> <pre><code># components/calendar/calendar.py\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n\n    class View:\n        # Register Component with `urlpatterns`\n        public = True\n\n        # Define handlers\n        def get(self, request, *args, **kwargs):\n            page = request.GET.get(\"page\", 1)\n            return self.component.render_to_response(\n                request=request,\n                kwargs={\n                    \"page\": page,\n                },\n            )\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"page\": kwargs[\"page\"],\n        }\n\n# Get auto-generated URL for the component\nurl = get_component_url(Calendar)\n\n# Or define explicit URL in urls.py\npath(\"calendar/\", Calendar.as_view())\n</code></pre>"},{"location":"#provide-inject","title":"Provide / Inject","text":"<p><code>django-components</code> supports the provide / inject pattern, similarly to React's Context Providers or Vue's provide / inject:</p> <ul> <li>Use the <code>{% provide %}</code> tag to provide data to the component tree</li> <li>Use the <code>Component.inject()</code> method to inject data into the component</li> </ul> <p>Read more about Provide / Inject.</p> <pre><code>&lt;body&gt;\n    {% provide \"theme\" variant=\"light\" %}\n        {% component \"header\" / %}\n    {% endprovide %}\n&lt;/body&gt;\n</code></pre> <pre><code>@register(\"header\")\nclass Header(Component):\n    template = \"...\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        theme = self.inject(\"theme\").variant\n        return {\n            \"theme\": theme,\n        }\n</code></pre>"},{"location":"#input-validation-and-static-type-hints","title":"Input validation and static type hints","text":"<p>Avoid needless errors with type hints and runtime input validation.</p> <p>To opt-in to input validation, define types for component's args, kwargs, slots, and more:</p> <pre><code>from typing import NamedTuple, Optional\nfrom django.template import Context\nfrom django_components import Component, Slot, SlotInput\n\nclass Button(Component):\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        variable: str\n        another: int\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        another_slot: SlotInput\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        args.size  # int\n        kwargs.variable  # str\n        slots.my_slot  # Slot[MySlotData]\n</code></pre> <p>To have type hints when calling <code>Button.render()</code> or <code>Button.render_to_response()</code>, wrap the inputs in their respective <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes:</p> <pre><code>Button.render(\n    # Error: First arg must be `int`, got `float`\n    args=Button.Args(\n        size=1.25,\n        text=\"abc\",\n    ),\n    # Error: Key \"another\" is missing\n    kwargs=Button.Kwargs(\n        variable=\"text\",\n    ),\n)\n</code></pre>"},{"location":"#extensions","title":"Extensions","text":"<p>Django-components functionality can be extended with Extensions. Extensions allow for powerful customization and integrations. They can:</p> <ul> <li>Tap into lifecycle events, such as when a component is created, deleted, or registered</li> <li>Add new attributes and methods to the components</li> <li>Add custom CLI commands</li> <li>Add custom URLs</li> </ul> <p>Some of the extensions include:</p> <ul> <li>Component caching</li> <li>Django View integration</li> <li>Component defaults</li> <li>Pydantic integration (input validation)</li> </ul> <p>Some of the planned extensions include:</p> <ul> <li>AlpineJS integration</li> <li>Storybook integration</li> <li>Component-level benchmarking with asv</li> </ul>"},{"location":"#caching","title":"Caching","text":"<ul> <li>Components can be cached using Django's cache framework.</li> <li>Caching rules can be configured on a per-component basis.</li> <li>Components are cached based on their input. Or you can write custom caching logic.</li> </ul> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n\n        def hash(self, *args, **kwargs):\n            return hash(f\"{json.dumps(args)}:{json.dumps(kwargs)}\")\n</code></pre>"},{"location":"#simple-testing","title":"Simple testing","text":"<ul> <li>Write tests for components with <code>@djc_test</code> decorator.</li> <li>The decorator manages global state, ensuring that tests don't leak.</li> <li>If using <code>pytest</code>, the decorator allows you to parametrize Django or Components settings.</li> <li>The decorator also serves as a stand-in for Django's <code>@override_settings</code>.</li> </ul> <pre><code>from django_components.testing import djc_test\n\nfrom components.my_table import MyTable\n\n@djc_test\ndef test_my_table():\n    rendered = MyTable.render(\n        kwargs={\n            \"title\": \"My table\",\n        },\n    )\n    assert rendered == \"&lt;table&gt;My table&lt;/table&gt;\"\n</code></pre>"},{"location":"#debugging-features","title":"Debugging features","text":"<ul> <li>Visual component inspection: Highlight components and slots directly in your browser.</li> <li>Detailed tracing logs to supply AI-agents with context: The logs include component and slot names and IDs, and their position in the tree.</li> </ul>"},{"location":"#sharing-components","title":"Sharing components","text":"<ul> <li>Install and use third-party components from PyPI</li> <li>Or publish your own \"component registry\"</li> <li> <p>Highly customizable - Choose how the components are called in the template (and more):</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}\n{% endcomponent %}\n\n{% calendar date=\"2024-11-06\" %}\n{% endcalendar %}\n</code></pre> </li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>Our aim is to be at least as fast as Django templates.</p> <p>As of <code>0.130</code>, <code>django-components</code> is ~4x slower than Django templates.</p> Render time django 68.9\u00b10.6ms django-components 259\u00b14ms <p>See the full performance breakdown for more information.</p>"},{"location":"#release-notes","title":"Release notes","text":"<p>Read the Release Notes to see the latest features and fixes.</p>"},{"location":"#community-examples","title":"Community examples","text":"<p>One of our goals with <code>django-components</code> is to make it easy to share components between projects. Head over to the Community examples to see some examples.</p>"},{"location":"#contributing-and-development","title":"Contributing and development","text":"<p>Get involved or sponsor this project - See here</p> <p>Running django-components locally for development - See here</p>"},{"location":"migrating_from_safer_staticfiles/","title":"Migrating from safer_staticfiles","text":"<p>This guide is for you if you're upgrating django_components to v0.100 or later from older versions.</p> <p>In version 0.100, we changed how components' static JS and CSS files are handled. See more in the \"Static files\" section.</p> <p>Migration steps:</p> <ol> <li>Remove <code>django_components.safer_staticfiles</code> from <code>INSTALLED_APPS</code> in your <code>settings.py</code>,    and replace it with <code>django.contrib.staticfiles</code>.</li> </ol> <p>Before:</p> <pre><code>INSTALLED_APPS = [\n   \"django.contrib.admin\",\n   ...\n   # \"django.contrib.staticfiles\",  # &lt;-- ADD\n   \"django_components\",\n   \"django_components.safer_staticfiles\",  # &lt;-- REMOVE\n]\n</code></pre> <p>After:</p> <pre><code>INSTALLED_APPS = [\n   \"django.contrib.admin\",\n   ...\n   \"django.contrib.staticfiles\",\n   \"django_components\",\n]\n</code></pre> <ol> <li>Add <code>STATICFILES_FINDERS</code> to <code>settings.py</code>, and add <code>django_components.finders.ComponentsFileSystemFinder</code>:</li> </ol> <pre><code>STATICFILES_FINDERS = [\n   # Default finders\n   \"django.contrib.staticfiles.finders.FileSystemFinder\",\n   \"django.contrib.staticfiles.finders.AppDirectoriesFinder\",\n   # Django components\n   \"django_components.finders.ComponentsFileSystemFinder\",  # &lt;-- ADDED\n]\n</code></pre> <ol> <li>Add <code>COMPONENTS.dirs</code> to <code>settings.py</code>.</li> </ol> <p>If you previously defined <code>STATICFILES_DIRS</code>, move    only those directories from <code>STATICFILES_DIRS</code> that point to components directories, and keep the rest.</p> <p>E.g. if you have <code>STATICFILES_DIRS</code> like this:</p> <pre><code>STATICFILES_DIRS = [\n   BASE_DIR / \"components\",  # &lt;-- MOVE\n   BASE_DIR / \"myapp\" / \"components\",  # &lt;-- MOVE\n   BASE_DIR / \"assets\",\n]\n</code></pre> <p>Then first two entries point to components dirs, whereas <code>/assets</code> points to non-component static files.    In this case move only the first two paths:</p> <pre><code>COMPONENTS = {\n   \"dirs\": [\n      BASE_DIR / \"components\",  # &lt;-- MOVED\n      BASE_DIR / \"myapp\" / \"components\",  # &lt;-- MOVED\n   ],\n}\n\nSTATICFILES_DIRS = [\n   BASE_DIR / \"assets\",\n]\n</code></pre> <p>Moreover, if you defined app-level component directories in <code>STATICFILES_DIRS</code> before,    you can now define as a RELATIVE path in <code>app_dirs</code>:</p> <pre><code>COMPONENTS = {\n   \"dirs\": [\n      # Search top-level \"/components/\" dir\n      BASE_DIR / \"components\",\n   ],\n   \"app_dirs\": [\n      # Search \"/[app]/components/\" dirs\n      \"components\",\n   ],\n}\n\nSTATICFILES_DIRS = [\n   BASE_DIR / \"assets\",\n]\n</code></pre>"},{"location":"release_notes/","title":"Release notes","text":""},{"location":"release_notes/#v01400","title":"\ud83d\udea8\ud83d\udce2 v0.140.0","text":""},{"location":"release_notes/#breaking-changes","title":"\ud83d\udea8\ud83d\udce2 BREAKING CHANGES","text":"<ul> <li> <p>Component typing no longer uses generics. Instead, the types are now defined as class attributes of the component class.</p> <p>Before:</p> <pre><code>Args = Tuple[float, str]\n\nclass Button(Component[Args]):\n    pass\n</code></pre> <p>After:</p> <pre><code>class Button(Component):\n    class Args(NamedTuple):\n        size: float\n        text: str\n</code></pre> <p>See Migrating from generics to class attributes for more info.</p> </li> <li> <p>The interface of the not-yet-released <code>get_js_data()</code> and <code>get_css_data()</code> methods has changed to   match <code>get_template_data()</code>.</p> <p>Before:</p> <pre><code>def get_js_data(self, *args, **kwargs):\ndef get_css_data(self, *args, **kwargs):\n</code></pre> <p>After:</p> <pre><code>def get_js_data(self, args, kwargs, slots, context):\ndef get_css_data(self, args, kwargs, slots, context):\n</code></pre> </li> <li> <p>Removed <code>EmptyTuple</code> and <code>EmptyDict</code> types. Instead, there is now a single <code>Empty</code> type.</p> <pre><code>from django_components import Component, Empty\n\nclass Button(Component):\n    template = \"Hello\"\n\n    Args = Empty\n    Kwargs = Empty\n</code></pre> </li> <li> <p>Arguments in <code>Component.render_to_response()</code> have changed   to match that of <code>Component.render()</code>.</p> <p>Please ensure that you pass the parameters as kwargs, not as positional arguments, to avoid breaking changes.</p> <p>The signature changed, moving the <code>args</code> and <code>kwargs</code> parameters to 2nd and 3rd position.</p> <p>Next, the <code>render_dependencies</code> parameter was added to match <code>Component.render()</code>.</p> <p>Lastly:</p> <ul> <li>Previously, any extra ARGS and KWARGS were passed to the <code>response_class</code>.</li> <li>Now, only extra KWARGS will be passed to the <code>response_class</code>.</li> </ul> <p>Before:</p> <pre><code>  def render_to_response(\n      cls,\n      context: Optional[Union[Dict[str, Any], Context]] = None,\n      slots: Optional[SlotsType] = None,\n      escape_slots_content: bool = True,\n      args: Optional[ArgsType] = None,\n      kwargs: Optional[KwargsType] = None,\n      deps_strategy: DependenciesStrategy = \"document\",\n      request: Optional[HttpRequest] = None,\n      *response_args: Any,\n      **response_kwargs: Any,\n  ) -&gt; HttpResponse:\n</code></pre> <p>After:</p> <pre><code>def render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[Tuple[Any, ...]] = None,\n    kwargs: Optional[Mapping] = None,\n    slots: Optional[Mapping] = None,\n    escape_slots_content: bool = True,\n    deps_strategy: DependenciesStrategy = \"document\",\n    render_dependencies: bool = True,\n    request: Optional[HttpRequest] = None,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n</code></pre> </li> <li> <p>The <code>Component.Url</code> class was merged with <code>Component.View</code>.</p> <p>Instead of <code>Component.Url.public</code>, use <code>Component.View.public</code>.</p> <p>If you imported <code>ComponentUrl</code> from <code>django_components</code>, you need to update your import to <code>ComponentView</code>.</p> <p>Before:</p> <pre><code>class MyComponent(Component):\n    class Url:\n        public = True\n\n    class View:\n        def get(self, request):\n            return self.render_to_response()\n</code></pre> <p>After:</p> <pre><code>class MyComponent(Component):\n    class View:\n        public = True\n\n        def get(self, request):\n            return self.render_to_response()\n</code></pre> </li> <li> <p>Component name in the <code>{% component %}</code> tag can no longer be set as a kwarg.</p> <p>Instead, the component name MUST be the first POSITIONAL argument only.</p> <p>Before, it was possible to set the component name as a kwarg and put it anywhere in the <code>{% component %}</code> tag:</p> <pre><code>{% component rows=rows headers=headers name=\"my_table\" ... / %}\n</code></pre> <p>Now, the component name MUST be the first POSITIONAL argument:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n</code></pre> <p>Thus, the <code>name</code> kwarg can now be used as a regular input.</p> <pre><code>{% component \"profile\" name=\"John\" job=\"Developer\" / %}\n</code></pre> </li> <li> <p>The second argument to <code>render_dependencies()</code> is now <code>strategy</code> instead of <code>type</code>.</p> <p>Before:</p> <pre><code>render_dependencies(content, type=\"document\")\n</code></pre> <p>After:</p> <pre><code>render_dependencies(content, strategy=\"document\")\n</code></pre> </li> </ul>"},{"location":"release_notes/#deprecation","title":"\ud83d\udea8\ud83d\udce2 Deprecation","text":"<ul> <li> <p><code>get_context_data()</code> is now deprecated. Use <code>get_template_data()</code> instead.</p> <p><code>get_template_data()</code> behaves the same way, but has a different function signature to accept also slots and context.</p> <p>Since <code>get_context_data()</code> is widely used, it will remain available until v2.</p> </li> <li> <p>The <code>type</code> kwarg in <code>Component.render()</code> and <code>Component.render_to_response()</code> is now deprecated. Use <code>deps_strategy</code> instead. The <code>type</code> kwarg will be removed in v1.</p> <p>Before:</p> <pre><code>Calendar.render_to_response(type=\"fragment\")\n</code></pre> <p>After:</p> <pre><code>Calendar.render_to_response(deps_strategy=\"fragment\")\n</code></pre> </li> <li> <p><code>SlotContent</code> was renamed to <code>SlotInput</code>. The old name is deprecated and will be removed in v1.</p> </li> </ul>"},{"location":"release_notes/#feat","title":"Feat","text":"<ul> <li> <p>New method to render template variables - <code>get_template_data()</code></p> <p><code>get_template_data()</code> behaves the same way as <code>get_context_data()</code>, but has a different function signature to accept also slots and context.</p> <pre><code>class Button(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"val1\": args[0],\n            \"val2\": kwargs[\"field\"],\n        }\n</code></pre> <p>If you define <code>Component.Args</code>, <code>Component.Kwargs</code>, <code>Component.Slots</code>, then the <code>args</code>, <code>kwargs</code>, <code>slots</code> arguments will be instances of these classes:</p> <pre><code>class Button(Component):\n    class Args(NamedTuple):\n        field1: str\n\n    class Kwargs(NamedTuple):\n        field2: int\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots, context):\n        return {\n            \"val1\": args.field1,\n            \"val2\": kwargs.field2,\n        }\n</code></pre> </li> <li> <p>Input validation is now part of the render process.</p> <p>When you specify the input types (such as <code>Component.Args</code>, <code>Component.Kwargs</code>, etc), the actual inputs to data methods (<code>Component.get_template_data()</code>, etc) will be instances of the types you specified.</p> <p>This practically brings back input validation, because the instantiation of the types will raise an error if the inputs are not valid.</p> <p>Read more on Typing and validation</p> </li> <li> <p>Render emails or other non-browser HTML with new \"dependencies render strategies\"</p> <p>When rendering a component with <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>deps_strategy</code> kwarg (previously <code>type</code>) now accepts a new options <code>\"simple\"</code>, <code>\"prepend\"</code>, or <code>\"append\"</code>.</p> <pre><code>Calendar.render_to_response(\n    request=request,\n    kwargs={\n        \"date\": request.GET.get(\"date\", \"\"),\n    },\n    deps_strategy=\"append\",\n)\n</code></pre> <p>Comparison of dependencies render strategies:</p> <ul> <li><code>\"document\"</code><ul> <li>Smartly inserts JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Inserts extra script to allow <code>fragment</code> strategy to work.</li> <li>Assumes the HTML will be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>\"fragment\"</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>Ignores placeholders and any <code>&lt;head&gt;</code> / <code>&lt;body&gt;</code> tags.</li> <li>No JS / CSS included.</li> </ul> </li> <li><code>\"simple\"</code><ul> <li>Smartly insert JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"prepend\"</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>Ignores placeholders and any <code>&lt;head&gt;</code> / <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"append\"</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>Ignores placeholders and any <code>&lt;head&gt;</code> / <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> </ul> </li> <li> <p><code>get_component_url()</code> now optionally accepts <code>query</code> and <code>fragment</code> arguments.</p> <pre><code>from django_components import get_component_url\n\nurl = get_component_url(\n    MyComponent,\n    query={\"foo\": \"bar\"},\n    fragment=\"baz\",\n)\n# /components/ext/view/components/c1ab2c3?foo=bar#baz\n</code></pre> </li> </ul>"},{"location":"release_notes/#v01391","title":"v0.139.1","text":""},{"location":"release_notes/#fix","title":"Fix","text":"<ul> <li>Fix compatibility of component caching with <code>{% extend %}</code> block (#1135)</li> </ul>"},{"location":"release_notes/#refactor","title":"Refactor","text":"<ul> <li> <p>Component ID is now prefixed with <code>c</code>, e.g. <code>c123456</code>.</p> </li> <li> <p>When typing a Component, you can now specify as few or as many parameters as you want.</p> <pre><code>Component[Args]\nComponent[Args, Kwargs]\nComponent[Args, Kwargs, Slots]\nComponent[Args, Kwargs, Slots, Data]\nComponent[Args, Kwargs, Slots, Data, JsData]\nComponent[Args, Kwargs, Slots, Data, JsData, CssData]\n</code></pre> <p>All omitted parameters will default to <code>Any</code>.</p> </li> <li> <p>Added <code>typing_extensions</code> to the project as a dependency</p> </li> <li> <p>Multiple extensions with the same name (case-insensitive) now raise an error</p> </li> <li> <p>Extension names (case-insensitive) also MUST NOT conflict with existing Component class API.</p> <p>So if you name an extension <code>render</code>, it will conflict with the <code>render()</code> method of the <code>Component</code> class, and thus raise an error.</p> </li> </ul>"},{"location":"release_notes/#v01390","title":"v0.139.0","text":""},{"location":"release_notes/#fix_1","title":"Fix","text":"<ul> <li>Fix bug: Fix compatibility with <code>Finder.find()</code> in Django 5.2 (#1119)</li> </ul>"},{"location":"release_notes/#v0138","title":"v0.138","text":""},{"location":"release_notes/#fix_2","title":"Fix","text":"<ul> <li>Fix bug: Allow components with <code>Url.public = True</code> to be defined before <code>django.setup()</code></li> </ul>"},{"location":"release_notes/#v0137","title":"v0.137","text":""},{"location":"release_notes/#feat_1","title":"Feat","text":"<ul> <li> <p>Each Component class now has a <code>class_id</code> attribute, which is unique to the component subclass.</p> <p>NOTE: This is different from <code>Component.id</code>, which is unique to each rendered instance.</p> <p>To look up a component class by its <code>class_id</code>, use <code>get_component_by_class_id()</code>.</p> </li> <li> <p>It's now easier to create URLs for component views.</p> <p>Before, you had to call <code>Component.as_view()</code> and pass that to <code>urlpatterns</code>.</p> <p>Now this can be done for you if you set <code>Component.Url.public</code> to <code>True</code>:</p> <pre><code>class MyComponent(Component):\n    class Url:\n        public = True\n    ...\n</code></pre> <p>Then, to get the URL for the component, use <code>get_component_url()</code>:</p> <pre><code>from django_components import get_component_url\n\nurl = get_component_url(MyComponent)\n</code></pre> <p>This way you don't have to mix your app URLs with component URLs.</p> <p>Read more on Component views and URLs.</p> </li> <li> <p>Per-component caching - Set <code>Component.Cache.enabled</code> to <code>True</code> to enable caching for a component.</p> <p>Component caching allows you to store the rendered output of a component. Next time the component is rendered with the same input, the cached output is returned instead of re-rendering the component.</p> <pre><code>class TestComponent(Component):\n    template = \"Hello\"\n\n    class Cache:\n        enabled = True\n        ttl = 0.1  # .1 seconds TTL\n        cache_name = \"custom_cache\"\n\n        # Custom hash method for args and kwargs\n        # NOTE: The default implementation simply serializes the input into a string.\n        #       As such, it might not be suitable for complex objects like Models.\n        def hash(self, *args, **kwargs):\n            return f\"{json.dumps(args)}:{json.dumps(kwargs)}\"\n</code></pre> <p>Read more on Component caching.</p> </li> <li> <p><code>@djc_test</code> can now be called without first calling <code>django.setup()</code>, in which case it does it for you.</p> </li> <li> <p>Expose <code>ComponentInput</code> class, which is a typing for <code>Component.input</code>.</p> </li> </ul>"},{"location":"release_notes/#deprecation_1","title":"Deprecation","text":"<ul> <li> <p>Currently, view request handlers such as <code>get()</code> and <code>post()</code> methods can be defined   directly on the <code>Component</code> class:</p> <pre><code>class MyComponent(Component):\n    def get(self, request):\n        return self.render_to_response()\n</code></pre> <p>Or, nested within the <code>Component.View</code> class:</p> <pre><code>class MyComponent(Component):\n    class View:\n        def get(self, request):\n            return self.render_to_response()\n</code></pre> <p>In v1, these methods should be defined only on the <code>Component.View</code> class instead.</p> </li> </ul>"},{"location":"release_notes/#refactor_1","title":"Refactor","text":"<ul> <li><code>Component.get_context_data()</code> can now omit a return statement or return <code>None</code>.</li> </ul>"},{"location":"release_notes/#v0136","title":"\ud83d\udea8\ud83d\udce2 v0.136","text":""},{"location":"release_notes/#breaking-changes_1","title":"\ud83d\udea8\ud83d\udce2 BREAKING CHANGES","text":"<ul> <li> <p>Component input validation was moved to a separate extension <code>djc-ext-pydantic</code>.</p> <p>If you relied on components raising errors when inputs were invalid, you need to install <code>djc-ext-pydantic</code> and add it to extensions:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"extensions\": [\n        \"djc_pydantic.PydanticExtension\",\n    ],\n}\n</code></pre> </li> </ul>"},{"location":"release_notes/#fix_3","title":"Fix","text":"<ul> <li>Make it possible to resolve URLs added by extensions by their names</li> </ul>"},{"location":"release_notes/#v0135","title":"v0.135","text":""},{"location":"release_notes/#feat_2","title":"Feat","text":"<ul> <li>Add defaults for the component inputs with the <code>Component.Defaults</code> nested class. Defaults   are applied if the argument is not given, or if it set to <code>None</code>.</li> </ul> <p>For lists, dictionaries, or other objects, wrap the value in <code>Default()</code> class to mark it as a factory   function:</p> <pre><code>```python\nfrom django_components import Default\n\nclass Table(Component):\n    class Defaults:\n        position = \"left\"\n        width = \"200px\"\n        options = Default(lambda: [\"left\", \"right\", \"center\"])\n\n    def get_context_data(self, position, width, options):\n        return {\n            \"position\": position,\n            \"width\": width,\n            \"options\": options,\n        }\n\n# `position` is used as given, `\"right\"`\n# `width` uses default because it's `None`\n# `options` uses default because it's missing\nTable.render(\n    kwargs={\n        \"position\": \"right\",\n        \"width\": None,\n    }\n)\n```\n</code></pre> <ul> <li> <p><code>{% html_attrs %}</code> now offers a Vue-like granular control over <code>class</code> and <code>style</code> HTML attributes, where each class name or style property can be managed separately.</p> <pre><code>{% html_attrs\n    class=\"foo bar\"\n    class={\"baz\": True, \"foo\": False}\n    class=\"extra\"\n%}\n</code></pre> <pre><code>{% html_attrs\n    style=\"text-align: center; background-color: blue;\"\n    style={\"background-color\": \"green\", \"color\": None, \"width\": False}\n    style=\"position: absolute; height: 12px;\"\n%}\n</code></pre> <p>Read more on HTML attributes.</p> </li> </ul>"},{"location":"release_notes/#fix_4","title":"Fix","text":"<ul> <li>Fix compat with Windows when reading component files (#1074)</li> <li>Fix resolution of component media files edge case (#1073)</li> </ul>"},{"location":"release_notes/#v0134","title":"v0.134","text":""},{"location":"release_notes/#fix_5","title":"Fix","text":"<ul> <li>HOTFIX: Fix the use of URLs in <code>Component.Media.js</code> and <code>Component.Media.css</code></li> </ul>"},{"location":"release_notes/#v0133","title":"v0.133","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.134 to fix bugs introduced in v0.132.</p>"},{"location":"release_notes/#fix_6","title":"Fix","text":"<ul> <li>HOTFIX: Fix the use of URLs in <code>Component.Media.js</code> and <code>Component.Media.css</code></li> </ul>"},{"location":"release_notes/#v0132","title":"v0.132","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.134 to fix bugs introduced in v0.132.</p>"},{"location":"release_notes/#feat_3","title":"Feat","text":"<ul> <li> <p>Allow to use glob patterns as paths for additional JS / CSS in   <code>Component.Media.js</code> and <code>Component.Media.css</code></p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = [\"*.js\"]\n        css = [\"*.css\"]\n</code></pre> </li> </ul>"},{"location":"release_notes/#fix_7","title":"Fix","text":"<ul> <li>Fix installation for Python 3.13 on Windows.</li> </ul>"},{"location":"release_notes/#v0131","title":"v0.131","text":""},{"location":"release_notes/#feat_4","title":"Feat","text":"<ul> <li> <p>Support for extensions (plugins) for django-components!</p> <ul> <li>Hook into lifecycle events of django-components</li> <li>Pre-/post-process component inputs, outputs, and templates</li> <li>Add extra methods or attributes to Components</li> <li>Add custom extension-specific CLI commands</li> <li>Add custom extension-specific URL routes</li> </ul> <p>Read more on Extensions.</p> </li> <li> <p>New CLI commands:</p> <ul> <li><code>components list</code> - List all components</li> <li><code>components create &lt;name&gt;</code> - Create a new component (supersedes <code>startcomponent</code>)</li> <li><code>components upgrade</code> - Upgrade a component (supersedes <code>upgradecomponent</code>)</li> <li><code>components ext list</code> - List all extensions</li> <li><code>components ext run &lt;extension&gt; &lt;command&gt;</code> - Run a command added by an extension</li> </ul> </li> <li> <p><code>@djc_test</code> decorator for writing tests that involve Components.</p> <ul> <li>The decorator manages global state, ensuring that tests don't leak.</li> <li>If using <code>pytest</code>, the decorator allows you to parametrize Django or Components settings.</li> <li>The decorator also serves as a stand-in for Django's <code>@override_settings</code>.</li> </ul> <p>See the API reference for <code>@djc_test</code> for more details.</p> </li> <li> <p><code>ComponentRegistry</code> now has a <code>has()</code> method to check if a component is registered    without raising an error.</p> </li> <li> <p>Get all created <code>Component</code> classes with <code>all_components()</code>.</p> </li> <li> <p>Get all created <code>ComponentRegistry</code> instances with <code>all_registries()</code>.</p> </li> </ul>"},{"location":"release_notes/#refactor_2","title":"Refactor","text":"<ul> <li> <p>The <code>startcomponent</code> and <code>upgradecomponent</code> commands are deprecated, and will be removed in v1.</p> <p>Instead, use <code>components create &lt;name&gt;</code> and <code>components upgrade</code>.</p> </li> </ul>"},{"location":"release_notes/#internal","title":"Internal","text":"<ul> <li>Settings are now loaded only once, and thus are considered immutable once loaded. Previously,   django-components would load settings from <code>settings.COMPONENTS</code> on each access. The new behavior   aligns with Django's settings.</li> </ul>"},{"location":"release_notes/#v0130","title":"v0.130","text":""},{"location":"release_notes/#feat_5","title":"Feat","text":"<ul> <li> <p>Access the HttpRequest object under <code>Component.request</code>.</p> <p>To pass the request object to a component, either: - Render a template or component with <code>RequestContext</code>, - Or set the <code>request</code> kwarg to <code>Component.render()</code> or <code>Component.render_to_response()</code>.</p> <p>Read more on HttpRequest.</p> </li> <li> <p>Access the context processors data under <code>Component.context_processors_data</code>.</p> <p>Context processors data is available only when the component has access to the <code>request</code> object, either by: - Passing the request to <code>Component.render()</code> or <code>Component.render_to_response()</code>, - Or by rendering a template or component with <code>RequestContext</code>, - Or being nested in another component that has access to the request object.</p> <p>The data from context processors is automatically available within the component's template.</p> <p>Read more on HttpRequest.</p> </li> </ul>"},{"location":"release_notes/#v0129","title":"v0.129","text":""},{"location":"release_notes/#fix_8","title":"Fix","text":"<ul> <li>Fix thread unsafe media resolve validation by moving it to ComponentMedia <code>__post_init</code> (#977</li> <li>Fix bug: Relative path in extends and include does not work when using template_file (#976</li> <li>Fix error when template cache setting (<code>template_cache_size</code>) is set to 0 (#974</li> </ul>"},{"location":"release_notes/#v0128","title":"v0.128","text":""},{"location":"release_notes/#feat_6","title":"Feat","text":"<ul> <li> <p>Configurable cache - Set <code>COMPONENTS.cache</code> to change where and how django-components caches JS and CSS files. (#946)</p> <p>Read more on Caching.</p> </li> <li> <p>Highlight coponents and slots in the UI - We've added two boolean settings <code>COMPONENTS.debug_highlight_components</code> and <code>COMPONENTS.debug_highlight_slots</code>, which can be independently set to <code>True</code>. First will wrap components in a blue border, the second will wrap slots in a red border. (#942)</p> <p>Read more on Troubleshooting.</p> </li> </ul>"},{"location":"release_notes/#refactor_3","title":"Refactor","text":"<ul> <li>Removed use of eval for node validation (#944)</li> </ul>"},{"location":"release_notes/#perf","title":"Perf","text":"<ul> <li> <p>Components can now be infinitely nested. (#936)</p> </li> <li> <p>Component input validation is now 6-7x faster on CPython and PyPy. This previously made up 10-30% of the total render time. (#945)</p> </li> </ul>"},{"location":"release_notes/#v0127","title":"v0.127","text":""},{"location":"release_notes/#fix_9","title":"Fix","text":"<ul> <li>Fix component rendering when using <code>{% cache %}</code> with remote cache and multiple web servers (#930)</li> </ul>"},{"location":"release_notes/#v0126","title":"v0.126","text":""},{"location":"release_notes/#refactor_4","title":"Refactor","text":"<ul> <li>Replaced BeautifulSoup4 with a custom HTML parser.</li> <li>The heuristic for inserting JS and CSS dependenies into the default place has changed.<ul> <li>JS is still inserted at the end of the <code>&lt;body&gt;</code>, and CSS at the end of <code>&lt;head&gt;</code>.</li> <li>However, we find end of <code>&lt;body&gt;</code> by searching for last occurrence of <code>&lt;/body&gt;</code></li> <li>And for the end of <code>&lt;head&gt;</code> we search for the first occurrence of <code>&lt;/head&gt;</code></li> </ul> </li> </ul>"},{"location":"release_notes/#v0125","title":"v0.125","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - We migrated from <code>EmilStenstrom/django-components</code> to <code>django-components/django-components</code>.</p> <p>Repo name and documentation URL changed. Package name remains the same.</p> <p>If you see any broken links or other issues, please report them in #922.</p>"},{"location":"release_notes/#feat_7","title":"Feat","text":"<ul> <li><code>@template_tag</code> and <code>BaseNode</code> - A decorator and a class that allow you to define   custom template tags that will behave similarly to django-components' own template tags.</li> </ul> <p>Read more on Template tags.</p> <p>Template tags defined with <code>@template_tag</code> and <code>BaseNode</code> will have the following features:</p> <ul> <li> <p>Accepting args, kwargs, and flags.</p> </li> <li> <p>Allowing literal lists and dicts as inputs as:</p> <p><code>key=[1, 2, 3]</code> or <code>key={\"a\": 1, \"b\": 2}</code>   - Using template tags tag inputs as:</p> <p><code>{% my_tag key=\"{% lorem 3 w %}\" / %}</code>   - Supporting the flat dictionary definition:</p> <p><code>attr:key=value</code>   - Spreading args and kwargs with <code>...</code>:</p> <p><code>{% my_tag ...args ...kwargs / %}</code>   - Being able to call the template tag as:</p> <p><code>{% my_tag %} ... {% endmy_tag %}</code> or <code>{% my_tag / %}</code></p> </li> </ul>"},{"location":"release_notes/#refactor_5","title":"Refactor","text":"<ul> <li> <p>Refactored template tag input validation. When you now call template tags like   <code>{% slot %}</code>, <code>{% fill %}</code>, <code>{% html_attrs %}</code>, and others, their inputs are now   validated the same way as Python function inputs are.</p> <p>So, for example</p> <pre><code>{% slot \"my_slot\" name=\"content\" / %}\n</code></pre> <p>will raise an error, because the positional argument <code>name</code> is given twice.</p> <p>NOTE: Special kwargs whose keys are not valid Python variable names are not affected by this change. So when you define:</p> <pre><code>{% component data-id=123 / %}\n</code></pre> <p>The <code>data-id</code> will still be accepted as a valid kwarg, assuming that your <code>get_context_data()</code> accepts <code>**kwargs</code>:</p> <pre><code>def get_context_data(self, **kwargs):\n    return {\n        \"data_id\": kwargs[\"data-id\"],\n    }\n</code></pre> </li> </ul>"},{"location":"release_notes/#v0124","title":"v0.124","text":""},{"location":"release_notes/#feat_8","title":"Feat","text":"<ul> <li> <p>Instead of inlining the JS and CSS under <code>Component.js</code> and <code>Component.css</code>, you can move     them to their own files, and link the JS/CSS files with <code>Component.js_file</code>  and <code>Component.css_file</code>.</p> <p>Even when you specify the JS/CSS with <code>Component.js_file</code> or <code>Component.css_file</code>, then you can still access the content under <code>Component.js</code> or <code>Component.css</code> - behind the scenes, the content of the JS/CSS files will be set to <code>Component.js</code> / <code>Component.css</code> upon first access.</p> <p>The same applies to <code>Component.template_file</code>, which will populate <code>Component.template</code> upon first access.</p> <p>With this change, the role of <code>Component.js/css</code> and the JS/CSS in <code>Component.Media</code> has changed:</p> <ul> <li>The JS/CSS defined in <code>Component.js/css</code> or <code>Component.js/css_file</code> is the \"main\" JS/CSS</li> <li>The JS/CSS defined in <code>Component.Media.js/css</code> are secondary or additional</li> </ul> <p>See the updated \"Getting Started\" tutorial</p> </li> </ul>"},{"location":"release_notes/#refactor_6","title":"Refactor","text":"<ul> <li> <p>The canonical way to define a template file was changed from <code>template_name</code> to <code>template_file</code>, to align with the rest of the API.</p> <p><code>template_name</code> remains for backwards compatibility. When you get / set <code>template_name</code>, internally this is proxied to <code>template_file</code>.</p> </li> <li> <p>The undocumented <code>Component.component_id</code> was removed. Instead, use <code>Component.id</code>. Changes:</p> <ul> <li>While <code>component_id</code> was unique every time you instantiated <code>Component</code>, the new <code>id</code> is unique every time you render the component (e.g. with <code>Component.render()</code>)</li> <li>The new <code>id</code> is available only during render, so e.g. from within <code>get_context_data()</code></li> </ul> </li> <li> <p>Component's HTML / CSS / JS are now resolved and loaded lazily. That is, if you specify <code>template_name</code>/<code>template_file</code>,   <code>js_file</code>, <code>css_file</code>, or <code>Media.js/css</code>, the file paths will be resolved only once you:</p> <ol> <li>Try to access component's HTML / CSS / JS, or</li> <li>Render the component.</li> </ol> <p>Read more on Accessing component's HTML / JS / CSS.</p> </li> <li> <p>Component inheritance:</p> <ul> <li>When you subclass a component, the JS and CSS defined on parent's <code>Media</code> class is now inherited by the child component.</li> <li>You can disable or customize Media inheritance by setting <code>extend</code> attribute on the <code>Component.Media</code> nested class. This work similarly to Django's <code>Media.extend</code>.</li> <li>When child component defines either <code>template</code> or <code>template_file</code>, both of parent's <code>template</code> and <code>template_file</code> are ignored. The same applies to <code>js_file</code> and <code>css_file</code>.</li> </ul> </li> <li> <p>Autodiscovery now ignores files and directories that start with an underscore (<code>_</code>), except <code>__init__.py</code></p> </li> <li> <p>The Signals emitted by or during the use of django-components are now documented, together the <code>template_rendered</code> signal.</p> </li> </ul>"},{"location":"release_notes/#v0123","title":"v0.123","text":""},{"location":"release_notes/#fix_10","title":"Fix","text":"<ul> <li>Fix edge cases around rendering components whose templates used the <code>{% extends %}</code> template tag (#859)</li> </ul>"},{"location":"release_notes/#v0122","title":"v0.122","text":""},{"location":"release_notes/#feat_9","title":"Feat","text":"<ul> <li>Add support for HTML fragments. HTML fragments can be rendered by passing <code>type=\"fragment\"</code> to <code>Component.render()</code> or <code>Component.render_to_response()</code>. Read more on how to use HTML fragments with HTMX, AlpineJS, or vanillaJS.</li> </ul>"},{"location":"release_notes/#v0121","title":"v0.121","text":""},{"location":"release_notes/#fix_11","title":"Fix","text":"<ul> <li>Fix the use of Django template filters (<code>|lower:\"etc\"</code>) with component inputs #855.</li> </ul>"},{"location":"release_notes/#v0120","title":"v0.120","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.121 to fix bugs introduced in v0.119.</p>"},{"location":"release_notes/#fix_12","title":"Fix","text":"<ul> <li>Fix the use of translation strings <code>_(\"bla\")</code> as inputs to components #849.</li> </ul>"},{"location":"release_notes/#v0119","title":"v0.119","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - This release introduced bugs #849, #855. Please update to v0.121.</p>"},{"location":"release_notes/#fix_13","title":"Fix","text":"<ul> <li>Fix compatibility with custom subclasses of Django's <code>Template</code> that need to access   <code>origin</code> or other initialization arguments. (https://github.com/django-components/django-components/pull/828)</li> </ul>"},{"location":"release_notes/#refactor_7","title":"Refactor","text":"<ul> <li>Compatibility with <code>django-debug-toolbar-template-profiler</code>:</li> <li> <p>Monkeypatching of Django's <code>Template</code> now happens at <code>AppConfig.ready()</code> (https://github.com/django-components/django-components/pull/825)</p> </li> <li> <p>Internal parsing of template tags tag was updated. No API change. (https://github.com/django-components/django-components/pull/827)</p> </li> </ul>"},{"location":"release_notes/#v0118","title":"v0.118","text":""},{"location":"release_notes/#feat_10","title":"Feat","text":"<ul> <li>Add support for <code>context_processors</code> and <code>RenderContext</code> inside component templates</li> </ul> <p><code>Component.render()</code> and <code>Component.render_to_response()</code> now accept an extra kwarg <code>request</code>.</p> <pre><code>```py\ndef my_view(request)\n    return MyTable.render_to_response(\n        request=request\n    )\n```\n</code></pre> <ul> <li> <p>When you pass in <code>request</code>, the component will use <code>RenderContext</code> instead of <code>Context</code>.     Thus the context processors will be applied to the context.</p> </li> <li> <p>NOTE: When you pass in both <code>request</code> and <code>context</code> to <code>Component.render()</code>, and <code>context</code> is already an instance of <code>Context</code>, the <code>request</code> kwarg will be ignored.</p> </li> </ul>"},{"location":"release_notes/#v0117","title":"v0.117","text":""},{"location":"release_notes/#fix_14","title":"Fix","text":"<ul> <li>The HTML parser no longer erronously inserts <code>&lt;html&gt;&lt;head&gt;&lt;body&gt;</code> on some occasions, and   no longer tries to close unclosed HTML tags.</li> </ul>"},{"location":"release_notes/#refactor_8","title":"Refactor","text":"<ul> <li>Replaced Selectolax with BeautifulSoup4 as project dependencies.</li> </ul>"},{"location":"release_notes/#v0116","title":"v0.116","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"release_notes/#fix_15","title":"Fix","text":"<ul> <li>Fix the order of execution of JS scripts:</li> <li>Scripts in <code>Component.Media.js</code> are executed in the order they are defined</li> <li> <p>Scripts in <code>Component.js</code> are executed AFTER <code>Media.js</code> scripts</p> </li> <li> <p>Fix compatibility with AlpineJS</p> </li> <li>Scripts in <code>Component.Media.js</code> are now again inserted as <code>&lt;script&gt;</code> tags</li> <li>By default, <code>Component.Media.js</code> are inserted as synchronous <code>&lt;script&gt;</code> tags,     so the AlpineJS components registered in the <code>Media.js</code> scripts will now again     run BEFORE the core AlpineJS script.</li> </ul> <p>AlpineJS can be configured like so:</p> <p>Option 1 - AlpineJS loaded in <code>&lt;head&gt;</code> with <code>defer</code> attribute:   <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    {% component_css_dependencies %}\n    &lt;script defer src=\"https://unpkg.com/alpinejs\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component 'my_alpine_component' / %}\n    {% component_js_dependencies %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>Option 2 - AlpineJS loaded in <code>&lt;body&gt;</code> AFTER <code>{% component_js_depenencies %}</code>:   <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        {% component_css_dependencies %}\n    &lt;/head&gt;\n    &lt;body&gt;\n        {% component 'my_alpine_component' / %}\n        {% component_js_dependencies %}\n\n        &lt;script src=\"https://unpkg.com/alpinejs\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"release_notes/#v0115","title":"v0.115","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"release_notes/#fix_16","title":"Fix","text":"<ul> <li>Fix integration with ManifestStaticFilesStorage on Windows by resolving component filepaths   (like <code>Component.template_name</code>) to POSIX paths.</li> </ul>"},{"location":"release_notes/#v0114","title":"v0.114","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"release_notes/#fix_17","title":"Fix","text":"<ul> <li>Prevent rendering Slot tags during fill discovery stage to fix a case when a component inside a slot   fill tried to access provided data too early.</li> </ul>"},{"location":"release_notes/#v0113","title":"v0.113","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"release_notes/#fix_18","title":"Fix","text":"<ul> <li>Ensure consistent order of scripts in <code>Component.Media.js</code></li> </ul>"},{"location":"release_notes/#v0112","title":"v0.112","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"release_notes/#fix_19","title":"Fix","text":"<ul> <li>Allow components to accept default fill even if no default slot was encountered during rendering</li> </ul>"},{"location":"release_notes/#v0111","title":"v0.111","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"release_notes/#fix_20","title":"Fix","text":"<ul> <li>Prevent rendering Component tags during fill discovery stage to fix a case when a component inside the default slot   tried to access provided data too early.</li> </ul>"},{"location":"release_notes/#v0110","title":"\ud83d\udea8\ud83d\udce2 v0.110","text":"<p>\u26a0\ufe0f Attention \u26a0\ufe0f - Please update to v0.117 to fix known bugs. See #791 and #789 and #818.</p>"},{"location":"release_notes/#general","title":"General","text":""},{"location":"release_notes/#breaking-changes_2","title":"\ud83d\udea8\ud83d\udce2 BREAKING CHANGES","text":"<ul> <li> <p>Installation changes:</p> <ul> <li>If your components include JS or CSS, you now must use the middleware and add django-components' URLs to your <code>urlpatterns</code> (See \"Adding support for JS and CSS\")</li> </ul> </li> <li> <p>Component typing signature changed from</p> <pre><code>Component[Args, Kwargs, Data, Slots]\n</code></pre> <p>to</p> <pre><code>Component[Args, Kwargs, Slots, Data, JsData, CssData]\n</code></pre> </li> <li> <p>If you rendered a component A with <code>Component.render()</code> and then inserted that into another component B, now you must pass <code>render_dependencies=False</code> to component A:</p> <pre><code>prerendered_a = CompA.render(\n    args=[...],\n    kwargs={...},\n    render_dependencies=False,\n)\n\nhtml = CompB.render(\n    kwargs={\n        content=prerendered_a,\n    },\n)\n</code></pre> </li> </ul>"},{"location":"release_notes/#feat_11","title":"Feat","text":"<ul> <li>Intellisense and mypy validation for settings:</li> </ul> <p>Instead of defining the <code>COMPONENTS</code> settings as a plain dict, you can use <code>ComponentsSettings</code>:</p> <pre><code># settings.py\nfrom django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    autodiscover=True,\n    ...\n)\n</code></pre> <ul> <li>Use <code>get_component_dirs()</code> and <code>get_component_files()</code> to get the same list of dirs / files that would be imported by <code>autodiscover()</code>, but without actually importing them.</li> </ul>"},{"location":"release_notes/#refactor_9","title":"Refactor","text":"<ul> <li> <p>For advanced use cases, use can omit the middleware and instead manage component JS and CSS dependencies yourself with <code>render_dependencies</code></p> </li> <li> <p>The <code>ComponentRegistry</code> settings <code>RegistrySettings</code>   were lowercased to align with the global settings:</p> </li> <li><code>RegistrySettings.CONTEXT_BEHAVIOR</code> -&gt; <code>RegistrySettings.context_behavior</code></li> <li><code>RegistrySettings.TAG_FORMATTER</code> -&gt; <code>RegistrySettings.tag_formatter</code></li> </ul> <p>The old uppercase settings <code>CONTEXT_BEHAVIOR</code> and <code>TAG_FORMATTER</code> are deprecated and will be removed in v1.</p> <ul> <li> <p>The setting <code>reload_on_template_change</code> was renamed to   <code>reload_on_file_change</code>.   And now it properly triggers server reload when any file in the component dirs change. The old name <code>reload_on_template_change</code>   is deprecated and will be removed in v1.</p> </li> <li> <p>The setting <code>forbidden_static_files</code> was renamed to   <code>static_files_forbidden</code>   to align with <code>static_files_allowed</code>   The old name <code>forbidden_static_files</code> is deprecated and will be removed in v1.</p> </li> </ul>"},{"location":"release_notes/#tags","title":"Tags","text":""},{"location":"release_notes/#breaking-changes_3","title":"\ud83d\udea8\ud83d\udce2 BREAKING CHANGES","text":"<ul> <li> <p><code>{% component_dependencies %}</code> tag was removed. Instead, use <code>{% component_js_dependencies %}</code> and <code>{% component_css_dependencies %}</code></p> <ul> <li> <p>The combined tag was removed to encourage the best practice of putting JS scripts at the end of <code>&lt;body&gt;</code>, and CSS styles inside <code>&lt;head&gt;</code>.</p> <p>On the other hand, co-locating JS script and CSS styles can lead to a flash of unstyled content, as either JS scripts will block the rendering, or CSS will load too late.</p> </li> </ul> </li> <li> <p>The undocumented keyword arg <code>preload</code> of <code>{% component_js_dependencies %}</code> and <code>{% component_css_dependencies %}</code> tags was removed.   This will be replaced with HTML fragment support.</p> </li> </ul>"},{"location":"release_notes/#fix_21","title":"Fix","text":"<ul> <li>Allow using forward slash (<code>/</code>) when defining custom TagFormatter,   e.g. <code>{% MyComp %}..{% /MyComp %}</code>.</li> </ul>"},{"location":"release_notes/#refactor_10","title":"Refactor","text":"<ul> <li><code>{% component_dependencies %}</code> tags are now OPTIONAL - If your components use JS and CSS, but you don't use <code>{% component_dependencies %}</code> tags, the JS and CSS will now be, by default, inserted at the end of <code>&lt;body&gt;</code> and at the end of <code>&lt;head&gt;</code> respectively.</li> </ul>"},{"location":"release_notes/#slots","title":"Slots","text":""},{"location":"release_notes/#feat_12","title":"Feat","text":"<ul> <li>Fills can now be defined within loops (<code>{% for %}</code>) or other tags (like <code>{% with %}</code>),   or even other templates using <code>{% include %}</code>.</li> </ul> <p>Following is now possible</p> <pre><code>{% component \"table\" %}\n  {% for slot_name in slots %}\n    {% fill name=slot_name %}\n    {% endfill %}\n  {% endfor %}\n{% endcomponent %}\n</code></pre> <ul> <li>If you need to access the data or the default content of a default fill, you can   set the <code>name</code> kwarg to <code>\"default\"</code>.</li> </ul> <p>Previously, a default fill would be defined simply by omitting the <code>{% fill %}</code> tags:</p> <pre><code>{% component \"child\" %}\n  Hello world\n{% endcomponent %}\n</code></pre> <p>But in that case you could not access the slot data or the default content, like it's possible   for named fills:</p> <pre><code>{% component \"child\" %}\n  {% fill name=\"header\" data=\"data\" %}\n    Hello {{ data.user.name }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Now, you can specify default tag by using <code>name=\"default\"</code>:</p> <pre><code>{% component \"child\" %}\n  {% fill name=\"default\" data=\"data\" %}\n    Hello {{ data.user.name }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <ul> <li>When inside <code>get_context_data()</code> or other component methods, the default fill   can now be accessed as <code>Component.input.slots[\"default\"]</code>, e.g.:</li> </ul> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        default_slot = self.input.slots[\"default\"]\n        ...\n</code></pre> <ul> <li>You can now dynamically pass all slots to a child component. This is similar to   passing all slots in Vue:</li> </ul> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        return {\n            \"slots\": self.input.slots,\n        }\n\n    template: \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% for slot_name in slots %}\n            {% fill name=slot_name data=\"data\" %}\n              {% slot name=slot_name ...data / %}\n            {% endfill %}\n          {% endfor %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"release_notes/#fix_22","title":"Fix","text":"<ul> <li> <p>Slots defined with <code>{% fill %}</code> tags are now properly accessible via <code>self.input.slots</code> in <code>get_context_data()</code></p> </li> <li> <p>Do not raise error if multiple slots with same name are flagged as default</p> </li> <li> <p>Slots can now be defined within loops (<code>{% for %}</code>) or other tags (like <code>{% with %}</code>),   or even other templates using <code>{% include %}</code>.</p> </li> </ul> <p>Previously, following would cause the kwarg <code>name</code> to be an empty string:</p> <pre><code>{% for slot_name in slots %}\n  {% slot name=slot_name %}\n{% endfor %}\n</code></pre>"},{"location":"release_notes/#refactor_11","title":"Refactor","text":"<ul> <li>When you define multiple slots with the same name inside a template,   you now have to set the <code>default</code> and <code>required</code> flags individually.</li> </ul> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>This means you can also have multiple slots with the same name but   different conditions.</p> <p>E.g. in this example, we have a component that renders a user avatar   - a small circular image with a profile picture of name initials.</p> <p>If the component is given <code>image_src</code> or <code>name_initials</code> variables,   the <code>image</code> slot is optional. But if neither of those are provided,   you MUST fill the <code>image</code> slot.</p> <pre><code>&lt;div class=\"avatar\"&gt;\n    {% if image_src %}\n        {% slot \"image\" default %}\n            &lt;img src=\"{{ image_src }}\" /&gt;\n        {% endslot %}\n    {% elif name_initials %}\n        {% slot \"image\" default required %}\n            &lt;div style=\"\n                border-radius: 25px;\n                width: 50px;\n                height: 50px;\n                background: blue;\n            \"&gt;\n                {{ name_initials }}\n            &lt;/div&gt;\n        {% endslot %}\n    {% else %}\n        {% slot \"image\" default required / %}\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <ul> <li>The slot fills that were passed to a component and which can be accessed as <code>Component.input.slots</code>   can now be passed through the Django template, e.g. as inputs to other tags.</li> </ul> <p>Internally, django-components handles slot fills as functions.</p> <p>Previously, if you tried to pass a slot fill within a template, Django would try to call it as a function.</p> <p>Now, something like this is possible:</p> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        return {\n            \"child_slot\": self.input.slots[\"child_slot\"],\n        }\n\n    template: \"\"\"\n      &lt;div&gt;\n        {% component \"child\" content=child_slot / %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <p>NOTE: Using <code>{% slot %}</code> and <code>{% fill %}</code> tags is still the preferred method, but the approach above   may be necessary in some complex or edge cases.</p> <ul> <li>The <code>is_filled</code> variable (and the <code>{{ component_vars.is_filled }}</code> context variable) now returns   <code>False</code> when you try to access a slot name which has not been defined:</li> </ul> <p>Before:</p> <pre><code>{{ component_vars.is_filled.header }} -&gt; True\n{{ component_vars.is_filled.footer }} -&gt; False\n{{ component_vars.is_filled.nonexist }} -&gt; \"\" (empty string)\n</code></pre> <p>After:   <pre><code>{{ component_vars.is_filled.header }} -&gt; True\n{{ component_vars.is_filled.footer }} -&gt; False\n{{ component_vars.is_filled.nonexist }} -&gt; False\n</code></pre></p> <ul> <li> <p>Components no longer raise an error if there are extra slot fills</p> </li> <li> <p>Components will raise error when a slot is doubly-filled. </p> </li> </ul> <p>E.g. if we have a component with a default slot:</p> <pre><code>{% slot name=\"content\" default / %}\n</code></pre> <p>Now there is two ways how we can target this slot: Either using <code>name=\"default\"</code>   or <code>name=\"content\"</code>.</p> <p>In case you specify BOTH, the component will raise an error:</p> <pre><code>{% component \"child\" %}\n  {% fill slot=\"default\" %}\n    Hello from default slot\n  {% endfill %}\n  {% fill slot=\"content\" data=\"data\" %}\n    Hello from content slot\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"release_notes/#v0100","title":"\ud83d\udea8\ud83d\udce2 v0.100","text":""},{"location":"release_notes/#breaking-changes_4","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>django_components.safer_staticfiles</code> app was removed. It is no longer needed.</p> </li> <li> <p>Installation changes:</p> <ul> <li>Instead of defining component directories in <code>STATICFILES_DIRS</code>, set them to <code>COMPONENTS.dirs</code>.</li> <li> <p>You now must define <code>STATICFILES_FINDERS</code></p> </li> <li> <p>See here how to migrate your settings.py</p> </li> </ul> </li> </ul>"},{"location":"release_notes/#feat_13","title":"Feat","text":"<ul> <li>Beside the top-level <code>/components</code> directory, you can now define also app-level components dirs, e.g. <code>[app]/components</code>   (See <code>COMPONENTS.app_dirs</code>).</li> </ul>"},{"location":"release_notes/#refactor_12","title":"Refactor","text":"<ul> <li>When you call <code>as_view()</code> on a component instance, that instance will be passed to <code>View.as_view()</code></li> </ul>"},{"location":"release_notes/#v097","title":"v0.97","text":""},{"location":"release_notes/#fix_23","title":"Fix","text":"<ul> <li>Fixed template caching. You can now also manually create cached templates with <code>cached_template()</code></li> </ul>"},{"location":"release_notes/#refactor_13","title":"Refactor","text":"<ul> <li> <p>The previously undocumented <code>get_template</code> was made private.</p> </li> <li> <p>In it's place, there's a new <code>get_template</code>, which supersedes <code>get_template_string</code> (will be removed in v1). The new <code>get_template</code> is the same as <code>get_template_string</code>, except   it allows to return either a string or a Template instance.</p> </li> <li> <p>You now must use only one of <code>template</code>, <code>get_template</code>, <code>template_name</code>, or <code>get_template_name</code>.</p> </li> </ul>"},{"location":"release_notes/#v096","title":"v0.96","text":""},{"location":"release_notes/#feat_14","title":"Feat","text":"<ul> <li> <p>Run-time type validation for Python 3.11+ - If the <code>Component</code> class is typed, e.g. <code>Component[Args, Kwargs, ...]</code>, the args, kwargs, slots, and data are validated against the given types. (See Runtime input validation with types)</p> </li> <li> <p>Render hooks - Set <code>on_render_before</code> and <code>on_render_after</code> methods on <code>Component</code> to intercept or modify the template or context before rendering, or the rendered result afterwards. (See Component hooks)</p> </li> <li> <p><code>component_vars.is_filled</code> context variable can be accessed from within <code>on_render_before</code> and <code>on_render_after</code> hooks as <code>self.is_filled.my_slot</code></p> </li> </ul>"},{"location":"release_notes/#095","title":"0.95","text":""},{"location":"release_notes/#feat_15","title":"Feat","text":"<ul> <li>Added support for dynamic components, where the component name is passed as a variable. (See Dynamic components)</li> </ul>"},{"location":"release_notes/#refactor_14","title":"Refactor","text":"<ul> <li>Changed <code>Component.input</code> to raise <code>RuntimeError</code> if accessed outside of render context. Previously it returned <code>None</code> if unset.</li> </ul>"},{"location":"release_notes/#v094","title":"v0.94","text":""},{"location":"release_notes/#feat_16","title":"Feat","text":"<ul> <li> <p>django_components now automatically configures Django to support multi-line tags. (See Multi-line tags)</p> </li> <li> <p>New setting <code>reload_on_template_change</code>. Set this to <code>True</code> to reload the dev server on changes to component template files. (See Reload dev server on component file changes)</p> </li> </ul>"},{"location":"release_notes/#v093","title":"v0.93","text":""},{"location":"release_notes/#feat_17","title":"Feat","text":"<ul> <li> <p>Spread operator <code>...dict</code> inside template tags. (See Spread operator)</p> </li> <li> <p>Use template tags inside string literals in component inputs. (See Use template tags inside component inputs)</p> </li> <li> <p>Dynamic slots, fills and provides - The <code>name</code> argument for these can now be a variable, a template expression, or via spread operator</p> </li> <li> <p>Component library authors can now configure <code>CONTEXT_BEHAVIOR</code> and <code>TAG_FORMATTER</code> settings independently from user settings.</p> </li> </ul>"},{"location":"release_notes/#v092","title":"\ud83d\udea8\ud83d\udce2 v0.92","text":""},{"location":"release_notes/#breaking-changes_5","title":"BREAKING CHANGES","text":"<ul> <li><code>Component</code> class is no longer a subclass of <code>View</code>. To configure the <code>View</code> class, set the <code>Component.View</code> nested class. HTTP methods like <code>get</code> or <code>post</code> can still be defined directly on <code>Component</code> class, and <code>Component.as_view()</code> internally calls <code>Component.View.as_view()</code>. (See Modifying the View class)</li> </ul>"},{"location":"release_notes/#feat_18","title":"Feat","text":"<ul> <li> <p>The inputs (args, kwargs, slots, context, ...) that you pass to <code>Component.render()</code> can be accessed from within <code>get_context_data</code>, <code>get_template</code> and <code>get_template_name</code> via <code>self.input</code>. (See Accessing data passed to the component)</p> </li> <li> <p>Typing: <code>Component</code> class supports generics that specify types for <code>Component.render</code> (See Adding type hints with Generics)</p> </li> </ul>"},{"location":"release_notes/#v090","title":"v0.90","text":""},{"location":"release_notes/#feat_19","title":"Feat","text":"<ul> <li> <p>All tags (<code>component</code>, <code>slot</code>, <code>fill</code>, ...) now support \"self-closing\" or \"inline\" form, where you can omit the closing tag:</p> <pre><code>{# Before #}\n{% component \"button\" %}{% endcomponent %}\n{# After #}\n{% component \"button\" / %}\n</code></pre> </li> <li> <p>All tags now support the \"dictionary key\" or \"aggregate\" syntax (<code>kwarg:key=val</code>):</p> <pre><code>{% component \"button\" attrs:class=\"hidden\" %}\n</code></pre> </li> <li> <p>You can change how the components are written in the template with TagFormatter.</p> <p>The default is <code>django_components.component_formatter</code>:</p> <pre><code>{% component \"button\" href=\"...\" disabled %}\n    Click me!\n{% endcomponent %}\n</code></pre> <p>While <code>django_components.shorthand_component_formatter</code> allows you to write components like so:</p> <pre><code>{% button href=\"...\" disabled %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"release_notes/#v085","title":"\ud83d\udea8\ud83d\udce2 v0.85","text":""},{"location":"release_notes/#breaking-changes_6","title":"BREAKING CHANGES","text":"<ul> <li> <p>Autodiscovery module resolution changed. Following undocumented behavior was removed:</p> <ul> <li> <p>Previously, autodiscovery also imported any <code>[app]/components.py</code> files, and used <code>SETTINGS_MODULE</code> to search for component dirs.</p> <p>To migrate from:</p> <ul> <li> <p><code>[app]/components.py</code> - Define each module in <code>COMPONENTS.libraries</code> setting,     or import each module inside the <code>AppConfig.ready()</code> hook in respective <code>apps.py</code> files.</p> </li> <li> <p><code>SETTINGS_MODULE</code> - Define component dirs using <code>STATICFILES_DIRS</code></p> </li> </ul> </li> <li> <p>Previously, autodiscovery handled relative files in <code>STATICFILES_DIRS</code>. To align with Django, <code>STATICFILES_DIRS</code> now must be full paths (Django docs).</p> </li> </ul> </li> </ul>"},{"location":"release_notes/#v081","title":"\ud83d\udea8\ud83d\udce2 v0.81","text":""},{"location":"release_notes/#breaking-changes_7","title":"BREAKING CHANGES","text":"<ul> <li>The order of arguments to <code>render_to_response</code> has changed, to align with the (now public) <code>render</code> method of <code>Component</code> class.</li> </ul>"},{"location":"release_notes/#feat_20","title":"Feat","text":"<ul> <li> <p><code>Component.render()</code> is public and documented</p> </li> <li> <p>Slots passed <code>render_to_response</code> and <code>render</code> can now be rendered also as functions.</p> </li> </ul>"},{"location":"release_notes/#v080","title":"v0.80","text":""},{"location":"release_notes/#feat_21","title":"Feat","text":"<ul> <li>Vue-like provide/inject with the <code>{% provide %}</code> tag and <code>inject()</code> method.</li> </ul>"},{"location":"release_notes/#v079","title":"\ud83d\udea8\ud83d\udce2 v0.79","text":""},{"location":"release_notes/#breaking-changes_8","title":"BREAKING CHANGES","text":"<ul> <li>Default value for the <code>COMPONENTS.context_behavior</code> setting was changes from <code>\"isolated\"</code> to <code>\"django\"</code>. If you did not set this value explicitly before, this may be a breaking change. See the rationale for change here.</li> </ul>"},{"location":"release_notes/#v077","title":"\ud83d\udea8\ud83d\udce2 v0.77","text":""},{"location":"release_notes/#breaking","title":"BREAKING","text":"<ul> <li> <p>The syntax for accessing default slot content has changed from</p> <pre><code>{% fill \"my_slot\" as \"alias\" %}\n    {{ alias.default }}\n{% endfill %}\n</code></pre> <p>to</p> <pre><code>{% fill \"my_slot\" default=\"alias\" %}\n    {{ alias }}\n{% endfill %}\n</code></pre> </li> </ul>"},{"location":"release_notes/#v074","title":"v0.74","text":""},{"location":"release_notes/#feat_22","title":"Feat","text":"<ul> <li> <p><code>{% html_attrs %}</code> tag for formatting data as HTML attributes</p> </li> <li> <p><code>prefix:key=val</code> construct for passing dicts to components</p> </li> </ul>"},{"location":"release_notes/#v070","title":"\ud83d\udea8\ud83d\udce2 v0.70","text":""},{"location":"release_notes/#breaking-changes_9","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>{% if_filled \"my_slot\" %}</code> tags were replaced with <code>{{ component_vars.is_filled.my_slot }}</code> variables.</p> </li> <li> <p>Simplified settings - <code>slot_context_behavior</code> and <code>context_behavior</code> were merged. See the documentation for more details.</p> </li> </ul>"},{"location":"release_notes/#v067","title":"v0.67","text":""},{"location":"release_notes/#refactor_15","title":"Refactor","text":"<ul> <li>Changed the default way how context variables are resolved in slots. See the documentation for more details.</li> </ul>"},{"location":"release_notes/#v050","title":"\ud83d\udea8\ud83d\udce2 v0.50","text":""},{"location":"release_notes/#breaking-changes_10","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>{% component_block %}</code> is now <code>{% component %}</code>, and <code>{% component %}</code> blocks need an ending <code>{% endcomponent %}</code> tag.</p> <p>The new <code>python manage.py upgradecomponent</code> command can be used to upgrade a directory (use <code>--path</code> argument to point to each dir) of templates that use components to the new syntax automatically.</p> <p>This change is done to simplify the API in anticipation of a 1.0 release of django_components. After 1.0 we intend to be stricter with big changes like this in point releases.</p> </li> </ul>"},{"location":"release_notes/#v034","title":"v0.34","text":""},{"location":"release_notes/#feat_23","title":"Feat","text":"<ul> <li>Components as views, which allows you to handle requests and render responses from within a component. See the documentation for more details.</li> </ul>"},{"location":"release_notes/#v028","title":"v0.28","text":""},{"location":"release_notes/#feat_24","title":"Feat","text":"<ul> <li>'implicit' slot filling and the <code>default</code> option for <code>slot</code> tags.</li> </ul>"},{"location":"release_notes/#v027","title":"v0.27","text":""},{"location":"release_notes/#feat_25","title":"Feat","text":"<ul> <li>A second installable app <code>django_components.safer_staticfiles</code>. It provides the same behavior as <code>django.contrib.staticfiles</code> but with extra security guarantees (more info below in Security Notes).</li> </ul>"},{"location":"release_notes/#v026","title":"\ud83d\udea8\ud83d\udce2 v0.26","text":""},{"location":"release_notes/#breaking-changes_11","title":"BREAKING CHANGES","text":"<ul> <li> <p>Changed the syntax for <code>{% slot %}</code> tags. From now on, we separate defining a slot (<code>{% slot %}</code>) from filling a slot with content (<code>{% fill %}</code>). This means you will likely need to change a lot of slot tags to fill.</p> <p>We understand this is annoying, but it's the only way we can get support for nested slots that fill in other slots, which is a very nice feature to have access to. Hoping that this will feel worth it!</p> </li> </ul>"},{"location":"release_notes/#v022","title":"v0.22","text":""},{"location":"release_notes/#feat_26","title":"Feat","text":"<ul> <li> <p>All files inside components subdirectores are autoimported to simplify setup.</p> <p>An existing project might start to get <code>AlreadyRegistered</code> errors because of this. To solve this, either remove your custom loading of components, or set <code>\"autodiscover\": False</code> in <code>settings.COMPONENTS</code>.</p> </li> </ul>"},{"location":"release_notes/#v017","title":"v0.17","text":""},{"location":"release_notes/#breaking-changes_12","title":"BREAKING CHANGES","text":"<ul> <li> <p>Renamed <code>Component.context</code> and <code>Component.template</code> to <code>get_context_data</code> and <code>get_template_name</code>. The old methods still work, but emit a deprecation warning.</p> <p>This change was done to sync naming with Django's class based views, and make using django-components more familiar to Django users. <code>Component.context</code> and <code>Component.template</code> will be removed when version 1.0 is released.</p> </li> </ul>"},{"location":"concepts/advanced/component_caching/","title":"Component caching","text":"<p>Component caching allows you to store the rendered output of a component. Next time the component is rendered with the same input, the cached output is returned instead of re-rendering the component.</p> <p>This is particularly useful for components that are expensive to render or do not change frequently.</p> <p>Info</p> <p>Component caching uses Django's cache framework, so you can use any cache backend that is supported by Django.</p>"},{"location":"concepts/advanced/component_caching/#enabling-caching","title":"Enabling caching","text":"<p>Caching is disabled by default.</p> <p>To enable caching for a component, set <code>Component.Cache.enabled</code> to <code>True</code>:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n</code></pre>"},{"location":"concepts/advanced/component_caching/#time-to-live-ttl","title":"Time-to-live (TTL)","text":"<p>You can specify a time-to-live (TTL) for the cache entry with <code>Component.Cache.ttl</code>, which determines how long the entry remains valid. The TTL is specified in seconds.</p> <pre><code>class MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n</code></pre> <ul> <li>If <code>ttl &gt; 0</code>, entries are cached for the specified number of seconds.</li> <li>If <code>ttl = -1</code>, entries are cached indefinitely.</li> <li>If <code>ttl = 0</code>, entries are not cached.</li> <li>If <code>ttl = None</code>, the default TTL is used.</li> </ul>"},{"location":"concepts/advanced/component_caching/#custom-cache-name","title":"Custom cache name","text":"<p>Since component caching uses Django's cache framework, you can specify a custom cache name with <code>Component.Cache.cache_name</code> to use a different cache backend:</p> <pre><code>class MyComponent(Component):\n    class Cache:\n        enabled = True\n        cache_name = \"my_cache\"\n</code></pre>"},{"location":"concepts/advanced/component_caching/#cache-key-generation","title":"Cache key generation","text":"<p>By default, the cache key is generated based on the component's input (args and kwargs). So the following two calls would generate separate entries in the cache:</p> <pre><code>MyComponent.render(name=\"Alice\")\nMyComponent.render(name=\"Bob\")\n</code></pre> <p>However, you have full control over the cache key generation. As such, you can:</p> <ul> <li>Cache the component on all inputs (default)</li> <li>Cache the component on particular inputs</li> <li>Cache the component irrespective of the inputs</li> </ul> <p>To achieve that, you can override the <code>Component.Cache.hash()</code> method to customize how arguments are hashed into the cache key.</p> <pre><code>class MyComponent(Component):\n    class Cache:\n        enabled = True\n\n        def hash(self, *args, **kwargs):\n            return f\"{json.dumps(args)}:{json.dumps(kwargs)}\"\n</code></pre> <p>For even more control, you can override other methods available on the <code>ComponentCache</code> class.</p> <p>Warning</p> <p>The default implementation of <code>Cache.hash()</code> simply serializes the input into a string. As such, it might not be suitable if you need to hash complex objects like Models.</p>"},{"location":"concepts/advanced/component_caching/#example","title":"Example","text":"<p>Here's a complete example of a component with caching enabled:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    template = \"Hello, {{ name }}\"\n\n    class Cache:\n        enabled = True\n        ttl = 300  # Cache for 5 minutes\n        cache_name = \"my_cache\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"name\": kwargs[\"name\"]}\n</code></pre> <p>In this example, the component's rendered output is cached for 5 minutes using the <code>my_cache</code> backend.</p>"},{"location":"concepts/advanced/component_context_scope/","title":"Component context and scope","text":"<p>By default, context variables are passed down the template as in regular Django - deeper scopes can access the variables from the outer scopes. So if you have several nested forloops, then inside the deep-most loop you can access variables defined by all previous loops.</p> <p>With this in mind, the <code>{% component %}</code> tag behaves similarly to <code>{% include %}</code> tag - inside the component tag, you can access all variables that were defined outside of it.</p> <p>And just like with <code>{% include %}</code>, if you don't want a specific component template to have access to the parent context, add <code>only</code> to the <code>{% component %}</code> tag:</p> <pre><code>{% component \"calendar\" date=\"2015-06-19\" only / %}\n</code></pre> <p>NOTE: <code>{% csrf_token %}</code> tags need access to the top-level context, and they will not function properly if they are rendered in a component that is called with the <code>only</code> modifier.</p> <p>If you find yourself using the <code>only</code> modifier often, you can set the context_behavior option to <code>\"isolated\"</code>, which automatically applies the <code>only</code> modifier. This is useful if you want to make sure that components don't accidentally access the outer context.</p> <p>Components can also access the outer context in their context methods like <code>get_template_data</code> by accessing the property <code>self.outer_context</code>.</p>"},{"location":"concepts/advanced/component_context_scope/#example-of-accessing-outer-context","title":"Example of Accessing Outer Context","text":"<pre><code>&lt;div&gt;\n  {% component \"calender\" / %}\n&lt;/div&gt;\n</code></pre> <p>Assuming that the rendering context has variables such as <code>date</code>, you can use <code>self.outer_context</code> to access them from within <code>get_template_data</code>. Here's how you might implement it:</p> <pre><code>class Calender(Component):\n\n    ...\n\n    def get_template_data(self, args, kwargs, slots, context):\n        outer_field = self.outer_context[\"date\"]\n        return {\n            \"date\": outer_fields,\n        }\n</code></pre> <p>However, as a best practice, it\u2019s recommended not to rely on accessing the outer context directly through <code>self.outer_context</code>. Instead, explicitly pass the variables to the component. For instance, continue passing the variables in the component tag as shown in the previous examples.</p>"},{"location":"concepts/advanced/component_context_scope/#context-behavior","title":"Context behavior","text":"<p>django_components supports both Django and Vue-like behavior when it comes to passing data to and through components. This can be configured in context_behavior.</p> <p>This has two modes:</p> <ul> <li> <p><code>\"django\"</code></p> <p>The default Django template behavior.</p> <p>Inside the <code>{% fill %}</code> tag, the context variables you can access are a union of:</p> <ul> <li>All the variables that were OUTSIDE the fill tag, including any\\   <code>{% with %}</code> tags.</li> <li>Any loops (<code>{% for ... %}</code>)   that the <code>{% fill %}</code> tag is part of.</li> <li>Data returned from <code>Component.get_template_data()</code>   of the component that owns the fill tag.</li> </ul> </li> <li> <p><code>\"isolated\"</code></p> <p>Similar behavior to Vue or React, this is useful if you want to make sure that components don't accidentally access variables defined outside of the component.</p> <p>Inside the <code>{% fill %}</code> tag, you can ONLY access variables from 2 places:</p> <ul> <li>Any loops (<code>{% for ... %}</code>)   that the <code>{% fill %}</code> tag is part of.</li> <li><code>Component.get_template_data()</code>   of the component which defined the template (AKA the \"root\" component).</li> </ul> </li> </ul> <p>Warning</p> <p>Notice that the component whose <code>get_template_data()</code> we use inside <code>{% fill %}</code> is NOT the same across the two modes!</p> <p>Consider this example:</p> <pre><code>class Outer(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% component \"inner\" %}\n          {% fill \"content\" %}\n            {{ my_var }}\n          {% endfill %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <ul> <li> <p><code>\"django\"</code> - <code>my_var</code> has access to data from <code>get_template_data()</code> of both <code>Inner</code> and <code>Outer</code>.   If there are variables defined in both, then <code>Inner</code> overshadows <code>Outer</code>.</p> </li> <li> <p><code>\"isolated\"</code> - <code>my_var</code> has access to data from <code>get_template_data()</code> of ONLY <code>Outer</code>.</p> </li> </ul>"},{"location":"concepts/advanced/component_context_scope/#example-django","title":"Example \"django\"","text":"<p>Given this template:</p> <pre><code>@register(\"root_comp\")\nclass RootComp(Component):\n    template = \"\"\"\n        {% with cheese=\"feta\" %}\n            {% component 'my_comp' %}\n                {{ my_var }}  # my_var\n                {{ cheese }}  # cheese\n            {% endcomponent %}\n        {% endwith %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return { \"my_var\": 123 }\n</code></pre> <p>Then if <code>get_template_data()</code> of the component <code>\"my_comp\"</code> returns following data:</p> <pre><code>{ \"my_var\": 456 }\n</code></pre> <p>Then the template will be rendered as:</p> <pre><code>456   # my_var\nfeta  # cheese\n</code></pre> <p>Because <code>\"my_comp\"</code> overshadows the outer variable <code>\"my_var\"</code>, so <code>{{ my_var }}</code> equals <code>456</code>.</p> <p>And variable <code>\"cheese\"</code> equals <code>feta</code>, because the fill CAN access all the data defined in the outer layers, like the <code>{% with %}</code> tag.</p>"},{"location":"concepts/advanced/component_context_scope/#example-isolated","title":"Example \"isolated\"","text":"<p>Given this template:</p> <pre><code>class RootComp(Component):\n    template = \"\"\"\n        {% with cheese=\"feta\" %}\n            {% component 'my_comp' %}\n                {{ my_var }}  # my_var\n                {{ cheese }}  # cheese\n            {% endcomponent %}\n        {% endwith %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return { \"my_var\": 123 }\n</code></pre> <p>Then if <code>get_template_data()</code> of the component <code>\"my_comp\"</code> returns following data:</p> <pre><code>{ \"my_var\": 456 }\n</code></pre> <p>Then the template will be rendered as:</p> <pre><code>123   # my_var\n    # cheese\n</code></pre> <p>Because variables <code>\"my_var\"</code> and <code>\"cheese\"</code> are searched only inside <code>RootComponent.get_template_data()</code>. But since <code>\"cheese\"</code> is not defined there, it's empty.</p> <p>Info</p> <p>Notice that the variables defined with the <code>{% with %}</code> tag are ignored inside the <code>{% fill %}</code> tag with the <code>\"isolated\"</code> mode.</p>"},{"location":"concepts/advanced/component_libraries/","title":"Component libraries","text":"<p>You can publish and share your components for others to use. Below you will find the steps to do so.</p> <p>For live examples, see the Community examples.</p>"},{"location":"concepts/advanced/component_libraries/#writing-component-libraries","title":"Writing component libraries","text":"<ol> <li> <p>Create a Django project with a similar structure:</p> <pre><code>project/\n  |--  myapp/\n    |--  __init__.py\n    |--  apps.py\n    |--  templates/\n      |--  table/\n        |--  table.py\n        |--  table.js\n        |--  table.css\n        |--  table.html\n    |--  menu.py   &lt;--- single-file component\n  |--  templatetags/\n    |--  __init__.py\n    |--  mytags.py\n</code></pre> </li> <li> <p>Create custom <code>Library</code>     and <code>ComponentRegistry</code> instances in <code>mytags.py</code></p> <p>This will be the entrypoint for using the components inside Django templates.</p> <p>Remember that Django requires the <code>Library</code> instance to be accessible under the <code>register</code> variable (See Django docs):</p> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry, RegistrySettings\n\nregister = library = django.template.Library()\ncomp_registry = ComponentRegistry(\n    library=library,\n    settings=RegistrySettings(\n        context_behavior=\"isolated\",\n        tag_formatter=\"django_components.component_formatter\",\n    ),\n)\n</code></pre> <p>As you can see above, this is also the place where we configure how our components should behave, using the <code>settings</code> argument. If omitted, default settings are used.</p> <p>For library authors, we recommend setting <code>context_behavior</code> to <code>\"isolated\"</code>, so that the state cannot leak into the components, and so the components' behavior is configured solely through the inputs. This means that the components will be more predictable and easier to debug.</p> <p>Next, you can decide how will others use your components by setting the <code>tag_formatter</code> options.</p> <p>If omitted or set to <code>\"django_components.component_formatter\"</code>, your components will be used like this:</p> <pre><code>{% component \"table\" items=items headers=headers %}\n{% endcomponent %}\n</code></pre> <p>Or you can use <code>\"django_components.component_shorthand_formatter\"</code> to use components like so:</p> <pre><code>{% table items=items headers=headers %}\n{% endtable %}\n</code></pre> <p>Or you can define a custom TagFormatter.</p> <p>Either way, these settings will be scoped only to your components. So, in the user code, there may be components side-by-side that use different formatters:</p> <pre><code>{% load mytags %}\n\n{# Component from your library \"mytags\", using the \"shorthand\" formatter #}\n{% table items=items headers=header %}\n{% endtable %}\n\n{# User-created components using the default settings #}\n{% component \"my_comp\" title=\"Abc...\" %}\n{% endcomponent %}\n</code></pre> </li> <li> <p>Write your components and register them with your instance of <code>ComponentRegistry</code></p> <p>There's one difference when you are writing components that are to be shared, and that's that the components must be explicitly registered with your instance of <code>ComponentRegistry</code> from the previous step.</p> <p>For better user experience, you can also define the types for the args, kwargs, slots and data.</p> <p>It's also a good idea to have a common prefix for your components, so they can be easily distinguished from users' components. In the example below, we use the prefix <code>my_</code> / <code>My</code>.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, SlotInput, register, types\n\nfrom myapp.templatetags.mytags import comp_registry\n\n# Define the component\n# NOTE: Don't forget to set the `registry`!\n@register(\"my_menu\", registry=comp_registry)\nclass MyMenu(Component):\n    # Define the types\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        vertical: Optional[bool] = None\n        klass: Optional[str] = None\n        style: Optional[str] = None\n\n    class Slots(NamedTuple):\n        default: Optional[SlotInput] = None\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        attrs = ...\n        return {\n            \"attrs\": attrs,\n        }\n\n    template: types.django_html = \"\"\"\n        {# Load django_components template tags #}\n        {% load component_tags %}\n\n        &lt;div {% html_attrs attrs class=\"my-menu\" %}&gt;\n            &lt;div class=\"my-menu__content\"&gt;\n                {% slot \"default\" default / %}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n</code></pre> </li> <li> <p>Import the components in <code>apps.py</code></p> <p>Normally, users rely on autodiscovery and <code>COMPONENTS.dirs</code> to load the component files.</p> <p>Since you, as the library author, are not in control of the file system, it is recommended to load the components manually.</p> <p>We recommend doing this in the <code>AppConfig.ready()</code> hook of your <code>apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\nclass MyAppConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"myapp\"\n\n    # This is the code that gets run when user adds myapp\n    # to Django's INSTALLED_APPS\n    def ready(self) -&gt; None:\n        # Import the components that you want to make available\n        # inside the templates.\n        from myapp.templates import (\n            menu,\n            table,\n        )\n</code></pre> <p>Note that you can also include any other startup logic within <code>AppConfig.ready()</code>.</p> </li> </ol> <p>And that's it! The next step is to publish it.</p>"},{"location":"concepts/advanced/component_libraries/#publishing-component-libraries","title":"Publishing component libraries","text":"<p>Once you are ready to share your library, you need to build a distribution and then publish it to PyPI.</p> <p>django_components uses the <code>build</code> utility to build a distribution:</p> <pre><code>python -m build --sdist --wheel --outdir dist/ .\n</code></pre> <p>And to publish to PyPI, you can use <code>twine</code> (See Python user guide)</p> <pre><code>twine upload --repository pypi dist/* -u __token__ -p &lt;PyPI_TOKEN&gt;\n</code></pre> <p>Notes on publishing:</p> <ul> <li>If you use components where the HTML / CSS / JS files are separate, you may need to define   <code>MANIFEST.in</code>   to include those files with the distribution   (see user guide).</li> </ul>"},{"location":"concepts/advanced/component_libraries/#installing-and-using-component-libraries","title":"Installing and using component libraries","text":"<p>After the package has been published, all that remains is to install it in other django projects:</p> <ol> <li> <p>Install the package:</p> <pre><code>pip install myapp django_components\n</code></pre> </li> <li> <p>Add the package to <code>INSTALLED_APPS</code></p> <pre><code>INSTALLED_APPS = [\n    ...\n    \"django_components\",\n    \"myapp\",\n]\n</code></pre> </li> <li> <p>Optionally add the template tags to the <code>builtins</code>,    so you don't have to call <code>{% load mytags %}</code> in every template:</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            'builtins': [\n                'myapp.templatetags.mytags',\n            ]\n        },\n    },\n]\n</code></pre> </li> <li> <p>And, at last, you can use the components in your own project!</p> <pre><code>{% my_menu title=\"Abc...\" %}\n    Hello World!\n{% endmy_menu %}\n</code></pre> </li> </ol>"},{"location":"concepts/advanced/component_registry/","title":"Registering components","text":"<p>In previous examples you could repeatedly see us using <code>@register()</code> to \"register\" the components. In this section we dive deeper into what it actually means and how you can manage (add or remove) components.</p> <p>As a reminder, we may have a component like this:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"template.html\"\n\n    # This component takes one parameter, a date string to show in the template\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n</code></pre> <p>which we then render in the template as:</p> <pre><code>{% component \"calendar\" date=\"1970-01-01\" %}\n{% endcomponent %}\n</code></pre> <p>As you can see, <code>@register</code> links up the component class with the <code>{% component %}</code> template tag. So when the template tag comes across a component called <code>\"calendar\"</code>, it can look up it's class and instantiate it.</p>"},{"location":"concepts/advanced/component_registry/#what-is-componentregistry","title":"What is ComponentRegistry","text":"<p>The <code>@register</code> decorator is a shortcut for working with the <code>ComponentRegistry</code>.</p> <p><code>ComponentRegistry</code> manages which components can be used in the template tags.</p> <p>Each <code>ComponentRegistry</code> instance is associated with an instance of Django's <code>Library</code>. And Libraries are inserted into Django template using the <code>{% load %}</code> tags.</p> <p>The <code>@register</code> decorator accepts an optional kwarg <code>registry</code>, which specifies, the <code>ComponentRegistry</code> to register components into. If omitted, the default <code>ComponentRegistry</code> instance defined in django_components is used.</p> <pre><code>my_registry = ComponentRegistry()\n\n@register(registry=my_registry)\nclass MyComponent(Component):\n    ...\n</code></pre> <p>The default <code>ComponentRegistry</code> is associated with the <code>Library</code> that you load when you call <code>{% load component_tags %}</code> inside your template, or when you add <code>django_components.templatetags.component_tags</code> to the template builtins.</p> <p>So when you register or unregister a component to/from a component registry, then behind the scenes the registry automatically adds/removes the component's template tags to/from the Library, so you can call the component from within the templates such as <code>{% component \"my_comp\" %}</code>.</p>"},{"location":"concepts/advanced/component_registry/#working-with-componentregistry","title":"Working with ComponentRegistry","text":"<p>The default <code>ComponentRegistry</code> instance can be imported as:</p> <pre><code>from django_components import registry\n</code></pre> <p>You can use the registry to manually add/remove/get components:</p> <pre><code>from django_components import registry\n\n# Register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n\n# Get all or single\nregistry.all()  # {\"button\": ButtonComponent, \"card\": CardComponent}\nregistry.get(\"card\")  # CardComponent\n\n# Check if component is registered\nregistry.has(\"button\")  # True\n\n# Unregister single component\nregistry.unregister(\"card\")\n\n# Unregister all components\nregistry.clear()\n</code></pre>"},{"location":"concepts/advanced/component_registry/#registering-components-to-custom-componentregistry","title":"Registering components to custom ComponentRegistry","text":"<p>If you are writing a component library to be shared with others, you may want to manage your own instance of <code>ComponentRegistry</code> and register components onto a different <code>Library</code> instance than the default one.</p> <p>The <code>Library</code> instance can be set at instantiation of <code>ComponentRegistry</code>. If omitted, then the default Library instance from django_components is used.</p> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry\n\nmy_library = Library(...)\nmy_registry = ComponentRegistry(library=my_library)\n</code></pre> <p>When you have defined your own <code>ComponentRegistry</code>, you can either register the components with <code>my_registry.register()</code>, or pass the registry to the <code>@component.register()</code> decorator via the <code>registry</code> kwarg:</p> <pre><code>from path.to.my.registry import my_registry\n\n@register(\"my_component\", registry=my_registry)\nclass MyComponent(Component):\n    ...\n</code></pre> <p>NOTE: The Library instance can be accessed under <code>library</code> attribute of <code>ComponentRegistry</code>.</p>"},{"location":"concepts/advanced/component_registry/#componentregistry-settings","title":"ComponentRegistry settings","text":"<p>When you are creating an instance of <code>ComponentRegistry</code>, you can define the components' behavior within the template.</p> <p>The registry accepts these settings:</p> <ul> <li><code>context_behavior</code></li> <li><code>tag_formatter</code></li> </ul> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry, RegistrySettings\n\nregister = library = django.template.Library()\ncomp_registry = ComponentRegistry(\n    library=library,\n    settings=RegistrySettings(\n        context_behavior=\"isolated\",\n        tag_formatter=\"django_components.component_formatter\",\n    ),\n)\n</code></pre> <p>These settings are the same as the ones you can set for django_components.</p> <p>In fact, when you set <code>COMPONENT.tag_formatter</code> or <code>COMPONENT.context_behavior</code>, these are forwarded to the default <code>ComponentRegistry</code>.</p> <p>This makes it possible to have multiple registries with different settings in one projects, and makes sharing of component libraries possible.</p>"},{"location":"concepts/advanced/extensions/","title":"Extensions","text":"<p>New in version 0.131</p> <p>Django-components functionality can be extended with \"extensions\". Extensions allow for powerful customization and integrations. They can:</p> <ul> <li>Tap into lifecycle events, such as when a component is created, deleted, registered, or unregistered.</li> <li>Add new attributes and methods to the components under an extension-specific nested class.</li> <li>Define custom commands that can be executed via the Django management command interface.</li> </ul>"},{"location":"concepts/advanced/extensions/#live-examples","title":"Live examples","text":"<ul> <li>djc-ext-pydantic</li> </ul>"},{"location":"concepts/advanced/extensions/#setting-up-extensions","title":"Setting up extensions","text":"<p>Extensions are configured in the Django settings under <code>COMPONENTS.extensions</code>.</p> <p>Extensions can be set by either as an import string or by passing in a class:</p> <pre><code># settings.py\n\nclass MyExtension(ComponentExtension):\n    name = \"my_extension\"\n\n    class ExtensionClass(ComponentExtension.ExtensionClass):\n        ...\n\nCOMPONENTS = ComponentsSettings(\n    extensions=[\n        MyExtension,\n        \"another_app.extensions.AnotherExtension\",\n        \"my_app.extensions.ThirdExtension\",\n    ],\n)\n</code></pre>"},{"location":"concepts/advanced/extensions/#lifecycle-hooks","title":"Lifecycle hooks","text":"<p>Extensions can define methods to hook into lifecycle events, such as:</p> <ul> <li>Component creation or deletion</li> <li>Un/registering a component</li> <li>Creating or deleting a registry</li> <li>Pre-processing data passed to a component on render</li> <li>Post-processing data returned from <code>get_template_data()</code>   and others.</li> </ul> <p>See the full list in Extension Hooks Reference.</p>"},{"location":"concepts/advanced/extensions/#configuring-extensions-per-component","title":"Configuring extensions per component","text":"<p>Each extension has a corresponding nested class within the <code>Component</code> class. These allow to configure the extensions on a per-component basis.</p> <p>Note</p> <p>Accessing the component instance from inside the nested classes:</p> <p>Each method of the nested classes has access to the <code>component</code> attribute, which points to the component instance.</p> <pre><code>class MyTable(Component):\n    class View:\n        def get(self, request):\n            # `self.component` points to the instance of `MyTable` Component.\n            return self.component.get(request)\n</code></pre>"},{"location":"concepts/advanced/extensions/#example-component-as-view","title":"Example: Component as View","text":"<p>The Components as Views feature is actually implemented as an extension that is configured by a <code>View</code> nested class.</p> <p>You can override the <code>get()</code>, <code>post()</code>, etc methods to customize the behavior of the component as a view:</p> <pre><code>class MyTable(Component):\n    class View:\n        def get(self, request):\n            return self.component.get(request)\n\n        def post(self, request):\n            return self.component.post(request)\n\n        ...\n</code></pre>"},{"location":"concepts/advanced/extensions/#example-storybook-integration","title":"Example: Storybook integration","text":"<p>The Storybook integration (work in progress) is an extension that is configured by a <code>Storybook</code> nested class.</p> <p>You can override methods such as <code>title</code>, <code>parameters</code>, etc, to customize how to generate a Storybook JSON file from the component.</p> <pre><code>class MyTable(Component):\n    class Storybook:\n        def title(self):\n            return self.component.__class__.__name__\n\n        def parameters(self) -&gt; Parameters:\n            return {\n                \"server\": {\n                    \"id\": self.component.__class__.__name__,\n                }\n            }\n\n        def stories(self) -&gt; List[StoryAnnotations]:\n            return []\n\n        ...\n</code></pre>"},{"location":"concepts/advanced/extensions/#accessing-extensions-in-components","title":"Accessing extensions in components","text":"<p>Above, we've configured extensions <code>View</code> and <code>Storybook</code> for the <code>MyTable</code> component.</p> <p>You can access the instances of these extension classes in the component instance.</p> <p>For example, the View extension is available as <code>self.view</code>:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # `self.view` points to the instance of `View` extension.\n        return {\n            \"view\": self.view,\n        }\n</code></pre> <p>And the Storybook extension is available as <code>self.storybook</code>:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # `self.storybook` points to the instance of `Storybook` extension.\n        return {\n            \"title\": self.storybook.title(),\n        }\n</code></pre> <p>Thus, you can use extensions to add methods or attributes that will be available to all components in their component context.</p>"},{"location":"concepts/advanced/extensions/#writing-extensions","title":"Writing extensions","text":"<p>Creating extensions in django-components involves defining a class that inherits from <code>ComponentExtension</code>. This class can implement various lifecycle hooks and define new attributes or methods to be added to components.</p>"},{"location":"concepts/advanced/extensions/#defining-an-extension","title":"Defining an extension","text":"<p>To create an extension, define a class that inherits from <code>ComponentExtension</code> and implement the desired hooks.</p> <ul> <li>Each extension MUST have a <code>name</code> attribute. The name MUST be a valid Python identifier.</li> <li>The extension MAY implement any of the hook methods.</li> <li>Each hook method receives a context object with relevant data.</li> </ul> <pre><code>from django_components.extension import ComponentExtension, OnComponentClassCreatedContext\n\nclass MyExtension(ComponentExtension):\n    name = \"my_extension\"\n\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext) -&gt; None:\n        # Custom logic for when a component class is created\n        ctx.component_cls.my_attr = \"my_value\"\n</code></pre> <p>Warning</p> <p>The <code>name</code> attribute MUST be unique across all extensions.</p> <p>Moreover, the <code>name</code> attribute MUST NOT conflict with existing Component class API.</p> <p>So if you name an extension <code>render</code>, it will conflict with the <code>render()</code> method of the <code>Component</code> class.</p>"},{"location":"concepts/advanced/extensions/#defining-the-extension-class","title":"Defining the extension class","text":"<p>In previous sections we've seen the <code>View</code> and <code>Storybook</code> extensions classes that were nested within the <code>Component</code> class:</p> <pre><code>class MyComponent(Component):\n    class View:\n        ...\n\n    class Storybook:\n        ...\n</code></pre> <p>These can be understood as component-specific overrides or configuration.</p> <p>The nested extension classes like <code>View</code> or <code>Storybook</code> will actually subclass from a base extension class as defined on the <code>ComponentExtension.ExtensionClass</code>.</p> <p>This is how extensions define the \"default\" behavior of their nested extension classes.</p> <p>For example, the <code>View</code> base extension class defines the handlers for GET, POST, etc:</p> <pre><code>from django_components.extension import ComponentExtension\n\nclass ViewExtension(ComponentExtension):\n    name = \"view\"\n\n    # The default behavior of the `View` extension class.\n    class ExtensionClass(ComponentExtension.ExtensionClass):\n        def get(self, request):\n            return self.component.get(request)\n\n        def post(self, request):\n            return self.component.post(request)\n\n        ...\n</code></pre> <p>In any component that then defines a nested <code>View</code> extension class, the <code>View</code> extension class will actually subclass from the <code>ViewExtension.ExtensionClass</code> class.</p> <p>In other words, when you define a component like this:</p> <pre><code>class MyTable(Component):\n    class View:\n        def get(self, request):\n            # Do something\n            ...\n</code></pre> <p>It will actually be implemented as if the <code>View</code> class subclassed from base class <code>ViewExtension.ExtensionClass</code>:</p> <pre><code>class MyTable(Component):\n    class View(ViewExtension.ExtensionClass):\n        def get(self, request):\n            # Do something\n            ...\n</code></pre> <p>Warning</p> <p>When writing an extension, the <code>ExtensionClass</code> MUST subclass the base class <code>ComponentExtension.ExtensionClass</code>.</p> <p>This base class ensures that the extension class will have access to the component instance.</p>"},{"location":"concepts/advanced/extensions/#registering-extensions","title":"Registering extensions","text":"<p>Once the extension is defined, it needs to be registered in the Django settings to be used by the application.</p> <p>Extensions can be given either as an extension class, or its import string:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"extensions\": [\n        \"my_app.extensions.MyExtension\",\n    ],\n}\n</code></pre> <p>Or by reference:</p> <pre><code># settings.py\nfrom my_app.extensions import MyExtension\n\nCOMPONENTS = {\n    \"extensions\": [\n        MyExtension,\n    ],\n}\n</code></pre>"},{"location":"concepts/advanced/extensions/#full-example-custom-logging-extension","title":"Full example: Custom logging extension","text":"<p>To tie it all together, here's an example of a custom logging extension that logs when components are created, deleted, or rendered:</p> <ul> <li>Each component can specify which color to use for the logging by setting <code>Component.ColorLogger.color</code>.</li> <li>The extension will log the component name and color when the component is created, deleted, or rendered.</li> </ul> <pre><code>from django_components.extension import (\n    ComponentExtension,\n    OnComponentClassCreatedContext,\n    OnComponentClassDeletedContext,\n    OnComponentInputContext,\n)\n\nclass ColorLoggerExtensionClass(ComponentExtension.ExtensionClass):\n    color: str\n\n\nclass ColorLoggerExtension(ComponentExtension):\n    name = \"color_logger\"\n\n    # All `Component.ColorLogger` classes will inherit from this class.\n    ExtensionClass = ColorLoggerExtensionClass\n\n    # These hooks don't have access to the Component instance, only to the Component class,\n    # so we access the color as `Component.ColorLogger.color`.\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext) -&gt; None:\n        log.info(\n            f\"Component {ctx.component_cls} created.\",\n            color=ctx.component_cls.ColorLogger.color,\n        )\n\n    def on_component_class_deleted(self, ctx: OnComponentClassDeletedContext) -&gt; None:\n        log.info(\n            f\"Component {ctx.component_cls} deleted.\",\n            color=ctx.component_cls.ColorLogger.color,\n        )\n\n    # This hook has access to the Component instance, so we access the color\n    # as `self.component.color_logger.color`.\n    def on_component_input(self, ctx: OnComponentInputContext) -&gt; None:\n        log.info(\n            f\"Rendering component {ctx.component_cls}.\",\n            color=ctx.component.color_logger.color,\n        )\n</code></pre> <p>To use the <code>ColorLoggerExtension</code>, add it to your settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"extensions\": [\n        ColorLoggerExtension,\n    ],\n}\n</code></pre> <p>Once registered, in any component, you can define a <code>ColorLogger</code> attribute:</p> <pre><code>class MyComponent(Component):\n    class ColorLogger:\n        color = \"red\"\n</code></pre> <p>This will log the component name and color when the component is created, deleted, or rendered.</p>"},{"location":"concepts/advanced/extensions/#utility-functions","title":"Utility functions","text":"<p>django-components provides a few utility functions to help with writing extensions:</p> <ul> <li><code>all_components()</code> - returns a list of all created component classes.</li> <li><code>all_registries()</code> - returns a list of all created registry instances.</li> </ul>"},{"location":"concepts/advanced/extensions/#accessing-the-component-class-from-within-an-extension","title":"Accessing the component class from within an extension","text":"<p>When you are writing the extension class that will be nested inside a Component class, e.g.</p> <pre><code>class MyTable(Component):\n    class MyExtension:\n        def some_method(self):\n            ...\n</code></pre> <p>You can access the owner Component class (<code>MyTable</code>) from within methods of the extension class (<code>MyExtension</code>) by using the <code>component_class</code> attribute:</p> <pre><code>class MyTable(Component):\n    class MyExtension:\n        def some_method(self):\n            print(self.component_class)\n</code></pre> <p>Here is how the <code>component_class</code> attribute may be used with our <code>ColorLogger</code> extension shown above:</p> <pre><code>class ColorLoggerExtensionClass(ComponentExtension.ExtensionClass):\n    color: str\n\n    def log(self, msg: str) -&gt; None:\n        print(f\"{self.component_class.name}: {msg}\")\n\n\nclass ColorLoggerExtension(ComponentExtension):\n    name = \"color_logger\"\n\n    # All `Component.ColorLogger` classes will inherit from this class.\n    ExtensionClass = ColorLoggerExtensionClass\n</code></pre>"},{"location":"concepts/advanced/extensions/#extension-commands","title":"Extension Commands","text":"<p>Extensions in django-components can define custom commands that can be executed via the Django management command interface. This allows for powerful automation and customization capabilities.</p> <p>For example, if you have an extension that defines a command that prints \"Hello world\", you can run the command with:</p> <pre><code>python manage.py components ext run my_ext hello\n</code></pre> <p>Where:</p> <ul> <li><code>python manage.py components</code> - is the Django entrypoint</li> <li><code>ext run</code> - is the subcommand to run extension commands</li> <li><code>my_ext</code> - is the extension name</li> <li><code>hello</code> - is the command name</li> </ul>"},{"location":"concepts/advanced/extensions/#defining-commands","title":"Defining Commands","text":"<p>To define a command, subclass from <code>ComponentCommand</code>. This subclass should define:</p> <ul> <li><code>name</code> - the command's name</li> <li><code>help</code> - the command's help text</li> <li><code>handle</code> - the logic to execute when the command is run</li> </ul> <pre><code>from django_components import ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n\n    def handle(self, *args, **kwargs):\n        print(\"Hello, world!\")\n\nclass MyExt(ComponentExtension):\n    name = \"my_ext\"\n    commands = [HelloCommand]\n</code></pre>"},{"location":"concepts/advanced/extensions/#defining-command-arguments-and-options","title":"Defining Command Arguments and Options","text":"<p>Commands can accept positional arguments and options (e.g. <code>--foo</code>), which are defined using the <code>arguments</code> attribute of the <code>ComponentCommand</code> class.</p> <p>The arguments are parsed with <code>argparse</code> into a dictionary of arguments and options. These are then available as keyword arguments to the <code>handle</code> method of the command.</p> <pre><code>from django_components import CommandArg, ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n\n    arguments = [\n        # Positional argument\n        CommandArg(\n            name_or_flags=\"name\",\n            help=\"The name to say hello to\",\n        ),\n        # Optional argument\n        CommandArg(\n            name_or_flags=[\"--shout\", \"-s\"],\n            action=\"store_true\",\n            help=\"Shout the hello\",\n        ),\n    ]\n\n    def handle(self, name: str, *args, **kwargs):\n        shout = kwargs.get(\"shout\", False)\n        msg = f\"Hello, {name}!\"\n        if shout:\n            msg = msg.upper()\n        print(msg)\n</code></pre> <p>You can run the command with arguments and options:</p> <pre><code>python manage.py components ext run my_ext hello John --shout\n&gt;&gt;&gt; HELLO, JOHN!\n</code></pre> <p>Note</p> <p>Command definitions are parsed with <code>argparse</code>, so you can use all the features of <code>argparse</code> to define your arguments and options.</p> <p>See the argparse documentation for more information.</p> <p>django-components defines types as <code>CommandArg</code>, <code>CommandArgGroup</code>, <code>CommandSubcommand</code>, and <code>CommandParserInput</code> to help with type checking.</p> <p>Note</p> <p>If a command doesn't have the <code>handle</code> method defined, the command will print a help message and exit.</p>"},{"location":"concepts/advanced/extensions/#grouping-arguments","title":"Grouping Arguments","text":"<p>Arguments can be grouped using <code>CommandArgGroup</code> to provide better organization and help messages.</p> <p>Read more on argparse argument groups.</p> <pre><code>from django_components import CommandArg, CommandArgGroup, ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n\n    # Argument parsing is managed by `argparse`.\n    arguments = [\n        # Positional argument\n        CommandArg(\n            name_or_flags=\"name\",\n            help=\"The name to say hello to\",\n        ),\n        # Optional argument\n        CommandArg(\n            name_or_flags=[\"--shout\", \"-s\"],\n            action=\"store_true\",\n            help=\"Shout the hello\",\n        ),\n        # When printing the command help message, `--bar` and `--baz`\n        # will be grouped under \"group bar\".\n        CommandArgGroup(\n            title=\"group bar\",\n            description=\"Group description.\",\n            arguments=[\n                CommandArg(\n                    name_or_flags=\"--bar\",\n                    help=\"Bar description.\",\n                ),\n                CommandArg(\n                    name_or_flags=\"--baz\",\n                    help=\"Baz description.\",\n                ),\n            ],\n        ),\n    ]\n\n    def handle(self, name: str, *args, **kwargs):\n        shout = kwargs.get(\"shout\", False)\n        msg = f\"Hello, {name}!\"\n        if shout:\n            msg = msg.upper()\n        print(msg)\n</code></pre>"},{"location":"concepts/advanced/extensions/#subcommands","title":"Subcommands","text":"<p>Extensions can define subcommands, allowing for more complex command structures.</p> <p>Subcommands are defined similarly to root commands, as subclasses of <code>ComponentCommand</code> class.</p> <p>However, instead of defining the subcommands in the <code>commands</code> attribute of the extension, you define them in the <code>subcommands</code> attribute of the parent command:</p> <pre><code>from django_components import CommandArg, CommandArgGroup, ComponentCommand, ComponentExtension\n\nclass ChildCommand(ComponentCommand):\n    name = \"child\"\n    help = \"Child command\"\n\n    def handle(self, *args, **kwargs):\n        print(\"Child command\")\n\nclass ParentCommand(ComponentCommand):\n    name = \"parent\"\n    help = \"Parent command\"\n    subcommands = [\n        ChildCommand,\n    ]\n\n    def handle(self, *args, **kwargs):\n        print(\"Parent command\")\n</code></pre> <p>In this example, we can run two commands.</p> <p>Either the parent command:</p> <pre><code>python manage.py components ext run parent\n&gt;&gt;&gt; Parent command\n</code></pre> <p>Or the child command:</p> <pre><code>python manage.py components ext run parent child\n&gt;&gt;&gt; Child command\n</code></pre> <p>Warning</p> <p>Subcommands are independent of the parent command. When a subcommand runs, the parent command is NOT executed.</p> <p>As such, if you want to pass arguments to both the parent and child commands, e.g.:</p> <pre><code>python manage.py components ext run parent --foo child --bar\n</code></pre> <p>You should instead pass all the arguments to the subcommand:</p> <pre><code>python manage.py components ext run parent child --foo --bar\n</code></pre>"},{"location":"concepts/advanced/extensions/#print-command-help","title":"Print command help","text":"<p>By default, all commands will print their help message when run with the <code>--help</code> / <code>-h</code> flag.</p> <pre><code>python manage.py components ext run my_ext --help\n</code></pre> <p>The help message prints out all the arguments and options available for the command, as well as any subcommands.</p>"},{"location":"concepts/advanced/extensions/#testing-commands","title":"Testing Commands","text":"<p>Commands can be tested using Django's <code>call_command()</code> function, which allows you to simulate running the command in tests.</p> <pre><code>from django.core.management import call_command\n\ncall_command('components', 'ext', 'run', 'my_ext', 'hello', '--name', 'John')\n</code></pre> <p>To capture the output of the command, you can use the <code>StringIO</code> module to redirect the output to a string:</p> <pre><code>from io import StringIO\n\nout = StringIO()\nwith patch(\"sys.stdout\", new=out):\n    call_command('components', 'ext', 'run', 'my_ext', 'hello', '--name', 'John')\noutput = out.getvalue()\n</code></pre> <p>And to temporarily set the extensions, you can use the <code>@djc_test</code> decorator.</p> <p>Thus, a full test example can then look like this:</p> <pre><code>from io import StringIO\nfrom unittest.mock import patch\n\nfrom django.core.management import call_command\nfrom django_components.testing import djc_test\n\n@djc_test(\n    components_settings={\n        \"extensions\": [\n            \"my_app.extensions.MyExtension\",\n        ],\n    },\n)\ndef test_hello_command(self):\n    out = StringIO()\n    with patch(\"sys.stdout\", new=out):\n        call_command('components', 'ext', 'run', 'my_ext', 'hello', '--name', 'John')\n    output = out.getvalue()\n    assert output == \"Hello, John!\\n\"\n</code></pre>"},{"location":"concepts/advanced/extensions/#extension-urls","title":"Extension URLs","text":"<p>Extensions can define custom views and endpoints that can be accessed through the Django application.</p> <p>To define URLs for an extension, set them in the <code>urls</code> attribute of your <code>ComponentExtension</code> class. Each URL is defined using the <code>URLRoute</code> class, which specifies the path, handler, and optional name for the route.</p> <p>Here's an example of how to define URLs within an extension:</p> <pre><code>from django_components.extension import ComponentExtension, URLRoute\nfrom django.http import HttpResponse\n\ndef my_view(request):\n    return HttpResponse(\"Hello from my extension!\")\n\nclass MyExtension(ComponentExtension):\n    name = \"my_extension\"\n\n    urls = [\n        URLRoute(path=\"my-view/\", handler=my_view, name=\"my_view\"),\n        URLRoute(path=\"another-view/&lt;int:id&gt;/\", handler=my_view, name=\"another_view\"),\n    ]\n</code></pre> <p>Warning</p> <p>The <code>URLRoute</code> objects are different from objects created with Django's <code>django.urls.path()</code>. Do NOT use <code>URLRoute</code> objects in Django's <code>urlpatterns</code> and vice versa!</p> <p>django-components uses a custom <code>URLRoute</code> class to define framework-agnostic routing rules.</p> <p>As of v0.131, <code>URLRoute</code> objects are directly converted to Django's <code>URLPattern</code> and <code>URLResolver</code> objects.</p>"},{"location":"concepts/advanced/extensions/#accessing-extension-urls","title":"Accessing Extension URLs","text":"<p>The URLs defined in an extension are available under the path</p> <pre><code>/components/ext/&lt;extension_name&gt;/\n</code></pre> <p>For example, if you have defined a URL with the path <code>my-view/&lt;str:name&gt;/</code> in an extension named <code>my_extension</code>, it can be accessed at:</p> <pre><code>/components/ext/my_extension/my-view/john/\n</code></pre>"},{"location":"concepts/advanced/extensions/#nested-urls","title":"Nested URLs","text":"<p>Extensions can also define nested URLs to allow for more complex routing structures.</p> <p>To define nested URLs, set the <code>children</code> attribute of the <code>URLRoute</code> object to a list of child <code>URLRoute</code> objects:</p> <pre><code>class MyExtension(ComponentExtension):\n    name = \"my_extension\"\n\n    urls = [\n        URLRoute(\n            path=\"parent/\",\n            name=\"parent_view\",\n            children=[\n                URLRoute(path=\"child/&lt;str:name&gt;/\", handler=my_view, name=\"child_view\"),\n            ],\n        ),\n    ]\n</code></pre> <p>In this example, the URL</p> <pre><code>/components/ext/my_extension/parent/child/john/\n</code></pre> <p>would call the <code>my_view</code> handler with the parameter <code>name</code> set to <code>\"John\"</code>.</p>"},{"location":"concepts/advanced/extensions/#passing-kwargs-and-other-extra-fields-to-url-routes","title":"Passing kwargs and other extra fields to URL routes","text":"<p>The <code>URLRoute</code> class is framework-agnostic, so that extensions could be used with non-Django frameworks in the future.</p> <p>However, that means that there may be some extra fields that Django's <code>django.urls.path()</code> accepts, but which are not defined on the <code>URLRoute</code> object.</p> <p>To address this, the <code>URLRoute</code> object has an <code>extra</code> attribute, which is a dictionary that can be used to pass any extra kwargs to <code>django.urls.path()</code>:</p> <pre><code>URLRoute(\n    path=\"my-view/&lt;str:name&gt;/\",\n    handler=my_view,\n    name=\"my_view\",\n    extra={\"kwargs\": {\"foo\": \"bar\"} },\n)\n</code></pre> <p>Is the same as:</p> <pre><code>django.urls.path(\n    \"my-view/&lt;str:name&gt;/\",\n    view=my_view,\n    name=\"my_view\",\n    kwargs={\"foo\": \"bar\"},\n)\n</code></pre> <p>because <code>URLRoute</code> is converted to Django's route like so:</p> <pre><code>django.urls.path(\n    route.path,\n    view=route.handler,\n    name=route.name,\n    **route.extra,\n)\n</code></pre>"},{"location":"concepts/advanced/hooks/","title":"Lifecycle hooks","text":"<p>New in version 0.96</p> <p>Component hooks are functions that allow you to intercept the rendering process at specific positions.</p>"},{"location":"concepts/advanced/hooks/#available-hooks","title":"Available hooks","text":"<ul> <li><code>on_render_before</code></li> </ul> <pre><code>def on_render_before(\n    self: Component,\n    context: Context,\n    template: Template\n) -&gt; None:\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template:</p> <pre><code>def on_render_before(self, context, template) -&gt; None:\n    # Insert value into the Context\n    context[\"from_on_before\"] = \":)\"\n\n    # Append text into the Template\n    template.nodelist.append(TextNode(\"FROM_ON_BEFORE\"))\n</code></pre> <ul> <li><code>on_render_after</code></li> </ul> <pre><code>def on_render_after(\n    self: Component,\n    context: Context,\n    template: Template,\n    content: str\n) -&gt; None | str | SafeString:\n</code></pre> <p>Hook that runs just after the component's template was rendered.   It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying   them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook:</p> <pre><code>def on_render_after(self, context, template, content):\n    # Prepend text to the rendered content\n    return \"Chocolate cookie recipe: \" + content\n</code></pre>"},{"location":"concepts/advanced/hooks/#component-hooks-example","title":"Component hooks example","text":"<p>You can use hooks together with provide / inject to create components that accept a list of items via a slot.</p> <p>In the example below, each <code>tab_item</code> component will be rendered on a separate tab page, but they are all defined in the default slot of the <code>tabs</code> component.</p> <p>See here for how it was done</p> <pre><code>{% component \"tabs\" %}\n  {% component \"tab_item\" header=\"Tab 1\" %}\n    &lt;p&gt;\n      hello from tab 1\n    &lt;/p&gt;\n    {% component \"button\" %}\n      Click me!\n    {% endcomponent %}\n  {% endcomponent %}\n\n  {% component \"tab_item\" header=\"Tab 2\" %}\n    Hello this is tab 2\n  {% endcomponent %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/advanced/html_fragments/","title":"HTML fragments","text":"<p>Django-components provides a seamless integration with HTML fragments with AJAX (HTML over the wire), whether you're using jQuery, HTMX, AlpineJS, or vanilla JavaScript.</p> <p>When you define a component that has extra JS or CSS, and you use django-components to render the fragment, django-components will:</p> <ul> <li>Automatically load the associated JS and CSS</li> <li>Ensure that JS is loaded and executed only once even if the fragment is inserted multiple times</li> </ul> <p>Info</p> <p>What are HTML fragments and \"HTML over the wire\"?</p> <p>It is one of the methods for updating the state in the browser UI upon user interaction.</p> <p>How it works is that:</p> <ol> <li>User makes an action - clicks a button or submits a form</li> <li>The action causes a request to be made from the client to the server.</li> <li>Server processes the request (e.g. form submission), and responds with HTML    of some part of the UI (e.g. a new entry in a table).</li> <li>A library like HTMX, AlpineJS, or custom function inserts the new HTML into    the correct place.</li> </ol>"},{"location":"concepts/advanced/html_fragments/#document-and-fragment-strategies","title":"Document and fragment strategies","text":"<p>Components support different \"strategies\" for rendering JS and CSS.</p> <p>Two of them are used to enable HTML fragments - \"document\" and \"fragment\".</p> <p>What's the difference?</p>"},{"location":"concepts/advanced/html_fragments/#document-strategy","title":"Document strategy","text":"<p>Document strategy assumes that the rendered components will be embedded into the HTML of the initial page load. This means that:</p> <ul> <li>The JS and CSS is embedded into the HTML as <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags   (see JS and CSS output locations)</li> <li>Django-components injects a JS script for managing JS and CSS assets</li> </ul> <p>A component is rendered as a \"document\" when:</p> <ul> <li>It is embedded inside a template as <code>{% component %}</code></li> <li>It is rendered with <code>Component.render()</code> or <code>Component.render_to_response()</code>   with the <code>deps_strategy</code> kwarg set to <code>\"document\"</code> (default)</li> </ul> <p>Example:</p> <pre><code>MyTable.render(\n    kwargs={...},\n)\n\n# or\n\nMyTable.render(\n    kwargs={...},\n    deps_strategy=\"document\",\n)\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#fragment-strategy","title":"Fragment strategy","text":"<p>Fragment strategy assumes that the main HTML has already been rendered and loaded on the page. The component renders HTML that will be inserted into the page as a fragment, at a LATER time:</p> <ul> <li>JS and CSS is not directly embedded to avoid duplicately executing the same JS scripts.   So template tags like <code>{% component_js_dependencies %}</code>   inside of fragments are ignored.</li> <li>Instead, django-components appends the fragment's content with a JSON <code>&lt;script&gt;</code> to trigger a call   to its asset manager JS script, which will load the JS and CSS smartly.</li> <li>The asset manager JS script is assumed to be already loaded on the page.</li> </ul> <p>A component is rendered as \"fragment\" when:</p> <ul> <li>It is rendered with <code>Component.render()</code>   or <code>Component.render_to_response()</code>   with the <code>deps_strategy</code> kwarg set to <code>\"fragment\"</code></li> </ul> <p>Example:</p> <pre><code>MyTable.render(\n    kwargs={...},\n    deps_strategy=\"fragment\",\n)\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#live-examples","title":"Live examples","text":"<p>For live interactive examples, start our demo project (<code>sampleproject</code>).</p> <p>Then navigate to these URLs:</p> <ul> <li><code>/fragment/base/alpine</code></li> <li><code>/fragment/base/htmx</code></li> <li><code>/fragment/base/js</code></li> </ul>"},{"location":"concepts/advanced/html_fragments/#example-htmx","title":"Example - HTMX","text":""},{"location":"concepts/advanced/html_fragments/#1-define-document-html","title":"1. Define document HTML","text":"[root]/components/demo.py<pre><code>from django_components import Component, types\n\n# HTML into which a fragment will be loaded using HTMX\nclass MyPage(Component):\n    Class View:\n        def get(self, request):\n            return self.component.render_to_response(request=request)\n\n    template = \"\"\"\n        {% load component_tags %}\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n            &lt;head&gt;\n                {% component_css_dependencies %}\n                &lt;script src=\"https://unpkg.com/htmx.org@1.9.12\"&gt;&lt;/script&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div id=\"target\"&gt;OLD&lt;/div&gt;\n\n                &lt;button\n                    hx-get=\"/mypage/frag\"\n                    hx-swap=\"outerHTML\"\n                    hx-target=\"#target\"\n                &gt;\n                  Click me!\n                &lt;/button&gt;\n\n                {% component_js_dependencies %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    \"\"\"\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#2-define-fragment-html","title":"2. Define fragment HTML","text":"[root]/components/demo.py<pre><code>class Frag(Component):\n    class View:\n        def get(self, request):\n            return self.component.render_to_response(\n                request=request,\n                # IMPORTANT: Don't forget `deps_strategy=\"fragment\"`\n                deps_strategy=\"fragment\",\n            )\n\n    template = \"\"\"\n        &lt;div class=\"frag\"&gt;\n            123\n            &lt;span id=\"frag-text\"&gt;&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    js = \"\"\"\n        document.querySelector('#frag-text').textContent = 'xxx';\n    \"\"\"\n\n    css = \"\"\"\n        .frag {\n            background: blue;\n        }\n    \"\"\"\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#3-create-view-and-urls","title":"3. Create view and URLs","text":"[app]/urls.py<pre><code>from django.urls import path\n\nfrom components.demo import MyPage, Frag\n\nurlpatterns = [\n    path(\"mypage/\", MyPage.as_view())\n    path(\"mypage/frag\", Frag.as_view()),\n]\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#example-alpinejs","title":"Example - AlpineJS","text":""},{"location":"concepts/advanced/html_fragments/#1-define-document-html_1","title":"1. Define document HTML","text":"[root]/components/demo.py<pre><code>from django_components import Component, types\n\n# HTML into which a fragment will be loaded using AlpineJS\nclass MyPage(Component):\n    class View:\n        def get(self, request):\n            return self.component.render_to_response(request=request)\n\n    template = \"\"\"\n        {% load component_tags %}\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n            &lt;head&gt;\n                {% component_css_dependencies %}\n                &lt;script defer src=\"https://unpkg.com/alpinejs\"&gt;&lt;/script&gt;\n            &lt;/head&gt;\n            &lt;body x-data=\"{\n                htmlVar: 'OLD',\n                loadFragment: function () {\n                    const url = '/mypage/frag';\n                    fetch(url)\n                        .then(response =&gt; response.text())\n                        .then(html =&gt; {\n                            this.htmlVar = html;\n                        });\n                }\n            }\"&gt;\n                &lt;div id=\"target\" x-html=\"htmlVar\"&gt;OLD&lt;/div&gt;\n\n                &lt;button @click=\"loadFragment\"&gt;\n                  Click me!\n                &lt;/button&gt;\n\n                {% component_js_dependencies %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    \"\"\"\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#2-define-fragment-html_1","title":"2. Define fragment HTML","text":"[root]/components/demo.py<pre><code>class Frag(Component):\n    class View:\n        def get(self, request):\n            return self.component.render_to_response(\n                request=request,\n                # IMPORTANT: Don't forget `deps_strategy=\"fragment\"`\n                deps_strategy=\"fragment\",\n            )\n\n    # NOTE: We wrap the actual fragment in a template tag with x-if=\"false\" to prevent it\n    #       from being rendered until we have registered the component with AlpineJS.\n    template = \"\"\"\n        &lt;template x-if=\"false\" data-name=\"frag\"&gt;\n            &lt;div class=\"frag\"&gt;\n                123\n                &lt;span x-data=\"frag\" x-text=\"fragVal\"&gt;\n                &lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/template&gt;\n    \"\"\"\n\n    js = \"\"\"\n        Alpine.data('frag', () =&gt; ({\n            fragVal: 'xxx',\n        }));\n\n        // Now that the component has been defined in AlpineJS, we can \"activate\"\n        // all instances where we use the `x-data=\"frag\"` directive.\n        document.querySelectorAll('[data-name=\"frag\"]').forEach((el) =&gt; {\n            el.setAttribute('x-if', 'true');\n        });\n    \"\"\"\n\n    css = \"\"\"\n        .frag {\n            background: blue;\n        }\n    \"\"\"\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#3-create-view-and-urls_1","title":"3. Create view and URLs","text":"[app]/urls.py<pre><code>from django.urls import path\n\nfrom components.demo import MyPage, Frag\n\nurlpatterns = [\n    path(\"mypage/\", MyPage.as_view())\n    path(\"mypage/frag\", Frag.as_view()),\n]\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#example-vanilla-js","title":"Example - Vanilla JS","text":""},{"location":"concepts/advanced/html_fragments/#1-define-document-html_2","title":"1. Define document HTML","text":"[root]/components/demo.py<pre><code>from django_components import Component, types\n\n# HTML into which a fragment will be loaded using JS\nclass MyPage(Component):\n    class View:\n        def get(self, request):\n            return self.component.render_to_response(request=request)\n\n    template = \"\"\"\n        {% load component_tags %}\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n            &lt;head&gt;\n                {% component_css_dependencies %}\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div id=\"target\"&gt;OLD&lt;/div&gt;\n\n                &lt;button&gt;\n                  Click me!\n                &lt;/button&gt;\n                &lt;script&gt;\n                    const url = `/mypage/frag`;\n                    document.querySelector('#loader').addEventListener('click', function () {\n                        fetch(url)\n                            .then(response =&gt; response.text())\n                            .then(html =&gt; {\n                                document.querySelector('#target').outerHTML = html;\n                            });\n                    });\n                &lt;/script&gt;\n\n                {% component_js_dependencies %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    \"\"\"\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#2-define-fragment-html_2","title":"2. Define fragment HTML","text":"[root]/components/demo.py<pre><code>class Frag(Component):\n    class View:\n        def get(self, request):\n            return self.component.render_to_response(\n                request=request,\n                # IMPORTANT: Don't forget `deps_strategy=\"fragment\"`\n                deps_strategy=\"fragment\",\n            )\n\n    template = \"\"\"\n        &lt;div class=\"frag\"&gt;\n            123\n            &lt;span id=\"frag-text\"&gt;&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    js = \"\"\"\n        document.querySelector('#frag-text').textContent = 'xxx';\n    \"\"\"\n\n    css = \"\"\"\n        .frag {\n            background: blue;\n        }\n    \"\"\"\n</code></pre>"},{"location":"concepts/advanced/html_fragments/#3-create-view-and-urls_2","title":"3. Create view and URLs","text":"[app]/urls.py<pre><code>from django.urls import path\n\nfrom components.demo import MyPage, Frag\n\nurlpatterns = [\n    path(\"mypage/\", MyPage.as_view())\n    path(\"mypage/frag\", Frag.as_view()),\n]\n</code></pre>"},{"location":"concepts/advanced/provide_inject/","title":"Prop drilling and provide / inject","text":"<p>New in version 0.80:</p> <p><code>django-components</code> supports the provide / inject pattern, similarly to React's Context Providers or Vue's provide / inject.</p> <p>This is achieved with the combination of:</p> <ul> <li><code>{% provide %}</code> tag</li> <li><code>Component.inject()</code> method</li> </ul>"},{"location":"concepts/advanced/provide_inject/#what-is-prop-drilling","title":"What is \"prop drilling\"","text":"<p>Prop drilling refers to a scenario in UI development where you need to pass data through many layers of a component tree to reach the nested components that actually need the data.</p> <p>Normally, you'd use props to send data from a parent component to its children. However, this straightforward method becomes cumbersome and inefficient if the data has to travel through many levels or if several components scattered at different depths all need the same piece of information.</p> <p>This results in a situation where the intermediate components, which don't need the data for their own functioning, end up having to manage and pass along these props. This clutters the component tree and makes the code verbose and harder to manage.</p> <p>A neat solution to avoid prop drilling is using the \"provide and inject\" technique.</p> <p>With provide / inject, a parent component acts like a data hub for all its descendants. This setup allows any component, no matter how deeply nested it is, to access the required data directly from this centralized provider without having to messily pass props down the chain. This approach significantly cleans up the code and makes it easier to maintain.</p> <p>This feature is inspired by Vue's Provide / Inject and React's Context / useContext.</p> <p>As the name suggest, using provide / inject consists of 2 steps</p> <ol> <li>Providing data</li> <li>Injecting provided data</li> </ol> <p>For examples of advanced uses of provide / inject, see this discussion.</p>"},{"location":"concepts/advanced/provide_inject/#providing-data","title":"Providing data","text":"<p>First we use the <code>{% provide %}</code> tag to define the data we want to \"provide\" (make available).</p> <pre><code>{% provide \"my_data\" hello=\"hi\" another=123 %}\n    {% component \"child\" / %}  &lt;--- Can access \"my_data\"\n{% endprovide %}\n\n{% component \"child\" / %}  &lt;--- Cannot access \"my_data\"\n</code></pre> <p>The first argument to the <code>{% provide %}</code> tag is the key by which we can later access the data passed to this tag. The key in this case is <code>\"my_data\"</code>.</p> <p>The key must resolve to a valid identifier (AKA a valid Python variable name).</p> <p>Next you define the data you want to \"provide\" by passing them as keyword arguments. This is similar to how you pass data to the <code>{% with %}</code> tag or the <code>{% slot %}</code> tag.</p> <p>Note</p> <p>Kwargs passed to <code>{% provide %}</code> are NOT added to the context. In the example below, the <code>{{ hello }}</code> won't render anything:</p> <pre><code>{% provide \"my_data\" hello=\"hi\" another=123 %}\n    {{ hello }}\n{% endprovide %}\n</code></pre> <p>Similarly to slots and fills, also provide's name argument can be set dynamically via a variable, a template expression, or a spread operator:</p> <pre><code>{% with my_name=\"my_name\" %}\n    {% provide name=my_name ... %}\n        ...\n    {% endprovide %}\n{% endwith %}\n</code></pre>"},{"location":"concepts/advanced/provide_inject/#injecting-data","title":"Injecting data","text":"<p>To \"inject\" (access) the data defined on the <code>{% provide %}</code> tag, you can use the <code>Component.inject()</code> method from within any other component methods.</p> <p>For a component to be able to \"inject\" some data, the component (<code>{% component %}</code> tag) must be nested inside the <code>{% provide %}</code> tag.</p> <p>In the example from previous section, we've defined two kwargs: <code>hello=\"hi\" another=123</code>. That means that if we now inject <code>\"my_data\"</code>, we get an object with 2 attributes - <code>hello</code> and <code>another</code>.</p> <pre><code>class ChildComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        my_data = self.inject(\"my_data\")\n        print(my_data.hello)    # hi\n        print(my_data.another)  # 123\n        return {}\n</code></pre> <p>First argument to <code>Component.inject()</code> is the key (or name) of the provided data. This must match the string that you used in the <code>{% provide %}</code> tag.</p> <p>If no provider with given key is found, <code>inject()</code> raises a <code>KeyError</code>.</p> <p>To avoid the error, you can pass a second argument to <code>inject()</code>. This will act as a default value similar to <code>dict.get(key, default)</code>:</p> <pre><code>class ChildComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        my_data = self.inject(\"invalid_key\", DEFAULT_DATA)\n        assert my_data == DEFAULT_DATA\n        return {}\n</code></pre> <p>Note</p> <p>The instance returned from <code>inject()</code> is immutable (subclass of <code>NamedTuple</code>). This ensures that the data returned from <code>inject()</code> will always have all the keys that were passed to the <code>{% provide %}</code> tag.</p> <p>Warning</p> <p><code>inject()</code> works strictly only during render execution. If you try to call <code>inject()</code> from outside, it will raise an error.</p>"},{"location":"concepts/advanced/provide_inject/#full-example","title":"Full example","text":"<pre><code>@register(\"child\")\nclass ChildComponent(Component):\n    template = \"\"\"\n        &lt;div&gt; {{ my_data.hello }} &lt;/div&gt;\n        &lt;div&gt; {{ my_data.another }} &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        my_data = self.inject(\"my_data\", \"default\")\n        return {\"my_data\": my_data}\n\ntemplate_str = \"\"\"\n    {% load component_tags %}\n    {% provide \"my_data\" hello=\"hi\" another=123 %}\n        {% component \"child\" / %}\n    {% endprovide %}\n\"\"\"\n</code></pre> <p>renders:</p> <pre><code>&lt;div&gt;hi&lt;/div&gt;\n&lt;div&gt;123&lt;/div&gt;\n</code></pre>"},{"location":"concepts/advanced/rendering_js_css/","title":"Rendering JS / CSS","text":""},{"location":"concepts/advanced/rendering_js_css/#js-and-css-output-locations","title":"JS and CSS output locations","text":"<p>If:</p> <ol> <li>Your components use JS and CSS via any of:<ul> <li><code>Component.css</code></li> <li><code>Component.js</code></li> <li><code>Component.Media.css</code></li> <li><code>Component.Media.js</code></li> </ul> </li> <li>And you use the <code>ComponentDependencyMiddleware</code> middleware</li> </ol> <p>Then, by default, the components' JS and CSS will be automatically inserted into the HTML:</p> <ul> <li>CSS styles will be inserted at the end of the <code>&lt;head&gt;</code></li> <li>JS scripts will be inserted at the end of the <code>&lt;body&gt;</code></li> </ul> <p>If you want to place the dependencies elsewhere in the HTML, you can override the locations by inserting following Django template tags:</p> <ul> <li><code>{% component_js_dependencies %}</code> - Set new location(s) for JS scripts</li> <li><code>{% component_css_dependencies %}</code> - Set new location(s) for CSS styles</li> </ul> <p>So if you have a component with JS and CSS:</p> <pre><code>from django_components import Component, types\n\nclass MyButton(Component):\n    template: types.django_html = \"\"\"\n        &lt;button class=\"my-button\"&gt;\n            Click me!\n        &lt;/button&gt;\n    \"\"\"\n    js: types.js = \"\"\"\n        for (const btnEl of document.querySelectorAll(\".my-button\")) {\n            btnEl.addEventListener(\"click\", () =&gt; {\n                console.log(\"BUTTON CLICKED!\");\n            });\n        }\n    \"\"\"\n    css: types.css \"\"\"\n        .my-button {\n            background: green;\n        }\n    \"\"\"\n\n    class Media:\n        js = [\"/extra/script.js\"]\n        css = [\"/extra/style.css\"]\n</code></pre> <p>Then the JS from <code>MyButton.js</code> and <code>MyButton.Media.js</code> will be rendered at the default place, or in <code>{% component_js_dependencies %}</code>.</p> <p>And the CSS from <code>MyButton.css</code> and <code>MyButton.Media.css</code> will be rendered at the default place, or in <code>{% component_css_dependencies %}</code>.</p> <p>And if you don't specify <code>{% component_dependencies %}</code> tags, it is the equivalent of:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;MyPage&lt;/title&gt;\n    ...\n    {% component_css_dependencies %}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;main&gt;\n      ...\n    &lt;/main&gt;\n    {% component_js_dependencies %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"concepts/advanced/rendering_js_css/#setting-up-the-middleware","title":"Setting up the middleware","text":"<p><code>ComponentDependencyMiddleware</code> is a Django middleware designed to manage and inject CSS / JS dependencies of rendered components dynamically. It ensures that only the necessary stylesheets and scripts are loaded in your HTML responses, based on the components used in your Django templates.</p> <p>To set it up, add the middleware to your <code>MIDDLEWARE</code> in <code>settings.py</code>:</p> <pre><code>MIDDLEWARE = [\n    # ... other middleware classes ...\n    'django_components.middleware.ComponentDependencyMiddleware'\n    # ... other middleware classes ...\n]\n</code></pre>"},{"location":"concepts/advanced/rendering_js_css/#render_dependencies-and-rendering-js-css-without-the-middleware","title":"<code>render_dependencies</code> and rendering JS / CSS without the middleware","text":"<p>For most scenarios, using the <code>ComponentDependencyMiddleware</code> middleware will be just fine.</p> <p>However, this section is for you if you want to:</p> <ul> <li>Render HTML that will NOT be sent as a server response</li> <li>Insert pre-rendered HTML into another component</li> <li>Render HTML fragments (partials)</li> </ul> <p>Every time there is an HTML string that has parts which were rendered using components, and any of those components has JS / CSS, then this HTML string MUST be processed with <code>render_dependencies()</code>.</p> <p>It is actually <code>render_dependencies()</code> that finds all used components in the HTML string, and inserts the component's JS and CSS into <code>{% component_dependencies %}</code> tags, or at the default locations.</p>"},{"location":"concepts/advanced/rendering_js_css/#render-js-css-without-the-middleware","title":"Render JS / CSS without the middleware","text":"<p>The truth is that the <code>ComponentDependencyMiddleware</code> middleware just calls <code>render_dependencies()</code>, passing in the HTML content. So if you render a template that contained <code>{% component %}</code> tags, you MUST pass the result through <code>render_dependencies()</code>. And the middleware is just one of the options.</p> <p>Here is how you can achieve the same, without the middleware, using <code>render_dependencies()</code>:</p> <pre><code>from django.template.base import Template\nfrom django.template.context import Context\nfrom django_component import render_dependencies\n\ntemplate = Template(\"\"\"\n    {% load component_tags %}\n    &lt;!doctype html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;MyPage&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;main&gt;\n            {% component \"my_button\" %}\n                Click me!\n            {% endcomponent %}\n        &lt;/main&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n\"\"\")\n\nrendered = template.render(Context())\nrendered = render_dependencies(rendered)\n</code></pre> <p>Same applies if you render a template using Django's <code>django.shortcuts.render</code>:</p> <pre><code>from django.shortcuts import render\n\ndef my_view(request):\n    rendered = render(request, \"pages/home.html\")\n    rendered = render_dependencies(rendered)\n    return rendered\n</code></pre> <p>Alternatively, when you render HTML with <code>Component.render()</code> or <code>Component.render_to_response()</code>, these, by default, call <code>render_dependencies()</code> for you, so you don't have to:</p> <pre><code>from django_components import Component\n\nclass MyButton(Component):\n    ...\n\n# No need to call `render_dependencies()`\nrendered = MyButton.render()\n</code></pre>"},{"location":"concepts/advanced/rendering_js_css/#inserting-pre-rendered-html-into-another-component","title":"Inserting pre-rendered HTML into another component","text":"<p>In previous section we've shown that <code>render_dependencies()</code> does NOT need to be called when you render a component via <code>Component.render()</code>.</p> <p>API of django_components makes it possible to compose components in a \"React-like\" way, where we pre-render a piece of HTML and then insert it into a larger structure.</p> <p>To do this, you must add <code>render_dependencies=False</code> to the nested components:</p> <pre><code>card_actions = CardActions.render(\n    kwargs={\"editable\": editable},\n    render_dependencies=False,\n)\n\ncard = Card.render(\n    slots={\"actions\": card_actions},\n    render_dependencies=False,\n)\n\npage = MyPage.render(\n    slots={\"card\": card},\n)\n</code></pre> <p>Why is <code>render_dependencies=False</code> required?</p> <p>This is a technical limitation of the current implementation.</p> <p>As mentioned earlier, each time we call <code>Component.render()</code>, we also call <code>render_dependencies()</code>.</p> <p>However, there is a problem here - When we call <code>render_dependencies()</code> inside <code>CardActions.render()</code>, we extract and REMOVE the info on components' JS and CSS from the HTML. But the template of <code>CardActions</code> contains no <code>{% component_depedencies %}</code> tags, and nor <code>&lt;head&gt;</code> nor <code>&lt;body&gt;</code> HTML tags. So the component's JS and CSS will NOT be inserted, and will be lost.</p> <p>To work around this, you must set <code>render_dependencies=False</code> when rendering pieces of HTML with <code>Component.render()</code> and inserting them into larger structures.</p>"},{"location":"concepts/advanced/rendering_js_css/#summary","title":"Summary","text":"<ol> <li>Every time you render HTML that contained components, you have to call <code>render_dependencies()</code>    on the rendered output.</li> <li>There are several ways to call <code>render_dependencies()</code>:<ul> <li>Using the <code>ComponentDependencyMiddleware</code> middleware</li> <li>Rendering the HTML by calling <code>Component.render()</code> with <code>render_dependencies=True</code> (default)</li> <li>Rendering the HTML by calling <code>Component.render_to_response()</code> (always renders dependencies)</li> <li>Directly passing rendered HTML to <code>render_dependencies()</code></li> </ul> </li> <li>If you pre-render one component to pass it into another, the pre-rendered component must be rendered with    <code>render_dependencies=False</code>.</li> </ol>"},{"location":"concepts/advanced/rendering_js_css/#dependencies-strategies","title":"Dependencies strategies","text":"<p>The rendered HTML may be used in different contexts (browser, email, etc). If your components use JS and CSS scripts, you may need to handle them differently.</p> <p><code>render()</code> and <code>render_to_response()</code> accept a <code>deps_strategy</code> parameter, which controls where and how the JS / CSS are inserted into the HTML.</p> <p>The <code>deps_strategy</code> parameter is set at the root of a component render tree, which is why it is not available for the <code>{% component %}</code> tag.</p> <p>Info</p> <p>The <code>deps_strategy</code> parameter is ultimately passed to <code>render_dependencies()</code>.</p> <p>There are five dependencies strategies:</p> <ul> <li><code>document</code> (default)<ul> <li>Smartly inserts JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Inserts extra script to allow <code>fragment</code> strategy to work.</li> <li>Assumes the HTML will be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>fragment</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>No JS / CSS included.</li> </ul> </li> <li><code>simple</code><ul> <li>Smartly insert JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>prepend</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>append</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> </ul>"},{"location":"concepts/advanced/rendering_js_css/#document","title":"<code>document</code>","text":"<p><code>deps_strategy=\"document\"</code> is the default. Use this if you are rendering a whole page, or if no other option suits better.</p> <pre><code>html = Button.render(deps_strategy=\"document\")\n</code></pre> <p>When you render a component tree with the <code>\"document\"</code> strategy, it is expected that:</p> <ul> <li>The HTML will be rendered at page load.</li> <li>The HTML will be inserted into a page / browser where JS can be executed.</li> </ul> <p>Location:</p> <p>JS and CSS is inserted:</p> <ul> <li>Preferentially into JS / CSS placeholders like <code>{% component_js_dependencies %}</code></li> <li>Otherwise, JS into <code>&lt;body&gt;</code> element, and CSS into <code>&lt;head&gt;</code> element</li> <li>If neither found, JS / CSS are NOT inserted</li> </ul> <p>Included scripts:</p> <p>For the <code>\"document\"</code> strategy, the JS and CSS is set up to avoid any delays when the end user loads the page in the browser:</p> <ul> <li> <p>Components' primary JS and CSS scripts (<code>Component.js</code>   and <code>Component.css</code>) - fully inlined:</p> <pre><code>&lt;script&gt;\n    console.log(\"Hello from Button!\");\n&lt;/script&gt;\n&lt;style&gt;\n    .button {\n    background-color: blue;\n    }\n&lt;/style&gt;\n</code></pre> </li> <li> <p>Components' secondary JS and CSS scripts   (<code>Component.Media</code>) - inserted as links:</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://example.com/styles.css\" /&gt;\n&lt;script src=\"https://example.com/script.js\"&gt;&lt;/script&gt;\n</code></pre> </li> <li> <p>A JS script is injected to manage component dependencies, enabling lazy loading of JS and CSS   for HTML fragments.</p> </li> </ul> <p>Info</p> <p>This strategy is required for fragments to work properly, as it sets up the dependency manager that fragments rely on.</p> <p>How the dependency manager works</p> <p>The dependency manager is a JS script that keeps track of all the JS and CSS dependencies that have already been loaded.</p> <p>When a fragment is inserted into the page, it will also insert a JSON <code>&lt;script&gt;</code> tag with fragment metadata.</p> <p>The dependency manager will pick up on that, and check which scripts the fragment needs.</p> <p>It will then fetch only the scripts that haven't been loaded yet.</p>"},{"location":"concepts/advanced/rendering_js_css/#fragment","title":"<code>fragment</code>","text":"<p><code>deps_strategy=\"fragment\"</code> is used when rendering a piece of HTML that will be inserted into a page that has already been rendered with the <code>\"document\"</code> strategy:</p> <pre><code>fragment = MyComponent.render(deps_strategy=\"fragment\")\n</code></pre> <p>The HTML of fragments is very lightweight because it doesn't include the JS and CSS scripts of the rendered components.</p> <p>With fragments, even if a component has JS and CSS, you can insert the same component into a page hundreds of times, and the JS and CSS will only ever be loaded once.</p> <p>This is intended for dynamic content that's loaded with AJAX after the initial page load, such as with jQuery, HTMX, AlpineJS or similar libraries.</p> <p>Location:</p> <p>None. The fragment's JS and CSS files will be loaded dynamically into the page.</p> <p>Included scripts:</p> <ul> <li>A special JSON <code>&lt;script&gt;</code> tag that tells the dependency manager what JS and CSS to load.</li> </ul>"},{"location":"concepts/advanced/rendering_js_css/#simple","title":"<code>simple</code>","text":"<p><code>deps_strategy=\"simple\"</code> is used either for non-browser use cases, or when you don't want to use the dependency manager.</p> <p>Practically, this is the same as the <code>\"document\"</code> strategy, except that the dependency manager is not used.</p> <pre><code>html = MyComponent.render(deps_strategy=\"simple\")\n</code></pre> <p>Location:</p> <p>JS and CSS is inserted:</p> <ul> <li>Preferentially into JS / CSS placeholders like <code>{% component_js_dependencies %}</code></li> <li>Otherwise, JS into <code>&lt;body&gt;</code> element, and CSS into <code>&lt;head&gt;</code> element</li> <li>If neither found, JS / CSS are NOT inserted</li> </ul> <p>Included scripts:</p> <ul> <li> <p>Components' primary JS and CSS scripts (<code>Component.js</code>   and <code>Component.css</code>) - fully inlined:</p> <pre><code>&lt;script&gt;\n    console.log(\"Hello from Button!\");\n&lt;/script&gt;\n&lt;style&gt;\n    .button {\n        background-color: blue;\n    }\n&lt;/style&gt;\n</code></pre> </li> <li> <p>Components' secondary JS and CSS scripts   (<code>Component.Media</code>) - inserted as links:</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://example.com/styles.css\" /&gt;\n&lt;script src=\"https://example.com/script.js\"&gt;&lt;/script&gt;\n</code></pre> </li> <li> <p>No extra scripts are inserted.</p> </li> </ul>"},{"location":"concepts/advanced/rendering_js_css/#prepend","title":"<code>prepend</code>","text":"<p>This is the same as <code>\"simple\"</code>, but placeholders like <code>{% component_js_dependencies %}</code> and HTML tags <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> are all ignored. The JS and CSS are always inserted before the rendered content.</p> <pre><code>html = MyComponent.render(deps_strategy=\"prepend\")\n</code></pre> <p>Location:</p> <p>JS and CSS is always inserted before the rendered content.</p> <p>Included scripts:</p> <p>Same as for the <code>\"simple\"</code> strategy.</p>"},{"location":"concepts/advanced/rendering_js_css/#append","title":"<code>append</code>","text":"<p>This is the same as <code>\"simple\"</code>, but placeholders like <code>{% component_js_dependencies %}</code> and HTML tags <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> are all ignored. The JS and CSS are always inserted after the rendered content.</p> <pre><code>html = MyComponent.render(deps_strategy=\"append\")\n</code></pre> <p>Location:</p> <p>JS and CSS is always inserted after the rendered content.</p> <p>Included scripts:</p> <p>Same as for the <code>\"simple\"</code> strategy.</p>"},{"location":"concepts/advanced/tag_formatters/","title":"Tag formatters","text":""},{"location":"concepts/advanced/tag_formatters/#customizing-component-tags-with-tagformatter","title":"Customizing component tags with TagFormatter","text":"<p>New in version 0.89</p> <p>By default, components are rendered using the pair of <code>{% component %}</code> / <code>{% endcomponent %}</code> template tags:</p> <pre><code>{% component \"button\" href=\"...\" disabled %}\nClick me!\n{% endcomponent %}\n\n{# or #}\n\n{% component \"button\" href=\"...\" disabled / %}\n</code></pre> <p>You can change this behaviour in the settings under the <code>COMPONENTS.tag_formatter</code>.</p> <p>For example, if you set the tag formatter to</p> <p><code>django_components.component_shorthand_formatter</code></p> <p>then the components' names will be used as the template tags:</p> <pre><code>{% button href=\"...\" disabled %}\n  Click me!\n{% endbutton %}\n\n{# or #}\n\n{% button href=\"...\" disabled / %}\n</code></pre>"},{"location":"concepts/advanced/tag_formatters/#available-tagformatters","title":"Available TagFormatters","text":"<p>django_components provides following predefined TagFormatters:</p> <ul> <li><code>ComponentFormatter</code> (<code>django_components.component_formatter</code>)</li> </ul> <p>Default</p> <p>Uses the <code>component</code> and <code>endcomponent</code> tags, and the component name is gives as the first positional argument.</p> <p>Example as block:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    {% fill \"content\" %}\n        ...\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Example as inlined tag:</p> <pre><code>{% component \"button\" href=\"...\" / %}\n</code></pre> <ul> <li><code>ShorthandComponentFormatter</code> (<code>django_components.component_shorthand_formatter</code>)</li> </ul> <p>Uses the component name as start tag, and <code>end&lt;component_name&gt;</code>   as an end tag.</p> <p>Example as block:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> <p>Example as inlined tag:</p> <pre><code>{% button href=\"...\" / %}\n</code></pre>"},{"location":"concepts/advanced/tag_formatters/#writing-your-own-tagformatter","title":"Writing your own TagFormatter","text":""},{"location":"concepts/advanced/tag_formatters/#background","title":"Background","text":"<p>First, let's discuss how TagFormatters work, and how components are rendered in django_components.</p> <p>When you render a component with <code>{% component %}</code> (or your own tag), the following happens:</p> <ol> <li><code>component</code> must be registered as a Django's template tag</li> <li>Django triggers django_components's tag handler for tag <code>component</code>.</li> <li>The tag handler passes the tag contents for pre-processing to <code>TagFormatter.parse()</code>.</li> </ol> <p>So if you render this:</p> <pre><code>{% component \"button\" href=\"...\" disabled %}\n{% endcomponent %}\n</code></pre> <p>Then <code>TagFormatter.parse()</code> will receive a following input:</p> <pre><code>[\"component\", '\"button\"', 'href=\"...\"', 'disabled']\n</code></pre> <ol> <li><code>TagFormatter</code> extracts the component name and the remaining input.</li> </ol> <p>So, given the above, <code>TagFormatter.parse()</code> returns the following:</p> <pre><code>TagResult(\n    component_name=\"button\",\n    tokens=['href=\"...\"', 'disabled']\n)\n</code></pre> <ol> <li>The tag handler resumes, using the tokens returned from <code>TagFormatter</code>.</li> </ol> <p>So, continuing the example, at this point the tag handler practically behaves as if you rendered:</p> <pre><code>{% component href=\"...\" disabled %}\n</code></pre> <ol> <li>Tag handler looks up the component <code>button</code>, and passes the args, kwargs, and slots to it.</li> </ol>"},{"location":"concepts/advanced/tag_formatters/#tagformatter","title":"TagFormatter","text":"<p><code>TagFormatter</code> handles following parts of the process above:</p> <ul> <li> <p>Generates start/end tags, given a component. This is what you then call from within your template as <code>{% component %}</code>.</p> </li> <li> <p>When you <code>{% component %}</code>, tag formatter pre-processes the tag contents, so it can link back the custom template tag to the right component.</p> </li> </ul> <p>To do so, subclass from <code>TagFormatterABC</code> and implement following method:</p> <ul> <li><code>start_tag</code></li> <li><code>end_tag</code></li> <li><code>parse</code></li> </ul> <p>For example, this is the implementation of <code>ShorthandComponentFormatter</code></p> <pre><code>class ShorthandComponentFormatter(TagFormatterABC):\n    # Given a component name, generate the start template tag\n    def start_tag(self, name: str) -&gt; str:\n        return name  # e.g. 'button'\n\n    # Given a component name, generate the start template tag\n    def end_tag(self, name: str) -&gt; str:\n        return f\"end{name}\"  # e.g. 'endbutton'\n\n    # Given a tag, e.g.\n    # `{% button href=\"...\" disabled %}`\n    #\n    # The parser receives:\n    # `['button', 'href=\"...\"', 'disabled']`\n    def parse(self, tokens: List[str]) -&gt; TagResult:\n        tokens = [*tokens]\n        name = tokens.pop(0)\n        return TagResult(\n            name,  # e.g. 'button'\n            tokens  # e.g. ['href=\"...\"', 'disabled']\n        )\n</code></pre> <p>That's it! And once your <code>TagFormatter</code> is ready, don't forget to update the settings!</p>"},{"location":"concepts/advanced/template_tags/","title":"Custom template tags","text":"<p>Template tags introduced by django-components, such as <code>{% component %}</code> and <code>{% slot %}</code>, offer additional features over the default Django template tags:</p> <ul> <li>Self-closing tags <code>{% mytag / %}</code></li> <li>Allowing the use of <code>:</code>, <code>-</code> (and more) in keys</li> <li>Spread operator <code>...</code></li> <li>Using template tags as inputs to other template tags</li> <li>Flat definition of dictionaries <code>attr:key=val</code></li> <li>Function-like input validation</li> </ul> <p>You too can easily create custom template tags that use the above features.</p>"},{"location":"concepts/advanced/template_tags/#defining-template-tags-with-template_tag","title":"Defining template tags with <code>@template_tag</code>","text":"<p>The simplest way to create a custom template tag is using the <code>template_tag</code> decorator. This decorator allows you to define a template tag by just writing a function that returns the rendered content.</p> <pre><code>from django.template import Context, Library\nfrom django_components import BaseNode, template_tag\n\nlibrary = Library()\n\n@template_tag(\n    library,\n    tag=\"mytag\",\n    end_tag=\"endmytag\",\n    allowed_flags=[\"required\"]\n)\ndef mytag(node: BaseNode, context: Context, name: str, **kwargs) -&gt; str:\n    return f\"Hello, {name}!\"\n</code></pre> <p>This will allow you to use the tag in your templates like this:</p> <pre><code>{% mytag name=\"John\" %}\n{% endmytag %}\n\n{# or with self-closing syntax #}\n{% mytag name=\"John\" / %}\n\n{# or with flags #}\n{% mytag name=\"John\" required %}\n{% endmytag %}\n</code></pre>"},{"location":"concepts/advanced/template_tags/#parameters","title":"Parameters","text":"<p>The <code>@template_tag</code> decorator accepts the following parameters:</p> <ul> <li><code>library</code>: The Django template library to register the tag with</li> <li><code>tag</code>: The name of the template tag (e.g. <code>\"mytag\"</code> for <code>{% mytag %}</code>)</li> <li><code>end_tag</code>: Optional. The name of the end tag (e.g. <code>\"endmytag\"</code> for <code>{% endmytag %}</code>)</li> <li><code>allowed_flags</code>: Optional. List of flags that can be used with the tag (e.g. <code>[\"required\"]</code> for <code>{% mytag required %}</code>)</li> </ul>"},{"location":"concepts/advanced/template_tags/#function-signature","title":"Function signature","text":"<p>The function decorated with <code>@template_tag</code> must accept at least two arguments:</p> <ol> <li><code>node</code>: The node instance (we'll explain this in detail in the next section)</li> <li><code>context</code>: The Django template context</li> </ol> <p>Any additional parameters in your function's signature define what inputs your template tag accepts. For example:</p> <pre><code>@template_tag(library, tag=\"greet\")\ndef greet(\n    node: BaseNode,\n    context: Context,\n    name: str,                    # required positional argument\n    count: int = 1,              # optional positional argument\n    *,                           # keyword-only arguments marker\n    msg: str,                    # required keyword argument\n    mode: str = \"default\",       # optional keyword argument\n) -&gt; str:\n    return f\"{msg}, {name}!\" * count\n</code></pre> <p>This allows the tag to be used like:</p> <pre><code>{# All parameters #}\n{% greet \"John\" count=2 msg=\"Hello\" mode=\"custom\" %}\n\n{# Only required parameters #}\n{% greet \"John\" msg=\"Hello\" %}\n\n{# Missing required parameter - will raise error #}\n{% greet \"John\" %}  {# Error: missing 'msg' #}\n</code></pre> <p>When you pass input to a template tag, it behaves the same way as if you passed the input to a function:</p> <ul> <li>If required parameters are missing, an error is raised</li> <li>If unexpected parameters are passed, an error is raised</li> </ul> <p>To accept keys that are not valid Python identifiers (e.g. <code>data-id</code>), or would conflict with Python keywords (e.g. <code>is</code>), you can use the <code>**kwargs</code> syntax:</p> <pre><code>@template_tag(library, tag=\"greet\")\ndef greet(\n    node: BaseNode,\n    context: Context,\n    **kwargs,\n) -&gt; str:\n    attrs = kwargs.copy()\n    is_var = attrs.pop(\"is\", None)\n    attrs_str = \" \".join(f'{k}=\"{v}\"' for k, v in attrs.items())\n\n    return mark_safe(f\"\"\"\n        &lt;div {attrs_str}&gt;\n            Hello, {is_var}!\n        &lt;/div&gt;\n    \"\"\")\n</code></pre> <p>This allows you to use the tag like this:</p> <pre><code>{% greet is=\"John\" data-id=\"123\" %}\n</code></pre>"},{"location":"concepts/advanced/template_tags/#defining-template-tags-with-basenode","title":"Defining template tags with <code>BaseNode</code>","text":"<p>For more control over your template tag, you can subclass <code>BaseNode</code> directly instead of using the decorator. This gives you access to additional features like the node's internal state and parsing details.</p> <pre><code>from django_components import BaseNode\n\nclass GreetNode(BaseNode):\n    tag = \"greet\"\n    end_tag = \"endgreet\"\n    allowed_flags = [\"required\"]\n\n    def render(self, context: Context, name: str, **kwargs) -&gt; str:\n        # Access node properties\n        if self.flags[\"required\"]:\n            return f\"Required greeting: Hello, {name}!\"\n        return f\"Hello, {name}!\"\n\n# Register the node\nGreetNode.register(library)\n</code></pre>"},{"location":"concepts/advanced/template_tags/#node-properties","title":"Node properties","text":"<p>When using <code>BaseNode</code>, you have access to several useful properties:</p> <ul> <li><code>node_id</code>: A unique identifier for this node instance</li> <li><code>flags</code>: Dictionary of flag values (e.g. <code>{\"required\": True}</code>)</li> <li><code>params</code>: List of raw parameters passed to the tag</li> <li><code>nodelist</code>: The template nodes between the start and end tags</li> <li><code>active_flags</code>: List of flags that are currently set to True</li> </ul> <p>This is what the <code>node</code> parameter in the <code>@template_tag</code> decorator gives you access to - it's the instance of the node class that was automatically created for your template tag.</p>"},{"location":"concepts/advanced/template_tags/#rendering-content-between-tags","title":"Rendering content between tags","text":"<p>When your tag has an end tag, you can access and render the content between the tags using <code>nodelist</code>:</p> <pre><code>class WrapNode(BaseNode):\n    tag = \"wrap\"\n    end_tag = \"endwrap\"\n\n    def render(self, context: Context, tag: str = \"div\", **attrs) -&gt; str:\n        # Render the content between tags\n        inner = self.nodelist.render(context)\n        attrs_str = \" \".join(f'{k}=\"{v}\"' for k, v in attrs.items())\n        return f\"&lt;{tag} {attrs_str}&gt;{inner}&lt;/{tag}&gt;\"\n\n# Usage:\n{% wrap tag=\"section\" class=\"content\" %}\n    Hello, world!\n{% endwrap %}\n</code></pre>"},{"location":"concepts/advanced/template_tags/#unregistering-nodes","title":"Unregistering nodes","text":"<p>You can unregister a node from a library using the <code>unregister</code> method:</p> <pre><code>GreetNode.unregister(library)\n</code></pre> <p>This is particularly useful in testing when you want to clean up after registering temporary tags.</p>"},{"location":"concepts/advanced/testing/","title":"Testing","text":"<p>New in version 0.131</p> <p>The <code>@djc_test</code> decorator is a powerful tool for testing components created with <code>django-components</code>. It ensures that each test is properly isolated, preventing components registered in one test from affecting others.</p>"},{"location":"concepts/advanced/testing/#usage","title":"Usage","text":"<p>The <code>@djc_test</code> decorator can be applied to functions, methods, or classes.</p> <p>When applied to a class, it decorates all methods starting with <code>test_</code>, and all nested classes starting with <code>Test</code>, recursively.</p>"},{"location":"concepts/advanced/testing/#applying-to-a-function","title":"Applying to a Function","text":"<p>To apply <code>djc_test</code> to a function, simply decorate the function as shown below:</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\n@djc_test\ndef test_my_component():\n    @register(\"my_component\")\n    class MyComponent(Component):\n        template = \"...\"\n    ...\n</code></pre>"},{"location":"concepts/advanced/testing/#applying-to-a-class","title":"Applying to a Class","text":"<p>When applied to a class, <code>djc_test</code> decorates each <code>test_</code> method, as well as all nested classes starting with <code>Test</code>.</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\n@djc_test\nclass TestMyComponent:\n    def test_something(self):\n        ...\n\n    class TestNested:\n        def test_something_else(self):\n            ...\n</code></pre> <p>This is equivalent to applying the decorator to both of the methods individually:</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\nclass TestMyComponent:\n    @djc_test\n    def test_something(self):\n        ...\n\n    class TestNested:\n        @djc_test\n        def test_something_else(self):\n            ...\n</code></pre>"},{"location":"concepts/advanced/testing/#arguments","title":"Arguments","text":"<p>See the API reference for <code>@djc_test</code> for more details.</p>"},{"location":"concepts/advanced/testing/#setting-up-django","title":"Setting Up Django","text":"<p>If you want to define a common Django settings that would be the baseline for all tests, you can call <code>django.setup()</code> before the <code>@djc_test</code> decorator:</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\ndjango.setup(...)\n\n@djc_test\ndef test_my_component():\n    ...\n</code></pre> <p>Info</p> <p>If you omit <code>django.setup()</code> in the example above, <code>@djc_test</code> will call it for you, so you don't need to do it manually.</p>"},{"location":"concepts/advanced/testing/#example-parametrizing-context-behavior","title":"Example: Parametrizing Context Behavior","text":"<p>You can parametrize the context behavior using <code>djc_test</code>:</p> <pre><code>from django_components.testing import djc_test\n\n@djc_test(\n    # Settings applied to all cases\n    components_settings={\n        \"app_dirs\": [\"custom_dir\"],\n    },\n    # Parametrized settings\n    parametrize=(\n        [\"components_settings\"],\n        [\n            [{\"context_behavior\": \"django\"}],\n            [{\"context_behavior\": \"isolated\"}],\n        ],\n        [\"django\", \"isolated\"],\n    )\n)\ndef test_context_behavior(components_settings):\n    rendered = MyComponent().render()\n    ...\n</code></pre>"},{"location":"concepts/fundamentals/autodiscovery/","title":"Autodiscovery","text":"<p>django-components automatically searches for files containing components in the <code>COMPONENTS.dirs</code> and  <code>COMPONENTS.app_dirs</code> directories.</p>"},{"location":"concepts/fundamentals/autodiscovery/#manually-register-components","title":"Manually register components","text":"<p>Every component that you want to use in the template with the <code>{% component %}</code> tag needs to be registered with the <code>ComponentRegistry</code>.</p> <p>We use the <code>@register</code> decorator for that:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    ...\n</code></pre> <p>But for the component to be registered, the code needs to be executed - and for that, the file needs to be imported as a module.</p> <p>This is the \"discovery\" part of the process.</p> <p>One way to do that is by importing all your components in <code>apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\nclass MyAppConfig(AppConfig):\n    name = \"my_app\"\n\n    def ready(self) -&gt; None:\n        from components.card.card import Card\n        from components.list.list import List\n        from components.menu.menu import Menu\n        from components.button.button import Button\n        ...\n</code></pre> <p>However, there's a simpler way!</p>"},{"location":"concepts/fundamentals/autodiscovery/#autodiscovery","title":"Autodiscovery","text":"<p>By default, the Python files found in the <code>COMPONENTS.dirs</code> and  <code>COMPONENTS.app_dirs</code> are auto-imported in order to execute the code that registers the components.</p> <p>Autodiscovery occurs when Django is loaded, during the <code>AppConfig.ready()</code> hook of the <code>apps.py</code> file.</p> <p>If you are using autodiscovery, keep a few points in mind:</p> <ul> <li>Avoid defining any logic on the module-level inside the components directories, that you would not want to run anyway.</li> <li>Components inside the auto-imported files still need to be registered with <code>@register</code></li> <li>Auto-imported component files must be valid Python modules, they must use suffix <code>.py</code>, and module name should follow PEP-8.</li> <li>Subdirectories and files starting with an underscore <code>_</code> (except <code>__init__.py</code>) are ignored.</li> </ul> <p>Autodiscovery can be disabled in the settings with <code>autodiscover=False</code>.</p>"},{"location":"concepts/fundamentals/autodiscovery/#manually-trigger-autodiscovery","title":"Manually trigger autodiscovery","text":"<p>Autodiscovery can be also triggered manually, using the <code>autodiscover()</code> function. This is useful if you want to run autodiscovery at a custom point of the lifecycle:</p> <pre><code>from django_components import autodiscover\n\nautodiscover()\n</code></pre> <p>To get the same list of modules that <code>autodiscover()</code> would return, but without importing them, use <code>get_component_files()</code>:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre>"},{"location":"concepts/fundamentals/component_defaults/","title":"Component defaults","text":"<p>When a component is being rendered, the component inputs are passed to various methods like <code>get_template_data()</code>, <code>get_js_data()</code>, or <code>get_css_data()</code>.</p> <p>It can be cumbersome to specify default values for each input in each method.</p> <p>To make things easier, Components can specify their defaults. Defaults are used when no value is provided, or when the value is set to <code>None</code> for a particular input.</p>"},{"location":"concepts/fundamentals/component_defaults/#defining-defaults","title":"Defining defaults","text":"<p>To define defaults for a component, you create a nested <code>Defaults</code> class within your <code>Component</code> class. Each attribute in the <code>Defaults</code> class represents a default value for a corresponding input.</p> <pre><code>from django_components import Component, Default, register\n\n@register(\"my_table\")\nclass MyTable(Component):\n\n    class Defaults:\n        position = \"left\"\n        selected_items = Default(lambda: [1, 2, 3])\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"position\": kwargs[\"position\"],\n            \"selected_items\": kwargs[\"selected_items\"],\n        }\n\n    ...\n</code></pre> <p>In this example, <code>position</code> is a simple default value, while <code>selected_items</code> uses a factory function wrapped in <code>Default</code> to ensure a new list is created each time the default is used.</p> <p>Now, when we render the component, the defaults will be applied:</p> <pre><code>{% component \"my_table\" position=\"right\" / %}\n</code></pre> <p>In this case:</p> <ul> <li><code>position</code> input is set to <code>right</code>, so no defaults applied</li> <li><code>selected_items</code> is not set, so it will be set to <code>[1, 2, 3]</code>.</li> </ul> <p>Same applies to rendering the Component in Python with the <code>render()</code> method:</p> <pre><code>MyTable.render(\n    kwargs={\n        \"position\": \"right\",\n        \"selected_items\": None,\n    },\n)\n</code></pre> <p>Notice that we've set <code>selected_items</code> to <code>None</code>. <code>None</code> values are treated as missing values, and so <code>selected_items</code> will be set to <code>[1, 2, 3]</code>.</p> <p>Warning</p> <p>The defaults are aplied only to keyword arguments. They are NOT applied to positional arguments!</p> <p>Warning</p> <p>When typing your components with <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, you may be inclined to define the defaults in the classes.</p> <pre><code>class ProfileCard(Component):\n    class Kwargs(NamedTuple):\n        show_details: bool = True\n</code></pre> <p>This is NOT recommended, because:</p> <ul> <li>The defaults will NOT be applied to inputs when using <code>self.input</code> property.</li> <li>The defaults will NOT be applied when a field is given but set to <code>None</code>.</li> </ul> <p>Instead, define the defaults in the <code>Defaults</code> class.</p>"},{"location":"concepts/fundamentals/component_defaults/#default-factories","title":"Default factories","text":"<p>For objects such as lists, dictionaries or other instances, you have to be careful - if you simply set a default value, this instance will be shared across all instances of the component!</p> <pre><code>from django_components import Component\n\nclass MyTable(Component):\n    class Defaults:\n        # All instances will share the same list!\n        selected_items = [1, 2, 3]\n</code></pre> <p>To avoid this, you can use a factory function wrapped in <code>Default</code>.</p> <pre><code>from django_components import Component, Default\n\nclass MyTable(Component):\n    class Defaults:\n        # A new list is created for each instance\n        selected_items = Default(lambda: [1, 2, 3])\n</code></pre> <p>This is similar to how the dataclass fields work.</p> <p>In fact, you can also use the dataclass's <code>field</code> function to define the factories:</p> <pre><code>from dataclasses import field\nfrom django_components import Component\n\nclass MyTable(Component):\n    class Defaults:\n        selected_items = field(default_factory=lambda: [1, 2, 3])\n</code></pre>"},{"location":"concepts/fundamentals/component_defaults/#accessing-defaults","title":"Accessing defaults","text":"<p>Since the defaults are defined on the component class, you can access the defaults for a component with the <code>Component.Defaults</code> property.</p> <p>So if we have a component like this:</p> <pre><code>from django_components import Component, Default, register\n\n@register(\"my_table\")\nclass MyTable(Component):\n\n    class Defaults:\n        position = \"left\"\n        selected_items = Default(lambda: [1, 2, 3])\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"position\": kwargs[\"position\"],\n            \"selected_items\": kwargs[\"selected_items\"],\n        }\n</code></pre> <p>We can access individual defaults like this:</p> <pre><code>print(MyTable.Defaults.position)\nprint(MyTable.Defaults.selected_items)\n</code></pre>"},{"location":"concepts/fundamentals/component_views_urls/","title":"Component views and URLs","text":"<p>New in version 0.34</p> <p>Note: Since 0.92, <code>Component</code> is no longer a subclass of Django's <code>View</code>. Instead, the nested <code>Component.View</code> class is a subclass of Django's <code>View</code>.</p> <p>For web applications, it's common to define endpoints that serve HTML content (AKA views).</p> <p>django-components has a suite of features that help you write and manage views and their URLs:</p> <ul> <li> <p>For each component, you can define methods for handling HTTP requests (GET, POST, etc.) - <code>get()</code>, <code>post()</code>, etc.</p> </li> <li> <p>Use <code>Component.as_view()</code> to be able to use your Components  with Django's <code>urlpatterns</code>. This works the same way as <code>View.as_view()</code>.</p> </li> <li> <p>To avoid having to manually define the endpoints for each component, you can set the component to be \"public\" with <code>Component.View.public = True</code>. This will automatically create a URL for the component. To retrieve the component URL, use <code>get_component_url()</code>.</p> </li> <li> <p>In addition, <code>Component</code> has a <code>render_to_response()</code> method that renders the component template based on the provided input and returns an <code>HttpResponse</code> object.</p> </li> </ul>"},{"location":"concepts/fundamentals/component_views_urls/#define-handlers","title":"Define handlers","text":"<p>Here's an example of a calendar component defined as a view. Simply define a <code>View</code> class with your custom <code>get()</code> method to handle GET requests:</p> [project root]/components/calendar.py<pre><code>from django_components import Component, ComponentView, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            &lt;div class=\"header\"&gt;\n                {% slot \"header\" / %}\n            &lt;/div&gt;\n            &lt;div class=\"body\"&gt;\n                Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    class View:\n        # Handle GET requests\n        def get(self, request, *args, **kwargs):\n            # Return HttpResponse with the rendered content\n            return Calendar.render_to_response(\n                request=request,\n                kwargs={\n                    \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n                },\n                slots={\n                    \"header\": \"Calendar header\",\n                },\n            )\n</code></pre> <p>Info</p> <p>The View class supports all the same HTTP methods as Django's <code>View</code> class. These are:</p> <p><code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code>, <code>head()</code>, <code>options()</code>, <code>trace()</code></p> <p>Each of these receive the <code>HttpRequest</code> object as the first argument.</p> <p>Warning</p> <p>Deprecation warning:</p> <p>Previously, the handler methods such as <code>get()</code> and <code>post()</code> could be defined directly on the <code>Component</code> class:</p> <pre><code>class Calendar(Component):\n    def get(self, request, *args, **kwargs):\n        return self.render_to_response(\n            kwargs={\n                \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n            }\n        )\n</code></pre> <p>This is deprecated from v0.137 onwards, and will be removed in v1.0.</p>"},{"location":"concepts/fundamentals/component_views_urls/#acccessing-component-instance","title":"Acccessing component instance","text":"<p>You can access the component instance from within the View methods by using the <code>View.component</code> attribute:</p> <pre><code>class Calendar(Component):\n    ...\n\n    class View:\n        def get(self, request):\n            return self.component.render_to_response(request=request)\n</code></pre> <p>Note</p> <p>The <code>View.component</code> instance is a dummy instance created solely for the View methods.</p> <p>It is the same as if you instantiated the component class directly:</p> <pre><code>component = Calendar()\ncomponent.render_to_response(request=request)\n</code></pre>"},{"location":"concepts/fundamentals/component_views_urls/#register-urls-manually","title":"Register URLs manually","text":"<p>To register the component as a route / endpoint in Django, add an entry to your <code>urlpatterns</code>. In place of the view function, create a view object with <code>Component.as_view()</code>:</p> [project root]/urls.py<pre><code>from django.urls import path\nfrom components.calendar.calendar import Calendar\n\nurlpatterns = [\n    path(\"calendar/\", Calendar.as_view()),\n]\n</code></pre> <p><code>Component.as_view()</code> internally calls <code>View.as_view()</code>, passing the component instance as one of the arguments.</p>"},{"location":"concepts/fundamentals/component_views_urls/#register-urls-automatically","title":"Register URLs automatically","text":"<p>If you don't care about the exact URL of the component, you can let django-components manage the URLs for you by setting the <code>Component.View.public</code> attribute to <code>True</code>:</p> <pre><code>class MyComponent(Component):\n    class View:\n        public = True\n\n        def get(self, request):\n            return self.component.render_to_response(request=request)\n    ...\n</code></pre> <p>Then, to get the URL for the component, use <code>get_component_url()</code>:</p> <pre><code>from django_components import get_component_url\n\nurl = get_component_url(MyComponent)\n</code></pre> <p>This way you don't have to mix your app URLs with component URLs.</p> <p>Info</p> <p>If you need to pass query parameters or a fragment to the component URL, you can do so by passing the <code>query</code> and <code>fragment</code> arguments to <code>get_component_url()</code>:</p> <pre><code>url = get_component_url(\n    MyComponent,\n    query={\"foo\": \"bar\"},\n    fragment=\"baz\",\n)\n# /components/ext/view/components/c1ab2c3?foo=bar#baz\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/","title":"HTML attributes","text":"<p>New in version 0.74:</p> <p>You can use the <code>{% html_attrs %}</code> tag to render various data as <code>key=\"value\"</code> HTML attributes.</p> <p><code>{% html_attrs %}</code> tag is versatile, allowing you to define HTML attributes however you need:</p> <ul> <li>Define attributes within the HTML template</li> <li>Define attributes in Python code</li> <li>Merge attributes from multiple sources</li> <li>Boolean attributes</li> <li>Append attributes</li> <li>Remove attributes</li> <li>Define default attributes</li> </ul> <p>From v0.135 onwards, <code>{% html_attrs %}</code> tag also supports merging <code>style</code> and <code>class</code> attributes the same way how Vue does.</p> <p>To get started, let's consider a simple example. If you have a template:</p> <pre><code>&lt;div class=\"{{ classes }}\" data-id=\"{{ my_id }}\"&gt;\n&lt;/div&gt;\n</code></pre> <p>You can rewrite it with the <code>{% html_attrs %}</code> tag:</p> <pre><code>&lt;div {% html_attrs class=classes data-id=my_id %}&gt;\n&lt;/div&gt;\n</code></pre> <p>The <code>{% html_attrs %}</code> tag accepts any number of keyword arguments, which will be merged and rendered as HTML attributes:</p> <pre><code>&lt;div class=\"text-red\" data-id=\"123\"&gt;\n&lt;/div&gt;\n</code></pre> <p>Moreover, the <code>{% html_attrs %}</code> tag accepts two positional arguments:</p> <ul> <li><code>attrs</code> - a dictionary of attributes to be rendered</li> <li><code>defaults</code> - a dictionary of default attributes</li> </ul> <p>You can use this for example to allow users of your component to add extra attributes. We achieve this by capturing the extra attributes and passing them to the <code>{% html_attrs %}</code> tag as a dictionary:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    # Pass all kwargs as `attrs`\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"attrs\": kwargs,\n            \"classes\": \"text-red\",\n            \"my_id\": 123,\n        }\n\n    template: t.django_html = \"\"\"\n        {# Pass the extra attributes to `html_attrs` #}\n        &lt;div {% html_attrs attrs class=classes data-id=my_id %}&gt;\n        &lt;/div&gt;\n    \"\"\"\n</code></pre> <p>This way you can render <code>MyComp</code> with extra attributes:</p> <p>Either via Django template:</p> <pre><code>{% component \"my_comp\"\n  id=\"example\"\n  class=\"pa-4\"\n  style=\"color: red;\"\n%}\n</code></pre> <p>Or via Python:</p> <pre><code>MyComp.render(\n    kwargs={\n        \"id\": \"example\",\n        \"class\": \"pa-4\",\n        \"style\": \"color: red;\",\n    }\n)\n</code></pre> <p>In both cases, the attributes will be merged and rendered as:</p> <pre><code>&lt;div id=\"example\" class=\"text-red pa-4\" style=\"color: red;\" data-id=\"123\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#summary","title":"Summary","text":"<ol> <li> <p>The two arguments, <code>attrs</code> and <code>defaults</code>, can be passed as positional args:</p> <pre><code>{% html_attrs attrs defaults key=val %}\n</code></pre> <p>or as kwargs:</p> <pre><code>{% html_attrs key=val defaults=defaults attrs=attrs %}\n</code></pre> </li> <li> <p>Both <code>attrs</code> and <code>defaults</code> are optional and can be omitted.</p> </li> <li> <p>Both <code>attrs</code> and <code>defaults</code> are dictionaries. As such, there's multiple ways to define them:</p> <ul> <li> <p>By referencing a variable:</p> <pre><code>{% html_attrs attrs=attrs %}\n</code></pre> </li> <li> <p>By defining a literal dictionary:</p> <pre><code>{% html_attrs attrs={\"key\": value} %}\n</code></pre> </li> <li> <p>Or by defining the dictionary keys:</p> <pre><code>{% html_attrs attrs:key=value %}\n</code></pre> </li> </ul> </li> <li> <p>All other kwargs are merged and can be repeated.</p> <pre><code>{% html_attrs class=\"text-red\" class=\"pa-4\" %}\n</code></pre> <p>Will render:</p> <pre><code>&lt;div class=\"text-red pa-4\"&gt;&lt;/div&gt;\n</code></pre> </li> </ol>"},{"location":"concepts/fundamentals/html_attributes/#usage","title":"Usage","text":""},{"location":"concepts/fundamentals/html_attributes/#boolean-attributes","title":"Boolean attributes","text":"<p>In HTML, boolean attributes are usually rendered with no value. Consider the example below where the first button is disabled and the second is not:</p> <pre><code>&lt;button disabled&gt;Click me!&lt;/button&gt;\n&lt;button&gt;Click me!&lt;/button&gt;\n</code></pre> <p>HTML rendering with <code>html_attrs</code> tag or <code>format_attributes</code> works the same way - an attribute set to <code>True</code> is rendered without the value, and an attribute set to <code>False</code> is not rendered at all.</p> <p>So given this input:</p> <pre><code>attrs = {\n    \"disabled\": True,\n    \"autofocus\": False,\n}\n</code></pre> <p>And template:</p> <pre><code>&lt;div {% html_attrs attrs %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then this renders:</p> <pre><code>&lt;div disabled&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#removing-attributes","title":"Removing attributes","text":"<p>Given how the boolean attributes work, you can \"remove\" or prevent an attribute from being rendered by setting it to <code>False</code> or <code>None</code>.</p> <p>So given this input:</p> <pre><code>attrs = {\n    \"class\": \"text-green\",\n    \"required\": False,\n    \"data-id\": None,\n}\n</code></pre> <p>And template:</p> <pre><code>&lt;div {% html_attrs attrs %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then this renders:</p> <pre><code>&lt;div class=\"text-green\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#default-attributes","title":"Default attributes","text":"<p>Sometimes you may want to specify default values for attributes. You can pass a second positional argument to set the defaults.</p> <pre><code>&lt;div {% html_attrs attrs defaults %}&gt;\n    ...\n&lt;/div&gt;\n</code></pre> <p>In the example above, if <code>attrs</code> contains a certain key, e.g. the <code>class</code> key, <code>{% html_attrs %}</code> will render:</p> <pre><code>&lt;div class=\"{{ attrs.class }}\"&gt;\n    ...\n&lt;/div&gt;\n</code></pre> <p>Otherwise, <code>{% html_attrs %}</code> will render:</p> <pre><code>&lt;div class=\"{{ defaults.class }}\"&gt;\n    ...\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#appending-attributes","title":"Appending attributes","text":"<p>For the <code>class</code> HTML attribute, it's common that we want to join multiple values, instead of overriding them.</p> <p>For example, if you're authoring a component, you may want to ensure that the component will ALWAYS have a specific class. Yet, you may want to allow users of your component to supply their own <code>class</code> attribute.</p> <p>We can achieve this by adding extra kwargs. These values will be appended, instead of overwriting the previous value.</p> <p>So if we have a variable <code>attrs</code>:</p> <pre><code>attrs = {\n    \"class\": \"my-class pa-4\",\n}\n</code></pre> <p>And on <code>{% html_attrs %}</code> tag, we set the key <code>class</code>:</p> <pre><code>&lt;div {% html_attrs attrs class=\"some-class\" %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then these will be merged and rendered as:</p> <pre><code>&lt;div data-value=\"my-class pa-4 some-class\"&gt;&lt;/div&gt;\n</code></pre> <p>To simplify merging of variables, you can supply the same key multiple times, and these will be all joined together:</p> <pre><code>{# my_var = \"class-from-var text-red\" #}\n&lt;div {% html_attrs attrs class=\"some-class another-class\" class=my_var %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Renders:</p> <pre><code>&lt;div\n  data-value=\"my-class pa-4 some-class another-class class-from-var text-red\"\n&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#merging-class-attributes","title":"Merging <code>class</code> attributes","text":"<p>The <code>class</code> attribute can be specified as a string of class names as usual.</p> <p>If you want granular control over individual class names, you can use a dictionary.</p> <ul> <li> <p>String: Used as is.</p> <pre><code>{% html_attrs class=\"my-class other-class\" %}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div class=\"my-class other-class\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Dictionary: Keys are the class names, and values are booleans. Only keys with truthy values are rendered.</p> <pre><code>{% html_attrs class={\n    \"extra-class\": True,\n    \"other-class\": False,\n} %}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div class=\"extra-class\"&gt;&lt;/div&gt;\n</code></pre> </li> </ul> <p>If a certain class is specified multiple times, it's the last instance that decides whether the class is rendered or not.</p> <p>Example:</p> <p>In this example, the <code>other-class</code> is specified twice. The last instance is <code>{\"other-class\": False}</code>, so the class is not rendered.</p> <pre><code>{% html_attrs\n    class=\"my-class other-class\"\n    class={\"extra-class\": True, \"other-class\": False}\n%}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div class=\"my-class extra-class\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#merging-style-attributes","title":"Merging <code>style</code> attributes","text":"<p>The <code>style</code> attribute can be specified as a string of style properties as usual.</p> <p>If you want granular control over individual style properties, you can use a dictionary.</p> <ul> <li> <p>String: Used as is.</p> <pre><code>{% html_attrs style=\"color: red; background-color: blue;\" %}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div style=\"color: red; background-color: blue;\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Dictionary: Keys are the style properties, and values are their values.</p> <pre><code>{% html_attrs style={\n    \"color\": \"red\",\n    \"background-color\": \"blue\",\n} %}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div style=\"color: red; background-color: blue;\"&gt;&lt;/div&gt;\n</code></pre> </li> </ul> <p>If a style property is specified multiple times, the last value is used.</p> <ul> <li>Properties set to <code>None</code> are ignored.</li> <li>If the last non-<code>None</code> instance of the property is set to <code>False</code>, the property is removed.</li> </ul> <p>Example:</p> <p>In this example, the <code>width</code> property is specified twice. The last instance is <code>{\"width\": False}</code>, so the property is removed.</p> <p>Secondly, the <code>background-color</code> property is also set twice. But the second time it's set to <code>None</code>, so that instance is ignored, leaving us only with <code>background-color: blue</code>.</p> <p>The <code>color</code> property is set to a valid value in both cases, so the latter (<code>green</code>) is used.</p> <pre><code>{% html_attrs\n    style=\"color: red; background-color: blue; width: 100px;\"\n    style={\"color\": \"green\", \"background-color\": None, \"width\": False}\n%}\n</code></pre> <p>Renders:</p> <pre><code>&lt;div style=\"color: green; background-color: blue;\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_attributes/#usage-outside-of-templates","title":"Usage outside of templates","text":"<p>In some cases, you want to prepare HTML attributes outside of templates.</p> <p>To achieve the same behavior as <code>{% html_attrs %}</code> tag, you can use the <code>merge_attributes()</code> and <code>format_attributes()</code> helper functions.</p>"},{"location":"concepts/fundamentals/html_attributes/#merging-attributes","title":"Merging attributes","text":"<p><code>merge_attributes()</code> accepts any number of dictionaries and merges them together, using the same merge strategy as <code>{% html_attrs %}</code>.</p> <pre><code>from django_components import merge_attributes\n\nmerge_attributes(\n    {\"class\": \"my-class\", \"data-id\": 123},\n    {\"class\": \"extra-class\"},\n    {\"class\": {\"cool-class\": True, \"uncool-class\": False} },\n)\n</code></pre> <p>Which will output:</p> <pre><code>{\n    \"class\": \"my-class extra-class cool-class\",\n    \"data-id\": 123,\n}\n</code></pre> <p>Warning</p> <p>Unlike <code>{% html_attrs %}</code>, where you can pass extra kwargs, <code>merge_attributes()</code> requires each argument to be a dictionary.</p>"},{"location":"concepts/fundamentals/html_attributes/#formatting-attributes","title":"Formatting attributes","text":"<p><code>format_attributes()</code> serializes attributes the same way as <code>{% html_attrs %}</code> tag does.</p> <pre><code>from django_components import format_attributes\n\nformat_attributes({\n    \"class\": \"my-class text-red pa-4\",\n    \"data-id\": 123,\n    \"required\": True,\n    \"disabled\": False,\n    \"ignored-attr\": None,\n})\n</code></pre> <p>Which will output:</p> <pre><code>'class=\"my-class text-red pa-4\" data-id=\"123\" required'\n</code></pre> <p>Note</p> <p>Prior to v0.135, the <code>format_attributes()</code> function was named <code>attributes_to_string()</code>.</p> <p>This function is now deprecated and will be removed in v1.0.</p>"},{"location":"concepts/fundamentals/html_attributes/#cheat-sheet","title":"Cheat sheet","text":"<p>Assuming that:</p> <pre><code>class_from_var = \"from-var\"\n\nattrs = {\n    \"class\": \"from-attrs\",\n    \"type\": \"submit\",\n}\n\ndefaults = {\n    \"class\": \"from-defaults\",\n    \"role\": \"button\",\n}\n</code></pre> <p>Then:</p> <ul> <li> <p>Empty tag</p> <pre><code>&lt;div {% html_attr %}&gt;&lt;/div&gt;\n</code></pre> <p>renders nothing:</p> <pre><code>&lt;div&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Only kwargs</p> <pre><code>&lt;div {% html_attr class=\"some-class\" class=class_from_var data-id=\"123\" %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"some-class from-var\" data-id=\"123\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Only attrs</p> <pre><code>&lt;div {% html_attr attrs %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs\" type=\"submit\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Attrs as kwarg</p> <pre><code>&lt;div {% html_attr attrs=attrs %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs\" type=\"submit\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Only defaults (as kwarg)</p> <pre><code>&lt;div {% html_attr defaults=defaults %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-defaults\" role=\"button\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Attrs using the <code>prefix:key=value</code> construct</p> <pre><code>&lt;div {% html_attr attrs:class=\"from-attrs\" attrs:type=\"submit\" %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs\" type=\"submit\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>Defaults using the <code>prefix:key=value</code> construct</p> <pre><code>&lt;div {% html_attr defaults:class=\"from-defaults\" %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-defaults\" role=\"button\"&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>All together (1) - attrs and defaults as positional args:</p> <pre><code>&lt;div {% html_attrs attrs defaults class=\"added_class\" class=class_from_var data-id=123 %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs added_class from-var\" type=\"submit\" role=\"button\" data-id=123&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>All together (2) - attrs and defaults as kwargs args:</p> <pre><code>&lt;div {% html_attrs class=\"added_class\" class=class_from_var data-id=123 attrs=attrs defaults=defaults %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs added_class from-var\" type=\"submit\" role=\"button\" data-id=123&gt;&lt;/div&gt;\n</code></pre> </li> <li> <p>All together (3) - mixed:</p> <pre><code>&lt;div {% html_attrs attrs defaults:class=\"default-class\" class=\"added_class\" class=class_from_var data-id=123 %}&gt;&lt;/div&gt;\n</code></pre> <p>renders:</p> <pre><code>&lt;div class=\"from-attrs added_class from-var\" type=\"submit\" data-id=123&gt;&lt;/div&gt;\n</code></pre> </li> </ul>"},{"location":"concepts/fundamentals/html_attributes/#full-example","title":"Full example","text":"<pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template: t.django_html = \"\"\"\n        &lt;div\n            {% html_attrs attrs\n                defaults:class=\"pa-4 text-red\"\n                class=\"my-comp-date\"\n                class=class_from_var\n                data-id=\"123\"\n            %}\n        &gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        date = kwargs.pop(\"date\")\n        return {\n            \"date\": date,\n            \"attrs\": kwargs,\n            \"class_from_var\": \"extra-class\"\n        }\n\n@register(\"parent\")\nclass Parent(Component):\n    template: t.django_html = \"\"\"\n        {% component \"my_comp\"\n            date=date\n            attrs:class=\"pa-0 border-solid border-red\"\n            attrs:data-json=json_data\n            attrs:@click=\"(e) =&gt; onClick(e, 'from_parent')\"\n        / %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": datetime.now(),\n            \"json_data\": json.dumps({\"value\": 456})\n        }\n</code></pre> <p>Note: For readability, we've split the tags across multiple lines.</p> <p>Inside <code>MyComp</code>, we defined a default attribute</p> <pre><code>defaults:class=\"pa-4 text-red\"\n</code></pre> <p>So if <code>attrs</code> includes key <code>class</code>, the default above will be ignored.</p> <p><code>MyComp</code> also defines <code>class</code> key twice. It means that whether the <code>class</code> attribute is taken from <code>attrs</code> or <code>defaults</code>, the two <code>class</code> values will be appended to it.</p> <p>So by default, <code>MyComp</code> renders:</p> <pre><code>&lt;div class=\"pa-4 text-red my-comp-date extra-class\" data-id=\"123\"&gt;...&lt;/div&gt;\n</code></pre> <p>Next, let's consider what will be rendered when we call <code>MyComp</code> from <code>Parent</code> component.</p> <p><code>MyComp</code> accepts a <code>attrs</code> dictionary, that is passed to <code>html_attrs</code>, so the contents of that dictionary are rendered as the HTML attributes.</p> <p>In <code>Parent</code>, we make use of passing dictionary key-value pairs as kwargs to define individual attributes as if they were regular kwargs.</p> <p>So all kwargs that start with <code>attrs:</code> will be collected into an <code>attrs</code> dict.</p> <pre><code>    attrs:class=\"pa-0 border-solid border-red\"\n    attrs:data-json=json_data\n    attrs:@click=\"(e) =&gt; onClick(e, 'from_parent')\"\n</code></pre> <p>And <code>get_template_data</code> of <code>MyComp</code> will receive a kwarg named <code>attrs</code> with following keys:</p> <pre><code>attrs = {\n    \"class\": \"pa-0 border-solid\",\n    \"data-json\": '{\"value\": 456}',\n    \"@click\": \"(e) =&gt; onClick(e, 'from_parent')\",\n}\n</code></pre> <p><code>attrs[\"class\"]</code> overrides the default value for <code>class</code>, whereas other keys will be merged.</p> <p>So in the end <code>MyComp</code> will render:</p> <pre><code>&lt;div\n  class=\"pa-0 border-solid my-comp-date extra-class\"\n  data-id=\"123\"\n  data-json='{\"value\": 456}'\n  @click=\"(e) =&gt; onClick(e, 'from_parent')\"\n&gt;\n  ...\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/","title":"HTML / JS / CSS files","text":""},{"location":"concepts/fundamentals/html_js_css_files/#overview","title":"Overview","text":"<p>Each component can have single \"primary\" HTML, CSS and JS file associated with them.</p> <p>Each of these can be either defined inline, or in a separate file:</p> <ul> <li>HTML files are defined using <code>Component.template</code> or <code>Component.template_file</code></li> <li>CSS files are defined using <code>Component.css</code> or <code>Component.css_file</code></li> <li>JS files are defined using <code>Component.js</code> or <code>Component.js_file</code></li> </ul> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    css_file = \"calendar.css\"\n    js_file = \"calendar.js\"\n</code></pre> <p>or</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"welcome\"&gt;\n            Hi there!\n        &lt;/div&gt;\n    \"\"\"\n    css = \"\"\"\n        .welcome {\n            color: red;\n        }\n    \"\"\"\n    js = \"\"\"\n        console.log(\"Hello, world!\");\n    \"\"\"\n</code></pre> <p>These \"primary\" files will have special behavior. For example, each will receive variables from the component's data methods. Read more about each file type below:</p> <ul> <li>HTML</li> <li>CSS</li> <li>JS</li> </ul> <p>In addition, you can define extra \"secondary\" CSS / JS files using the nested <code>Component.Media</code> class, by setting <code>Component.Media.js</code> and <code>Component.Media.css</code>.</p> <p>Single component can have many secondary files. There is no special behavior for them.</p> <p>You can use these for third-party libraries, or for shared CSS / JS files.</p> <p>Read more about Secondary JS / CSS files.</p> <p>Warning</p> <p>You cannot use both inlined code and separate file for a single language type (HTML, CSS, JS).</p> <p>However, you can freely mix these for different languages:</p> <pre><code>class MyTable(Component):\n    template: types.django_html = \"\"\"\n      &lt;div class=\"welcome\"&gt;\n        Hi there!\n      &lt;/div&gt;\n    \"\"\"\n    js_file = \"my_table.js\"\n    css_file = \"my_table.css\"\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#html","title":"HTML","text":"<p>Components use Django's template system to define their HTML. This means that you can use Django's template syntax to define your HTML.</p> <p>Inside the template, you can access the data returned from the <code>get_template_data()</code> method.</p> <p>You can define the HTML directly in your Python code using the <code>template</code> attribute:</p> <pre><code>class Button(Component):\n    template = \"\"\"\n        &lt;button class=\"btn\"&gt;\n            {% if icon %}\n                &lt;i class=\"{{ icon }}\"&gt;&lt;/i&gt;\n            {% endif %}\n            {{ text }}\n        &lt;/button&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n            \"icon\": kwargs.get(\"icon\", None),\n        }\n</code></pre> <p>Or you can define the HTML in a separate file and reference it using <code>template_file</code>:</p> <pre><code>class Button(Component):\n    template_file = \"button.html\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n            \"icon\": kwargs.get(\"icon\", None),\n        }\n</code></pre> button.html<pre><code>&lt;button class=\"btn\"&gt;\n    {% if icon %}\n        &lt;i class=\"{{ icon }}\"&gt;&lt;/i&gt;\n    {% endif %}\n    {{ text }}\n&lt;/button&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#html-processing","title":"HTML processing","text":"<p>Django Components expects the rendered template to be a valid HTML. This is needed to enable features like CSS / JS variables.</p> <p>Here is how the HTML is post-processed:</p> <ol> <li> <p>Insert component ID: Each root element in the rendered HTML automatically receives a <code>data-djc-id-cxxxxxx</code> attribute containing a unique component instance ID.</p> <pre><code>&lt;!-- Output HTML --&gt;\n&lt;div class=\"card\" data-djc-id-c1a2b3c&gt;\n    ...\n&lt;/div&gt;\n&lt;div class=\"backdrop\" data-djc-id-c1a2b3c&gt;\n    ...\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Insert CSS ID: If the component defines CSS variables through <code>get_css_data()</code>, the root elements also receive a <code>data-djc-css-xxxxxx</code> attribute. This attribute links the element to its specific CSS variables.</p> <pre><code>&lt;!-- Output HTML --&gt;\n&lt;div class=\"card\" data-djc-id-c1a2b3c data-djc-css-d4e5f6&gt;\n    &lt;!-- Component content --&gt;\n&lt;/div&gt;\n</code></pre> </li> <li> <p>Insert JS and CSS: After the HTML is rendered, Django Components handles inserting JS and CSS dependencies into the page based on the dependencies rendering strategy (document, fragment, or inline).</p> <p>For example, if your component contains the <code>{% component_js_dependencies %}</code> or <code>{% component_css_dependencies %}</code> tags, or the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> elements, the JS and CSS scripts will be inserted into the HTML.</p> <p>For more information on how JS and CSS dependencies are rendered, see Rendering JS / CSS.</p> </li> </ol>"},{"location":"concepts/fundamentals/html_js_css_files/#js","title":"JS","text":"<p>The component's JS script is executed in the browser:</p> <ul> <li>It is executed AFTER the \"secondary\" JS files from <code>Component.Media.js</code> are loaded.</li> <li>The script is only executed once, even if there are multiple instances of the component on the page.</li> <li>Component JS scripts are executed in the order how they appeared in the template / HTML (top to bottom).</li> </ul> <p>You can define the JS directly in your Python code using the <code>js</code> attribute:</p> <pre><code>class Button(Component):\n    js = \"\"\"\n        console.log(\"Hello, world!\");\n    \"\"\"\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n        }\n</code></pre> <p>Or you can define the JS in a separate file and reference it using <code>js_file</code>:</p> <pre><code>class Button(Component):\n    js_file = \"button.js\"\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n        }\n</code></pre> button.js<pre><code>console.log(\"Hello, world!\");\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#css","title":"CSS","text":"<p>You can define the CSS directly in your Python code using the <code>css</code> attribute:</p> <pre><code>class Button(Component):\n    css = \"\"\"\n        .btn {\n            width: 100px;\n            color: var(--color);\n        }\n    \"\"\"\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs.get(\"color\", \"red\"),\n        }\n</code></pre> <p>Or you can define the CSS in a separate file and reference it using <code>css_file</code>:</p> <pre><code>class Button(Component):\n    css_file = \"button.css\"\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"text\": kwargs.get(\"text\", \"Click me\"),\n        }\n</code></pre> button.css<pre><code>.btn {\n    color: red;\n}\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_files/#file-paths","title":"File paths","text":"<p>Compared to the secondary JS / CSS files, the definition of file paths for the main HTML / JS / CSS files is quite simple - just strings, without any lists, objects, or globs.</p> <p>However, similar to the secondary JS / CSS files, you can specify the file paths relative to the component's directory.</p> <p>So if you have a directory with following files:</p> <pre><code>[project root]/components/calendar/\n\u251c\u2500\u2500 calendar.html\n\u251c\u2500\u2500 calendar.css\n\u251c\u2500\u2500 calendar.js\n\u2514\u2500\u2500 calendar.py\n</code></pre> <p>You can define the component like this:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    css_file = \"calendar.css\"\n    js_file = \"calendar.js\"\n</code></pre> <p>Assuming that <code>COMPONENTS.dirs</code> contains path <code>[project root]/components</code>, the example above is the same as writing out:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n    css_file = \"calendar/style.css\"\n    js_file = \"calendar/script.js\"\n</code></pre> <p>If the path cannot be resolved relative to the component, django-components will attempt to resolve the path relative to the component directories, as set in <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code>.</p> <p>Read more about file path resolution.</p>"},{"location":"concepts/fundamentals/html_js_css_files/#access-component-definition","title":"Access component definition","text":"<p>Component's HTML / CSS / JS is resolved and loaded lazily.</p> <p>This means that, when you specify any of <code>template_file</code>, <code>js_file</code>, <code>css_file</code>, or <code>Media.js/css</code>, these file paths will be resolved only once you either:</p> <ol> <li> <p>Access any of the following attributes on the component:</p> <ul> <li><code>media</code>,  <code>template</code>,  <code>template_file</code>,  <code>js</code>,  <code>js_file</code>,  <code>css</code>,  <code>css_file</code></li> </ul> </li> <li> <p>Render the component.</p> </li> </ol> <p>Once the component's media files have been loaded once, they will remain in-memory on the Component class:</p> <ul> <li>HTML from <code>Component.template_file</code>   will be available under <code>Component.template</code></li> <li>CSS from <code>Component.css_file</code>   will be available under <code>Component.css</code></li> <li>JS from <code>Component.js_file</code>   will be available under <code>Component.js</code></li> </ul> <p>Thus, whether you define HTML via <code>Component.template_file</code> or <code>Component.template</code>, you can always access the HTML content under <code>Component.template</code>. And the same applies for JS and CSS.</p> <p>Example:</p> <pre><code># When we create Calendar component, the files like `calendar/template.html`\n# are not yet loaded!\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n    css_file = \"calendar/style.css\"\n    js_file = \"calendar/script.js\"\n\n    class Media:\n        css = \"calendar/style1.css\"\n        js = \"calendar/script2.js\"\n\n# It's only at this moment that django-components reads the files like `calendar/template.html`\nprint(Calendar.css)\n# Output:\n# .calendar {\n#   width: 200px;\n#   background: pink;\n# }\n</code></pre> <p>Warning</p> <p>Do NOT modify HTML / CSS / JS after it has been loaded</p> <p>django-components assumes that the component's media files like <code>js_file</code> or <code>Media.js/css</code> are static.</p> <p>If you need to dynamically change these media files, consider instead defining multiple Components.</p> <p>Modifying these files AFTER the component has been loaded at best does nothing. However, this is an untested behavior, which may lead to unexpected errors.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/","title":"HTML / JS / CSS variables","text":"<p>When a component recieves input through <code>{% component %}</code> tag, or the <code>Component.render()</code> or <code>Component.render_to_response()</code> methods, you can define how the input is handled, and what variables will be available to the template, JavaScript and CSS.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#overview","title":"Overview","text":"<p>Django Components offers three key methods for passing variables to different parts of your component:</p> <ul> <li><code>get_template_data()</code> - Provides variables to your HTML template</li> <li><code>get_js_data()</code> - Provides variables to your JavaScript code</li> <li><code>get_css_data()</code> - Provides variables to your CSS styles</li> </ul> <p>These methods let you pre-process inputs before they're used in rendering.</p> <p>Each method handles the data independently - you can define different data for the template, JS, and CSS.</p> <pre><code>class ProfileCard(Component):\n    class Kwargs(NamedTuple):\n        user_id: int\n        show_details: bool\n\n    class Defaults:\n        show_details = True\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        user = User.objects.get(id=kwargs.user_id)\n        return {\n            \"user\": user,\n            \"show_details\": kwargs.show_details,\n        }\n\n    def get_js_data(self, args, kwargs: Kwargs, slots, context):\n        return {\n            \"user_id\": kwargs.user_id,\n        }\n\n    def get_css_data(self, args, kwargs: Kwargs, slots, context):\n        text_color = \"red\" if kwargs.show_details else \"blue\"\n        return {\n            \"text_color\": text_color,\n        }\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_variables/#template-variables","title":"Template variables","text":"<p>The <code>get_template_data()</code> method is the primary way to provide variables to your HTML template. It receives the component inputs and returns a dictionary of data that will be available in the template.</p> <p>If <code>get_template_data()</code> returns <code>None</code>, an empty dictionary will be used.</p> <pre><code>class ProfileCard(Component):\n    template_file = \"profile_card.html\"\n\n    class Kwargs(NamedTuple):\n        user_id: int\n        show_details: bool\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        user = User.objects.get(id=kwargs.user_id)\n\n        # Process and transform inputs\n        return {\n            \"user\": user,\n            \"show_details\": kwargs.show_details,\n            \"user_joined_days\": (timezone.now() - user.date_joined).days,\n        }\n</code></pre> <p>In your template, you can then use these variables:</p> <pre><code>&lt;div class=\"profile-card\"&gt;\n    &lt;h2&gt;{{ user.username }}&lt;/h2&gt;\n\n    {% if show_details %}\n        &lt;p&gt;Member for {{ user_joined_days }} days&lt;/p&gt;\n        &lt;p&gt;Email: {{ user.email }}&lt;/p&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_variables/#legacy-get_context_data","title":"Legacy <code>get_context_data()</code>","text":"<p>The <code>get_context_data()</code> method is the legacy way to provide variables to your HTML template. It serves the same purpose as <code>get_template_data()</code> - it receives the component inputs and returns a dictionary of data that will be available in the template.</p> <p>However, <code>get_context_data()</code> has a few drawbacks:</p> <ul> <li>It does NOT receive the <code>slots</code> and <code>context</code> parameters.</li> <li>The <code>args</code> and <code>kwargs</code> parameters are given as variadic <code>*args</code> and <code>**kwargs</code> parameters. As such, they cannot be typed.</li> </ul> <pre><code>class ProfileCard(Component):\n    template_file = \"profile_card.html\"\n\n    def get_context_data(self, user_id, show_details=False, *args, **kwargs):\n        user = User.objects.get(id=user_id)\n        return {\n            \"user\": user,\n            \"show_details\": show_details,\n        }\n</code></pre> <p>There is a slight difference between <code>get_context_data()</code> and <code>get_template_data()</code> when rendering a component with the <code>{% component %}</code> tag.</p> <p>For example if you have component that accepts kwarg <code>date</code>:</p> <pre><code>class MyComponent(Component):\n    def get_context_data(self, date, *args, **kwargs):\n        return {\n            \"date\": date,\n        }\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n</code></pre> <p>The difference is that:</p> <ul> <li> <p>With <code>get_context_data()</code>, you can pass <code>date</code> either as arg or kwarg:</p> <pre><code>\u2705\n{% component \"my_component\" date=some_date %}\n{% component \"my_component\" some_date %}\n</code></pre> </li> <li> <p>But with <code>get_template_data()</code>, <code>date</code> MUST be passed as kwarg:</p> <pre><code>\u2705\n{% component \"my_component\" date=some_date %}\n\n\u274c\n{% component \"my_component\" some_date %}\n</code></pre> </li> </ul> <p>Warning</p> <p><code>get_template_data()</code> and <code>get_context_data()</code> are mutually exclusive.</p> <p>If both methods return non-empty dictionaries, an error will be raised.</p> <p>Note</p> <p>The <code>get_context_data()</code> method will be removed in v2.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#accessing-component-inputs","title":"Accessing component inputs","text":"<p>The component inputs are available in two ways:</p> <ol> <li> <p>Function arguments (recommended)</p> <p>The data methods receive the inputs as parameters, which you can access directly.</p> <pre><code>class ProfileCard(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access inputs directly as parameters\n        return {\n            \"user_id\": user_id,\n            \"show_details\": show_details,\n        }\n</code></pre> <p>Info</p> <p>By default, the <code>args</code> parameter is a list, while <code>kwargs</code> and <code>slots</code> are dictionaries.</p> <p>If you add typing to your component with <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, the respective inputs will be given as instances of these classes.</p> <p>Learn more about Component typing.</p> </li> <li> <p><code>self.input</code> property</p> <p>The data methods receive only the main inputs. There are additional settings that may be passed to components. If you need to access these, you can do so via the <code>self.input</code> property.</p> <p>The <code>input</code> property contains all the inputs passed to the component (instance of <code>ComponentInput</code>).</p> <p>This includes:</p> <ul> <li><code>input.args</code> - List of positional arguments</li> <li><code>input.kwargs</code> - Dictionary of keyword arguments</li> <li><code>input.slots</code> - Dictionary of slots. Values are normalized to <code>Slot</code> instances</li> <li><code>input.context</code> - <code>Context</code> object that should be used to render the component</li> <li><code>input.type</code> - The type of the component (document, fragment)</li> <li><code>input.render_dependencies</code> - Whether to render dependencies (CSS, JS)</li> </ul> <p>For more details, see Component inputs.</p> <pre><code>class ProfileCard(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access positional arguments\n        user_id = self.input.args[0] if self.input.args else None\n\n        # Access keyword arguments\n        show_details = self.input.kwargs.get(\"show_details\", False)\n\n        # Render component differently depending on the type\n        if self.input.type == \"fragment\":\n            ...\n\n        return {\n            \"user_id\": user_id,\n            \"show_details\": show_details,\n        }\n</code></pre> <p>Info</p> <p>Unlike the parameters passed to the data methods, the <code>args</code>, <code>kwargs</code>, and <code>slots</code> in <code>self.input</code> property are always lists and dictionaries, regardless of whether you added typing to your component.</p> </li> </ol>"},{"location":"concepts/fundamentals/html_js_css_variables/#default-values","title":"Default values","text":"<p>You can use <code>Defaults</code> class to provide default values for your inputs.</p> <p>These defaults will be applied either when:</p> <ul> <li>The input is not provided at rendering time</li> <li>The input is provided as <code>None</code></li> </ul> <p>When you then access the inputs in your data methods, the default values will be already applied.</p> <p>Read more about Component Defaults.</p> <pre><code>from django_components import Component, Default, register\n\n@register(\"profile_card\")\nclass ProfileCard(Component):\n    class Kwargs(NamedTuple):\n        show_details: bool\n\n    class Defaults:\n        show_details = True\n\n    # show_details will be set to True if `None` or missing\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        return {\n            \"show_details\": kwargs.show_details,\n        }\n\n    ...\n</code></pre> <p>Warning</p> <p>When typing your components with <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, you may be inclined to define the defaults in the classes.</p> <pre><code>class ProfileCard(Component):\n    class Kwargs(NamedTuple):\n        show_details: bool = True\n</code></pre> <p>This is NOT recommended, because:</p> <ul> <li>The defaults will NOT be applied to inputs when using <code>self.input</code> property.</li> <li>The defaults will NOT be applied when a field is given but set to <code>None</code>.</li> </ul> <p>Instead, define the defaults in the <code>Defaults</code> class.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#accessing-render-api","title":"Accessing Render API","text":"<p>All three data methods have access to the Component's Render API, which includes:</p> <ul> <li><code>self.id</code> - The unique ID for the current render call</li> <li><code>self.input</code> - All the component inputs</li> <li><code>self.request</code> - The request object (if available)</li> <li><code>self.context_processors_data</code> - Data from Django's context processors (if request is available)</li> <li><code>self.inject()</code> - Inject data into the component</li> </ul>"},{"location":"concepts/fundamentals/html_js_css_variables/#type-hints","title":"Type hints","text":""},{"location":"concepts/fundamentals/html_js_css_variables/#typing-inputs","title":"Typing inputs","text":"<p>You can add type hints for the component inputs to ensure that the component logic is correct.</p> <p>For this, define the <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes, and then add type hints to the data methods.</p> <p>This will also validate the inputs at runtime, as the type classes will be instantiated with the inputs.</p> <p>Read more about Component typing.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, SlotInput\n\nclass Button(Component):\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        footer: SlotInput\n\n    # Use the above classes to add type hints to the data method\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        # The parameters are instances of the classes we defined\n        assert isinstance(args, Button.Args)\n        assert isinstance(kwargs, Button.Kwargs)\n        assert isinstance(slots, Button.Slots)\n</code></pre> <p>Note</p> <p>The data available via <code>self.input</code> property is NOT typed.</p>"},{"location":"concepts/fundamentals/html_js_css_variables/#typing-data","title":"Typing data","text":"<p>In the same fashion, you can add types and validation for the data that should be RETURNED from each data method.</p> <p>For this, set the <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code> classes on the component class.</p> <p>For each data method, you can either return a plain dictionary with the data, or an instance of the respective data class.</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Button(Component):\n    class TemplateData(NamedTuple):\n        data1: str\n        data2: int\n\n    class JsData(NamedTuple):\n        js_data1: str\n        js_data2: int\n\n    class CssData(NamedTuple):\n        css_data1: str\n        css_data2: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return Button.TemplateData(\n            data1=\"...\",\n            data2=123,\n        )\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return Button.JsData(\n            js_data1=\"...\",\n            js_data2=123,\n        )\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return Button.CssData(\n            css_data1=\"...\",\n            css_data2=123,\n        )\n</code></pre>"},{"location":"concepts/fundamentals/html_js_css_variables/#pass-through-kwargs","title":"Pass-through kwargs","text":"<p>It's best practice to explicitly define what args and kwargs a component accepts.</p> <p>However, if you want a looser setup, you can easily write components that accept any number of kwargs, and pass them all to the template (similar to django-cotton).</p> <p>To do that, simply return the <code>kwargs</code> dictionary itself from <code>get_template_data()</code>:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre> <p>You can do the same for <code>get_js_data()</code> and <code>get_css_data()</code>, if needed:</p> <pre><code>class MyComponent(Component):\n    def get_js_data(self, args, kwargs, slots, context):\n        return kwargs\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre>"},{"location":"concepts/fundamentals/http_request/","title":"HTTP Request","text":"<p>The most common use of django-components is to render HTML when the server receives a request. As such, there are a few features that are dependent on the request object.</p>"},{"location":"concepts/fundamentals/http_request/#passing-the-httprequest-object","title":"Passing the HttpRequest object","text":"<p>In regular Django templates, the request object is available only within the <code>RequestContext</code>.</p> <p>In Components, you can either use <code>RequestContext</code>, or pass the <code>request</code> object explicitly to <code>Component.render()</code> and <code>Component.render_to_response()</code>.</p> <p>So the request object is available to components either when:</p> <ul> <li>The component is rendered with <code>RequestContext</code> (Regular Django behavior)</li> <li>The component is rendered with a regular <code>Context</code> (or none), but you set the <code>request</code> kwarg     of <code>Component.render()</code>.</li> <li>The component is nested and the parent has access to the request object.</li> </ul> <pre><code># \u2705 With request\nMyComponent.render(request=request)\nMyComponent.render(context=RequestContext(request, {}))\n\n# \u274c Without request\nMyComponent.render()\nMyComponent.render(context=Context({}))\n</code></pre> <p>When a component is rendered within a template with <code>{% component %}</code> tag, the request object is available depending on whether the template is rendered with <code>RequestContext</code> or not.</p> <pre><code>template = Template(\"\"\"\n&lt;div&gt;\n  {% component \"MyComponent\" / %}\n&lt;/div&gt;\n\"\"\")\n\n# \u274c No request\nrendered = template.render(Context({}))\n\n# \u2705 With request\nrendered = template.render(RequestContext(request, {}))\n</code></pre>"},{"location":"concepts/fundamentals/http_request/#accessing-the-httprequest-object","title":"Accessing the HttpRequest object","text":"<p>When the component has access to the <code>request</code> object, the request object will be available in <code>Component.request</code>.</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            'user_id': self.request.GET['user_id'],\n        }\n</code></pre>"},{"location":"concepts/fundamentals/http_request/#context-processors","title":"Context Processors","text":"<p>Components support Django's context processors.</p> <p>In regular Django templates, the context processors are applied only when the template is rendered with <code>RequestContext</code>.</p> <p>In Components, the context processors are applied when the component has access to the <code>request</code> object.</p>"},{"location":"concepts/fundamentals/http_request/#accessing-context-processors-data","title":"Accessing context processors data","text":"<p>The data from context processors is automatically available within the component's template.</p> <pre><code>class MyComponent(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {{ csrf_token }}\n        &lt;/div&gt;\n    \"\"\"\n\nMyComponent.render(request=request)\n</code></pre> <p>You can also access the context processors data from within <code>get_template_data()</code> and other methods under <code>Component.context_processors_data</code>.</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        csrf_token = self.context_processors_data['csrf_token']\n        return {\n            'csrf_token': csrf_token,\n        }\n</code></pre> <p>This is a dictionary with the context processors data.</p> <p>If the request object is not available, then <code>self.context_processors_data</code> will be an empty dictionary.</p> <p>Warning</p> <p>The <code>self.context_processors_data</code> object is generated dynamically, so changes to it are not persisted.</p>"},{"location":"concepts/fundamentals/render_api/","title":"Render API","text":"<p>When a component is being rendered, whether with <code>Component.render()</code> or <code>{% component %}</code>, a component instance is populated with the current inputs and context. This allows you to access things like component inputs.</p> <p>We refer to these render-time-only methods and attributes as the \"Render API\".</p> <p>Render API is available inside these <code>Component</code> methods:</p> <ul> <li><code>get_template_data()</code></li> <li><code>get_js_data()</code></li> <li><code>get_css_data()</code></li> <li><code>get_context_data()</code></li> <li><code>on_render_before()</code></li> <li><code>on_render_after()</code></li> </ul> <p>Note</p> <p>If you try to access the Render API outside of these methods, you will get a <code>RuntimeError</code>.</p> <p>Example:</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's ID\n        assert self.id == \"c1A2b3c\"\n\n        # Access component's inputs, slots and context\n        assert self.input.args == (123, \"str\")\n        assert self.input.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.input.slots[\"footer\"]\n        some_var = self.input.context[\"some_var\"]\n\n        # Access the request object and Django's context processors, if available\n        assert self.request.GET == {\"query\": \"something\"}\n        assert self.context_processors_data['user'].username == \"admin\"\n\n        return {\n            \"variable\": variable,\n        }\n\nrendered = Table.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"footer\": \"MY_SLOT\"},\n)\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#overview","title":"Overview","text":"<p>The Render API includes:</p> <ul> <li><code>self.id</code> - The unique ID for the current render call</li> <li><code>self.input</code> - All the component inputs</li> <li><code>self.request</code> - The request object (if available)</li> <li><code>self.context_processors_data</code> - Data from Django's context processors (if request is available)</li> <li><code>self.inject()</code> - Inject data into the component</li> </ul>"},{"location":"concepts/fundamentals/render_api/#component-id","title":"Component ID","text":"<p>Component ID (or render ID) is a unique identifier for the current render call.</p> <p>That means that if you call <code>Component.render()</code> multiple times, the ID will be different for each call.</p> <p>It is available as <code>self.id</code>.</p> <p>The ID is a 7-letter alphanumeric string in the format <code>cXXXXXX</code>, where <code>XXXXXX</code> is a random string of 6 alphanumeric characters (case-sensitive).</p> <p>E.g. <code>c1a2b3c</code>.</p> <p>A single render ID has a chance of collision 1 in 57 billion. However, due to birthday paradox, the chance of collision increases to 1% when approaching ~33K render IDs.</p> <p>Thus, there is currently a soft-cap of ~30K components rendered on a single page.</p> <p>If you need to expand this limit, please open an issue on GitHub.</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's ID\n        assert self.id == \"c1A2b3c\"\n\n        return {}\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#component-inputs","title":"Component inputs","text":"<p>All the component inputs are captured and available as <code>self.input</code>.</p> <p><code>self.input</code> (<code>ComponentInput</code>) has the mostly the same fields as the input to <code>Component.render()</code>. This includes:</p> <ul> <li><code>args</code> - List of positional arguments</li> <li><code>kwargs</code> - Dictionary of keyword arguments</li> <li><code>slots</code> - Dictionary of slots. Values are normalized to <code>Slot</code> instances</li> <li><code>context</code> - <code>Context</code> object that should be used to render the component</li> <li>And other kwargs passed to <code>Component.render()</code> like <code>type</code> and <code>render_dependencies</code></li> </ul> <p>Thus, use can use <code>self.input.args</code> and <code>self.input.kwargs</code> to access the positional and keyword arguments passed to <code>Component.render()</code>.</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's inputs, slots and context\n        assert self.input.args == [123, \"str\"]\n        assert self.input.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.input.slots[\"footer\"]\n        some_var = self.input.context[\"some_var\"]\n\n        return {}\n\nrendered = TestComponent.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"footer\": \"MY_SLOT\"},\n)\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#request-object-and-context-processors","title":"Request object and context processors","text":"<p>If the component was either:</p> <ul> <li>Given a <code>request</code> kwarg</li> <li>Rendered with <code>RenderContext</code></li> <li>Nested in another component for which any of these conditions is true</li> </ul> <p>Then the request object will be available in <code>self.request</code>.</p> <p>If the request object is available, you will also be able to access the <code>context processors</code> data in <code>self.context_processors_data</code>.</p> <p>This is a dictionary with the context processors data.</p> <p>If the request object is not available, then <code>self.context_processors_data</code> will be an empty dictionary.</p> <p>Read more about the request object and context processors in the HTTP Request section.</p> <pre><code>from django.http import HttpRequest\n\nclass Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access the request object and Django's context processors\n        assert self.request.GET == {\"query\": \"something\"}\n        assert self.context_processors_data['user'].username == \"admin\"\n\n        return {}\n\nrendered = Table.render(\n    request=HttpRequest(),\n)\n</code></pre>"},{"location":"concepts/fundamentals/render_api/#provide-inject","title":"Provide / Inject","text":"<p>Components support a provide / inject system as known from Vue or React.</p> <p>When rendering the component, you can call <code>self.inject()</code> with the key of the data you want to inject.</p> <p>The object returned by <code>self.inject()</code></p> <p>To provide data to components, use the <code>{% provide %}</code> template tag.</p> <p>Read more about Provide / Inject.</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access provided data\n        data = self.inject(\"some_data\")\n        assert data.some_data == \"some_data\"\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/","title":"Rendering components","text":"<p>Your components can be rendered either within your Django templates, or directly in Python code.</p>"},{"location":"concepts/fundamentals/rendering_components/#overview","title":"Overview","text":"<p>Django Components provides three main methods to render components:</p> <ul> <li><code>{% component %}</code> tag - Renders the component within your Django templates</li> <li><code>Component.render()</code> method - Renders the component to a string</li> <li><code>Component.render_to_response()</code> method - Renders the component and wraps it in an HTTP response</li> </ul>"},{"location":"concepts/fundamentals/rendering_components/#component-tag","title":"<code>{% component %}</code> tag","text":"<p>Use the <code>{% component %}</code> tag to render a component within your Django templates.</p> <p>The <code>{% component %}</code> tag takes:</p> <ul> <li>Component's registered name as the first positional argument,</li> <li>Followed by any number of positional and keyword arguments.</li> </ul> <pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"button\" name=\"John\" job=\"Developer\" / %}\n&lt;/div&gt;\n</code></pre> <p>To pass in slots content, you can insert <code>{% fill %}</code> tags, directly within the <code>{% component %}</code> tag to \"fill\" the slots:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n    {% fill \"pagination\" %}\n      &lt; 1 | 2 | 3 &gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>You can even nest <code>{% fill %}</code> tags within <code>{% if %}</code>, <code>{% for %}</code> and other tags:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n    {% if rows %}\n        {% fill \"pagination\" %}\n            &lt; 1 | 2 | 3 &gt;\n        {% endfill %}\n    {% endif %}\n{% endcomponent %}\n</code></pre> <p>Omitting the <code>component</code> keyword</p> <p>If you would like to omit the <code>component</code> keyword, and simply refer to your components by their registered names:</p> <pre><code>{% button name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>You can do so by setting the \"shorthand\" Tag formatter in the settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\",\n}\n</code></pre> <p>Extended template tag syntax</p> <p>Unlike regular Django template tags, django-components' tags offer extra features like defining literal lists and dicts, and more. Read more about Template tag syntax.</p>"},{"location":"concepts/fundamentals/rendering_components/#registering-components","title":"Registering components","text":"<p>For a component to be renderable with the <code>{% component %}</code> tag, it must be first registered with the <code>@register()</code> decorator.</p> <p>For example, if you register a component under the name <code>\"button\"</code>:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component, register\n\n@register(\"button\")\nclass Button(Component):\n    template_file = \"button.html\"\n\n    class Kwargs(NamedTuple):\n        name: str\n        job: str\n\n    def get_template_data(self, args, kwargs, slots, context):\n        ...\n</code></pre> <p>Then you can render this component by using its registered name <code>\"button\"</code> in the template:</p> <pre><code>{% component \"button\" name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>As you can see above, the args and kwargs passed to the <code>{% component %}</code> tag correspond to the component's input.</p> <p>For more details, read Registering components.</p> <p>Why do I need to register components?</p> <p>TL;DR: To be able to share components as libraries, and because components can be registed with multiple registries / libraries.</p> <p>Django-components allows to share components across projects.</p> <p>However, different projects may use different settings. For example, one project may prefer the \"long\" format:</p> <pre><code>{% component \"button\" name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>While the other may use the \"short\" format:</p> <pre><code>{% button name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>Both approaches are supported simultaneously for backwards compatibility, because django-components started out with only the \"long\" format.</p> <p>To avoid ambiguity, when you use a 3rd party library, it uses the syntax that the author had configured for it.</p> <p>So when you are creating a component, django-components need to know which registry the component belongs to, so it knows which syntax to use.</p>"},{"location":"concepts/fundamentals/rendering_components/#rendering-templates","title":"Rendering templates","text":"<p>If you have embedded the component in a Django template using the <code>{% component %}</code> tag:</p> [project root]/templates/my_template.html<pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"calendar\" date=\"2024-12-13\" / %}\n&lt;/div&gt;\n</code></pre> <p>You can simply render the template with the Django's API:</p> <ul> <li><code>django.shortcuts.render()</code></li> </ul> <pre><code>from django.shortcuts import render\n\ncontext = {\"date\": \"2024-12-13\"}\nrendered_template = render(request, \"my_template.html\", context)\n</code></pre> <ul> <li><code>Template.render()</code></li> </ul> <pre><code>from django.template import Template\nfrom django.template.loader import get_template\n\n# Either from a file\ntemplate = get_template(\"my_template.html\")\n\n# or inlined\ntemplate = Template(\"\"\"\n    {% load component_tags %}\n    &lt;div&gt;\n        {% component \"calendar\" date=\"2024-12-13\" / %}\n    &lt;/div&gt;\n\"\"\")\n\nrendered_template = template.render()\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#isolating-components","title":"Isolating components","text":"<p>By default, components behave similarly to Django's <code>{% include %}</code>, and the template inside the component has access to the variables defined in the outer template.</p> <p>You can selectively isolate a component, using the <code>only</code> flag, so that the inner template can access only the data that was explicitly passed to it:</p> <pre><code>{% component \"name\" positional_arg keyword_arg=value ... only / %}\n</code></pre> <p>Alternatively, you can set all components to be isolated by default, by setting <code>context_behavior</code> to <code>\"isolated\"</code> in your settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"context_behavior\": \"isolated\",\n}\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#render-method","title":"<code>render()</code> method","text":"<p>The <code>Component.render()</code> method renders a component to a string.</p> <p>This is the equivalent of calling the <code>{% component %}</code> tag.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, SlotInput\n\nclass Button(Component):\n    template_file = \"button.html\"\n\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n\n    class Slots(NamedTuple):\n        footer: Optional[SlotInput] = None\n\n    def get_template_data(self, args, kwargs, slots, context):\n        ...\n\nButton.render(\n    args=[\"John\"],\n    kwargs={\n        \"surname\": \"Doe\",\n        \"age\": 30,\n    },\n    slots={\n        \"footer\": \"i AM A SLOT\",\n    },\n)\n</code></pre> <p><code>Component.render()</code> accepts the following arguments:</p> <ul> <li><code>args</code> - Positional arguments to pass to the component (as a list or tuple)</li> <li><code>kwargs</code> - Keyword arguments to pass to the component (as a dictionary)</li> <li><code>slots</code> - Slot content to pass to the component (as a dictionary)</li> <li><code>context</code> - Django context for rendering (can be a dictionary or a <code>Context</code> object)</li> <li><code>deps_strategy</code> - Dependencies rendering strategy (default: <code>\"document\"</code>)</li> <li><code>request</code> - HTTP request object, used for context processors (optional)</li> <li><code>escape_slots_content</code> - Whether to HTML-escape slot content (default: <code>True</code>)</li> <li><code>render_dependencies</code> - Whether to process JS and CSS dependencies (default: <code>True</code>)</li> </ul> <p>All arguments are optional. If not provided, they default to empty values or sensible defaults.</p> <p>See the API reference for <code>Component.render()</code> for more details on the arguments.</p>"},{"location":"concepts/fundamentals/rendering_components/#render_to_response-method","title":"<code>render_to_response()</code> method","text":"<p>The <code>Component.render_to_response()</code> method works just like <code>Component.render()</code>, but wraps the result in an HTTP response.</p> <p>It accepts all the same arguments as <code>Component.render()</code>.</p> <p>Any extra arguments are passed to the <code>HttpResponse</code> constructor.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, SlotInput\n\nclass Button(Component):\n    template_file = \"button.html\"\n\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n\n    class Slots(NamedTuple):\n        footer: Optional[SlotInput] = None\n\n    def get_template_data(self, args, kwargs, slots, context):\n        ...\n\n# Render the component to an HttpResponse\nresponse = Button.render_to_response(\n    args=[\"John\"],\n    kwargs={\n        \"surname\": \"Doe\",\n        \"age\": 30,\n    },\n    slots={\n        \"footer\": \"i AM A SLOT\",\n    },\n    # Additional response arguments\n    status=200,\n    headers={\"X-Custom-Header\": \"Value\"},\n)\n</code></pre> <p>This method is particularly useful in view functions, as you can return the result of the component directly:</p> <pre><code>def profile_view(request, user_id):\n    return Button.render_to_response(\n        kwargs={\n            \"surname\": \"Doe\",\n            \"age\": 30,\n        },\n        request=request,\n    )\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#custom-response-classes","title":"Custom response classes","text":"<p>By default, <code>Component.render_to_response()</code> returns a standard Django <code>HttpResponse</code>.</p> <p>You can customize this by setting the <code>response_class</code> attribute on your component:</p> <pre><code>from django.http import HttpResponse\nfrom django_components import Component\n\nclass MyHttpResponse(HttpResponse):\n    ...\n\nclass MyComponent(Component):\n    response_class = MyHttpResponse\n\nresponse = MyComponent.render_to_response()\nassert isinstance(response, MyHttpResponse)\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#dependencies-rendering","title":"Dependencies rendering","text":"<p>The rendered HTML may be used in different contexts (browser, email, etc), and each may need different handling of JS and CSS scripts.</p> <p><code>render()</code> and <code>render_to_response()</code> accept a <code>deps_strategy</code> parameter, which controls where and how the JS / CSS are inserted into the HTML.</p> <p>The <code>deps_strategy</code> parameter is ultimately passed to <code>render_dependencies()</code>.</p> <p>Learn more about Rendering JS / CSS.</p> <p>There are five dependencies rendering strategies:</p> <ul> <li><code>document</code> (default)<ul> <li>Smartly inserts JS / CSS into placeholders (<code>{% component_js_dependencies %}</code>) or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Inserts extra script to allow <code>fragment</code> components to work.</li> <li>Assumes the HTML will be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>fragment</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>Assumes the page was already rendered with <code>\"document\"</code> strategy.</li> <li>No JS / CSS included.</li> </ul> </li> <li><code>simple</code><ul> <li>Smartly insert JS / CSS into placeholders (<code>{% component_js_dependencies %}</code>) or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>prepend</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>Ignores the placeholders (<code>{% component_js_dependencies %}</code>) and any <code>&lt;head&gt;</code>/<code>&lt;body&gt;</code> HTML tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>append</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>Ignores the placeholders (<code>{% component_js_dependencies %}</code>) and any <code>&lt;head&gt;</code>/<code>&lt;body&gt;</code> HTML tags.</li> <li>No extra script loaded.</li> </ul> </li> </ul> <p>Info</p> <p>You can use the <code>\"prepend\"</code> and <code>\"append\"</code> strategies to force to output JS / CSS for components that don't have neither the placeholders like <code>{% component_js_dependencies %}</code>, nor any <code>&lt;head&gt;</code>/<code>&lt;body&gt;</code> HTML tags:</p> <pre><code>rendered = Calendar.render_to_response(\n    request=request,\n    kwargs={\n        \"date\": request.GET.get(\"date\", \"\"),\n    },\n    deps_strategy=\"append\",\n)\n</code></pre> <p>Renders something like this:</p> <pre><code>&lt;!-- Calendar component --&gt;\n&lt;div class=\"calendar\"&gt;\n    ...\n&lt;/div&gt;\n&lt;!-- Appended JS / CSS --&gt;\n&lt;script src=\"...\"&gt;&lt;/script&gt;\n&lt;link href=\"...\"&gt;&lt;/link&gt;\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#passing-context","title":"Passing context","text":"<p>The <code>render()</code> and <code>render_to_response()</code> methods accept an optional <code>context</code> argument. This sets the context within which the component is rendered.</p> <p>When a component is rendered within a template with the <code>{% component %}</code> tag, this will be automatically set to the Context instance that is used for rendering the template.</p> <p>When you call <code>Component.render()</code> directly from Python, there is no context object, so you can ignore this input most of the time. Instead, use <code>args</code>, <code>kwargs</code>, and <code>slots</code> to pass data to the component.</p> <p>However, you can pass <code>RequestContext</code> to the <code>context</code> argument, so that the component will gain access to the request object and will use context processors. Read more on Working with HTTP requests.</p> <pre><code>Button.render(\n    context=RequestContext(request),\n)\n</code></pre> <p>For advanced use cases, you can use <code>context</code> argument to \"pre-render\" the component in Python, and then pass the rendered output as plain string to the template. With this, the inner component is rendered as if it was within the template with <code>{% component %}</code>.</p> <pre><code>class Button(Component):\n    def render(self, context, template):\n        # Pass `context` to Icon component so it is rendered\n        # as if nested within Button.\n        icon = Icon.render(\n            context=context,\n            args=[\"icon-name\"],\n            render_dependencies=False,\n        )\n        # Update context with icon\n        with context.update({\"icon\": icon}):\n            return template.render(context)\n</code></pre> <p>Warning</p> <p>Whether the variables defined in <code>context</code> are actually available in the template depends on the context behavior mode:</p> <ul> <li> <p>In <code>\"django\"</code> context behavior mode, the template will have access to the keys of this context.</p> </li> <li> <p>In <code>\"isolated\"</code> context behavior mode, the template will NOT have access to this context,     and data MUST be passed via component's args and kwargs.</p> </li> </ul> <p>Therefore, it's strongly recommended to not rely on defining variables on the context object, but instead passing them through as <code>args</code> and <code>kwargs</code></p> <p>\u274c Don't do this:</p> <pre><code>html = ProfileCard.render(\n    context={\"name\": \"John\"},\n)\n</code></pre> <p>\u2705 Do this:</p> <pre><code>html = ProfileCard.render(\n    kwargs={\"name\": \"John\"},\n)\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#typing-render-methods","title":"Typing render methods","text":"<p>Neither <code>Component.render()</code> nor <code>Component.render_to_response()</code> are typed, due to limitations of Python's type system.</p> <p>To add type hints, you can wrap the inputs in component's <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes.</p> <p>Read more on Typing and validation.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, Slot, SlotInput\n\n# Define the component with the types\nclass Button(Component):\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        footer: SlotInput\n\n# Add type hints to the render call\nButton.render(\n    args=Button.Args(\n        name=\"John\",\n    ),\n    kwargs=Button.Kwargs(\n        surname=\"Doe\",\n        age=30,\n    ),\n    slots=Button.Slots(\n        footer=Slot(lambda *a, **kwa: \"Click me!\"),\n    ),\n)\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#nesting-components","title":"Nesting components","text":"<p>You can nest components by rendering one component and using its output as input to another:</p> <pre><code>from django.utils.safestring import mark_safe\n\n# Render the inner component\ninner_html = InnerComponent.render(\n    kwargs={\"some_data\": \"value\"},\n    render_dependencies=False,  # Important for nesting!\n)\n\n# Use inner component's output in the outer component\nouter_html = OuterComponent.render(\n    kwargs={\n        \"content\": mark_safe(inner_html),  # Mark as safe to prevent escaping\n    },\n)\n</code></pre> <p>The key here is setting <code>render_dependencies=False</code> for the inner component. This prevents duplicate dependencies when the outer component is rendered.</p> <p>When <code>render_dependencies=False</code>:</p> <ul> <li>No JS or CSS dependencies will be added to the output HTML</li> <li>The component's content is rendered as-is</li> <li>The outer component will take care of including all needed dependencies</li> </ul> <p>Read more about Rendering JS / CSS.</p>"},{"location":"concepts/fundamentals/rendering_components/#dynamic-components","title":"Dynamic components","text":"<p>Django components defines a special \"dynamic\" component (<code>DynamicComponent</code>).</p> <p>Normally, you have to hard-code the component name in the template:</p> <pre><code>{% component \"button\" / %}\n</code></pre> <p>The dynamic component allows you to dynamically render any component based on the <code>is</code> kwarg. This is similar to Vue's dynamic components (<code>&lt;component :is&gt;</code>).</p> <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>As with other components, the dynamic component can be rendered from Python:</p> <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            render_dependencies=False,\n        ),\n    },\n)\n</code></pre>"},{"location":"concepts/fundamentals/rendering_components/#dynamic-component-name","title":"Dynamic component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/","title":"Secondary JS / CSS files","text":""},{"location":"concepts/fundamentals/secondary_js_css_files/#overview","title":"Overview","text":"<p>Each component can define extra or \"secondary\" CSS / JS files using the nested <code>Component.Media</code> class, by setting <code>Component.Media.js</code> and <code>Component.Media.css</code>.</p> <p>The main HTML / JS / CSS files are limited to 1 per component. This is not the case for the secondary files, where components can have many of them.</p> <p>There is also no special behavior or post-processing for these secondary files, they are loaded as is.</p> <p>You can use these for third-party libraries, or for shared CSS / JS files.</p> <p>These must be set as paths, URLs, or custom objects.</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    class Media:\n        js = [\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",\n            \"calendar/script.js\",\n        ]\n        css = [\n            \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",\n            \"calendar/style.css\",\n        ]\n</code></pre> <p>Note</p> <p>django-component's management of files is inspired by Django's <code>Media</code> class.</p> <p>To be familiar with how Django handles static files, we recommend reading also:</p> <ul> <li>How to manage static files (e.g. images, JavaScript, CSS)</li> </ul>"},{"location":"concepts/fundamentals/secondary_js_css_files/#media-class","title":"<code>Media</code> class","text":"<p>Use the <code>Media</code> class to define secondary JS / CSS files for a component.</p> <p>This <code>Media</code> class behaves similarly to Django's Media class:</p> <ul> <li>Static paths - Paths are handled as static file paths, and are resolved to URLs with Django's   <code>{% static %}</code> template tag.</li> <li>URLs - A path that starts with <code>http</code>, <code>https</code>, or <code>/</code> is considered a URL. URLs are NOT resolved with <code>{% static %}</code>.</li> <li>HTML tags - Both static paths and URLs are rendered to <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> HTML tags with   <code>media_class.render_js()</code> and <code>media_class.render_css()</code>.</li> <li>Bypass formatting - A <code>SafeString</code>,   or a function (with <code>__html__</code> method) is considered an already-formatted HTML tag, skipping both static file   resolution and rendering with <code>media_class.render_js()</code> or <code>media_class.render_css()</code>.</li> <li>Inheritance - You can set <code>extend</code> to configure     whether to inherit JS / CSS from parent components. See Media inheritance.</li> </ul> <p>However, there's a few differences from Django's Media class:</p> <ol> <li>Our Media class accepts various formats for the JS and CSS files: either a single file, a list,    or (CSS-only) a dictonary (See <code>ComponentMediaInput</code>).</li> <li>Individual JS / CSS files can be any of <code>str</code>, <code>bytes</code>, <code>Path</code>,    <code>SafeString</code>, or a function    (See <code>ComponentMediaInputPath</code>).</li> <li>Individual JS / CSS files can be glob patterns, e.g. <code>*.js</code> or <code>styles/**/*.css</code>.</li> <li>If you set <code>Media.extend</code> to a list,    it should be a list of <code>Component</code> classes.</li> </ol> <pre><code>from components.layout import LayoutComp\n\nclass MyTable(Component):\n    class Media:\n        js = [\n            \"path/to/script.js\",\n            \"path/to/*.js\",  # Or as a glob\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",  # AlpineJS\n        ]\n        css = {\n            \"all\": [\n                \"path/to/style.css\",\n                \"path/to/*.css\",  # Or as a glob\n                \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",  # TailwindCSS\n            ],\n            \"print\": [\"path/to/style2.css\"],\n        }\n\n        # Reuse JS / CSS from LayoutComp\n        extend = [\n            LayoutComp,\n        ]\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/#css-media-types","title":"CSS media types","text":"<p>You can define which stylesheets will be associated with which CSS media types. You do so by defining CSS files as a dictionary.</p> <p>See the corresponding Django Documentation.</p> <p>Again, you can set either a single file or a list of files per media type:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": \"path/to/style1.css\",\n            \"print\": [\"path/to/style2.css\", \"path/to/style3.css\"],\n        }\n</code></pre> <p>Which will render the following HTML:</p> <pre><code>&lt;link href=\"/static/path/to/style1.css\" media=\"all\" rel=\"stylesheet\"&gt;\n&lt;link href=\"/static/path/to/style2.css\" media=\"print\" rel=\"stylesheet\"&gt;\n&lt;link href=\"/static/path/to/style3.css\" media=\"print\" rel=\"stylesheet\"&gt;\n</code></pre> <p>Note</p> <p>When you define CSS as a string or a list, the <code>all</code> media type is implied.</p> <p>So these two examples are the same:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        css = \"path/to/style1.css\"\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": [\"path/to/style1.css\"],\n        }\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/#media-inheritance","title":"Media inheritance","text":"<p>By default, the media files are inherited from the parent component.</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"parent.js\", \"script.js\"]\n</code></pre> <p>You can set the component NOT to inherit from the parent component by setting the <code>extend</code> attribute to <code>False</code>:</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        extend = False  # Don't inherit parent media\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"script.js\"]\n</code></pre> <p>Alternatively, you can specify which components to inherit from. In such case, the media files are inherited ONLY from the specified components, and NOT from the original parent components:</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        # Only inherit from these, ignoring the files from the parent\n        extend = [OtherComponent1, OtherComponent2]\n\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"script.js\", \"other1.js\", \"other2.js\"]\n</code></pre> <p>Info</p> <p>The <code>extend</code> behaves consistently with Django's Media class, with one exception:</p> <ul> <li>When you set <code>extend</code> to a list, the list is expected to contain Component classes (or other classes that have a nested <code>Media</code> class).</li> </ul>"},{"location":"concepts/fundamentals/secondary_js_css_files/#accessing-media-files","title":"Accessing Media files","text":"<p>To access the files that you defined under <code>Component.Media</code>, use <code>Component.media</code> (lowercase).</p> <p>This is consistent behavior with Django's Media class.</p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"path/to/script.js\"\n        css = \"path/to/style.css\"\n\nprint(MyComponent.media)\n# Output:\n# &lt;script src=\"/static/path/to/script.js\"&gt;&lt;/script&gt;\n# &lt;link href=\"/static/path/to/style.css\" media=\"all\" rel=\"stylesheet\"&gt;\n</code></pre> <p>When working with component media files, it is important to understand the difference:</p> <ul> <li> <p><code>Component.Media</code></p> <ul> <li>Is the \"raw\" media definition, or the input, which holds only the component's own media definition</li> <li>This class is NOT instantiated, it merely holds the JS / CSS files.</li> </ul> </li> <li> <p><code>Component.media</code></p> <ul> <li>Returns all resolved media files, including those inherited from parent components</li> <li>Is an instance of <code>Component.media_class</code></li> </ul> </li> </ul> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass ChildComponent(ParentComponent):\n    class Media:\n        js = [\"child.js\"]\n\n# Access only this component's media\nprint(ChildComponent.Media.js)  # [\"child.js\"]\n\n# Access all inherited media\nprint(ChildComponent.media._js)  # [\"parent.js\", \"child.js\"]\n</code></pre> <p>Note</p> <p>You should not manually modify <code>Component.media</code> or <code>Component.Media</code> after the component has been resolved, as this may lead to unexpected behavior.</p> <p>If you want to modify the class that is instantiated for <code>Component.media</code>, you can configure <code>Component.media_class</code> (See example).</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/#file-paths","title":"File paths","text":"<p>Unlike the main HTML / JS / CSS files, the path definition for the secondary files are quite ergonomic.</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/#relative-to-component","title":"Relative to component","text":"<p>As seen in the getting started example, to associate HTML / JS / CSS files with a component, you can set them as <code>Component.template_file</code>, <code>Component.js_file</code> and <code>Component.css_file</code> respectively:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"template.html\"\n    css_file = \"style.css\"\n    js_file = \"script.js\"\n</code></pre> <p>In the example above, we defined the files relative to the directory where the component file is defined.</p> <p>Alternatively, you can specify the file paths relative to the directories set in <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code>.</p> <p>If you specify the paths relative to component's directory, django-componenents does the conversion automatically for you.</p> <p>Thus, assuming that <code>COMPONENTS.dirs</code> contains path <code>[project root]/components</code>, the example above is the same as writing:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n    css_file = \"calendar/style.css\"\n    js_file = \"calendar/script.js\"\n</code></pre> <p>Important</p> <p>File path resolution in-depth</p> <p>At component class creation, django-components checks all file paths defined on the component (e.g. <code>Component.template_file</code>).</p> <p>For each file path, it checks if the file path is relative to the component's directory. And such file exists, the component's file path is re-written to be defined relative to a first matching directory in <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code>.</p> <p>Example:</p> [root]/components/mytable/mytable.py<pre><code>class MyTable(Component):\n    template_file = \"mytable.html\"\n</code></pre> <ol> <li>Component <code>MyTable</code> is defined in file <code>[root]/components/mytable/mytable.py</code>.</li> <li>The component's directory is thus <code>[root]/components/mytable/</code>.</li> <li>Because <code>MyTable.template_file</code> is <code>mytable.html</code>, django-components tries to     resolve it as <code>[root]/components/mytable/mytable.html</code>.</li> <li>django-components checks the filesystem. If there's no such file, nothing happens.</li> <li>If there IS such file, django-components tries to rewrite the path.</li> <li>django-components searches <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> for a first     directory that contains <code>[root]/components/mytable/mytable.html</code>.</li> <li>It comes across <code>[root]/components/</code>, which DOES contain the path to <code>mytable.html</code>.</li> <li>Thus, it rewrites <code>template_file</code> from <code>mytable.html</code> to <code>mytable/mytable.html</code>.</li> </ol> <p>NOTE: In case of ambiguity, the preference goes to resolving the files relative to the component's directory.</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/#globs","title":"Globs","text":"<p>Components can have many secondary files. To simplify their declaration, you can use globs.</p> <p>Globs MUST be relative to the component's directory.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    class Media:\n        js = [\n            \"path/to/*.js\",\n            \"another/path/*.js\",\n        ]\n        css = \"*.css\"\n</code></pre> <p>How this works is that django-components will detect that the path is a glob, and will try to resolve all files matching the glob pattern relative to the component's directory.</p> <p>After that, the file paths are handled the same way as if you defined them explicitly.</p>"},{"location":"concepts/fundamentals/secondary_js_css_files/#supported-types","title":"Supported types","text":"<p>File paths can be any of:</p> <ul> <li><code>str</code></li> <li><code>bytes</code></li> <li><code>PathLike</code> (<code>__fspath__</code> method)</li> <li><code>SafeData</code> (<code>__html__</code> method)</li> <li><code>Callable</code> that returns any of the above, evaluated at class creation (<code>__new__</code>)</li> </ul> <p>To help with typing the union, use <code>ComponentMediaInputPath</code>.</p> <pre><code>from pathlib import Path\n\nfrom django.utils.safestring import mark_safe\n\nclass SimpleComponent(Component):\n    class Media:\n        css = [\n            mark_safe('&lt;link href=\"/static/calendar/style1.css\" rel=\"stylesheet\" /&gt;'),\n            Path(\"calendar/style1.css\"),\n            \"calendar/style2.css\",\n            b\"calendar/style3.css\",\n            lambda: \"calendar/style4.css\",\n        ]\n        js = [\n            mark_safe('&lt;script src=\"/static/calendar/script1.js\"&gt;&lt;/script&gt;'),\n            Path(\"calendar/script1.js\"),\n            \"calendar/script2.js\",\n            b\"calendar/script3.js\",\n            lambda: \"calendar/script4.js\",\n        ]\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/#paths-as-objects","title":"Paths as objects","text":"<p>In the example above, you can see that when we used Django's <code>mark_safe()</code> to mark a string as a <code>SafeString</code>, we had to define the URL / path as an HTML <code>&lt;script&gt;</code>/<code>&lt;link&gt;</code> elements.</p> <p>This is an extension of Django's Paths as objects feature, where \"safe\" strings are taken as is, and are accessed only at render time.</p> <p>Because of that, the paths defined as \"safe\" strings are NEVER resolved, neither relative to component's directory, nor relative to <code>COMPONENTS.dirs</code>. It is assumed that you will define the full <code>&lt;script&gt;</code>/<code>&lt;link&gt;</code> tag with the correct URL / path.</p> <p>\"Safe\" strings can be used to lazily resolve a path, or to customize the <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> tag for individual paths:</p> <p>In the example below, we make use of \"safe\" strings to add <code>type=\"module\"</code> to the script tag that will fetch <code>calendar/script2.js</code>. In this case, we implemented a \"safe\" string by defining a <code>__html__</code> method.</p> <pre><code># Path object\nclass ModuleJsPath:\n    def __init__(self, static_path: str) -&gt; None:\n        self.static_path = static_path\n\n    # Lazily resolve the path\n    def __html__(self):\n        full_path = static(self.static_path)\n        return format_html(\n            f'&lt;script type=\"module\" src=\"{full_path}\"&gt;&lt;/script&gt;'\n        )\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n\n    class Media:\n        css = \"calendar/style1.css\"\n        js = [\n            # &lt;script&gt; tag constructed by Media class\n            \"calendar/script1.js\",\n            # Custom &lt;script&gt; tag\n            ModuleJsPath(\"calendar/script2.js\"),\n        ]\n</code></pre>"},{"location":"concepts/fundamentals/secondary_js_css_files/#rendering-paths","title":"Rendering paths","text":"<p>As part of the rendering process, the secondary JS / CSS files are resolved and rendered into <code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> HTML tags, so they can be inserted into the render.</p> <p>In the Paths as objects section, we saw that we can use that to selectively change how the HTML tags are constructed.</p> <p>However, if you need to change how ALL CSS and JS files are rendered for a given component, you can provide your own subclass of Django's <code>Media</code> class to the <code>Component.media_class</code> attribute.</p> <p>To change how the tags are constructed, you can override the <code>Media.render_js()</code> and <code>Media.render_css()</code> methods:</p> <pre><code>from django.forms.widgets import Media\nfrom django_components import Component, register\n\nclass MyMedia(Media):\n    # Same as original Media.render_js, except\n    # the `&lt;script&gt;` tag has also `type=\"module\"`\n    def render_js(self):\n        tags = []\n        for path in self._js:\n            if hasattr(path, \"__html__\"):\n                tag = path.__html__()\n            else:\n                tag = format_html(\n                    '&lt;script type=\"module\" src=\"{}\"&gt;&lt;/script&gt;',\n                    self.absolute_path(path)\n                )\n        return tags\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar/template.html\"\n    css_file = \"calendar/style.css\"\n    js_file = \"calendar/script.js\"\n\n    class Media:\n        css = \"calendar/style1.css\"\n        js = \"calendar/script2.js\"\n\n    # Override the behavior of Media class\n    media_class = MyMedia\n</code></pre>"},{"location":"concepts/fundamentals/single_file_components/","title":"Single-file components","text":"<p>Components can be defined in a single file, inlining the HTML, JS and CSS within the Python code.</p>"},{"location":"concepts/fundamentals/single_file_components/#writing-single-file-components","title":"Writing single file components","text":"<p>To do this, you can use the <code>template</code>, <code>js</code>, and <code>css</code> class attributes instead of the <code>template_file</code>, <code>js_file</code>, and <code>css_file</code>.</p> <p>For example, here's the calendar component from the Getting started tutorial:</p> calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n</code></pre> <p>And here is the same component, rewritten in a single file:</p> [project root]/components/calendar.py<pre><code>from django_components import Component, register, types\n\n@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n\n    template: types.django_html = \"\"\"\n        &lt;div class=\"calendar\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css: types.css = \"\"\"\n        .calendar {\n            width: 200px;\n            background: pink;\n        }\n        .calendar span {\n            font-weight: bold;\n        }\n    \"\"\"\n\n    js: types.js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar\")) {\n                document.querySelector(\".calendar\").onclick = () =&gt; {\n                    alert(\"Clicked calendar!\");\n                };\n            }\n        })()\n    \"\"\"\n</code></pre> <p>You can mix and match, so you can have a component with inlined HTML, while the JS and CSS are in separate files:</p> [project root]/components/calendar.py<pre><code>from django_components import Component, register, types\n\n@register(\"calendar\")\nclass Calendar(Component):\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    template: types.django_html = \"\"\"\n        &lt;div class=\"calendar\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/single_file_components/#syntax-highlighting","title":"Syntax highlighting","text":"<p>If you \"inline\" the HTML, JS and CSS code into the Python class, you should set up syntax highlighting to let your code editor know that the inlined code is HTML, JS and CSS.</p> <p>In the examples above, we've annotated the <code>template</code>, <code>js</code>, and <code>css</code> attributes with the <code>types.django_html</code>, <code>types.js</code> and <code>types.css</code> types. These are used for syntax highlighting in VSCode.</p> <p>Warning</p> <p>Autocompletion / intellisense does not work in the inlined code.</p> <p>Help us add support for intellisense in the inlined code! Start a conversation in the GitHub Discussions.</p>"},{"location":"concepts/fundamentals/single_file_components/#vscode","title":"VSCode","text":"<ol> <li> <p>First install Python Inline Source Syntax Highlighting extension, it will give you syntax highlighting for the template, CSS, and JS.</p> </li> <li> <p>Next, in your component, set typings of <code>Component.template</code>, <code>Component.js</code>, <code>Component.css</code> to <code>types.django_html</code>, <code>types.css</code>, and <code>types.js</code> respectively. The extension will recognize these and will activate syntax highlighting.</p> </li> </ol> [project root]/components/calendar.py<pre><code>from django_components import Component, register, types\n\n@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n\n    template: types.django_html = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css: types.css = \"\"\"\n        .calendar-component {\n            width: 200px;\n            background: pink;\n        }\n        .calendar-component span {\n            font-weight: bold;\n        }\n    \"\"\"\n\n    js: types.js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar-component\")) {\n                document.querySelector(\".calendar-component\").onclick = function(){ alert(\"Clicked calendar!\"); };\n            }\n        })()\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/single_file_components/#pycharm-or-other-jetbrains-ides","title":"Pycharm (or other Jetbrains IDEs)","text":"<p>With PyCharm (or any other editor from Jetbrains), you don't need to use <code>types.django_html</code>, <code>types.css</code>, <code>types.js</code> since Pycharm uses language injections.</p> <p>You only need to write the comments <code># language=&lt;lang&gt;</code> above the variables.</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n        }\n\n    # language=HTML\n    template= \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    # language=CSS\n    css = \"\"\"\n        .calendar-component {\n            width: 200px;\n            background: pink;\n        }\n        .calendar-component span {\n            font-weight: bold;\n        }\n    \"\"\"\n\n    # language=JS\n    js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar-component\")) {\n                document.querySelector(\".calendar-component\").onclick = function(){ alert(\"Clicked calendar!\"); };\n            }\n        })()\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/single_file_components/#markdown-code-blocks-with-pygments","title":"Markdown code blocks with Pygments","text":"<p>Pygments is a syntax highlighting library written in Python. It's also what's used by this documentation site (mkdocs-material) to highlight code blocks.</p> <p>To write code blocks with syntax highlighting, you need to install the <code>pygments-djc</code> package.</p> <pre><code>pip install pygments-djc\n</code></pre> <p>And then initialize it by importing <code>pygments_djc</code> somewhere in your project:</p> <pre><code>import pygments_djc\n</code></pre> <p>Now you can use the <code>djc_py</code> code block to write code blocks with syntax highlighting for components.</p> <pre><code>\\```djc_py\nfrom django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n        .calendar-component {\n            width: 200px;\n            background: pink;\n        }\n        .calendar-component span {\n            font-weight: bold;\n        }\n    \"\"\"\n\\```\n</code></pre> <p>Will be rendered as below. Notice that the CSS and HTML are highlighted correctly:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template= \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n        .calendar-component {\n            width: 200px;\n            background: pink;\n        }\n        .calendar-component span {\n            font-weight: bold;\n        }\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/slots/","title":"Slots","text":"<p>New in version 0.26:</p> <ul> <li>The <code>slot</code> tag now serves only to declare new slots inside the component template.</li> <li>To override the content of a declared slot, use the newly introduced <code>fill</code> tag instead.</li> <li>Whereas unfilled slots used to raise a warning, filling a slot is now optional by default.</li> <li>To indicate that a slot must be filled, the new <code>required</code> option should be added at the end of the <code>slot</code> tag.</li> </ul> <p>Components support something called 'slots'. When a component is used inside another template, slots allow the parent template to override specific parts of the child component by passing in different content. This mechanism makes components more reusable and composable. This behavior is similar to slots in Vue.</p> <p>In the example below we introduce two block tags that work hand in hand to make this work. These are...</p> <ul> <li><code>{% slot &lt;name&gt; %}</code>/<code>{% endslot %}</code>: Declares a new slot in the component template.</li> <li><code>{% fill &lt;name&gt; %}</code>/<code>{% endfill %}</code>: (Used inside a <code>{% component %}</code> tag pair.) Fills a declared slot with the specified content.</li> </ul> <p>Let's update our calendar component to support more customization. We'll add <code>slot</code> tag pairs to its template, template.html.</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"header\" %}Calendar header{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"body\" %}Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>When using the component, you specify which slots you want to fill and where you want to use the defaults from the template. It looks like this:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"body\" %}\n        Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Since the 'header' fill is unspecified, it's taken from the base template. If you put this in a template, and pass in <code>date=2020-06-06</code>, this is what gets rendered:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        Calendar header\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        Can you believe it's already &lt;span&gt;2020-06-06&lt;/span&gt;??\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#named-slots","title":"Named slots","text":"<p>As seen in the previouse section, you can use <code>{% fill slot_name %}</code> to insert content into a specific slot.</p> <p>You can define fills for multiple slot simply by defining them all within the <code>{% component %} {% endcomponent %}</code> tags:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}\n        Hi this is header!\n    {% endfill %}\n    {% fill \"body\" %}\n        Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>You can also use <code>{% for %}</code>, <code>{% with %}</code>, or other non-component tags (even <code>{% include %}</code>) to construct the <code>{% fill %}</code> tags, as long as these other tags do not leave any text behind!</p> <pre><code>{% component \"table\" %}\n  {% for slot_name in slots %}\n    {% fill name=slot_name %}\n      {{ slot_name }}\n    {% endfill %}\n  {% endfor %}\n\n  {% with slot_name=\"abc\" %}\n    {% fill name=slot_name %}\n      {{ slot_name }}\n    {% endfill %}\n  {% endwith %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#default-slot","title":"Default slot","text":"<p>Added in version 0.28</p> <p>As you can see, component slots lets you write reusable containers that you fill in when you use a component. This makes for highly reusable components that can be used in different circumstances.</p> <p>It can become tedious to use <code>fill</code> tags everywhere, especially when you're using a component that declares only one slot. To make things easier, <code>slot</code> tags can be marked with an optional keyword: <code>default</code>.</p> <p>When added to the tag (as shown below), this option lets you pass filling content directly in the body of a <code>component</code> tag pair \u2013 without using a <code>fill</code> tag. Choose carefully, though: a component template may contain at most one slot that is marked as <code>default</code>. The <code>default</code> option can be combined with other slot options, e.g. <code>required</code>.</p> <p>Here's the same example as before, except with default slots and implicit filling.</p> <p>The template:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"header\" %}Calendar header{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"body\" default %}Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Including the component (notice how the <code>fill</code> tag is omitted):</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n{% endcomponent %}\n</code></pre> <p>The rendered result (exactly the same as before):</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n  &lt;div class=\"header\"&gt;Calendar header&lt;/div&gt;\n  &lt;div class=\"body\"&gt;Can you believe it's already &lt;span&gt;2020-06-06&lt;/span&gt;??&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>You may be tempted to combine implicit fills with explicit <code>fill</code> tags. This will not work. The following component template will raise an error when rendered.</p> <pre><code>{# DON'T DO THIS #}\n{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}Totally new header!{% endfill %}\n    Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n{% endcomponent %}\n</code></pre> <p>Instead, you can use a named fill with name <code>default</code> to target the default fill:</p> <pre><code>{# THIS WORKS #}\n{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}Totally new header!{% endfill %}\n    {% fill \"default\" %}\n        Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>NOTE: If you doubly-fill a slot, that is, that both <code>{% fill \"default\" %}</code> and <code>{% fill \"header\" %}</code> would point to the same slot, this will raise an error when rendered.</p>"},{"location":"concepts/fundamentals/slots/#accessing-default-slot-in-python","title":"Accessing default slot in Python","text":"<p>Since the default slot is stored under the slot name <code>default</code>, you can access the default slot like so:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        default_slot = slots[\"default\"]\n        return {\n            \"default_slot\": default_slot,\n        }\n</code></pre>"},{"location":"concepts/fundamentals/slots/#render-fill-in-multiple-places","title":"Render fill in multiple places","text":"<p>Added in version 0.70</p> <p>You can render the same content in multiple places by defining multiple slots with identical names:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"image\" %}Image here{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"image\" %}Image here{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>So if used like:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"image\" %}\n        &lt;img src=\"...\" /&gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>This renders:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        &lt;img src=\"...\" /&gt;\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        &lt;img src=\"...\" /&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#default-and-required-slots","title":"Default and required slots","text":"<p>If you use a slot multiple times, you can still mark the slot as <code>default</code> or <code>required</code>. For that, you must mark each slot individually, e.g.:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Which you can then use as regular default slot:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    &lt;img src=\"...\" /&gt;\n{% endcomponent %}\n</code></pre> <p>Since each slot is tagged individually, you can have multiple slots with the same name but different conditions.</p> <p>E.g. in this example, we have a component that renders a user avatar - a small circular image with a profile picture or name initials.</p> <p>If the component is given <code>image_src</code> or <code>name_initials</code> variables, the <code>image</code> slot is optional. But if neither of those are provided, you MUST fill the <code>image</code> slot.</p> <pre><code>&lt;div class=\"avatar\"&gt;\n    {% if image_src %}\n        {% slot \"image\" default %}\n            &lt;img src=\"{{ image_src }}\" /&gt;\n        {% endslot %}\n    {% elif name_initials %}\n        {% slot \"image\" default %}\n            &lt;div style=\"\n                border-radius: 25px;\n                width: 50px;\n                height: 50px;\n                background: blue;\n            \"&gt;\n                {{ name_initials }}\n            &lt;/div&gt;\n        {% endslot %}\n    {% else %}\n        {% slot \"image\" default required / %}\n    {% endif %}\n&lt;/div&gt;\n</code></pre>"},{"location":"concepts/fundamentals/slots/#accessing-original-content-of-slots","title":"Accessing original content of slots","text":"<p>Added in version 0.26</p> <p>NOTE: In version 0.77, the syntax was changed from</p> <pre><code>{% fill \"my_slot\" as \"alias\" %} {{ alias.default }}\n</code></pre> <p>to</p> <pre><code>{% fill \"my_slot\" default=\"slot_default\" %} {{ slot_default }}\n</code></pre> <p>Sometimes you may want to keep the original slot, but only wrap or prepend/append content to it. To do so, you can access the default slot via the <code>default</code> kwarg.</p> <p>Similarly to the <code>data</code> attribute, you specify the variable name through which the default slot will be made available.</p> <p>For instance, let's say you're filling a slot called 'body'. To render the original slot, assign it to a variable using the <code>'default'</code> keyword. You then render this variable to insert the default content:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"body\" default=\"body_default\" %}\n        {{ body_default }}. Have a great day!\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>This produces:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        Calendar header\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        Today's date is &lt;span&gt;2020-06-06&lt;/span&gt;. Have a great day!\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>To access the original content of a default slot, set the name to <code>default</code>:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"default\" default=\"slot_default\" %}\n        {{ slot_default }}. Have a great day!\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#conditional-slots","title":"Conditional slots","text":"<p>Added in version 0.26.</p> <p>NOTE: In version 0.70, <code>{% if_filled %}</code> tags were replaced with <code>{{ component_vars.is_filled }}</code> variables. If your slot name contained special characters, see the section Accessing <code>is_filled</code> of slot names with special characters.</p> <p>In certain circumstances, you may want the behavior of slot filling to depend on whether or not a particular slot is filled.</p> <p>For example, suppose we have the following component template:</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>By default the slot named 'subtitle' is empty. Yet when the component is used without explicit fills, the div containing the slot is still rendered, as shown below:</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n  &lt;div class=\"title\"&gt;Title&lt;/div&gt;\n  &lt;div class=\"subtitle\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>This may not be what you want. What if instead the outer 'subtitle' div should only be included when the inner slot is in fact filled?</p> <p>The answer is to use the <code>{{ component_vars.is_filled.&lt;name&gt; }}</code> variable. You can use this together with Django's <code>{% if/elif/else/endif %}</code> tags to define a block whose contents will be rendered only if the component slot with the corresponding 'name' is filled.</p> <p>This is what our example looks like with <code>component_vars.is_filled</code>.</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    {% if component_vars.is_filled.subtitle %}\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <p>Here's our example with more complex branching.</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    {% if component_vars.is_filled.subtitle %}\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n    {% elif component_vars.is_filled.title %}\n        ...\n    {% elif component_vars.is_filled.&lt;name&gt; %}\n        ...\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <p>Sometimes you're not interested in whether a slot is filled, but rather that it isn't. To negate the meaning of <code>component_vars.is_filled</code>, simply treat it as boolean and negate it with <code>not</code>:</p> <pre><code>{% if not component_vars.is_filled.subtitle %}\n&lt;div class=\"subtitle\"&gt;\n    {% slot \"subtitle\" / %}\n&lt;/div&gt;\n{% endif %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#accessing-is_filled-of-slot-names-with-special-characters","title":"Accessing <code>is_filled</code> of slot names with special characters","text":"<p>To be able to access a slot name via <code>component_vars.is_filled</code>, the slot name needs to be composed of only alphanumeric characters and underscores (e.g. <code>this__isvalid_123</code>).</p> <p>However, you can still define slots with other special characters. In such case, the slot name in <code>component_vars.is_filled</code> is modified to replace all invalid characters into <code>_</code>.</p> <p>So a slot named <code>\"my super-slot :)\"</code> will be available as <code>component_vars.is_filled.my_super_slot___</code>.</p> <p>Same applies when you are accessing <code>is_filled</code> from within the Python, e.g.:</p> <pre><code>class MyTable(Component):\n    def on_render_before(self, context, template) -&gt; None:\n        # \u2705 Works\n        if self.is_filled[\"my_super_slot___\"]:\n            # Do something\n\n        # \u274c Does not work\n        if self.is_filled[\"my super-slot :)\"]:\n            # Do something\n</code></pre>"},{"location":"concepts/fundamentals/slots/#conditional-fills","title":"Conditional fills","text":"<p>Similarly, you can use <code>{% if %}</code> and <code>{% for %}</code> when defining the <code>{% fill %}</code> tags, to conditionally fill the slots when using the componnet:</p> <p>In the example below, the <code>{% fill \"footer\" %}</code> fill is used only if the condition is true. If falsy, the fill is ignored, and so the <code>my_table</code> component will use its default content for the <code>footer</code> slot.</p> <pre><code>{% component \"my_table\" %}\n    {% if editable %}\n        {% fill \"footer\" %}\n            &lt;input name=\"name\" /&gt;\n        {% endfill %}\n    {% endif %}\n{% endcomponent %}\n</code></pre> <p>You can even combine <code>{% if %}</code> and <code>{% for %}</code>:</p> <pre><code>{% component \"my_table\" %}\n    {% for header in headers %}\n        {% if header != \"hyperlink\" %}\n            {# Generate fill name like `header.my_column` #}\n            {% fill name=\"header.\"|add:header\" %}\n                &lt;b&gt;{{ header }}&lt;/b&gt;\n            {% endfill %}\n        {% endif %}\n    {% endfor %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#scoped-slots","title":"Scoped slots","text":"<p>Added in version 0.76:</p> <p>Consider a component with slot(s). This component may do some processing on the inputs, and then use the processed variable in the slot's default template:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {% slot \"content\" default %}\n                input: {{ input }}\n            {% endslot %}\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        processed_input = do_something(kwargs[\"input\"])\n        return {\"input\": processed_input}\n</code></pre> <p>You may want to design a component so that users of your component can still access the <code>input</code> variable, so they don't have to recompute it.</p> <p>This behavior is called \"scoped slots\". This is inspired by Vue scoped slots and scoped slots of django-web-components.</p> <p>Using scoped slots consists of two steps:</p> <ol> <li>Passing data to <code>slot</code> tag</li> <li>Accessing data in <code>fill</code> tag</li> </ol>"},{"location":"concepts/fundamentals/slots/#passing-data-to-slots","title":"Passing data to slots","text":"<p>To pass the data to the <code>slot</code> tag, simply pass them as keyword attributes (<code>key=value</code>):</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {% slot \"content\" default input=input %}\n                input: {{ input }}\n            {% endslot %}\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        processed_input = do_something(kwargs[\"input\"])\n        return {\n            \"input\": processed_input,\n        }\n</code></pre>"},{"location":"concepts/fundamentals/slots/#accessing-slot-data-in-fill","title":"Accessing slot data in fill","text":"<p>Next, we head over to where we define a fill for this slot. Here, to access the slot data we set the <code>data</code> attribute to the name of the variable through which we want to access the slot data. In the example below, we set it to <code>data</code>:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"content\" data=\"slot_data\" %}\n        {{ slot_data.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>To access slot data on a default slot, you have to explictly define the <code>{% fill %}</code> tags.</p> <p>So this works:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"content\" data=\"slot_data\" %}\n        {{ slot_data.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>While this does not:</p> <pre><code>{% component \"my_comp\" data=\"data\" %}\n    {{ data.input }}\n{% endcomponent %}\n</code></pre> <p>Note: You cannot set the <code>data</code> attribute and <code>default</code> attribute) to the same name. This raises an error:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"content\" data=\"slot_var\" default=\"slot_var\" %}\n        {{ slot_var.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#slot-data-of-default-slots","title":"Slot data of default slots","text":"<p>To access data of a default slot, you can specify <code>{% fill name=\"default\" %}</code>:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"default\" data=\"slot_data\" %}\n        {{ slot_data.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#dynamic-slots-and-fills","title":"Dynamic slots and fills","text":"<p>Until now, we were declaring slot and fill names statically, as a string literal, e.g.</p> <pre><code>{% slot \"content\" / %}\n</code></pre> <p>However, sometimes you may want to generate slots based on the given input. One example of this is a table component like that of Vuetify, which creates a header and an item slots for each user-defined column.</p> <p>In django_components you can achieve the same, simply by using a variable (or a template expression) instead of a string literal:</p> <pre><code>&lt;table&gt;\n  &lt;tr&gt;\n    {% for header in headers %}\n      &lt;th&gt;\n        {% slot \"header-{{ header.key }}\" value=header.title %}\n          {{ header.title }}\n        {% endslot %}\n      &lt;/th&gt;\n    {% endfor %}\n  &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre> <p>When using the component, you can either set the fill explicitly:</p> <pre><code>{% component \"table\" headers=headers items=items %}\n  {% fill \"header-name\" data=\"data\" %}\n    &lt;b&gt;{{ data.value }}&lt;/b&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Or also use a variable:</p> <pre><code>{% component \"table\" headers=headers items=items %}\n  {# Make only the active column bold #}\n  {% fill \"header-{{ active_header_name }}\" data=\"data\" %}\n    &lt;b&gt;{{ data.value }}&lt;/b&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>NOTE: It's better to use static slot names whenever possible for clarity. The dynamic slot names should be reserved for advanced use only.</p> <p>Lastly, in rare cases, you can also pass the slot name via the spread operator. This is possible, because the slot name argument is actually a shortcut for a <code>name</code> keyword argument.</p> <p>So this:</p> <pre><code>{% slot \"content\" / %}\n</code></pre> <p>is the same as:</p> <pre><code>{% slot name=\"content\" / %}\n</code></pre> <p>So it's possible to define a <code>name</code> key on a dictionary, and then spread that onto the slot tag:</p> <pre><code>{# slot_props = {\"name\": \"content\"} #}\n{% slot ...slot_props / %}\n</code></pre>"},{"location":"concepts/fundamentals/slots/#pass-through-all-the-slots","title":"Pass through all the slots","text":"<p>You can dynamically pass all slots to a child component. This is similar to passing all slots in Vue:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"slots\": slots,\n        }\n\n    template = \"\"\"\n    &lt;div&gt;\n      {% component \"child\" %}\n        {% for slot_name in slots %}\n          {% fill name=slot_name data=\"data\" %}\n            {% slot name=slot_name ...data / %}\n          {% endfill %}\n        {% endfor %}\n      {% endcomponent %}\n    &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/slots/#escaping-slots-content","title":"Escaping slots content","text":"<p>Slots content are automatically escaped by default to prevent XSS attacks.</p> <p>In other words, it's as if you would be using Django's <code>mark_safe()</code> function on the slot content:</p> <pre><code>from django.utils.safestring import mark_safe\n\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {% slot \"date\" default date=date / %}\n        &lt;/div&gt;\n    \"\"\"\n\nCalendar.render(\n    slots={\n        \"date\": mark_safe(\"&lt;b&gt;Hello&lt;/b&gt;\"),\n    }\n)\n</code></pre> <p>To disable escaping, you can pass <code>escape_slots_content=False</code> to <code>Component.render()</code> or <code>Component.render_to_response()</code> methods.</p> <p>Warning</p> <p>If you disable escaping, you should make sure that any content you pass to the slots is safe, especially if it comes from user input!</p> <p>Info</p> <p>If you're planning on passing an HTML string, check Django's use of <code>format_html</code> and <code>mark_safe</code>.</p>"},{"location":"concepts/fundamentals/subclassing_components/","title":"Subclassing components","text":"<p>In larger projects, you might need to write multiple components with similar behavior. In such cases, you can extract shared behavior into a standalone component class to keep things DRY.</p> <p>When subclassing a component, there's a couple of things to keep in mind:</p>"},{"location":"concepts/fundamentals/subclassing_components/#template-js-and-css-inheritance","title":"Template, JS, and CSS inheritance","text":"<p>When it comes to the pairs:</p> <ul> <li><code>Component.template</code>/<code>Component.template_file</code></li> <li><code>Component.js</code>/<code>Component.js_file</code></li> <li><code>Component.css</code>/<code>Component.css_file</code></li> </ul> <p>inheritance follows these rules:</p> <ul> <li>If a child component class defines either member of a pair (e.g., either <code>template</code> or <code>template_file</code>), it takes precedence and the parent's definition is ignored completely.</li> <li>For example, if a child component defines <code>template_file</code>, the parent's <code>template</code> or <code>template_file</code> will be ignored.</li> <li>This applies independently to each pair - you can inherit the JS while overriding the template, for instance.</li> </ul> <p>For example:</p> <pre><code>class BaseCard(Component):\n    template = \"\"\"\n        &lt;div class=\"card\"&gt;\n            &lt;div class=\"card-content\"&gt;{{ content }}&lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n    css = \"\"\"\n        .card {\n            border: 1px solid gray;\n        }\n    \"\"\"\n    js = \"\"\"console.log('Base card loaded');\"\"\"\n\n# This class overrides parent's template, but inherits CSS and JS\nclass SpecialCard(BaseCard):\n    template = \"\"\"\n        &lt;div class=\"card special\"&gt;\n            &lt;div class=\"card-content\"&gt;\u2728 {{ content }} \u2728&lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n# This class overrides parent's template and CSS, but inherits JS\nclass CustomCard(BaseCard):\n    template_file = \"custom_card.html\"\n    css = \"\"\"\n        .card {\n            border: 2px solid gold;\n        }\n    \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/subclassing_components/#media-inheritance","title":"Media inheritance","text":"<p>The <code>Component.Media</code> nested class follows Django's media inheritance rules:</p> <ul> <li>If both parent and child define a <code>Media</code> class, the child's media will automatically include both its own and the parent's JS and CSS files.</li> <li>This behavior can be configured using the <code>extend</code> attribute in the Media class, similar to Django's forms.   Read more on this in Media inheritance.</li> </ul> <p>For example:</p> <pre><code>class BaseModal(Component):\n    template = \"&lt;div&gt;Modal content&lt;/div&gt;\"\n\n    class Media:\n        css = [\"base_modal.css\"]\n        js = [\"base_modal.js\"]  # Contains core modal functionality\n\nclass FancyModal(BaseModal):\n    class Media:\n        # Will include both base_modal.css/js AND fancy_modal.css/js\n        css = [\"fancy_modal.css\"]  # Additional styling\n        js = [\"fancy_modal.js\"]    # Additional animations\n\nclass SimpleModal(BaseModal):\n    class Media:\n        extend = False  # Don't inherit parent's media\n        css = [\"simple_modal.css\"]  # Only this CSS will be included\n        js = [\"simple_modal.js\"]    # Only this JS will be included\n</code></pre>"},{"location":"concepts/fundamentals/subclassing_components/#regular-python-inheritance","title":"Regular Python inheritance","text":"<p>All other attributes and methods (including the <code>Component.View</code> class and its methods) follow standard Python inheritance rules.</p> <p>For example:</p> <pre><code>class BaseForm(Component):\n    template = \"\"\"\n        &lt;form&gt;\n            {{ form_content }}\n            &lt;button type=\"submit\"&gt;\n                {{ submit_text }}\n            &lt;/button&gt;\n        &lt;/form&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"form_content\": self.get_form_content(),\n            \"submit_text\": \"Submit\"\n        }\n\n    def get_form_content(self):\n        return \"&lt;input type='text' name='data'&gt;\"\n\nclass ContactForm(BaseForm):\n    # Extend parent's \"context\"\n    # but override \"submit_text\"\n    def get_template_data(self, args, kwargs, slots, context):\n        context = super().get_template_data(args, kwargs, slots, context)\n        context[\"submit_text\"] = \"Send Message\"  \n        return context\n\n    # Completely override parent's get_form_content\n    def get_form_content(self):\n        return \"\"\"\n            &lt;input type='text' name='name' placeholder='Your Name'&gt;\n            &lt;input type='email' name='email' placeholder='Your Email'&gt;\n            &lt;textarea name='message' placeholder='Your Message'&gt;&lt;/textarea&gt;\n        \"\"\"\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/","title":"Template tag syntax","text":"<p>All template tags in django_component, like <code>{% component %}</code> or <code>{% slot %}</code>, and so on, support extra syntax that makes it possible to write components like in Vue or React (JSX).</p>"},{"location":"concepts/fundamentals/template_tag_syntax/#self-closing-tags","title":"Self-closing tags","text":"<p>When you have a tag like <code>{% component %}</code> or <code>{% slot %}</code>, but it has no content, you can simply append a forward slash <code>/</code> at the end, instead of writing out the closing tags like <code>{% endcomponent %}</code> or <code>{% endslot %}</code>:</p> <p>So this:</p> <pre><code>{% component \"button\" %}{% endcomponent %}\n</code></pre> <p>becomes</p> <pre><code>{% component \"button\" / %}\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/#special-characters","title":"Special characters","text":"<p>New in version 0.71:</p> <p>Keyword arguments can contain special characters <code># @ . - _</code>, so keywords like so are still valid:</p> <pre><code>&lt;body&gt;\n    {% component \"calendar\" my-date=\"2015-06-19\" @click.native=do_something #some_id=True / %}\n&lt;/body&gt;\n</code></pre> <p>These can then be accessed inside <code>get_template_data</code> so:</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"my-date\"],\n            \"id\": kwargs[\"#some_id\"],\n            \"on_click\": kwargs[\"@click.native\"]\n        }\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/#spread-operator","title":"Spread operator","text":"<p>New in version 0.93:</p> <p>Instead of passing keyword arguments one-by-one:</p> <pre><code>{% component \"calendar\" title=\"How to abc\" date=\"2015-06-19\" author=\"John Wick\" / %}\n</code></pre> <p>You can use a spread operator <code>...dict</code> to apply key-value pairs from a dictionary:</p> <pre><code>post_data = {\n    \"title\": \"How to...\",\n    \"date\": \"2015-06-19\",\n    \"author\": \"John Wick\",\n}\n</code></pre> <pre><code>{% component \"calendar\" ...post_data / %}\n</code></pre> <p>This behaves similar to JSX's spread operator or Vue's <code>v-bind</code>.</p> <p>Spread operators are treated as keyword arguments, which means that:</p> <ol> <li>Spread operators must come after positional arguments.</li> <li>You cannot use spread operators for positional-only arguments.</li> </ol> <p>Other than that, you can use spread operators multiple times, and even put keyword arguments in-between or after them:</p> <pre><code>{% component \"calendar\" ...post_data id=post.id ...extra / %}\n</code></pre> <p>In a case of conflicts, the values added later (right-most) overwrite previous values.</p>"},{"location":"concepts/fundamentals/template_tag_syntax/#template-tags-inside-literal-strings","title":"Template tags inside literal strings","text":"<p>New in version 0.93</p> <p>When passing data around, sometimes you may need to do light transformations, like negating booleans or filtering lists.</p> <p>Normally, what you would have to do is to define ALL the variables inside <code>get_template_data()</code>. But this can get messy if your components contain a lot of logic.</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"editable\": kwargs[\"editable\"],\n            \"readonly\": not kwargs[\"editable\"],\n            \"input_id\": f\"input-{kwargs['id']}\",\n            \"icon_id\": f\"icon-{kwargs['id']}\",\n            ...\n        }\n</code></pre> <p>Instead, template tags in django_components (<code>{% component %}</code>, <code>{% slot %}</code>, <code>{% provide %}</code>, etc) allow you to treat literal string values as templates:</p> <pre><code>{% component 'blog_post'\n  \"As positional arg {# yay #}\"\n  title=\"{{ person.first_name }} {{ person.last_name }}\"\n  id=\"{% random_int 10 20 %}\"\n  readonly=\"{{ editable|not }}\"\n  author=\"John Wick {# TODO: parametrize #}\"\n/ %}\n</code></pre> <p>In the example above, the component receives:</p> <ul> <li>Positional argument <code>\"As positional arg \"</code> (Comment omitted)</li> <li><code>title</code> - passed as <code>str</code>, e.g. <code>John Doe</code></li> <li><code>id</code> - passed as <code>int</code>, e.g. <code>15</code></li> <li><code>readonly</code> - passed as <code>bool</code>, e.g. <code>False</code></li> <li><code>author</code> - passed as <code>str</code>, e.g. <code>John Wick</code> (Comment omitted)</li> </ul> <p>This is inspired by django-cotton.</p>"},{"location":"concepts/fundamentals/template_tag_syntax/#passing-data-as-string-vs-original-values","title":"Passing data as string vs original values","text":"<p>In the example above, the kwarg <code>id</code> was passed as an integer, NOT a string.</p> <p>When the string literal contains only a single template tag, with no extra text (and no extra whitespace), then the value is passed as the original type instead of a string.</p> <p>Here, <code>page</code> is an integer:</p> <pre><code>{% component 'blog_post' page=\"{% random_int 10 20 %}\" / %}\n</code></pre> <p>Here, <code>page</code> is a string:</p> <pre><code>{% component 'blog_post' page=\" {% random_int 10 20 %} \" / %}\n</code></pre> <p>And same applies to the <code>{{ }}</code> variable tags:</p> <p>Here, <code>items</code> is a list:</p> <pre><code>{% component 'cat_list' items=\"{{ cats|slice:':2' }}\" / %}\n</code></pre> <p>Here, <code>items</code> is a string:</p> <pre><code>{% component 'cat_list' items=\"{{ cats|slice:':2' }} See more\" / %}\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/#evaluating-python-expressions-in-template","title":"Evaluating Python expressions in template","text":"<p>You can even go a step further and have a similar experience to Vue or React, where you can evaluate arbitrary code expressions:</p> <pre><code>&lt;MyForm value={isEnabled ? inputValue : null} /&gt;\n</code></pre> <p>Similar is possible with <code>django-expr</code>, which adds an <code>expr</code> tag and filter that you can use to evaluate Python expressions from within the template:</p> <pre><code>{% component \"my_form\"\n  value=\"{% expr 'input_value if is_enabled else None' %}\"\n/ %}\n</code></pre> <p>Note: Never use this feature to mix business logic and template logic. Business logic should still be in the view!</p>"},{"location":"concepts/fundamentals/template_tag_syntax/#pass-dictonary-by-its-key-value-pairs","title":"Pass dictonary by its key-value pairs","text":"<p>New in version 0.74:</p> <p>Sometimes, a component may expect a dictionary as one of its inputs.</p> <p>Most commonly, this happens when a component accepts a dictionary of HTML attributes (usually called <code>attrs</code>) to pass to the underlying template.</p> <p>In such cases, we may want to define some HTML attributes statically, and other dynamically. But for that, we need to define this dictionary on Python side:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        {% component \"other\" attrs=attrs / %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        attrs = {\n            \"class\": \"pa-4 flex\",\n            \"data-some-id\": kwargs[\"some_id\"],\n            \"@click.stop\": \"onClickHandler\",\n        }\n        return {\"attrs\": attrs}\n</code></pre> <p>But as you can see in the case above, the event handler <code>@click.stop</code> and styling <code>pa-4 flex</code> are disconnected from the template. If the component grew in size and we moved the HTML to a separate file, we would have hard time reasoning about the component's template.</p> <p>Luckily, there's a better way.</p> <p>When we want to pass a dictionary to a component, we can define individual key-value pairs as component kwargs, so we can keep all the relevant information in the template. For that, we prefix the key with the name of the dict and <code>:</code>. So key <code>class</code> of input <code>attrs</code> becomes <code>attrs:class</code>. And our example becomes:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        {% component \"other\"\n            attrs:class=\"pa-4 flex\"\n            attrs:data-some-id=some_id\n            attrs:@click.stop=\"onClickHandler\"\n        / %}\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"some_id\": kwargs[\"some_id\"]}\n</code></pre> <p>Sweet! Now all the relevant HTML is inside the template, and we can move it to a separate file with confidence:</p> <pre><code>{% component \"other\"\n    attrs:class=\"pa-4 flex\"\n    attrs:data-some-id=some_id\n    attrs:@click.stop=\"onClickHandler\"\n/ %}\n</code></pre> <p>Note: It is NOT possible to define nested dictionaries, so <code>attrs:my_key:two=2</code> would be interpreted as:</p> <pre><code>{\"attrs\": {\"my_key:two\": 2}}\n</code></pre>"},{"location":"concepts/fundamentals/template_tag_syntax/#multiline-tags","title":"Multiline tags","text":"<p>By default, Django expects a template tag to be defined on a single line.</p> <p>However, this can become unwieldy if you have a component with a lot of inputs:</p> <pre><code>{% component \"card\" title=\"Joanne Arc\" subtitle=\"Head of Kitty Relations\" date_last_active=\"2024-09-03\" ... %}\n</code></pre> <p>Instead, when you install django_components, it automatically configures Django to suport multi-line tags.</p> <p>So we can rewrite the above as:</p> <pre><code>{% component \"card\"\n    title=\"Joanne Arc\"\n    subtitle=\"Head of Kitty Relations\"\n    date_last_active=\"2024-09-03\"\n    ...\n%}\n</code></pre> <p>Much better!</p> <p>To disable this behavior, set <code>COMPONENTS.multiline_tag</code> to <code>False</code></p>"},{"location":"concepts/fundamentals/typing_and_validation/","title":"Typing and validation","text":""},{"location":"concepts/fundamentals/typing_and_validation/#typing-overview","title":"Typing overview","text":"<p>Warning</p> <p>In versions 0.92 to 0.139 (inclusive), the component typing was specified through generics.</p> <p>Since v0.140, the types must be specified as class attributes of the Component class - <code>Args</code>, <code>Kwargs</code>, <code>Slots</code>, <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code>.</p> <p>See Migrating from generics to class attributes for more info.</p> <p>Warning</p> <p>Input validation was NOT part of Django Components between versions 0.136 and 0.139 (inclusive).</p> <p>The <code>Component</code> class optionally accepts class attributes that allow you to define the types of args, kwargs, slots, as well as the data returned from the data methods.</p> <p>Use this to add type hints to your components, to validate the inputs at runtime, and to document them.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django.template import Context\nfrom django_components import Component, SlotInput\n\nclass Button(Component):\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        variable: str\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        ...\n\n    template_file = \"button.html\"\n</code></pre> <p>The class attributes are:</p> <ul> <li><code>Args</code> - Type for positional arguments.</li> <li><code>Kwargs</code> - Type for keyword arguments.</li> <li><code>Slots</code> - Type for slots.</li> <li><code>TemplateData</code> - Type for data returned from <code>get_template_data()</code>.</li> <li><code>JsData</code> - Type for data returned from <code>get_js_data()</code>.</li> <li><code>CssData</code> - Type for data returned from <code>get_css_data()</code>.</li> </ul> <p>You can specify as many or as few of these as you want, the rest will default to <code>None</code>.</p>"},{"location":"concepts/fundamentals/typing_and_validation/#typing-inputs","title":"Typing inputs","text":"<p>You can use <code>Component.Args</code>, <code>Component.Kwargs</code>, and <code>Component.Slots</code> to type the component inputs.</p> <p>When you set these classes, at render time the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters of the data methods (<code>get_template_data()</code>, <code>get_js_data()</code>, <code>get_css_data()</code>) will be instances of these classes.</p> <p>This way, each component can have runtime validation of the inputs:</p> <ul> <li>When you use <code>NamedTuple</code>   or <code>@dataclass</code>,   instantiating these classes will check ONLY for the presence of the attributes.</li> <li>When you use Pydantic models,   instantiating these classes will check for the presence AND type of the attributes.</li> </ul> <p>If you omit the <code>Args</code>, <code>Kwargs</code>, or <code>Slots</code> classes, or set them to <code>None</code>, the inputs will be passed as plain lists or dictionaries, and will not be validated.</p> <pre><code>from typing_extensions import NamedTuple, TypedDict\nfrom django.template import Context\nfrom django_components import Component, Slot, SlotInput\n\n# The data available to the `footer` scoped slot\nclass ButtonFooterSlotData(TypedDict):\n    value: int\n\n# Define the component with the types\nclass Button(Component):\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        # Use `SlotInput` to allow slots to be given as `Slot` instance,\n        # plain string, or a function that returns a string.\n        my_slot: Optional[SlotInput] = None\n        # Use `Slot` to allow ONLY `Slot` instances.\n        # The generic is optional, and it specifies the data available\n        # to the slot function.\n        footer: Slot[ButtonFooterSlotData]\n\n    # Add type hints to the data method\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        # The parameters are instances of the classes we defined\n        assert isinstance(args, Button.Args)\n        assert isinstance(kwargs, Button.Kwargs)\n        assert isinstance(slots, Button.Slots)\n\n        args.name  # str\n        kwargs.age  # int\n        slots.footer  # Slot[ButtonFooterSlotData]\n\n# Add type hints to the render call\nButton.render(\n    args=Button.Args(\n        name=\"John\",\n    ),\n    kwargs=Button.Kwargs(\n        surname=\"Doe\",\n        age=30,\n    ),\n    slots=Button.Slots(\n        footer=Slot(lambda *a, **kwa: \"Click me!\"),\n    ),\n)\n</code></pre> <p>If you don't want to validate some parts, set them to <code>None</code> or omit them.</p> <p>The following will validate only the keyword inputs:</p> <pre><code>class Button(Component):\n    # We could also omit these\n    Args = None\n    Slots = None\n\n    class Kwargs(NamedTuple):\n        name: str\n        age: int\n\n    # Only `kwargs` is instantiated. `args` and `slots` are not.\n    def get_template_data(self, args, kwargs: Kwargs, slots, context: Context):\n        assert isinstance(args, list)\n        assert isinstance(slots, dict)\n        assert isinstance(kwargs, Button.Kwargs)\n\n        args[0]  # str\n        slots[\"footer\"]  # Slot[ButtonFooterSlotData]\n        kwargs.age  # int\n</code></pre> <p>Info</p> <p>Components can receive slots as strings, functions, or instances of <code>Slot</code>.</p> <p>Internally these are all normalized to instances of <code>Slot</code>.</p> <p>Therefore, the <code>slots</code> dictionary available in data methods (like <code>get_template_data()</code>) will always be a dictionary of <code>Slot</code> instances.</p> <p>To correctly type this dictionary, you should set the fields of <code>Slots</code> to <code>Slot</code> or <code>SlotInput</code>:</p> <p><code>SlotInput</code> is a union of <code>Slot</code>, string, and function types.</p>"},{"location":"concepts/fundamentals/typing_and_validation/#typing-data","title":"Typing data","text":"<p>You can use <code>Component.TemplateData</code>, <code>Component.JsData</code>, and <code>Component.CssData</code> to type the data returned from <code>get_template_data()</code>, <code>get_js_data()</code>, and <code>get_css_data()</code>.</p> <p>When you set these classes, at render time they will be instantiated with the data returned from these methods.</p> <p>This way, each component can have runtime validation of the returned data:</p> <ul> <li>When you use <code>NamedTuple</code>   or <code>@dataclass</code>,   instantiating these classes will check ONLY for the presence of the attributes.</li> <li>When you use Pydantic models,   instantiating these classes will check for the presence AND type of the attributes.</li> </ul> <p>If you omit the <code>TemplateData</code>, <code>JsData</code>, or <code>CssData</code> classes, or set them to <code>None</code>, the validation and instantiation will be skipped.</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Button(Component):\n    class TemplateData(NamedTuple):\n        data1: str\n        data2: int\n\n    class JsData(NamedTuple):\n        js_data1: str\n        js_data2: int\n\n    class CssData(NamedTuple):\n        css_data1: str\n        css_data2: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"data1\": \"...\",\n            \"data2\": 123,\n        }\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"js_data1\": \"...\",\n            \"js_data2\": 123,\n        }\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"css_data1\": \"...\",\n            \"css_data2\": 123,\n        }\n</code></pre> <p>For each data method, you can either return a plain dictionary with the data, or an instance of the respective data class directly.</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Button(Component):\n    class TemplateData(NamedTuple):\n        data1: str\n        data2: int\n\n    class JsData(NamedTuple):\n        js_data1: str\n        js_data2: int\n\n    class CssData(NamedTuple):\n        css_data1: str\n        css_data2: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return Button.TemplateData(\n            data1=\"...\",\n            data2=123,\n        )\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return Button.JsData(\n            js_data1=\"...\",\n            js_data2=123,\n        )\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return Button.CssData(\n            css_data1=\"...\",\n            css_data2=123,\n        )\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#custom-types","title":"Custom types","text":"<p>We recommend to use <code>NamedTuple</code> for the <code>Args</code> class, and <code>NamedTuple</code>, dataclasses, or Pydantic models for <code>Kwargs</code>, <code>Slots</code>, <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code> classes.</p> <p>However, you can use any class, as long as they meet the conditions below.</p> <p>For example, here is how you can use Pydantic models to validate the inputs at runtime.</p> <pre><code>from django_components import Component\nfrom pydantic import BaseModel\n\nclass Table(Component):\n    class Kwargs(BaseModel):\n        name: str\n        age: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        assert isinstance(kwargs, Table.Kwargs)\n\nTable.render(\n    kwargs=Table.Kwargs(name=\"John\", age=30),\n)\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#args-class","title":"<code>Args</code> class","text":"<p>The <code>Args</code> class represents a list of positional arguments. It must meet two conditions:</p> <ol> <li> <p>The constructor for the <code>Args</code> class must accept positional arguments.</p> <pre><code>Args(*args)\n</code></pre> </li> <li> <p>The <code>Args</code> instance must be convertable to a list.</p> <pre><code>list(Args(1, 2, 3))\n</code></pre> </li> </ol> <p>To implement the conversion to a list, you can implement the <code>__iter__()</code> method:</p> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#dictionary-classes","title":"Dictionary classes","text":"<p>On the other hand, other types (<code>Kwargs</code>, <code>Slots</code>, <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code>) represent dictionaries. They must meet these two conditions:</p> <ol> <li> <p>The constructor must accept keyword arguments.</p> <pre><code>Kwargs(**kwargs)\nSlots(**slots)\n</code></pre> </li> <li> <p>The instance must be convertable to a dictionary.</p> <pre><code>dict(Kwargs(a=1, b=2))\ndict(Slots(a=1, b=2))\n</code></pre> </li> </ol> <p>To implement the conversion to a dictionary, you can implement either:</p> <ol> <li> <p><code>_asdict()</code> method     <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def _asdict(self):\n        return {'x': self.x, 'y': self.y}\n</code></pre></p> </li> <li> <p>Or make the class dict-like with <code>__iter__()</code> and <code>__getitem__()</code> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code></pre></p> </li> </ol>"},{"location":"concepts/fundamentals/typing_and_validation/#passing-variadic-args-and-kwargs","title":"Passing variadic args and kwargs","text":"<p>You may have a component that accepts any number of args or kwargs.</p> <p>However, this cannot be described with the current Python's typing system (as of v0.140).</p> <p>As a workaround:</p> <ul> <li> <p>For a variable number of positional arguments (<code>*args</code>), set a positional argument that accepts a list of values:</p> <pre><code>class Table(Component):\n    class Args(NamedTuple):\n        args: List[str]\n\nTable.render(\n    args=Table.Args(args=[\"a\", \"b\", \"c\"]),\n)\n</code></pre> </li> <li> <p>For a variable number of keyword arguments (<code>**kwargs</code>), set a keyword argument that accepts a dictionary of values:</p> <pre><code>class Table(Component):\n    class Kwargs(NamedTuple):\n        variable: str\n        another: int\n        # Pass any extra keys under `extra`\n        extra: Dict[str, any]\n\nTable.render(\n    kwargs=Table.Kwargs(\n        variable=\"a\",\n        another=1,\n        extra={\"foo\": \"bar\"},\n    ),\n)\n</code></pre> </li> </ul>"},{"location":"concepts/fundamentals/typing_and_validation/#handling-no-args-or-no-kwargs","title":"Handling no args or no kwargs","text":"<p>To declare that a component accepts no args, kwargs, etc, define the types with no attributes using the <code>pass</code> keyword:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Button(Component):\n    class Args(NamedTuple):\n        pass\n\n    class Kwargs(NamedTuple):\n        pass\n\n    class Slots(NamedTuple):\n        pass\n</code></pre> <p>This can get repetitive, so we added a <code>Empty</code> type to make it easier:</p> <pre><code>from django_components import Component, Empty\n\nclass Button(Component):\n    Args = Empty\n    Kwargs = Empty\n    Slots = Empty\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#subclassing","title":"Subclassing","text":"<p>Subclassing components with types is simple.</p> <p>Since each type class is a separate class attribute, you can just override them in the Component subclass.</p> <p>In the example below, <code>ButtonExtra</code> inherits <code>Kwargs</code> from <code>Button</code>, but overrides the <code>Args</code> class.</p> <pre><code>from django_components import Component, Empty\n\nclass Button(Component):\n    class Args(NamedTuple):\n        size: int\n\n    class Kwargs(NamedTuple):\n        color: str\n\nclass ButtonExtra(Button):\n    class Args(NamedTuple):\n        name: str\n        size: int\n\n# Stil works the same way!\nButtonExtra.render(\n    args=ButtonExtra.Args(name=\"John\", size=30),\n    kwargs=ButtonExtra.Kwargs(color=\"red\"),\n)\n</code></pre> <p>The only difference is when it comes to type hints to the data methods like <code>get_template_data()</code>.</p> <p>When you define the nested classes like <code>Args</code> and <code>Kwargs</code> directly on the class, you can reference them just by their class name (<code>Args</code> and <code>Kwargs</code>).</p> <p>But when you have a Component subclass, and it uses <code>Args</code> or <code>Kwargs</code> from the parent, you will have to reference the type as a forward reference, including the full name of the component (<code>Button.Args</code> and <code>Button.Kwargs</code>).</p> <p>Compare the following:</p> <pre><code>class Button(Component):\n    class Args(NamedTuple):\n        size: int\n\n    class Kwargs(NamedTuple):\n        color: str\n\n    # Both `Args` and `Kwargs` are defined on the class\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots, context):\n        pass\n\nclass ButtonExtra(Button):\n    class Args(NamedTuple):\n        name: str\n        size: int\n\n    # `Args` is defined on the subclass, `Kwargs` is defined on the parent\n    def get_template_data(self, args: Args, kwargs: \"ButtonExtra.Kwargs\", slots, context):\n        pass\n\nclass ButtonSame(Button):\n    # Both `Args` and `Kwargs` are defined on the parent\n    def get_template_data(self, args: \"ButtonSame.Args\", kwargs: \"ButtonSame.Kwargs\", slots, context):\n        pass\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#runtime-type-validation","title":"Runtime type validation","text":"<p>When you add types to your component, and implement them as <code>NamedTuple</code> or <code>dataclass</code>, the validation will check only for the presence of the attributes.</p> <p>So this will not catch if you pass a string to an <code>int</code> attribute.</p> <p>To enable runtime type validation, you need to use Pydantic models, and install the <code>djc-ext-pydantic</code> extension.</p> <p>The <code>djc-ext-pydantic</code> extension ensures compatibility between django-components' classes such as <code>Component</code>, or <code>Slot</code> and Pydantic models.</p> <p>First install the extension:</p> <pre><code>pip install djc-ext-pydantic\n</code></pre> <p>And then add the extension to your project:</p> <pre><code>COMPONENTS = {\n    \"extensions\": [\n        \"djc_pydantic.PydanticExtension\",\n    ],\n}\n</code></pre>"},{"location":"concepts/fundamentals/typing_and_validation/#migrating-from-generics-to-class-attributes","title":"Migrating from generics to class attributes","text":"<p>In versions 0.92 to 0.139 (inclusive), the component typing was specified through generics.</p> <p>Since v0.140, the types must be specified as class attributes of the Component class - <code>Args</code>, <code>Kwargs</code>, <code>Slots</code>, <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code>.</p> <p>This change was necessary to make it possible to subclass components. Subclassing with generics was otherwise too complicated. Read the discussion here.</p> <p>Because of this change, the <code>Component.render()</code> method is no longer typed. To type-check the inputs, you should wrap the inputs in <code>Component.Args</code>, <code>Component.Kwargs</code>, <code>Component.Slots</code>, etc.</p> <p>For example, if you had a component like this:</p> <pre><code>from typing import NotRequired, Tuple, TypedDict\nfrom django_components import Component, Slot, SlotInput\n\nButtonArgs = Tuple[int, str]\n\nclass ButtonKwargs(TypedDict):\n    variable: str\n    another: int\n    maybe_var: NotRequired[int] # May be omitted\n\nclass ButtonSlots(TypedDict):\n    # Use `SlotInput` to allow slots to be given as `Slot` instance,\n    # plain string, or a function that returns a string.\n    my_slot: NotRequired[SlotInput]\n    # Use `Slot` to allow ONLY `Slot` instances.\n    another_slot: Slot\n\nButtonType = Component[ButtonArgs, ButtonKwargs, ButtonSlots]\n\nclass Button(ButtonType):\n    def get_context_data(self, *args, **kwargs):\n        self.input.args[0]  # int\n        self.input.kwargs[\"variable\"]  # str\n        self.input.slots[\"my_slot\"]  # Slot[MySlotData]\n\nButton.render(\n    args=(1, \"hello\"),\n    kwargs={\n        \"variable\": \"world\",\n        \"another\": 123,\n    },\n    slots={\n        \"my_slot\": \"...\",\n        \"another_slot\": Slot(lambda: ...),\n    },\n)\n</code></pre> <p>The steps to migrate are:</p> <ol> <li>Convert all the types (<code>ButtonArgs</code>, <code>ButtonKwargs</code>, <code>ButtonSlots</code>) to subclasses     of <code>NamedTuple</code>.</li> <li>Move these types inside the Component class (<code>Button</code>), and rename them to <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code>.</li> <li>If you defined typing for the data methods (like <code>get_context_data()</code>), move them inside the Component class, and rename them to <code>TemplateData</code>, <code>JsData</code>, and <code>CssData</code>.</li> <li>Remove the <code>Component</code> generic.</li> <li> <p>If you accessed the <code>args</code>, <code>kwargs</code>, or <code>slots</code> attributes via     <code>self.input</code>, you will need to add the type hints yourself, because <code>self.input</code> is no longer typed.</p> <p>Otherwise, you may use <code>Component.get_template_data()</code> instead of <code>get_context_data()</code>, as <code>get_template_data()</code> receives <code>args</code>, <code>kwargs</code>, <code>slots</code> and <code>context</code> as arguments. You will still need to add the type hints yourself.</p> </li> <li> <p>Lastly, you will need to update the <code>Component.render()</code>     calls to wrap the inputs in <code>Component.Args</code>, <code>Component.Kwargs</code>, and <code>Component.Slots</code>, to manually add type hints.</p> </li> </ol> <p>Thus, the code above will become:</p> <pre><code>from typing import NamedTuple, Optional\nfrom django.template import Context\nfrom django_components import Component, Slot, SlotInput\n\n# The Component class does not take any generics\nclass Button(Component):\n    # Types are now defined inside the component class\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        variable: str\n        another: int\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        # Use `SlotInput` to allow slots to be given as `Slot` instance,\n        # plain string, or a function that returns a string.\n        my_slot: Optional[SlotInput] = None\n        # Use `Slot` to allow ONLY `Slot` instances.\n        another_slot: Slot\n\n    # The args, kwargs, slots are instances of the component's Args, Kwargs, and Slots classes\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        args.size  # int\n        kwargs.variable  # str\n        slots.my_slot  # Slot[MySlotData]\n\nButton.render(\n    # Wrap the inputs in the component's Args, Kwargs, and Slots classes\n    args=Button.Args(1, \"hello\"),\n    kwargs=Button.Kwargs(\n        variable=\"world\",\n        another=123,\n    ),\n    slots=Button.Slots(\n        my_slot=\"...\",\n        another_slot=Slot(lambda: ...),\n    ),\n)\n</code></pre>"},{"location":"getting_started/adding_js_and_css/","title":"Adding JS and CSS","text":"<p>Next we will add CSS and JavaScript to our template.</p> <p>Info</p> <p>In django-components, using JS and CSS is as simple as defining them on the Component class. You don't have to insert the <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags into the HTML manually.</p> <p>Behind the scenes, django-components keeps track of which components use which JS and CSS files. Thus, when a component is rendered on the page, the page will contain only the JS and CSS used by the components, and nothing more!</p>"},{"location":"getting_started/adding_js_and_css/#1-update-project-structure","title":"1. Update project structure","text":"<p>Start by creating empty <code>calendar.js</code> and <code>calendar.css</code> files:</p> <pre><code>sampleproject/\n\u251c\u2500\u2500 calendarapp/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 calendar/\n\u2502       \u251c\u2500\u2500 calendar.py\n\u2502       \u251c\u2500\u2500 calendar.js       \ud83c\udd95\n\u2502       \u251c\u2500\u2500 calendar.css      \ud83c\udd95\n\u2502       \u2514\u2500\u2500 calendar.html\n\u251c\u2500\u2500 sampleproject/\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting_started/adding_js_and_css/#2-write-css","title":"2. Write CSS","text":"<p>Inside <code>calendar.css</code>, write:</p> [project root]/components/calendar/calendar.css<pre><code>.calendar {\n  width: 200px;\n  background: pink;\n}\n.calendar span {\n  font-weight: bold;\n}\n</code></pre> <p>Be sure to prefix your rules with unique CSS class like <code>calendar</code>, so the CSS doesn't clash with other rules.</p> <p>Note</p> <p>Soon, django-components will automatically scope your CSS by default, so you won't have to worry about CSS class clashes.</p> <p>This CSS will be inserted into the page as an inlined <code>&lt;style&gt;</code> tag, at the position defined by <code>{% component_css_dependencies %}</code>, or at the end of the inside the <code>&lt;head&gt;</code> tag (See JS and CSS output locations).</p> <p>So in your HTML, you may see something like this:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n    &lt;style&gt;\n      .calendar {\n        width: 200px;\n        background: pink;\n      }\n      .calendar span {\n        font-weight: bold;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting_started/adding_js_and_css/#3-write-js","title":"3. Write JS","text":"<p>Next we write a JavaScript file that specifies how to interact with this component.</p> <p>You are free to use any javascript framework you want.</p> [project root]/components/calendar/calendar.js<pre><code>(function () {\n  document.querySelector(\".calendar\").onclick = () =&gt; {\n    alert(\"Clicked calendar!\");\n  };\n})();\n</code></pre> <p>A good way to make sure the JS of this component doesn't clash with other components is to define all JS code inside an anonymous self-invoking function (<code>(() =&gt; { ... })()</code>). This makes all variables defined only be defined inside this component and not affect other components.</p> <p>Note</p> <p>Soon, django-components will automatically wrap your JS in a self-invoking function by default (except for JS defined with <code>&lt;script type=\"module\"&gt;</code>).</p> <p>Similarly to CSS, JS will be inserted into the page as an inlined <code>&lt;script&gt;</code> tag, at the position defined by <code>{% component_js_dependencies %}</code>, or at the end of the inside the <code>&lt;body&gt;</code> tag (See JS and CSS output locations).</p> <p>So in your HTML, you may see something like this:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n    &lt;script&gt;\n      (function () {\n        document.querySelector(\".calendar\").onclick = () =&gt; {\n          alert(\"Clicked calendar!\");\n        };\n      })();\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting_started/adding_js_and_css/#rules-of-js-execution","title":"Rules of JS execution","text":"<ol> <li> <p>JS is executed in the order in which the components are found in the HTML</p> <p>By default, the JS is inserted as a synchronous script (<code>&lt;script&gt; ... &lt;/script&gt;</code>)</p> <p>So if you define multiple components on the same page, their JS will be executed in the order in which the components are found in the HTML.</p> <p>So if we have a template like so:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component \"calendar\" / %}\n    {% component \"table\" / %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Then the JS file of the component <code>calendar</code> will be executed first, and the JS file of component <code>table</code> will be executed second.</p> </li> <li> <p>JS will be executed only once, even if there is multiple instances of the same component</p> <p>In this case, the JS of <code>calendar</code> will STILL execute first (because it was found first), and will STILL execute only once, even though it's present twice:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component \"calendar\" / %}\n    {% component \"table\" / %}\n    {% component \"calendar\" / %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> </ol>"},{"location":"getting_started/adding_js_and_css/#4-link-js-and-css-to-a-component","title":"4. Link JS and CSS to a component","text":"<p>Finally, we return to our Python component in <code>calendar.py</code> to tie this together.</p> <p>To link JS and CSS defined in other files, use <code>js_file</code> and <code>css_file</code> attributes:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"   # &lt;--- new\n    css_file = \"calendar.css\"   # &lt;--- new\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>And that's it! If you were to embed this component in an HTML, django-components will automatically embed the associated JS and CSS.</p> <p>Note</p> <p>Similarly to the template file, the JS and CSS file paths can be either:</p> <ol> <li>Relative to the Python component file (as seen above),</li> <li>Relative to any of the component directories as defined by <code>COMPONENTS.dirs</code> and/or <code>COMPONENTS.app_dirs</code> (e.g. <code>[your apps]/components</code> dir and <code>[project root]/components</code>)</li> <li>Relative to any of the directories defined by <code>STATICFILES_DIRS</code>.</li> </ol>"},{"location":"getting_started/adding_js_and_css/#5-link-additional-js-and-css-to-a-component","title":"5. Link additional JS and CSS to a component","text":"<p>Your components may depend on third-party packages or styling, or other shared logic. To load these additional dependencies, you can use a nested <code>Media</code> class.</p> <p>This <code>Media</code> class behaves similarly to Django's Media class, with a few differences:</p> <ol> <li>Our Media class accepts various formats for the JS and CSS files: either a single file, a list, or (CSS-only) a dictonary (see below).</li> <li>Individual JS / CSS files can be any of <code>str</code>, <code>bytes</code>, <code>Path</code>, <code>SafeString</code>, or a function.</li> <li>Individual JS / CSS files can be glob patterns, e.g. <code>*.js</code> or <code>styles/**/*.css</code>.</li> <li>If you set <code>Media.extend</code> to a list,    it should be a list of <code>Component</code> classes.</li> </ol> <p>Learn more about using Media.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    class Media:   # &lt;--- new\n        js = [\n            \"path/to/shared.js\",\n            \"path/to/*.js\",  # Or as a glob\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",  # AlpineJS\n        ]\n        css = [\n            \"path/to/shared.css\",\n            \"path/to/*.css\",  # Or as a glob\n            \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",  # Tailwind\n        ]\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>Note</p> <p>Same as with the \"primary\" JS and CSS, the file paths files can be either:</p> <ol> <li>Relative to the Python component file (as seen above),</li> <li>Relative to any of the component directories as defined by <code>COMPONENTS.dirs</code> and/or <code>COMPONENTS.app_dirs</code> (e.g. <code>[your apps]/components</code> dir and <code>[project root]/components</code>)</li> </ol> <p>Info</p> <p>The <code>Media</code> nested class is shaped based on Django's Media class.</p> <p>As such, django-components allows multiple formats to define the nested Media class:</p> <pre><code># Single files\nclass Media:\n    js = \"calendar.js\"\n    css = \"calendar.css\"\n\n# Lists of files\nclass Media:\n    js = [\"calendar.js\", \"calendar2.js\"]\n    css = [\"calendar.css\", \"calendar2.css\"]\n\n# Dictionary of media types for CSS\nclass Media:\n    js = [\"calendar.js\", \"calendar2.js\"]\n    css = {\n      \"all\": [\"calendar.css\", \"calendar2.css\"],\n    }\n</code></pre> <p>If you define a list of JS files, they will be executed one-by-one, left-to-right.</p>"},{"location":"getting_started/adding_js_and_css/#rules-of-execution-of-scripts-in-mediajs","title":"Rules of execution of scripts in <code>Media.js</code>","text":"<p>The scripts defined in <code>Media.js</code> still follow the rules outlined above:</p> <ol> <li>JS is executed in the order in which the components are found in the HTML.</li> <li>JS will be executed only once, even if there is multiple instances of the same component.</li> </ol> <p>Additionally to <code>Media.js</code> applies that:</p> <ol> <li>JS in <code>Media.js</code> is executed before the component's primary JS.</li> <li>JS in <code>Media.js</code> is executed in the same order as it was defined.</li> <li>If there is multiple components that specify the same JS path or URL in <code>Media.js</code>,    this JS will be still loaded and executed only once.</li> </ol> <p>Putting all of this together, our <code>Calendar</code> component above would render HTML like so:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    ...\n    &lt;!-- CSS from Media.css --&gt;\n    &lt;link href=\"/static/path/to/shared.css\" media=\"all\" rel=\"stylesheet\" /&gt;\n    &lt;link\n      href=\"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\"\n      media=\"all\"\n      rel=\"stylesheet\"\n    /&gt;\n    &lt;!-- CSS from Component.css_file --&gt;\n    &lt;style&gt;\n      .calendar {\n        width: 200px;\n        background: pink;\n      }\n      .calendar span {\n        font-weight: bold;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n    &lt;!-- JS from Media.js --&gt;\n    &lt;script src=\"/static/path/to/shared.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\"&gt;&lt;/script&gt;\n    &lt;!-- JS from Component.js_file --&gt;\n    &lt;script&gt;\n      (function () {\n        document.querySelector(\".calendar\").onclick = () =&gt; {\n          alert(\"Clicked calendar!\");\n        };\n      })();\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now that we have a fully-defined component, next let's use it in a Django template \u27a1\ufe0f.</p>"},{"location":"getting_started/adding_slots/","title":"Adding slots","text":"<p>Our calendar component's looking great! But we just got a new assignment from our colleague - The calendar date needs to be shown on 3 different pages:</p> <ol> <li>On one page, it needs to be shown as is</li> <li>On the second, the date needs to be bold</li> <li>On the third, the date needs to be in italics</li> </ol> <p>As a reminder, this is what the component's template looks like:</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>There's many ways we could approach this:</p> <ul> <li>Expose the date in a slot</li> <li>Style <code>.calendar &gt; span</code> differently on different pages</li> <li>Pass a variable to the component that decides how the date is rendered</li> <li>Create a new component</li> </ul> <p>First two options are more flexible, because the custom styling is not baked into a component's implementation. And for the sake of demonstration, we'll solve this challenge with slots.</p>"},{"location":"getting_started/adding_slots/#1-what-are-slots","title":"1. What are slots","text":"<p>Components support something called Slots.</p> <p>When a component is used inside another template, slots allow the parent template to override specific parts of the child component by passing in different content.</p> <p>This mechanism makes components more reusable and composable.</p> <p>This behavior is similar to slots in Vue.</p> <p>In the example below we introduce two tags that work hand in hand to make this work. These are...</p> <ul> <li><code>{% slot &lt;name&gt; %}</code>/<code>{% endslot %}</code>: Declares a new slot in the component template.</li> <li><code>{% fill &lt;name&gt; %}</code>/<code>{% endfill %}</code>: (Used inside a <code>{% component %}</code>   tag pair.) Fills a declared slot with the specified content.</li> </ul>"},{"location":"getting_started/adding_slots/#2-add-a-slot-tag","title":"2. Add a slot tag","text":"<p>Let's update our calendar component to support more customization. We'll add <code>{% slot %}</code> tag to the template:</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is\n  {% slot \"date\" default %}  {# &lt;--- new #}\n    &lt;span&gt;{{ date }}&lt;/span&gt;\n  {% endslot %}\n&lt;/div&gt;\n</code></pre> <p>Notice that:</p> <ol> <li> <p>We named the slot <code>date</code> - so we can fill this slot by using <code>{% fill \"date\" %}</code></p> </li> <li> <p>We also made it the default slot.</p> </li> <li> <p>We placed our original implementation inside the <code>{% slot %}</code>    tag - this is what will be rendered when the slot is NOT overriden.</p> </li> </ol>"},{"location":"getting_started/adding_slots/#3-add-fill-tag","title":"3. Add fill tag","text":"<p>Now we can use <code>{% fill %}</code> tags inside the <code>{% component %}</code> tags to override the <code>date</code> slot to generate the bold and italics variants:</p> <pre><code>{# Default #}\n{% component \"calendar\" date=\"2024-12-13\" / %}\n\n{# Bold #}\n{% component \"calendar\" date=\"2024-12-13\" %}\n  &lt;b&gt; 2024-12-13 &lt;/b&gt;\n{% endcomponent %}\n\n{# Italics #}\n{% component \"calendar\" date=\"2024-12-13\" %}\n  &lt;i&gt; 2024-12-13 &lt;/i&gt;\n{% endcomponent %}\n</code></pre> <p>Which will render as:</p> <pre><code>&lt;!-- Default --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;2024-12-13&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;!-- Bold --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;b&gt;2024-12-13&lt;/b&gt;\n&lt;/div&gt;\n\n&lt;!-- Italics --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;i&gt;2024-12-13&lt;/i&gt;\n&lt;/div&gt;\n</code></pre> <p>Info</p> <p>Since we used the <code>default</code> flag on <code>{% slot \"date\" %}</code> inside our calendar component, we can target the <code>date</code> component in multiple ways:</p> <ol> <li> <p>Explicitly by it's name     <pre><code>{% component \"calendar\" date=\"2024-12-13\" %}\n  {% fill \"date\" %}\n    &lt;i&gt; 2024-12-13 &lt;/i&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre></p> </li> <li> <p>Implicitly as the default slot (Omitting the     <code>{% fill %}</code> tag)     <pre><code>{% component \"calendar\" date=\"2024-12-13\" %}\n  &lt;i&gt; 2024-12-13 &lt;/i&gt;\n{% endcomponent %}\n</code></pre></p> </li> <li> <p>Explicitly as the default slot (Setting fill name to <code>default</code>)     <pre><code>{% component \"calendar\" date=\"2024-12-13\" %}\n  {% fill \"default\" %}\n    &lt;i&gt; 2024-12-13 &lt;/i&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre></p> </li> </ol>"},{"location":"getting_started/adding_slots/#5-wait-theres-a-bug","title":"5. Wait, there's a bug","text":"<p>There is a mistake in our code! <code>2024-12-13</code> is Friday, so that's fine. But if we updated the to <code>2024-12-14</code>, which is Saturday, our template from previous step would render this:</p> <pre><code>&lt;!-- Default --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;2024-12-16&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;!-- Bold --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;b&gt;2024-12-14&lt;/b&gt;\n&lt;/div&gt;\n\n&lt;!-- Italics --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;i&gt;2024-12-14&lt;/i&gt;\n&lt;/div&gt;\n</code></pre> <p>The first instance rendered <code>2024-12-16</code>, while the rest rendered <code>2024-12-14</code>!</p> <p>Why? Remember that in the <code>get_template_data()</code> method of our Calendar component, we pre-process the date. If the date falls on Saturday or Sunday, we shift it to next Monday:</p> [project root]/components/calendar/calendar.py<pre><code>from datetime import date\n\nfrom django_components import Component, register\n\n# If date is Sat or Sun, shift it to next Mon, so the date is always workweek.\ndef to_workweek_date(d: date):\n    ...\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    ...\n    def get_template_data(self, args, kwargs, slots, context):\n        workweek_date = to_workweek_date(kwargs[\"date\"])\n        return {\n            \"date\": workweek_date,\n            \"extra_class\": kwargs.get(\"extra_class\", \"text-blue\"),\n        }\n</code></pre> <p>And the issue is that in our template, we used the <code>date</code> value that we used as input, which is NOT the same as the <code>date</code> variable used inside Calendar's template.</p>"},{"location":"getting_started/adding_slots/#5-adding-data-to-slots","title":"5. Adding data to slots","text":"<p>We want to use the same <code>date</code> variable that's used inside Calendar's template.</p> <p>Luckily, django-components allows passing data to the slot, also known as Scoped slots.</p> <p>This consists of two steps:</p> <ol> <li>Pass the <code>date</code> variable to the <code>{% slot %}</code> tag</li> <li>Access the <code>date</code> variable in the <code>{% fill %}</code>    tag by using the special <code>data</code> kwarg</li> </ol> <p>Let's update the Calendar's template:</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is\n  {% slot \"date\" default date=date %}  {# &lt;--- changed #}\n    &lt;span&gt;{{ date }}&lt;/span&gt;\n  {% endslot %}\n&lt;/div&gt;\n</code></pre> <p>Info</p> <p>The <code>{% slot %}</code> tag has one special kwarg, <code>name</code>. When you write</p> <pre><code>{% slot \"date\" / %}\n</code></pre> <p>It's the same as:</p> <pre><code>{% slot name=\"date\" / %}\n</code></pre> <p>Other than the <code>name</code> kwarg, you can pass any extra kwargs to the <code>{% slot %}</code> tag, and these will be exposed as the slot's data.</p> <pre><code>{% slot name=\"date\" kwarg1=123 kwarg2=\"text\" kwarg3=my_var / %}\n</code></pre>"},{"location":"getting_started/adding_slots/#6-accessing-slot-data-in-fills","title":"6. Accessing slot data in fills","text":"<p>Now, on the <code>{% fill %}</code> tags, we can use the <code>data</code> kwarg to specify the variable under which the slot data will be available.</p> <p>The variable from the <code>data</code> kwarg contains all the extra kwargs passed to the <code>{% slot %}</code> tag.</p> <p>So if we set <code>data=\"slot_data\"</code>, then we can access the date variable under <code>slot_data.date</code>:</p> <pre><code>{# Default #}\n{% component \"calendar\" date=\"2024-12-13\" / %}\n\n{# Bold #}\n{% component \"calendar\" date=\"2024-12-13\" %}\n  {% fill \"date\" data=\"slot_data\" %}\n    &lt;b&gt; {{ slot_data.date }} &lt;/b&gt;\n  {% endfill %}\n{% endcomponent %}\n\n{# Italics #}\n{% component \"calendar\" date=\"2024-12-13\" %}\n  {% fill \"date\" data=\"slot_data\" %}\n    &lt;i&gt; {{ slot_data.date }} &lt;/i&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>By using the <code>date</code> variable from the slot, we'll render the correct date each time:</p> <pre><code>&lt;!-- Default --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;2024-12-16&lt;/span&gt;\n&lt;/div&gt;\n\n&lt;!-- Bold --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;b&gt;2024-12-16&lt;/b&gt;\n&lt;/div&gt;\n\n&lt;!-- Italics --&gt;\n&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;i&gt;2024-12-16&lt;/i&gt;\n&lt;/div&gt;\n</code></pre> <p>Info</p> <p>When to use slots vs variables?</p> <p>Generally, slots are more flexible - you can access the slot data, even the original slot content. Thus, slots behave more like functions that render content based on their context.</p> <p>On the other hand, variables are simpler - the variable you pass to a component is what will be used.</p> <p>Moreover, slots are treated as part of the template - for example the CSS scoping (work in progress) is applied to the slot content too.</p>"},{"location":"getting_started/components_in_templates/","title":"Components in templates","text":"<p>By the end of this section, we want to be able to use our components in Django templates like so:</p> <pre><code>{% load component_tags %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component \"calendar\" / %}\n  &lt;/body&gt;\n&lt;html&gt;\n</code></pre>"},{"location":"getting_started/components_in_templates/#1-register-component","title":"1. Register component","text":"<p>First, however, we need to register our component class with <code>ComponentRegistry</code>.</p> <p>To register a component with a <code>ComponentRegistry</code>, we will use the <code>@register</code> decorator, and give it a name under which the component will be accessible from within the template:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register  # &lt;--- new\n\n@register(\"calendar\")  # &lt;--- new\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>This will register the component to the default registry. Default registry is loaded into the template by calling <code>{% load component_tags %}</code> inside the template.</p> <p>Info</p> <p>Why do we have to register components?</p> <p>We want to use our component as a template tag (<code>{% ... %}</code>) in Django template.</p> <p>In Django, template tags are managed by the <code>Library</code> instances. Whenever you include <code>{% load xxx %}</code> in your template, you are loading a <code>Library</code> instance into your template.</p> <p><code>ComponentRegistry</code> acts like a router and connects the registered components with the associated <code>Library</code>.</p> <p>That way, when you include <code>{% load component_tags %}</code> in your template, you are able to \"call\" components like <code>{% component \"calendar\" / %}</code>.</p> <p><code>ComponentRegistries</code> also make it possible to group and share components as standalone packages. Learn more here.</p> <p>Note</p> <p>You can create custom <code>ComponentRegistry</code> instances, which will use different <code>Library</code> instances. In that case you will have to load different libraries depending on which components you want to use:</p> <p>Example 1 - Using component defined in the default registry <pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"calendar\" / %}\n&lt;/div&gt;\n</code></pre></p> <p>Example 2 - Using component defined in a custom registry <pre><code>{% load my_custom_tags %}\n&lt;div&gt;\n  {% my_component \"table\" / %}\n&lt;/div&gt;\n</code></pre></p> <p>Note that, because the tag name <code>component</code> is use by the default ComponentRegistry, the custom registry was configured to use the tag <code>my_component</code> instead. Read more here</p>"},{"location":"getting_started/components_in_templates/#2-load-and-use-the-component-in-template","title":"2. Load and use the component in template","text":"<p>The component is now registered under the name <code>calendar</code>. All that remains to do is to load and render the component inside a template:</p> <pre><code>{% load component_tags %}  {# Load the default registry #}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% component \"calendar\" / %}  {# Render the component #}\n  &lt;/body&gt;\n&lt;html&gt;\n</code></pre> <p>Info</p> <p>Component tags should end with <code>/</code> if they do not contain any Slot fills. But you can also use <code>{% endcomponent %}</code> instead:</p> <pre><code>{% component \"calendar\" %}{% endcomponent %}\n</code></pre> <p>We defined the Calendar's template as</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>and the variable <code>date</code> as <code>\"1970-01-01\"</code>.</p> <p>Thus, the final output will look something like this:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n    &lt;style&gt;\n      .calendar {\n        width: 200px;\n        background: pink;\n      }\n      .calendar span {\n        font-weight: bold;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"calendar\"&gt;\n      Today's date is &lt;span&gt;1970-01-01&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n      (function () {\n        document.querySelector(\".calendar\").onclick = () =&gt; {\n          alert(\"Clicked calendar!\");\n        };\n      })();\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;html&gt;\n</code></pre> <p>This makes it possible to organize your front-end around reusable components, instead of relying on template tags and keeping your CSS and Javascript in the static directory.</p> <p>Info</p> <p>Remember that you can use <code>{% component_js_dependencies %}</code> and <code>{% component_css_dependencies %}</code> to change where the <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags will be rendered (See JS and CSS output locations).</p> <p>Info</p> <p>How does django-components pick up registered components?</p> <p>Notice that it was enough to add <code>@register</code> to the component. We didn't need to import the component file anywhere to execute it.</p> <p>This is because django-components automatically imports all Python files found in the component directories during an event called Autodiscovery.</p> <p>So with Autodiscovery, it's the same as if you manually imported the component files on the <code>ready()</code> hook:</p> <pre><code>class MyApp(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"myapp\"\n\n    def ready(self):\n        import myapp.components.calendar\n        import myapp.components.table\n        ...\n</code></pre> <p>You can now render the components in templates!</p> <p>Currently our component always renders the same content. Let's parametrise it, so that our Calendar component is configurable from within the template \u27a1\ufe0f</p>"},{"location":"getting_started/parametrising_components/","title":"Parametrising components","text":"<p>So far, our Calendar component will always render the date <code>1970-01-01</code>. Let's make it more useful and flexible by being able to pass in custom date.</p> <p>What we want is to be able to use the Calendar component within the template like so:</p> <pre><code>{% component \"calendar\" date=\"2024-12-13\" extra_class=\"text-red\" / %}\n</code></pre>"},{"location":"getting_started/parametrising_components/#1-understading-component-inputs","title":"1. Understading component inputs","text":"<p>In section Create your first component, we defined the <code>get_template_data()</code> method that defines what variables will be available within the template:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    ...\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>What we didn't say is that <code>get_template_data()</code> actually receives the args and kwargs that were passed to a component.</p> <p>So if we call a component with a <code>date</code> and <code>extra_class</code> keywords:</p> <pre><code>{% component \"calendar\" date=\"2024-12-13\" extra_class=\"text-red\" / %}\n</code></pre> <p>This is the same as calling:</p> <pre><code>Calendar.get_template_data(\n    args=[],\n    kwargs={\"date\": \"2024-12-13\", \"extra_class\": \"text-red\"},\n)\n</code></pre> <p>And same applies to positional arguments, or mixing args and kwargs, where:</p> <pre><code>{% component \"calendar\" \"2024-12-13\" extra_class=\"text-red\" / %}\n</code></pre> <p>is same as</p> <pre><code>Calendar.get_template_data(\n    args=[\"2024-12-13\"],\n    kwargs={\"extra_class\": \"text-red\"},\n)\n</code></pre>"},{"location":"getting_started/parametrising_components/#2-define-inputs","title":"2. Define inputs","text":"<p>Let's put this to test. We want to pass <code>date</code> and <code>extra_class</code> kwargs to the component. And so, we can write the <code>get_template_data()</code> method such that it expects those parameters:</p> [project root]/components/calendar/calendar.py<pre><code>from datetime import date\n\nfrom django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    ...\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"],\n            \"extra_class\": kwargs.get(\"extra_class\", \"text-blue\"),\n        }\n</code></pre> <p>Since <code>extra_class</code> is optional in the function signature, it's optional also in the template. So both following calls are valid:</p> <pre><code>{% component \"calendar\" date=\"2024-12-13\" / %}\n{% component \"calendar\" date=\"2024-12-13\" extra_class=\"text-red\" / %}\n</code></pre> <p>Warning</p> <p><code>get_template_data()</code> differentiates between positional and keyword arguments, so you have to make sure to pass the arguments correctly.</p> <p>Since <code>date</code> is expected to be a keyword argument, it MUST be provided as such:</p> <pre><code>\u2705 `date` is kwarg\n{% component \"calendar\" date=\"2024-12-13\" / %}\n\n\u274c `date` is arg\n{% component \"calendar\" \"2024-12-13\" / %}\n</code></pre>"},{"location":"getting_started/parametrising_components/#3-process-inputs","title":"3. Process inputs","text":"<p>The <code>get_template_data()</code> method is powerful, because it allows us to decouple component inputs from the template variables. In other words, we can pre-process the component inputs, and massage them into a shape that's most appropriate for what the template needs. And it also allows us to pass in static data into the template.</p> <p>Imagine our component receives data from the database that looks like below (taken from Django).</p> <pre><code>cities = [\n    {\"name\": \"Mumbai\", \"population\": \"19,000,000\", \"country\": \"India\"},\n    {\"name\": \"Calcutta\", \"population\": \"15,000,000\", \"country\": \"India\"},\n    {\"name\": \"New York\", \"population\": \"20,000,000\", \"country\": \"USA\"},\n    {\"name\": \"Chicago\", \"population\": \"7,000,000\", \"country\": \"USA\"},\n    {\"name\": \"Tokyo\", \"population\": \"33,000,000\", \"country\": \"Japan\"},\n]\n</code></pre> <p>We need to group the list items by size into following buckets by population:</p> <ul> <li>0-10,000,000</li> <li>10,000,001-20,000,000</li> <li>20,000,001-30,000,000</li> <li>+30,000,001</li> </ul> <p>So we want to end up with following data:</p> <pre><code>cities_by_pop = [\n    {\n      \"name\": \"0-10,000,000\",\n      \"items\": [\n          {\"name\": \"Chicago\", \"population\": \"7,000,000\", \"country\": \"USA\"},\n      ]\n    },\n    {\n      \"name\": \"10,000,001-20,000,000\",\n      \"items\": [\n          {\"name\": \"Calcutta\", \"population\": \"15,000,000\", \"country\": \"India\"},\n          {\"name\": \"Mumbai\", \"population\": \"19,000,000\", \"country\": \"India\"},\n          {\"name\": \"New York\", \"population\": \"20,000,000\", \"country\": \"USA\"},\n      ]\n    },\n    {\n      \"name\": \"30,000,001-40,000,000\",\n      \"items\": [\n          {\"name\": \"Tokyo\", \"population\": \"33,000,000\", \"country\": \"Japan\"},\n      ]\n    },\n]\n</code></pre> <p>Without the <code>get_template_data()</code> method, we'd have to either:</p> <ol> <li>Pre-process the data in Python before passing it to the components.</li> <li>Define a Django filter or template tag to take the data and process it on the spot.</li> </ol> <p>Instead, with <code>get_template_data()</code>, we can keep this transformation private to this component, and keep the rest of the codebase clean.</p> <pre><code>def group_by_pop(data):\n    ...\n\n@register(\"population_table\")\nclass PopulationTable(Component):\n    template_file = \"population_table.html\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"data\": group_by_pop(kwargs[\"data\"]),\n        }\n</code></pre> <p>Similarly we can make use of <code>get_template_data()</code> to pre-process the date that was given to the component:</p> [project root]/components/calendar/calendar.py<pre><code>from datetime import date\n\nfrom django_components import Component, register\n\n# If date is Sat or Sun, shift it to next Mon, so the date is always workweek.\ndef to_workweek_date(d: date):\n    ...\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    ...\n    def get_template_data(self, args, kwargs, slots, context):\n        workweek_date = to_workweek_date(kwargs[\"date\"])  # &lt;--- new\n        return {\n            \"date\": workweek_date,  # &lt;--- changed\n            \"extra_class\": kwargs.get(\"extra_class\", \"text-blue\"),\n        }\n</code></pre>"},{"location":"getting_started/parametrising_components/#4-pass-inputs-to-components","title":"4. Pass inputs to components","text":"<p>Once we're happy with <code>Calendar.get_template_data()</code>, we can update our templates to use the parametrized version of the component:</p> <pre><code>&lt;div&gt;\n  {% component \"calendar\" date=\"2024-12-13\" / %}\n  {% component \"calendar\" date=\"1970-01-01\" / %}\n&lt;/div&gt;\n</code></pre> <p>Next, you will learn how to use slots give your components even more flexibility \u27a1\ufe0f</p>"},{"location":"getting_started/parametrising_components/#5-add-defaults","title":"5. Add defaults","text":"<p>In our example, we've set the <code>extra_class</code> to default to <code>\"text-blue\"</code> by setting it in the <code>get_template_data()</code> method.</p> <p>However, you may want to use the same default value in multiple methods, like <code>get_js_data()</code> or <code>get_css_data()</code>.</p> <p>To make things easier, Components can specify their defaults. Defaults are used when no value is provided, or when the value is set to <code>None</code> for a particular input.</p> <p>To define defaults for a component, you create a nested <code>Defaults</code> class within your <code>Component</code> class. Each attribute in the <code>Defaults</code> class represents a default value for a corresponding input.</p> <pre><code>from django_components import Component, Default, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n\n    class Defaults:  # &lt;--- new\n        extra_class = \"text-blue\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        workweek_date = to_workweek_date(kwargs[\"date\"])\n        return {\n            \"date\": workweek_date,\n            \"extra_class\": kwargs[\"extra_class\"],  # &lt;--- changed\n        }\n</code></pre>"},{"location":"getting_started/rendering_components/","title":"Rendering components","text":"<p>Our calendar component can accept and pre-process data, defines its own CSS and JS, and can be used in templates.</p> <p>...But how do we actually render the components into HTML?</p> <p>There's 3 ways to render a component:</p> <ul> <li>Render the template that contains the <code>{% component %}</code> tag</li> <li>Render the component directly with <code>Component.render()</code></li> <li>Render the component directly with <code>Component.render_to_response()</code></li> </ul> <p>As a reminder, this is what the calendar component looks like:</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre>"},{"location":"getting_started/rendering_components/#1-render-the-template","title":"1. Render the template","text":"<p>If you have embedded the component in a Django template using the <code>{% component %}</code> tag:</p> [project root]/templates/my_template.html<pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"calendar\" date=\"2024-12-13\" / %}\n&lt;/div&gt;\n</code></pre> <p>You can simply render the template with the Django tooling:</p>"},{"location":"getting_started/rendering_components/#with-djangoshortcutsrender","title":"With <code>django.shortcuts.render()</code>","text":"<pre><code>from django.shortcuts import render\n\ncontext = {\"date\": \"2024-12-13\"}\nrendered_template = render(request, \"my_template.html\", context)\n</code></pre>"},{"location":"getting_started/rendering_components/#with-templaterender","title":"With <code>Template.render()</code>","text":"<p>Either loading the template with <code>get_template()</code>:</p> <pre><code>from django.template.loader import get_template\n\ntemplate = get_template(\"my_template.html\")\ncontext = {\"date\": \"2024-12-13\"}\nrendered_template = template.render(context)\n</code></pre> <p>Or creating a new <code>Template</code> instance:</p> <pre><code>from django.template import Template\n\ntemplate = Template(\"\"\"\n{% load component_tags %}\n&lt;div&gt;\n  {% component \"calendar\" date=\"2024-12-13\" / %}\n&lt;/div&gt;\n\"\"\")\nrendered_template = template.render()\n</code></pre>"},{"location":"getting_started/rendering_components/#2-render-the-component","title":"2. Render the component","text":"<p>You can also render the component directly with <code>Component.render()</code>, without wrapping the component in a template.</p> <pre><code>from components.calendar import Calendar\n\ncalendar = Calendar\nrendered_component = calendar.render()\n</code></pre> <p>You can pass args, kwargs, slots, and more, to the component:</p> <pre><code>from components.calendar import Calendar\n\ncalendar = Calendar\nrendered_component = calendar.render(\n    args=[\"2024-12-13\"],\n    kwargs={\n        \"extra_class\": \"my-class\"\n    },\n    slots={\n        \"date\": \"&lt;b&gt;2024-12-13&lt;/b&gt;\"\n    },\n)\n</code></pre> <p>Info</p> <p>Among other, you can pass also the <code>request</code> object to the <code>render</code> method:</p> <pre><code>from components.calendar import Calendar\n\ncalendar = Calendar\nrendered_component = calendar.render(request=request)\n</code></pre> <p>The <code>request</code> object is required for some of the component's features, like using Django's context processors.</p>"},{"location":"getting_started/rendering_components/#3-render-the-component-to-httpresponse","title":"3. Render the component to HttpResponse","text":"<p>A common pattern in Django is to render the component and then return the resulting HTML as a response to an HTTP request.</p> <p>For this, you can use the <code>Component.render_to_response()</code> convenience method.</p> <p><code>render_to_response()</code> accepts the same args, kwargs, slots, and more, as <code>Component.render()</code>, but wraps the result in an <code>HttpResponse</code>.</p> <pre><code>from components.calendar import Calendar\n\ndef my_view(request):\n    response = Calendar.render_to_response(\n        args=[\"2024-12-13\"],\n        kwargs={\n            \"extra_class\": \"my-class\"\n        },\n        slots={\n            \"date\": \"&lt;b&gt;2024-12-13&lt;/b&gt;\"\n        },\n        request=request,\n    )\n    return response\n</code></pre> <p>Info</p> <p>Response class of <code>render_to_response</code></p> <p>While <code>render</code> method returns a plain string, <code>render_to_response</code> wraps the rendered content in a \"Response\" class. By default, this is <code>django.http.HttpResponse</code>.</p> <p>If you want to use a different Response class in <code>render_to_response</code>, set the <code>Component.response_class</code> attribute:</p> <pre><code>class MyCustomResponse(HttpResponse):\n    def __init__(self, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        # Configure response\n        self.headers = ...\n        self.status = ...\n\nclass SimpleComponent(Component):\n    response_class = MyCustomResponse\n</code></pre>"},{"location":"getting_started/rendering_components/#rendering-slots","title":"Rendering slots","text":"<p>Slots content are automatically escaped by default to prevent XSS attacks.</p> <p>In other words, it's as if you would be using Django's <code>mark_safe()</code> function on the slot content:</p> <pre><code>from django.utils.safestring import mark_safe\n\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {% slot \"date\" default date=date / %}\n        &lt;/div&gt;\n    \"\"\"\n\nCalendar.render(\n    slots={\n        \"date\": mark_safe(\"&lt;b&gt;Hello&lt;/b&gt;\"),\n    }\n)\n</code></pre> <p>To disable escaping, you can pass <code>escape_slots_content=False</code> to <code>Component.render()</code> or <code>Component.render_to_response()</code> methods.</p> <p>Warning</p> <p>If you disable escaping, you should make sure that any content you pass to the slots is safe, especially if it comes from user input!</p> <p>Info</p> <p>If you're planning on passing an HTML string, check Django's use of <code>format_html</code> and <code>mark_safe</code>.</p>"},{"location":"getting_started/rendering_components/#component-views-and-urls","title":"Component views and URLs","text":"<p>For web applications, it's common to define endpoints that serve HTML content (AKA views).</p> <p>If this is your case, you can define the view request handlers directly on your component by using the nested<code>Component.View</code> class.</p> <p>This is a great place for:</p> <ul> <li> <p>Endpoints that render whole pages, if your component   is a page component.</p> </li> <li> <p>Endpoints that render the component as HTML fragments, to be used with HTMX or similar libraries.</p> </li> </ul> <p>Read more on Component views and URLs.</p> [project root]/components/calendar.py<pre><code>from django_components import Component, ComponentView, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            &lt;div class=\"header\"&gt;\n                {% slot \"header\" / %}\n            &lt;/div&gt;\n            &lt;div class=\"body\"&gt;\n                Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    class View:\n        # Handle GET requests\n        def get(self, request, *args, **kwargs):\n            # Return HttpResponse with the rendered content\n            return Calendar.render_to_response(\n                request=request,\n                kwargs={\n                    \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n                },\n                slots={\n                    \"header\": \"Calendar header\",\n                },\n            )\n</code></pre> <p>Info</p> <p>The View class supports all the same HTTP methods as Django's <code>View</code> class. These are:</p> <p><code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code>, <code>head()</code>, <code>options()</code>, <code>trace()</code></p> <p>Each of these receive the <code>HttpRequest</code> object as the first argument.</p> <p>Next, you need to set the URL for the component.</p> <p>You can either:</p> <ol> <li> <p>Automatically assign the URL by setting the <code>Component.View.public</code> attribute to <code>True</code>.</p> <p>In this case, use <code>get_component_url()</code> to get the URL for the component view.</p> <pre><code>from django_components import Component, get_component_url\n\nclass Calendar(Component):\n    class View:\n        public = True\n\nurl = get_component_url(Calendar)\n</code></pre> </li> <li> <p>Manually assign the URL by setting <code>Component.as_view()</code> to your <code>urlpatterns</code>:</p> <pre><code>from django.urls import path\nfrom components.calendar import Calendar\n\nurlpatterns = [\n    path(\"calendar/\", Calendar.as_view()),\n]\n</code></pre> </li> </ol> <p>And with that, you're all set! When you visit the URL, the component will be rendered and the content will be returned.</p> <p>The <code>get()</code>, <code>post()</code>, etc methods will receive the <code>HttpRequest</code> object as the first argument. So you can parametrize how the component is rendered for example by passing extra query parameters to the URL:</p> <pre><code>http://localhost:8000/calendar/?date=2024-12-13\n</code></pre>"},{"location":"getting_started/your_first_component/","title":"Create your first component","text":"<p>A component in django-components can be as simple as a Django template and Python code to declare the component:</p> calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n</code></pre> <p>Or a combination of Django template, Python, CSS, and Javascript:</p> calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> calendar.css<pre><code>.calendar {\n  width: 200px;\n  background: pink;\n}\n</code></pre> calendar.js<pre><code>document.querySelector(\".calendar\").onclick = function () {\n  alert(\"Clicked calendar!\");\n};\n</code></pre> calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n</code></pre> <p>Alternatively, you can \"inline\" HTML, JS, and CSS right into the component class:</p> <pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template = \"\"\"\n      &lt;div class=\"calendar\"&gt;\n        Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n      &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n      .calendar {\n        width: 200px;\n        background: pink;\n      }\n    \"\"\"\n\n    js = \"\"\"\n      document.querySelector(\".calendar\").onclick = function () {\n        alert(\"Clicked calendar!\");\n      };\n    \"\"\"\n</code></pre> <p>Note</p> <p>If you \"inline\" the HTML, JS and CSS code into the Python class, you can set up syntax highlighting for better experience. However, autocompletion / intellisense does not work with syntax highlighting.</p> <p>We'll start by creating a component that defines only a Django template:</p>"},{"location":"getting_started/your_first_component/#1-create-project-structure","title":"1. Create project structure","text":"<p>Start by creating empty <code>calendar.py</code> and <code>calendar.html</code> files:</p> <pre><code>sampleproject/\n\u251c\u2500\u2500 calendarapp/\n\u251c\u2500\u2500 components/             \ud83c\udd95\n\u2502   \u2514\u2500\u2500 calendar/           \ud83c\udd95\n\u2502       \u251c\u2500\u2500 calendar.py     \ud83c\udd95\n\u2502       \u2514\u2500\u2500 calendar.html   \ud83c\udd95\n\u251c\u2500\u2500 sampleproject/\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"getting_started/your_first_component/#2-write-django-template","title":"2. Write Django template","text":"<p>Inside <code>calendar.html</code>, write:</p> [project root]/components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>In this example we've defined one template variable <code>date</code>. You can use any and as many variables as you like. These variables will be defined in the Python file in <code>get_template_data()</code> when creating an instance of this component.</p> <p>Note</p> <p>The template will be rendered with whatever template backend you've specified in your Django settings file.</p> <p>Currently django-components supports only the default <code>\"django.template.backends.django.DjangoTemplates\"</code> template backend!</p>"},{"location":"getting_started/your_first_component/#3-create-new-component-in-python","title":"3. Create new Component in Python","text":"<p>In <code>calendar.py</code>, create a subclass of Component to create a new component.</p> <p>To link the HTML template with our component, set <code>template_file</code> to the name of the HTML file.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n</code></pre> <p>Note</p> <p>The path to the template file can be either:</p> <ol> <li>Relative to the component's python file (as seen above),</li> <li>Relative to any of the component directories as defined by <code>COMPONENTS.dirs</code> and/or <code>COMPONENTS.app_dirs</code> (e.g. <code>[your apps]/components</code> dir and <code>[project root]/components</code>)</li> </ol>"},{"location":"getting_started/your_first_component/#4-define-the-template-variables","title":"4. Define the template variables","text":"<p>In <code>calendar.html</code>, we've used the variable <code>date</code>. So we need to define it for the template to work.</p> <p>This is done using <code>Component.get_template_data()</code>. It's a function that returns a dictionary. The entries in this dictionary will become available within the template as variables, e.g. as <code>{{ date }}</code>.</p> [project root]/components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": \"1970-01-01\",\n        }\n</code></pre> <p>Now, when we render the component with <code>Component.render()</code> method:</p> <pre><code>Calendar.render()\n</code></pre> <p>It will output</p> <pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;1970-01-01&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>And voil\u00e1!! We've created our first component.</p> <p>Next, let's add JS and CSS to this component \u27a1\ufe0f.</p>"},{"location":"guides/devguides/dependency_mgmt/","title":"JS and CSS rendering","text":"<p>Aim of this doc is to share the intuition on how we manage the JS and CSS (\"dependencies\") associated with components, and how we render them.</p>"},{"location":"guides/devguides/dependency_mgmt/#starting-conditions","title":"Starting conditions","text":"<ol> <li> <p>First of all, when we consider a component, it has two kind of dependencies - the \"inlined\" JS and CSS, and additional linked JS and CSS via <code>Media.js/css</code>:</p> <pre><code>from django_components import Component, types\n\nclass MyTable(Component):\n    # Inlined JS\n    js: types.js = \"\"\"\n      console.log(123);\n    \"\"\"\n\n    # Inlined CSS\n    css: types.css = \"\"\"\n      .my-table {\n        color: red;\n      }\n    \"\"\"\n\n    # Linked JS / CSS\n    class Media:\n        js = [\n            \"script-one.js\",  # STATIC file relative to component file\n            \"/script-two.js\", # URL path\n            \"https://example.com/script-three.js\", # URL\n        ]\n\n        css = [\n            \"style-one.css\",  # STATIC file relative to component file\n            \"/style-two.css\", # URL path\n            \"https://example.com/style-three.css\", # URL\n        ]\n</code></pre> </li> <li> <p>Second thing to keep in mind is that all component's are eventually rendered into a string. And so, if we want to associate extra info with a rendered component, it has to be serialized to a string.</p> <p>This is because a component may be embedded in a Django Template with the <code>{% component %}</code> tag, which, when rendered, is turned into a string:</p> <pre><code>template = Template(\"\"\"\n  {% load component_tags %}\n  &lt;div&gt;\n    {% component \"my_table\" / %}\n  &lt;/div&gt;\n\"\"\")\n\nhtml_str = template.render(Context({}))\n</code></pre> <p>And for this reason, we take the same approach also when we render a component with <code>Component.render()</code> - It returns a string.</p> </li> <li> <p>Thirdly, we also want to add support for JS / CSS variables. That is, that a variable defined on the component would be somehow accessible from within the JS script / CSS style.</p> <p>A simple approach to this would be to modify the inlined JS / CSS directly, and insert them for each component. But if you had extremely large JS / CSS, and e.g. only a single JS / CSS variable that you want to insert, it would be wasteful to create a copy of the JS / CSS scripts for each component instance.</p> <p>So instead, a preferred approach here is to defined and insert the inlined JS / CSS only once, and have some kind of mechanism on how we make correct the JS / CSS variables available only to the correct components.</p> </li> <li> <p>Last important thing is that we want the JS / CSS dependencies to work also with HTML fragments.</p> <p>So normally, e.g. when a user hits URL of a web page, the server renders full HTML document, with <code>&lt;!doctype&gt;</code>, <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code>. In such case, we know about ALL JS and CSS dependencies at render time, so we can e.g. insert them into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> ourselves.</p> <p>However this renders only the initial state. HTML fragments is a common pattern where interactivity is added to the web page by fetching and replacing bits of HTML on the main HTML document after some user action.</p> <p>In the case of HTML fragments, the HTML is NOT a proper document, but only the HTML that will be inserted somewhere into the DOM.</p> <p>The challenge here is that Django template for the HTML fragment MAY contain components, and these components MAY have inlined or linked JS and CSS.</p> <pre><code>def fragment_view(request):\n    template = Template(\"\"\"\n      {% load component_tags %}\n      &lt;div&gt;\n        {% component \"my_table\" / %}\n      &lt;/div&gt;\n    \"\"\")\n\n    fragment_str = template.render(Context({}))\n    return HttpResponse(fragment_str, status=200)\n</code></pre> <p>User may use different libraries to fetch and insert the HTML fragments (e.g. HTMX, AlpineJS, ...). From our perspective, the only thing that we can reliably say is that we expect that the HTML fragment WILL be eventually inserted into the DOM.</p> <p>So to include the corresponding JS and CSS, a simple approach could be to append them to the HTML as <code>&lt;style&gt;</code> and <code>&lt;script&gt;</code>, e.g.:</p> <pre><code>&lt;!-- Original content --&gt;\n&lt;div&gt;...&lt;/div&gt;\n&lt;!-- Associated CSS files --&gt;\n&lt;link href=\"http://...\" /&gt;\n&lt;style&gt;\n  .my-class {\n    color: red;\n  }\n&lt;/style&gt;\n&lt;!-- Associated JS files --&gt;\n&lt;script src=\"http://...\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  console.log(123);\n&lt;/script&gt;\n</code></pre> <p>But this has a number of issues:</p> <ul> <li>The JS scripts would run for each instance of the component.</li> <li>Bloating of the HTML file, as each inlined JS or CSS would be included fully for each component.</li> <li>While this sound OK, this could really bloat the HTML files if we used a UI component library for the basic building blocks like buttons, lists, cards, etc.</li> </ul> </li> </ol>"},{"location":"guides/devguides/dependency_mgmt/#flow","title":"Flow","text":"<p>So the solution should address all the points above. To achieve that, we manage the JS / CSS dependencies ourselves in the browser. So when a full HTML document is loaded, we keep track of which JS and CSS have been loaded. And when an HTML fragment is inserted, we check which JS / CSS dependencies it has, and load only those that have NOT been loaded yet.</p> <p>This is how we achieve that:</p> <ol> <li> <p>When a component is rendered, it inserts an HTML comment containing metadata about the rendered component.</p> <p>So a template like this</p> <pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"my_table\" / %}\n&lt;/div&gt;\n{% component \"button\" %}\n  Click me!\n{% endcomponent %}\n</code></pre> <p>May actually render:</p> <pre><code>&lt;div&gt;\n  &lt;!-- _RENDERED \"my_table_10bc2c,c020ad\" --&gt;\n  &lt;table&gt;\n    ...\n  &lt;/table&gt;\n&lt;/div&gt;\n&lt;!-- _RENDERED \"button_309dcf,31c0da\" --&gt;\n&lt;button&gt;Click me!&lt;/button&gt;\n</code></pre> <p>Each <code>&lt;!-- _RENDERED --&gt;</code> comment includes comma-separated data - a unique hash for the component class, e.g. <code>my_table_10bc2c</code>, and the component ID, e.g. <code>c020ad</code>.</p> <p>This way, we or the user can freely pass the rendered around or transform it, treating it as a string to add / remove / replace bits. As long as the <code>&lt;!-- _RENDERED --&gt;</code> comments remain in the rendered string, we will be able to deduce which JS and CSS dependencies the component needs.</p> </li> <li> <p>Post-process the rendered HTML, extracting the <code>&lt;!-- _RENDERED --&gt;</code> comments, and instead inserting the corresponding JS and CSS dependencies.</p> <p>If we dealt only with JS, then we could get away with processing the <code>&lt;!-- _RENDERED --&gt;</code> comments on the client (browser). However, the CSS needs to be processed still on the server, so the browser receives CSS styles already inserted as <code>&lt;style&gt;</code> or <code>&lt;link&gt;</code> HTML tags. Because if we do not do that, we get a flash of unstyled content, as there will be a delay between when the HTML page loaded and when the CSS was fetched and loaded.</p> <p>So, assuming that a user has already rendered their template, which still contains <code>&lt;!-- _RENDERED --&gt;</code> comments, we need to extract and process these comments.</p> <p>There's multiple ways to achieve this:</p> <ul> <li> <p>The approach recommended to the users is to use the <code>ComponentDependencyMiddleware</code> middleware, which scans all outgoing HTML, and post-processes the <code>&lt;!-- _RENDERED --&gt;</code> comments.</p> </li> <li> <p>If users are using <code>Component.render()</code> or <code>Component.render_to_response()</code>, these post-process the <code>&lt;!-- _RENDERED --&gt;</code> comments by default.</p> </li> <li> <p>NOTE: Users are able to opt out of the post-processing by setting <code>render_dependencies=False</code>.</p> </li> <li> <p>For advanced use cases, users may use <code>render_dependencies()</code> directly. This is the function that both <code>ComponentDependencyMiddleware</code> and <code>Component.render()</code> call internally.</p> </li> </ul> <p><code>render_dependencies()</code>, whether called directly, via middleware or other way, does the following:</p> <ol> <li> <p>Find all <code>&lt;!-- _RENDERED --&gt;</code> comments, and for each comment:</p> </li> <li> <p>Look up the corresponding component class.</p> </li> <li> <p>Get the component's inlined JS / CSS from <code>Component.js/css</code>, and linked JS / CSS from <code>Component.Media.js/css</code>.</p> </li> <li> <p>Generate JS script that loads the JS / CSS dependencies.</p> </li> <li> <p>Insert the JS scripts either at the end of <code>&lt;body&gt;</code>, or in place of <code>{% component_dependencies %}</code> / <code>{% component_js_dependencies %}</code> tags.</p> </li> <li> <p>To avoid the flash of unstyled content, we need place the styles into the HTML instead of dynamically loading them from within a JS script. The CSS is placed either at the end of <code>&lt;head&gt;</code>, or in place of <code>{% component_dependencies %}</code> / <code>{% component_css_dependencies %}</code></p> </li> <li> <p>We cache the component's inlined JS and CSS, so they can be fetched via an URL, so the inlined JS / CSS an be treated the same way as the JS / CSS dependencies set in <code>Component.Media.js/css</code>.</p> <ul> <li>NOTE: While this is currently not entirely necessary, it opens up the doors for allowing plugins to post-process the inlined JS and CSS. Because after it has been post-processed, we need to store it somewhere.</li> </ul> </li> </ol> </li> <li> <p>Server returns the post-processed HTML.</p> </li> <li> <p>In the browser, the generated JS script from step 2.4 is executed. It goes through all JS and CSS dependencies it was given. If some JS / CSS was already loaded, it is NOT fetched again. Otherwise it generates the corresponding <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> HTML tags to load the JS / CSS dependencies.</p> <p>In the browser, the \"dependency manager JS\" may look like this:</p> <pre><code>// Load JS or CSS script if not loaded already\nComponents.loadJs('&lt;script src=\"/abc/xyz/script.js\"&gt;');\nComponents.loadCss('&lt;link href=\"/abc/xyz/style.css\"&gt;');\n\n// Or mark one as already-loaded, so it is ignored when\n// we call `loadJs`\nComponents.markScriptLoaded(\"js\", \"/abc/def\");\n</code></pre> <p>Note that <code>loadJs() / loadCss()</code> receive whole <code>&lt;script&gt; / &lt;link&gt;</code> tags, not just the URL. This is because when Django's <code>Media</code> class renders JS and CSS, it formats it as <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags. And we allow users to modify how the JS and CSS should be rendered into the <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags.</p> <p>So, if users decided to add an extra attribute to their <code>&lt;script&gt;</code> tags, e.g. <code>&lt;script defer src=\"http://...\"&gt;&lt;/script&gt;</code>, then this way we make sure that the <code>defer</code> attribute will be present on the <code>&lt;script&gt;</code> tag when it is inserted into the DOM at the time of loading the JS script.</p> </li> <li> <p>To be able to fetch component's inlined JS and CSS, django-components adds a URL path under:</p> <p><code>/components/cache/&lt;str:comp_cls_id&gt;.&lt;str:script_type&gt;/</code></p> <p>E.g. <code>/components/cache/MyTable_10bc2c.js/</code></p> <p>This endpoint takes the component's unique ID, e.g. <code>MyTable_10bc2c</code>, and looks up the component's inlined JS or CSS.</p> </li> </ol> <p>Thus, with this approach, we ensure that:</p> <ol> <li>All JS / CSS dependencies are loaded / executed only once.</li> <li>The approach is compatible with HTML fragments</li> <li>The approach is compatible with JS / CSS variables.</li> <li>Inlined JS / CSS may be post-processed by plugins</li> </ol>"},{"location":"guides/devguides/slot_rendering/","title":"Slot rendering","text":"<p>This doc serves as a primer on how component slots and fills are resolved.</p>"},{"location":"guides/devguides/slot_rendering/#flow","title":"Flow","text":"<ol> <li> <p>Imagine you have a template. Some kind of text, maybe HTML:    <pre><code>| ------\n| ---------\n| ----\n| -------\n</code></pre></p> </li> <li> <p>The template may contain some vars, tags, etc    <pre><code>| -- {{ my_var }} --\n| ---------\n| ----\n| -------\n</code></pre></p> </li> <li> <p>The template also contains some slots, etc    <pre><code>| -- {{ my_var }} --\n| ---------\n| -- {% slot \"myslot\" %} ---\n| -- {% endslot %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>Slots may be nested    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %} ---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- JKL {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>Some slots may be inside fills for other components    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %}---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ------\n| -- {% component \"mycomp\" %} ---\n| ---- {% slot \"myslot\" %} ---\n| ------- JKL {{ my_var }}\n| ------- {% slot \"myslot_inner\" %}\n| ---------- MNO {{ my_var }}\n| ------- {% endslot %}\n| ---- {% endslot %} ---\n| -- {% endcomponent %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- PQR {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>The names of the slots and fills may be defined using variables    <pre><code>| -- {% slot slot_name %} ---\n| ---- STU {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>The slot and fill names may be defined using for loops or other variables defined within the template (e.g. <code>{% with %}</code> tag or <code>{% ... as var %}</code> syntax)    <pre><code>| -- {% for slot_name in slots %} ---\n| ---- {% slot slot_name %} ---\n| ------ STU {{ slot_name }}\n| ---- {% endslot %} ---\n| -- {% endfor %} ---\n| -------\n</code></pre></p> </li> <li> <p>Variables for names and for loops allow us implement \"passthrough slots\" - that is, taking all slots that our component received, and passing them to a child component, dynamically.    <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- {% for slot_name in slots %} ---\n| ------ {% fill slot_name %} ---\n| -------- {% slot slot_name %} ---\n| ---------- XYZ {{ slot_name }}\n| --------- {% endslot %}\n| ------- {% endfill %}\n| ---- {% endfor %} ---\n| -- {% endcomponent %} ---\n| ----\n</code></pre></p> </li> <li> <p>Putting that all together, a document may look like this:    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %}---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ------\n| -- {% component \"mycomp\" %} ---\n| ---- {% slot \"myslot\" %} ---\n| ------- JKL {{ my_var }}\n| ------- {% slot \"myslot_inner\" %}\n| ---------- MNO {{ my_var }}\n| ------- {% endslot %}\n| ---- {% endslot %} ---\n| -- {% endcomponent %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- PQR {{ my_var }}\n| -- {% endslot %} ---\n| -------\n| -- {% for slot_name in slots %} ---\n| ---- {% component \"mycomp\" %} ---\n| ------- {% slot slot_name %}\n| ---------- STU {{ slot_name }}\n| ------- {% endslot %}\n| ---- {% endcomponent %} ---\n| -- {% endfor %} ---\n| ----\n| -- {% component \"mycomp\" %} ---\n| ---- {% for slot_name in slots %} ---\n| ------ {% fill slot_name %} ---\n| -------- {% slot slot_name %} ---\n| ---------- XYZ {{ slot_name }}\n| --------- {% endslot %}\n| ------- {% endfill %}\n| ---- {% endfor %} ---\n| -- {% endcomponent %} ---\n| -------\n</code></pre></p> </li> <li> <p>Given the above, we want to render the slots with <code>{% fill %}</code> tag that were defined OUTSIDE of this template. How do I do that?</p> <p>NOTE: Before v0.110, slots were resolved statically, by walking down the Django Template and Nodes. However, this did not allow for using for loops or other variables defined in the template.</p> <p>Currently, this consists of 2 steps:</p> <ol> <li> <p>If a component is rendered within a template using <code>{% component %}</code> tag, determine the given <code>{% fill %}</code> tags in the component's body (the content in between <code>{% component %}</code> and <code>{% endcomponent %}</code>).</p> <p>After this step, we know about all the fills that were passed to the component.</p> </li> <li> <p>Then we simply render the template as usual. And then we reach the <code>{% slot %}</code> tag, we search the context for the available fills.</p> <ul> <li>If there IS a fill with the same name as the slot, we render the fill.</li> <li>If the slot is marked <code>default</code>, and there is a fill named <code>default</code>, then we render that.</li> <li>Otherwise, we render the slot's default content.</li> </ul> </li> </ol> </li> <li> <p>Obtaining the fills from <code>{% fill %}</code>.</p> <p>When a component is rendered with <code>{% component %}</code> tag, and it has some content in between <code>{% component %}</code> and <code>{% endcomponent %}</code>, we want to figure out if that content is a default slot (no <code>{% fill %}</code> used), or if there is a collection of named <code>{% fill %}</code> tags:</p> <p>Default slot:</p> <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- STU {{ slot_name }}\n| -- {% endcomponent %} ---\n</code></pre> <p>Named slots:</p> <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- {% fill \"slot_a\" %}\n| ------ STU\n| ---- {% endslot %}\n| ---- {% fill \"slot_b\" %}\n| ------ XYZ\n| ---- {% endslot %}\n| -- {% endcomponent %} ---\n</code></pre> <p>To respect any forloops or other variables defined within the template to which the fills may have access, we:</p> <ol> <li>Render the content between <code>{% component %}</code> and <code>{% endcomponent %}</code> using the context    outside of the component.</li> <li>When we reach a <code>{% fill %}</code> tag, we capture any variables that were created between    the <code>{% component %}</code> and <code>{% fill %}</code> tags.</li> <li>When we reach <code>{% fill %}</code> tag, we do not continue rendering deeper. Instead we    make a record that we found the fill tag with given name, kwargs, etc.</li> <li>After the rendering is done, we check if we've encountered any fills.    If yes, we expect only named fills. If no, we assume that the the component's body    is a default slot.</li> <li>Lastly we process the found fills, and make them available to the context, so any    slots inside the component may access these fills.</li> </ol> </li> <li> <p>Rendering slots</p> <p>Slot rendering works similarly to collecting fills, in a sense that we do not search for the slots ahead of the time, but instead let Django handle the rendering of the template, and we step in only when Django come across as <code>{% slot %}</code> tag.</p> <p>When we reach a slot tag, we search the context for the available fills.</p> <ul> <li>If there IS a fill with the same name as the slot, we render the fill.</li> <li>If the slot is marked <code>default</code>, and there is a fill named <code>default</code>, then we render that.</li> <li>Otherwise, we render the slot's default content.</li> </ul> </li> </ol>"},{"location":"guides/devguides/slot_rendering/#using-the-correct-context-in-slotfill-tags","title":"Using the correct context in {% slot/fill %} tags","text":"<p>In previous section, we said that the <code>{% fill %}</code> tags should be already rendered by the time they are inserted into the <code>{% slot %}</code> tags.</p> <p>This is not quite true. To help you understand, consider this complex case:</p> <pre><code>| -- {% for var in [1, 2, 3] %} ---\n| ---- {% component \"mycomp2\" %} ---\n| ------ {% fill \"first\" %}\n| ------- STU {{ my_var }}\n| -------     {{ var }}\n| ------ {% endfill %}\n| ------ {% fill \"second\" %}\n| -------- {% component var=var my_var=my_var %}\n| ---------- VWX {{ my_var }}\n| -------- {% endcomponent %}\n| ------ {% endfill %}\n| ---- {% endcomponent %} ---\n| -- {% endfor %} ---\n| -------\n</code></pre> <p>We want the forloop variables to be available inside the <code>{% fill %}</code> tags. Because of that, however, we CANNOT render the fills/slots in advance.</p> <p>Instead, our solution is closer to how Vue handles slots. In Vue, slots are effectively functions that accept a context variables and render some content.</p> <p>While we do not wrap the logic in a function, we do PREPARE IN ADVANCE: 1. The content that should be rendered for each slot 2. The context variables from <code>get_template_data()</code></p> <p>Thus, once we reach the <code>{% slot %}</code> node, in it's <code>render()</code> method, we access the data above, and, depending on the <code>context_behavior</code> setting, include the current context or not. For more info, see <code>SlotNode.render()</code>.</p>"},{"location":"guides/devguides/slots_and_blocks/","title":"Using slot and block tags","text":"<ol> <li> <p>First let's clarify how <code>include</code> and <code>extends</code> tags work inside components.</p> <p>When component template includes <code>include</code> or <code>extends</code> tags, it's as if the \"included\" template was inlined. So if the \"included\" template contains <code>slot</code> tags, then the component uses those slots.</p> <p>If you have a template <code>abc.html</code>: <pre><code>&lt;div&gt;\n  hello\n  {% slot \"body\" %}{% endslot %}\n&lt;/div&gt;\n</code></pre></p> <p>And components that make use of <code>abc.html</code> via <code>include</code> or <code>extends</code>: <pre><code>from django_components import Component, register\n\n@register(\"my_comp_extends\")\nclass MyCompWithExtends(Component):\n    template = \"\"\"{% extends \"abc.html\" %}\"\"\"\n\n@register(\"my_comp_include\")\nclass MyCompWithInclude(Component):\n    template = \"\"\"{% include \"abc.html\" %}\"\"\"\n</code></pre></p> <p>Then you can set slot fill for the slot imported via <code>include/extends</code>:</p> <pre><code>{% component \"my_comp_extends\" %}\n    {% fill \"body\" %}\n        123\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>And it will render: <pre><code>&lt;div&gt;\n  hello\n  123\n&lt;/div&gt;\n</code></pre></p> </li> <li> <p>Slot and block</p> <p>If you have a template <code>abc.html</code> like so:</p> <pre><code>&lt;div&gt;\n  hello\n  {% block inner %}\n    1\n    {% slot \"body\" %}\n      2\n    {% endslot %}\n  {% endblock %}\n&lt;/div&gt;\n</code></pre> <p>and component <code>my_comp</code>:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template_file = \"abc.html\"\n</code></pre> <p>Then:</p> <ol> <li> <p>Since the <code>block</code> wasn't overriden, you can use the <code>body</code> slot:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"body\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>And we get:</p> <pre><code>&lt;div&gt;hello 1 XYZ&lt;/div&gt;\n</code></pre> </li> <li> <p><code>blocks</code> CANNOT be overriden through the <code>component</code> tag, so something like this:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"body\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n{% block \"inner\" %}\n    456\n{% endblock %}\n</code></pre> <p>Will still render the component content just the same:</p> <pre><code>&lt;div&gt;hello 1 XYZ&lt;/div&gt;\n</code></pre> </li> <li> <p>You CAN override the <code>block</code> tags of <code>abc.html</code> if the component template     uses <code>extends</code>. In that case, just as you would expect, the <code>block inner</code> inside     <code>abc.html</code> will render <code>OVERRIDEN</code>:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        {% extends \"abc.html\" %}\n        {% block inner %}\n          OVERRIDEN\n        {% endblock %}\n    \"\"\"\n</code></pre> </li> <li> <p>This is where it gets interesting (but still intuitive). You can insert even     new <code>slots</code> inside these \"overriding\" blocks:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n      {% extends \"abc.html\" %}\n\n      {% load component_tags %}\n      {% block \"inner\" %}\n        OVERRIDEN\n        {% slot \"new_slot\" %}\n          hello\n        {% endslot %}\n      {% endblock %}\n    \"\"\"\n</code></pre> <p>And you can then pass fill for this <code>new_slot</code> when rendering the component:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"new_slot\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>NOTE: Currently you can supply fills for both <code>new_slot</code> and <code>body</code> slots, and you will not get an error for an invalid/unknown slot name. But since <code>body</code> slot is not rendered, it just won't do anything. So this renders the same as above:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"new_slot\" %}\n        XYZ\n    {% endfill %}\n    {% fill \"body\" %}\n        www\n    {% endfill %}\n{% endcomponent %}\n</code></pre> </li> </ol> </li> </ol>"},{"location":"guides/other/troubleshooting/","title":"Troubleshooting","text":"<p>As larger projects get more complex, it can be hard to debug issues. Django Components provides a number of tools and approaches that can help you with that.</p>"},{"location":"guides/other/troubleshooting/#component-and-slot-highlighting","title":"Component and slot highlighting","text":"<p>Django Components provides a visual debugging feature that helps you understand the structure and boundaries of your components and slots. When enabled, it adds a colored border and a label around each component and slot on your rendered page.</p> <p>To enable component and slot highlighting, set <code>debug_highlight_components</code> and/or <code>debug_highlight_slots</code> to <code>True</code> in your <code>settings.py</code> file:</p> <pre><code>from django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    debug_highlight_components=True,\n    debug_highlight_slots=True,\n)\n</code></pre> <p>Components will be highlighted with a blue border and label:</p> <p></p> <p>While the slots will be highlighted with a red border and label:</p> <p></p> <p>Warning</p> <p>Use this feature ONLY in during development. Do NOT use it in production.</p>"},{"location":"guides/other/troubleshooting/#component-path-in-errors","title":"Component path in errors","text":"<p>When an error occurs, the error message will show the path to the component that caused the error. E.g.</p> <pre><code>KeyError: \"An error occured while rendering components MyPage &gt; MyLayout &gt; MyComponent &gt; Childomponent(slot:content)\n</code></pre> <p>The error message contains also the slot paths, so if you have a template like this:</p> <pre><code>{% component \"my_page\" %}\n    {% slot \"content\" %}\n        {% component \"table\" %}\n            {% slot \"header\" %}\n                {% component \"table_header\" %}\n                    ...  {# ERROR HERE #}\n                {% endcomponent %}\n            {% endslot %}\n        {% endcomponent %}\n    {% endslot %}\n{% endcomponent %}\n</code></pre> <p>Then the error message will show the path to the component that caused the error:</p> <pre><code>KeyError: \"An error occured while rendering components my_page &gt; layout &gt; layout(slot:content) &gt; my_page(slot:content) &gt; table &gt; table(slot:header) &gt; table_header &gt; table_header(slot:content)\n</code></pre>"},{"location":"guides/other/troubleshooting/#debug-and-trace-logging","title":"Debug and trace logging","text":"<p>Django components supports logging with Django.</p> <p>To configure logging for Django components, set the <code>django_components</code> logger in <code>LOGGING</code> in <code>settings.py</code> (below).</p> <p>Also see the <code>settings.py</code> file in sampleproject for a real-life example.</p> <pre><code>import logging\nimport sys\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    \"handlers\": {\n        \"console\": {\n            'class': 'logging.StreamHandler',\n            'stream': sys.stdout,\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": logging.DEBUG,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre> <p>Info</p> <p>To set TRACE level, set <code>\"level\"</code> to <code>5</code>:</p> <pre><code>LOGGING = {\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": 5,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre>"},{"location":"guides/other/troubleshooting/#logger-levels","title":"Logger levels","text":"<p>As of v0.126, django-components primarily uses these logger levels:</p> <ul> <li><code>DEBUG</code>: Report on loading associated HTML / JS / CSS files, autodiscovery, etc.</li> <li><code>TRACE</code>: Detailed interaction of components and slots. Logs when template tags,   components, and slots are started / ended rendering, and when a slot is filled.</li> </ul>"},{"location":"guides/other/troubleshooting/#slot-origin","title":"Slot origin","text":"<p>When you pass a slot fill to a Component, the component and slot names is remebered on the slot object.</p> <p>Thus, you can check where a slot was filled from by printing it out:</p> <pre><code>class MyComponent(Component):\n    def on_render_before(self):\n        print(self.input.slots)\n</code></pre> <p>might print:</p> <pre><code>{\n    'content': &lt;Slot component_name='layout' slot_name='content'&gt;,\n    'header': &lt;Slot component_name='my_page' slot_name='header'&gt;,\n    'left_panel': &lt;Slot component_name='layout' slot_name='left_panel'&gt;,\n}\n</code></pre>"},{"location":"guides/other/troubleshooting/#agentic-debugging","title":"Agentic debugging","text":"<p>All the features above make django-components to work really well with coding AI agents like Github Copilot or CursorAI.</p> <p>To debug component rendering with LLMs, you want to provide the LLM with:</p> <ol> <li>The components source code</li> <li>The rendered output</li> <li>As much additional context as possible</li> </ol> <p>Your codebase already contains the components source code, but not the latter two.</p>"},{"location":"guides/other/troubleshooting/#providing-rendered-output","title":"Providing rendered output","text":"<p>To provide the LLM with the rendered output, you can simply export the rendered output to a file.</p> <pre><code>rendered = ProjectPage.render(...)\nwith open(\"result.html\", \"w\") as f:\n    f.write(rendered)\n</code></pre> <p>If you're using <code>render_to_response</code>, access the output from the <code>HttpResponse</code> object:</p> <pre><code>response = ProjectPage.render_to_response(...)\nwith open(\"result.html\", \"wb\") as f:\n    f.write(response.content)\n</code></pre>"},{"location":"guides/other/troubleshooting/#providing-contextual-logs","title":"Providing contextual logs","text":"<p>Next, we provide the agent with info on HOW we got the result that we have. We do so by providing the agent with the trace-level logs.</p> <p>In your <code>settings.py</code>, configure the trace-level logs to be written to the <code>django_components.log</code> file:</p> <pre><code>LOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"handlers\": {\n        \"file\": {\n            \"class\": \"logging.FileHandler\",\n            \"filename\": \"django_components.log\",\n            \"mode\": \"w\",  # Overwrite the file each time\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": 5,\n            \"handlers\": [\"file\"],\n        },\n    },\n}\n</code></pre>"},{"location":"guides/other/troubleshooting/#prompting-the-agent","title":"Prompting the agent","text":"<p>Now, you can prompt the agent and include the trace log and the rendered output to guide the agent with debugging.</p> <p>I have a django-components (DJC) project. DJC is like if Vue or React component-based web development but made for Django ecosystem.</p> <p>In the view <code>project_view</code>, I am rendering the <code>ProjectPage</code> component. However, the output is not as expected. The output is missing the tabs.</p> <p>You have access to the full log trace in <code>django_components.log</code>.</p> <p>You can also see the rendered output in <code>result.html</code>.</p> <p>With this information, help me debug the issue.</p> <p>First, tell me what kind of info you would be looking for in the logs, and why (how it relates to understanding the cause of the bug).</p> <p>Then tell me if that info was there, and what the implications are.</p> <p>Finally, tell me what you would do to fix the issue.</p>"},{"location":"guides/setup/caching/","title":"Caching","text":"<p>This page describes the kinds of assets that django-components caches and how to configure the cache backends.</p>"},{"location":"guides/setup/caching/#component-caching","title":"Component caching","text":"<p>You can cache the output of your components by setting the <code>Component.Cache</code> options.</p> <p>Read more about Component caching.</p>"},{"location":"guides/setup/caching/#components-js-and-css-files","title":"Component's JS and CSS files","text":"<p>django-components simultaneously supports:</p> <ul> <li>Rendering and fetching components as HTML fragments</li> <li>Allowing components (even fragments) to have JS and CSS files associated with them</li> <li>Features like JS/CSS variables or CSS scoping</li> </ul> <p>To achieve all this, django-components defines additional temporary JS and CSS files. These temporary files need to be stored somewhere, so that they can be fetched by the browser when the component is rendered as a fragment. And for that, django-components uses Django's cache framework.</p> <p>This includes:</p> <ul> <li>Inlined JS/CSS defined via <code>Component.js</code> and <code>Component.css</code></li> <li>JS/CSS variables generated from <code>get_js_data()</code> and <code>get_css_data()</code></li> </ul> <p>By default, django-components uses Django's local memory cache backend to store these assets. You can configure it to use any of your Django cache backends by setting the <code>COMPONENTS.cache</code> option in your settings:</p> <pre><code>COMPONENTS = {\n    # Name of the cache backend to use\n    \"cache\": \"my-cache-backend\",\n}\n</code></pre> <p>The value should be the name of one of your configured cache backends from Django's <code>CACHES</code> setting.</p> <p>For example, to use Redis for caching component assets:</p> <pre><code>CACHES = {\n    \"default\": {\n        \"BACKEND\": \"django.core.cache.backends.locmem.LocMemCache\",\n    },\n    \"component-media\": {\n        \"BACKEND\": \"django.core.cache.backends.redis.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379/1\",\n    }\n}\n\nCOMPONENTS = {\n    # Use the Redis cache backend\n    \"cache\": \"component-media\",\n}\n</code></pre> <p>See <code>COMPONENTS.cache</code> for more details about this setting.</p>"},{"location":"guides/setup/development_server/","title":"Development server","text":""},{"location":"guides/setup/development_server/#reload-dev-server-on-component-file-changes","title":"Reload dev server on component file changes","text":"<p>This is relevant if you are using the project structure as shown in our examples, where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <pre><code>sampleproject/\n\u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 calendar/\n\u2502       \u251c\u2500\u2500 calendar.py\n\u2502       \u2514\u2500\u2500 calendar.html\n\u2502       \u2514\u2500\u2500 calendar.css\n\u2502       \u2514\u2500\u2500 calendar.js\n\u251c\u2500\u2500 sampleproject/\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>From relevant StackOverflow thread:</p> <p>TL;DR is that the server won't reload if it thinks the changed file is in a templates directory, or in a nested sub directory of a templates directory. This is by design.</p> <p>To make the dev server reload on all component files, set <code>reload_on_file_change</code> to <code>True</code>. This configures Django to watch for component files too.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"overview/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"overview/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"overview/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or  advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic  address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a  professional setting</li> </ul>"},{"location":"overview/code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"overview/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"overview/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at emil@emilstenstrom.se. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"overview/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"overview/community/","title":"Community","text":""},{"location":"overview/community/#community-questions","title":"Community questions","text":"<p>The best place to ask questions is in our Github Discussion board.</p> <p>Please, before opening a new discussion, check if similar discussion wasn't opened already.</p>"},{"location":"overview/community/#community-examples","title":"Community examples","text":"<p>One of our goals with <code>django-components</code> is to make it easy to share components between projects (see how to package components). If you have a set of components that you think would be useful to others, please open a pull request to add them to the list below.</p> <ul> <li> <p>django-htmx-components: A set of components for use with htmx. Try out the live demo.</p> </li> <li> <p>djc-heroicons: A component that renders icons from Heroicons.com.</p> </li> </ul>"},{"location":"overview/compatibility/","title":"Compatibility","text":"<p>Django-components supports all supported combinations versions of Django and Python.</p> Python version Django version 3.8 4.2 3.9 4.2 3.10 4.2, 5.1, 5.2 3.11 4.2, 5.1, 5.2 3.12 4.2, 5.1, 5.2 3.13 5.1, 5.2"},{"location":"overview/compatibility/#operating-systems","title":"Operating systems","text":"<p>django-components is tested against Ubuntu and Windows, and should work on any operating system that supports Python.</p> <p>Note</p> <p>django-components uses Rust-based parsers for better performance.</p> <p>These sub-packages are built with maturin which supports a wide range of operating systems, architectures, and Python versions (see the full list).</p> <p>This should cover most of the cases.</p> <p>However, if your environment is not supported, you will need to install Rust and Cargo to build the sub-packages from source.</p>"},{"location":"overview/contributing/","title":"Contributing","text":""},{"location":"overview/contributing/#bug-reports","title":"Bug reports","text":"<p>If you find a bug, please open an issue with detailed description of what happened.</p>"},{"location":"overview/contributing/#bug-fixes","title":"Bug fixes","text":"<p>If you found a fix for a bug or typo, go ahead and open a PR with a fix. We'll help you out with the rest!</p>"},{"location":"overview/contributing/#feature-requests","title":"Feature requests","text":"<p>For feature requests or suggestions, please open either a discussion or an issue.</p>"},{"location":"overview/contributing/#getting-involved","title":"Getting involved","text":"<p>django_components is still under active development, and there's much to build, so come aboard!</p>"},{"location":"overview/contributing/#sponsoring","title":"Sponsoring","text":"<p>Another way you can get involved is by donating to the development of django_components.</p>"},{"location":"overview/development/","title":"Development","text":""},{"location":"overview/development/#install-locally-and-run-the-tests","title":"Install locally and run the tests","text":"<p>Start by forking the project by clicking the Fork button up in the right corner in the GitHub. This makes a copy of the repository in your own name. Now you can clone this repository locally and start adding features:</p> <pre><code>git clone https://github.com/&lt;your GitHub username&gt;/django-components.git\ncd django-components\n</code></pre> <p>To quickly run the tests install the local dependencies by running:</p> <pre><code>pip install -r requirements-dev.txt\n</code></pre> <p>You also have to install this local django-components version. Use <code>-e</code> for editable mode so you don't have to re-install after every change:</p> <pre><code>pip install -e .\n</code></pre> <p>Now you can run the tests to make sure everything works as expected:</p> <pre><code>pytest\n</code></pre> <p>The library is also tested across many versions of Python and Django. To run tests that way:</p> <pre><code>pyenv install -s 3.8\npyenv install -s 3.9\npyenv install -s 3.10\npyenv install -s 3.11\npyenv install -s 3.12\npyenv install -s 3.13\npyenv local 3.8 3.9 3.10 3.11 3.12 3.13\ntox -p\n</code></pre> <p>To run tests for a specific Python version, use:</p> <pre><code>tox -e py38\n</code></pre> <p>NOTE: See the available environments in <code>tox.ini</code>.</p> <p>And to run only linters, use:</p> <pre><code>tox -e mypy,flake8,isort,black\n</code></pre>"},{"location":"overview/development/#running-playwright-tests","title":"Running Playwright tests","text":"<p>We use Playwright for end-to-end tests. You will therefore need to install Playwright to be able to run these tests.</p> <p>Luckily, Playwright makes it very easy:</p> <pre><code>pip install -r requirements-dev.txt\nplaywright install chromium --with-deps\n</code></pre> <p>After Playwright is ready, simply run the tests with <code>tox</code>:</p> <pre><code>tox\n</code></pre>"},{"location":"overview/development/#developing-against-live-django-app","title":"Developing against live Django app","text":"<p>How do you check that your changes to django-components project will work in an actual Django project?</p> <p>Use the sampleproject demo project to validate the changes:</p> <ol> <li> <p>Navigate to sampleproject directory:</p> <pre><code>cd sampleproject\n</code></pre> </li> <li> <p>Install dependencies from the requirements.txt file:</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Link to your local version of django-components:</p> <pre><code>pip install -e ..\n</code></pre> <p>Note</p> <p>The path to the local version (in this case <code>..</code>) must point to the directory that has the <code>setup.py</code> file.</p> </li> <li> <p>Start Django server     <pre><code>python manage.py runserver\n</code></pre></p> </li> </ol> <p>Once the server is up, it should be available at http://127.0.0.1:8000.</p> <p>To display individual components, add them to the <code>urls.py</code>, like in the case of http://127.0.0.1:8000/greeting</p>"},{"location":"overview/development/#building-js-code","title":"Building JS code","text":"<p>django_components uses a bit of JS code to:</p> <ul> <li>Manage the loading of JS and CSS files used by the components</li> <li>Allow to pass data from Python to JS</li> </ul> <p>When you make changes to this JS code, you also need to compile it:</p> <ol> <li> <p>Make sure you are inside <code>src/django_components_js</code>:</p> <pre><code>cd src/django_components_js\n</code></pre> </li> <li> <p>Install the JS dependencies</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Compile the JS/TS code:</p> <pre><code>python build.py\n</code></pre> <p>The script will combine all JS/TS code into a single <code>.js</code> file, minify it, and copy it to <code>django_components/static/django_components/django_components.min.js</code>.</p> </li> </ol>"},{"location":"overview/development/#packaging-and-publishing","title":"Packaging and publishing","text":"<p>To package the library into a distribution that can be published to PyPI, run:</p> <pre><code># Install pypa/build\npython -m pip install build --user\n# Build a binary wheel and a source tarball\npython -m build --sdist --wheel --outdir dist/ .\n</code></pre> <p>To publish the package to PyPI, use <code>twine</code> (See Python user guide):</p> <pre><code>twine upload --repository pypi dist/* -u __token__ -p &lt;PyPI_TOKEN&gt;\n</code></pre> <p>See the full workflow here.</p>"},{"location":"overview/development/#development-guides","title":"Development guides","text":"<p>Head over to Dev guides for a deep dive into how django_components' features are implemented.</p>"},{"location":"overview/installation/","title":"Installation","text":"<ol> <li> <p>Install <code>django_components</code> into your environment:</p> <pre><code>pip install django_components\n</code></pre> </li> <li> <p>Load <code>django_components</code> into Django by adding it into <code>INSTALLED_APPS</code> in in your settings file:</p> <pre><code>INSTALLED_APPS = [\n    ...,\n    'django_components',\n]\n</code></pre> </li> <li> <p><code>BASE_DIR</code> setting is required. Ensure that it is defined:</p> <pre><code>from pathlib import Path\n\nBASE_DIR = Path(__file__).resolve().parent.parent\n</code></pre> </li> <li> <p>Optional. Set <code>COMPONENTS.dirs</code>    and/or <code>COMPONENTS.app_dirs</code>    so django_components knows where to find component HTML, JS and CSS files:</p> <p>If <code>COMPONENTS.dirs</code> is omitted, django-components will by default look for a top-level <code>/components</code> directory, <code>{BASE_DIR}/components</code>.</p> <pre><code>from django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    dirs=[\n        ...,\n        Path(BASE_DIR) / \"components\",\n    ],\n)\n</code></pre> <p>In addition to <code>COMPONENTS.dirs</code>, django_components will also load components from app-level directories, such as <code>my-app/components/</code>. The directories within apps are configured with <code>COMPONENTS.app_dirs</code>, and the default is <code>[app]/components</code>.</p> <p>Note</p> <p>The input to <code>COMPONENTS.dirs</code> is the same as for <code>STATICFILES_DIRS</code>, and the paths must be full paths. See Django docs.</p> </li> <li> <p>Next, modify <code>TEMPLATES</code> section of settings.py as follows:</p> <ul> <li>Remove <code>'APP_DIRS': True,</code><ul> <li>NOTE: Instead of <code>APP_DIRS: True</code>, we will use   <code>django.template.loaders.app_directories.Loader</code>,   which has the same effect.</li> </ul> </li> <li>Add <code>loaders</code> to <code>OPTIONS</code> list and set it to following value:</li> </ul> <p>This allows Django to load component HTML files as Django templates.</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            'loaders':[(\n                'django.template.loaders.cached.Loader', [\n                    # Default Django loader\n                    'django.template.loaders.filesystem.Loader',\n                    # Including this is the same as APP_DIRS=True\n                    'django.template.loaders.app_directories.Loader',\n                    # Components loader\n                    'django_components.template_loader.Loader',\n                ]\n            )],\n        },\n    },\n]\n</code></pre> </li> </ol>"},{"location":"overview/installation/#adding-support-for-js-and-css","title":"Adding support for JS and CSS","text":"<p>If you want to use JS or CSS with components, you will need to:</p> <ol> <li> <p>Add <code>\"django_components.finders.ComponentsFileSystemFinder\"</code> to <code>STATICFILES_FINDERS</code> in your settings file.</p> <p>This allows Django to serve component JS and CSS as static files.</p> <pre><code>STATICFILES_FINDERS = [\n    # Default finders\n    \"django.contrib.staticfiles.finders.FileSystemFinder\",\n    \"django.contrib.staticfiles.finders.AppDirectoriesFinder\",\n    # Django components\n    \"django_components.finders.ComponentsFileSystemFinder\",\n]\n</code></pre> </li> <li> <p>Add <code>ComponentDependencyMiddleware</code>    to <code>MIDDLEWARE</code> setting.</p> <p>The middleware searches the outgoing HTML for all components that were rendered to generate the HTML, and adds the JS and CSS associated with those components.</p> <pre><code>MIDDLEWARE = [\n    ...\n    \"django_components.middleware.ComponentDependencyMiddleware\",\n]\n</code></pre> <p>Read more in Rendering JS/CSS dependencies.</p> </li> <li> <p>Add django-component's URL paths to your <code>urlpatterns</code>:</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    ...\n    path(\"\", include(\"django_components.urls\")),\n]\n</code></pre> </li> <li> <p>Optional. If you want to change where the JS and CSS is rendered, use     <code>{% component_js_dependencies %}</code>     and <code>{% component_css_dependencies %}</code>.</p> <p>By default, the JS <code>&lt;script&gt;</code> and CSS <code>&lt;link&gt;</code> tags are automatically inserted into the HTML (See JS and CSS output locations).</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    ...\n    {% component_css_dependencies %}\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n    {% component_js_dependencies %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> <li> <p>Optional. By default, components' JS and CSS files are cached in memory.</p> <p>If you want to change the cache backend, set the <code>COMPONENTS.cache</code> setting.</p> <p>Read more in Caching.</p> </li> </ol>"},{"location":"overview/installation/#optional","title":"Optional","text":""},{"location":"overview/installation/#builtin-template-tags","title":"Builtin template tags","text":"<p>To avoid loading the app in each template using <code>{% load component_tags %}</code>, you can add the tag as a 'builtin' in settings.py</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            'builtins': [\n                'django_components.templatetags.component_tags',\n            ]\n        },\n    },\n]\n</code></pre> <p>Now you're all set! Read on to find out how to build your first component.</p>"},{"location":"overview/license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2019 Emil Stenstr\u00f6m</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"overview/performance/","title":"Performance","text":"<p>We track the performance of <code>django-components</code> using ASV.</p> <p>See the benchmarks dashboard.</p>"},{"location":"overview/security_notes/","title":"Security notes \ud83d\udea8","text":"<p>It is strongly recommended to read this section before using django-components in production.</p>"},{"location":"overview/security_notes/#static-files","title":"Static files","text":"<p>TL;DR: No action needed from v0.100 onwards. Before v0.100, use <code>safer_staticfiles</code> to avoid exposing backend logic.</p> <p>Components can be organized however you prefer. That said, our prefered way is to keep the files of a component close together by bundling them in the same directory.</p> <p>This means that files containing backend logic, such as Python modules and HTML templates, live in the same directory as static files, e.g. JS and CSS.</p> <p>From v0.100 onwards, we keep component files (as defined by <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code>) separate from the rest of the static files (defined by <code>STATICFILES_DIRS</code>). That way, the Python and HTML files are NOT exposed by the server. Only the static JS, CSS, and other common formats.</p> <p>Note</p> <p>If you need to expose different file formats, you can configure these with <code>COMPONENTS.static_files_allowed</code> and <code>COMPONENTS.static_files_forbidden</code>.</p>"},{"location":"overview/security_notes/#static-files-prior-to-v0100","title":"Static files prior to v0.100","text":"<p>Prior to v0.100, if your were using django.contrib.staticfiles to collect static files, no distinction was made between the different kinds of files.</p> <p>As a result, your Python code and templates may inadvertently become available on your static file server. You probably don't want this, as parts of your backend logic will be exposed, posing a potential security vulnerability.</p> <p>From v0.27 until v0.100, django-components shipped with an additional installable app django_components.safer_staticfiles. It was a drop-in replacement for django.contrib.staticfiles. Its behavior is 100% identical except it ignores <code>.py</code> and <code>.html</code> files, meaning these will not end up on your static files server.</p> <p>To use it, add it to <code>INSTALLED_APPS</code> and remove django.contrib.staticfiles.</p> <pre><code>INSTALLED_APPS = [\n    # 'django.contrib.staticfiles',   # &lt;-- REMOVE\n    'django_components',\n    'django_components.safer_staticfiles'  # &lt;-- ADD\n]\n</code></pre> <p>If you are on an pre-v0.27 version of django-components, your alternatives are:</p> <ul> <li>a) passing <code>--ignore &lt;pattern&gt;</code> options to the collecstatic CLI command,</li> <li>b) defining a subclass of StaticFilesConfig.</li> </ul> <p>Both routes are described in the official docs of the staticfiles app.</p> <p>Note that <code>safer_staticfiles</code> excludes the <code>.py</code> and <code>.html</code> files for collectstatic command:</p> <pre><code>python manage.py collectstatic\n</code></pre> <p>but it is ignored on the development server:</p> <pre><code>python manage.py runserver\n</code></pre> <p>For a step-by-step guide on deploying production server with static files, see the demo project.</p> <p>See the older versions of the sampleproject for a setup with pre-v0.100 version.</p>"},{"location":"overview/welcome/","title":"Welcome to Django Components","text":"<p><code>django-components</code> combines Django's templating system with the modularity seen in modern frontend frameworks like Vue or React.</p> <p>With <code>django-components</code> you can support Django projects small and large without leaving the Django ecosystem.</p>"},{"location":"overview/welcome/#quickstart","title":"Quickstart","text":"<p>A component in django-components can be as simple as a Django template and Python code to declare the component:</p> components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n</code></pre> <p>Or a combination of Django template, Python, CSS, and Javascript:</p> components/calendar/calendar.html<pre><code>&lt;div class=\"calendar\"&gt;\n  Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> components/calendar/calendar.css<pre><code>.calendar {\n  width: 200px;\n  background: pink;\n}\n</code></pre> components/calendar/calendar.js<pre><code>document.querySelector(\".calendar\").onclick = () =&gt; {\n  alert(\"Clicked calendar!\");\n};\n</code></pre> components/calendar/calendar.py<pre><code>from django_components import Component\n\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n    js_file = \"calendar.js\"\n    css_file = \"calendar.css\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"date\": kwargs[\"date\"]}\n</code></pre> <p>Use the component like this:</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}{% endcomponent %}\n</code></pre> <p>And this is what gets rendered:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n  Today's date is &lt;span&gt;2024-11-06&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>Read on to learn about all the exciting details and configuration possibilities!</p> <p>(If you instead prefer to jump right into the code, check out the example project)</p>"},{"location":"overview/welcome/#features","title":"Features","text":""},{"location":"overview/welcome/#modern-and-modular-ui","title":"Modern and modular UI","text":"<ul> <li>Create self-contained, reusable UI elements.</li> <li>Each component can include its own HTML, CSS, and JS, or additional third-party JS and CSS.</li> <li>HTML, CSS, and JS can be defined on the component class, or loaded from files.</li> </ul> <pre><code>from django_components import Component\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template = \"\"\"\n        &lt;div class=\"calendar\"&gt;\n            Today's date is\n            &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    css = \"\"\"\n        .calendar {\n            width: 200px;\n            background: pink;\n        }\n    \"\"\"\n\n    js = \"\"\"\n        document.querySelector(\".calendar\")\n            .addEventListener(\"click\", () =&gt; {\n                alert(\"Clicked calendar!\");\n            });\n    \"\"\"\n\n    # Additional JS and CSS\n    class Media:\n        js = [\"https://cdn.jsdelivr.net/npm/htmx.org@2.1.1/dist/htmx.min.js\"]\n        css = [\"bootstrap/dist/css/bootstrap.min.css\"]\n\n    # Variables available in the template\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"date\": kwargs[\"date\"]\n        }\n</code></pre>"},{"location":"overview/welcome/#composition-with-slots","title":"Composition with slots","text":"<ul> <li>Render components inside templates with   <code>{% component %}</code> tag.</li> <li>Compose them with <code>{% slot %}</code>   and <code>{% fill %}</code> tags.</li> <li>Vue-like slot system, including scoped slots.</li> </ul> <pre><code>{% component \"Layout\"\n    bookmarks=bookmarks\n    breadcrumbs=breadcrumbs\n%}\n    {% fill \"header\" %}\n        &lt;div class=\"flex justify-between gap-x-12\"&gt;\n            &lt;div class=\"prose\"&gt;\n                &lt;h3&gt;{{ project.name }}&lt;/h3&gt;\n            &lt;/div&gt;\n            &lt;div class=\"font-semibold text-gray-500\"&gt;\n                {{ project.start_date }} - {{ project.end_date }}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    {% endfill %}\n\n    {# Access data passed to `{% slot %}` with `data` #}\n    {% fill \"tabs\" data=\"tabs_data\" %}\n        {% component \"TabItem\" header=\"Project Info\" %}\n            {% component \"ProjectInfo\"\n                project=project\n                project_tags=project_tags\n                attrs:class=\"py-5\"\n                attrs:width=tabs_data.width\n            / %}\n        {% endcomponent %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"overview/welcome/#extended-template-tags","title":"Extended template tags","text":"<p><code>django-components</code> is designed for flexibility, making working with templates a breeze.</p> <p>It extends Django's template tags syntax with:</p> <ul> <li>Literal lists and dictionaries in the template</li> <li>Self-closing tags <code>{% mytag / %}</code></li> <li>Multi-line template tags</li> <li>Spread operator <code>...</code> to dynamically pass args or kwargs into the template tag</li> <li>Template tags inside literal strings like <code>\"{{ first_name }} {{ last_name }}\"</code></li> <li>Pass dictonaries by their key-value pairs <code>attr:key=val</code></li> </ul> <pre><code>{% component \"table\"\n    ...default_attrs\n    title=\"Friend list for {{ user.name }}\"\n    headers=[\"Name\", \"Age\", \"Email\"]\n    data=[\n        {\n            \"name\": \"John\"|upper,\n            \"age\": 30|add:1,\n            \"email\": \"john@example.com\",\n            \"hobbies\": [\"reading\"],\n        },\n        {\n            \"name\": \"Jane\"|upper,\n            \"age\": 25|add:1,\n            \"email\": \"jane@example.com\",\n            \"hobbies\": [\"reading\", \"coding\"],\n        },\n    ],\n    attrs:class=\"py-4 ma-2 border-2 border-gray-300 rounded-md\"\n/ %}\n</code></pre> <p>You too can define template tags with these features by using <code>@template_tag()</code> or <code>BaseNode</code>.</p> <p>Read more on Custom template tags.</p>"},{"location":"overview/welcome/#full-programmatic-access","title":"Full programmatic access","text":"<p>When you render a component, you can access everything about the component:</p> <ul> <li>Component input: args, kwargs, slots and context</li> <li>Component's template, CSS and JS</li> <li>Django's context processors</li> <li>Unique render ID</li> </ul> <pre><code>class Table(Component):\n    js_file = \"table.js\"\n    css_file = \"table.css\"\n\n    template = \"\"\"\n        &lt;div class=\"table\"&gt;\n            &lt;span&gt;{{ variable }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's ID\n        assert self.id == \"djc1A2b3c\"\n\n        # Access component's inputs and slots\n        assert self.input.args == (123, \"str\")\n        assert self.input.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.input.slots[\"footer\"]\n        some_var = self.input.context[\"some_var\"]\n\n        # Access the request object and Django's context processors, if available\n        assert self.request.GET == {\"query\": \"something\"}\n        assert self.context_processors_data['user'].username == \"admin\"\n\n        return {\n            \"variable\": kwargs[\"variable\"],\n        }\n\n# Access component's HTML / JS / CSS\nTable.template\nTable.js\nTable.css\n\n# Render the component\nrendered = Table.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"footer\": \"MY_FOOTER\"},\n)\n</code></pre>"},{"location":"overview/welcome/#granular-html-attributes","title":"Granular HTML attributes","text":"<p>Use the <code>{% html_attrs %}</code> template tag to render HTML attributes.</p> <p>It supports:</p> <ul> <li>Defining attributes as whole dictionaries or keyword arguments</li> <li>Merging attributes from multiple sources</li> <li>Boolean attributes</li> <li>Appending attributes</li> <li>Removing attributes</li> <li>Defining default attributes</li> </ul> <pre><code>&lt;div\n    {% html_attrs\n        attrs\n        defaults:class=\"default-class\"\n        class=\"extra-class\"\n    %}\n&gt;\n</code></pre> <p><code>{% html_attrs %}</code> offers a Vue-like granular control for <code>class</code> and <code>style</code> HTML attributes, where you can use a dictionary to manage each class name or style property separately.</p> <pre><code>{% html_attrs\n    class=\"foo bar\"\n    class={\n        \"baz\": True,\n        \"foo\": False,\n    }\n    class=\"extra\"\n%}\n</code></pre> <pre><code>{% html_attrs\n    style=\"text-align: center; background-color: blue;\"\n    style={\n        \"background-color\": \"green\",\n        \"color\": None,\n        \"width\": False,\n    }\n    style=\"position: absolute; height: 12px;\"\n%}\n</code></pre> <p>Read more about HTML attributes.</p>"},{"location":"overview/welcome/#html-fragment-support","title":"HTML fragment support","text":"<p><code>django-components</code> makes integration with HTMX, AlpineJS or jQuery easy by allowing components to be rendered as HTML fragments:</p> <ul> <li> <p>Components's JS and CSS files are loaded automatically when the fragment is inserted into the DOM.</p> </li> <li> <p>Components can be exposed as Django Views with <code>get()</code>, <code>post()</code>, <code>put()</code>, <code>patch()</code>, <code>delete()</code> methods</p> </li> <li> <p>Automatically create an endpoint for a component with <code>Component.View.public</code></p> </li> </ul> <pre><code># components/calendar/calendar.py\n@register(\"calendar\")\nclass Calendar(Component):\n    template_file = \"calendar.html\"\n\n    class View:\n        # Register Component with `urlpatterns`\n        public = True\n\n        # Define handlers\n        def get(self, request, *args, **kwargs):\n            page = request.GET.get(\"page\", 1)\n            return self.component.render_to_response(\n                request=request,\n                kwargs={\n                    \"page\": page,\n                },\n            )\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"page\": kwargs[\"page\"],\n        }\n\n# Get auto-generated URL for the component\nurl = get_component_url(Calendar)\n\n# Or define explicit URL in urls.py\npath(\"calendar/\", Calendar.as_view())\n</code></pre>"},{"location":"overview/welcome/#provide-inject","title":"Provide / Inject","text":"<p><code>django-components</code> supports the provide / inject pattern, similarly to React's Context Providers or Vue's provide / inject:</p> <ul> <li>Use the <code>{% provide %}</code> tag to provide data to the component tree</li> <li>Use the <code>Component.inject()</code> method to inject data into the component</li> </ul> <p>Read more about Provide / Inject.</p> <pre><code>&lt;body&gt;\n    {% provide \"theme\" variant=\"light\" %}\n        {% component \"header\" / %}\n    {% endprovide %}\n&lt;/body&gt;\n</code></pre> <pre><code>@register(\"header\")\nclass Header(Component):\n    template = \"...\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        theme = self.inject(\"theme\").variant\n        return {\n            \"theme\": theme,\n        }\n</code></pre>"},{"location":"overview/welcome/#input-validation-and-static-type-hints","title":"Input validation and static type hints","text":"<p>Avoid needless errors with type hints and runtime input validation.</p> <p>To opt-in to input validation, define types for component's args, kwargs, slots, and more:</p> <pre><code>from typing import NamedTuple, Optional\nfrom django.template import Context\nfrom django_components import Component, Slot, SlotInput\n\nclass Button(Component):\n    class Args(NamedTuple):\n        size: int\n        text: str\n\n    class Kwargs(NamedTuple):\n        variable: str\n        another: int\n        maybe_var: Optional[int] = None  # May be omitted\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        another_slot: SlotInput\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        args.size  # int\n        kwargs.variable  # str\n        slots.my_slot  # Slot[MySlotData]\n</code></pre> <p>To have type hints when calling <code>Button.render()</code> or <code>Button.render_to_response()</code>, wrap the inputs in their respective <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes:</p> <pre><code>Button.render(\n    # Error: First arg must be `int`, got `float`\n    args=Button.Args(\n        size=1.25,\n        text=\"abc\",\n    ),\n    # Error: Key \"another\" is missing\n    kwargs=Button.Kwargs(\n        variable=\"text\",\n    ),\n)\n</code></pre>"},{"location":"overview/welcome/#extensions","title":"Extensions","text":"<p>Django-components functionality can be extended with Extensions. Extensions allow for powerful customization and integrations. They can:</p> <ul> <li>Tap into lifecycle events, such as when a component is created, deleted, or registered</li> <li>Add new attributes and methods to the components</li> <li>Add custom CLI commands</li> <li>Add custom URLs</li> </ul> <p>Some of the extensions include:</p> <ul> <li>Component caching</li> <li>Django View integration</li> <li>Component defaults</li> <li>Pydantic integration (input validation)</li> </ul> <p>Some of the planned extensions include:</p> <ul> <li>AlpineJS integration</li> <li>Storybook integration</li> <li>Component-level benchmarking with asv</li> </ul>"},{"location":"overview/welcome/#caching","title":"Caching","text":"<ul> <li>Components can be cached using Django's cache framework.</li> <li>Caching rules can be configured on a per-component basis.</li> <li>Components are cached based on their input. Or you can write custom caching logic.</li> </ul> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n\n        def hash(self, *args, **kwargs):\n            return hash(f\"{json.dumps(args)}:{json.dumps(kwargs)}\")\n</code></pre>"},{"location":"overview/welcome/#simple-testing","title":"Simple testing","text":"<ul> <li>Write tests for components with <code>@djc_test</code> decorator.</li> <li>The decorator manages global state, ensuring that tests don't leak.</li> <li>If using <code>pytest</code>, the decorator allows you to parametrize Django or Components settings.</li> <li>The decorator also serves as a stand-in for Django's <code>@override_settings</code>.</li> </ul> <pre><code>from django_components.testing import djc_test\n\nfrom components.my_table import MyTable\n\n@djc_test\ndef test_my_table():\n    rendered = MyTable.render(\n        kwargs={\n            \"title\": \"My table\",\n        },\n    )\n    assert rendered == \"&lt;table&gt;My table&lt;/table&gt;\"\n</code></pre>"},{"location":"overview/welcome/#debugging-features","title":"Debugging features","text":"<ul> <li>Visual component inspection: Highlight components and slots directly in your browser.</li> <li>Detailed tracing logs to supply AI-agents with context: The logs include component and slot names and IDs, and their position in the tree.</li> </ul>"},{"location":"overview/welcome/#sharing-components","title":"Sharing components","text":"<ul> <li>Install and use third-party components from PyPI</li> <li>Or publish your own \"component registry\"</li> <li> <p>Highly customizable - Choose how the components are called in the template (and more):</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}\n{% endcomponent %}\n\n{% calendar date=\"2024-11-06\" %}\n{% endcalendar %}\n</code></pre> </li> </ul>"},{"location":"overview/welcome/#performance","title":"Performance","text":"<p>Our aim is to be at least as fast as Django templates.</p> <p>As of <code>0.130</code>, <code>django-components</code> is ~4x slower than Django templates.</p> Render time django 68.9\u00b10.6ms django-components 259\u00b14ms <p>See the full performance breakdown for more information.</p>"},{"location":"overview/welcome/#release-notes","title":"Release notes","text":"<p>Read the Release Notes to see the latest features and fixes.</p>"},{"location":"overview/welcome/#community-examples","title":"Community examples","text":"<p>One of our goals with <code>django-components</code> is to make it easy to share components between projects. Head over to the Community examples to see some examples.</p>"},{"location":"overview/welcome/#contributing-and-development","title":"Contributing and development","text":"<p>Get involved or sponsor this project - See here</p> <p>Running django-components locally for development - See here</p>"},{"location":"reference/api/","title":"API","text":""},{"location":"reference/api/#api","title":"API","text":""},{"location":"reference/api/#django_components.BaseNode","title":"BaseNode","text":"<pre><code>BaseNode(\n    params: List[TagAttr], flags: Optional[Dict[str, bool]] = None, nodelist: Optional[NodeList] = None, node_id: Optional[str] = None\n)\n</code></pre> <p>Bases: <code>django.template.base.Node</code></p> <p>See source code</p> <p>Node class for all django-components custom template tags.</p> <p>This class has a dual role:</p> <ol> <li> <p>It declares how a particular template tag should be parsed - By setting the    <code>tag</code>,    <code>end_tag</code>,    and <code>allowed_flags</code>    attributes:</p> <pre><code>class SlotNode(BaseNode):\n    tag = \"slot\"\n    end_tag = \"endslot\"\n    allowed_flags = [\"required\"]\n</code></pre> <p>This will allow the template tag <code>{% slot %}</code> to be used like this:</p> <pre><code>{% slot required %} ... {% endslot %}\n</code></pre> </li> <li> <p>The <code>render</code> method is     the actual implementation of the template tag.</p> <p>This is where the tag's logic is implemented:</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mynode\"\n\n    def render(self, context: Context, name: str, **kwargs: Any) -&gt; str:\n        return f\"Hello, {name}!\"\n</code></pre> <p>This will allow the template tag <code>{% mynode %}</code> to be used like this:</p> <pre><code>{% mynode name=\"John\" %}\n</code></pre> </li> </ol> <p>The template tag accepts parameters as defined on the <code>render</code> method's signature.</p> <p>For more info, see <code>BaseNode.render()</code>.</p> <p>Methods:</p> <ul> <li> <code>parse</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>unregister</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>active_flags</code>               (<code>List[str]</code>)           \u2013            </li> <li> <code>allowed_flags</code>               (<code>Optional[List[str]]</code>)           \u2013            </li> <li> <code>end_tag</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>flags</code>           \u2013            </li> <li> <code>node_id</code>           \u2013            </li> <li> <code>nodelist</code>           \u2013            </li> <li> <code>params</code>           \u2013            </li> <li> <code>tag</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.BaseNode.active_flags","title":"active_flags  <code>property</code>","text":"<pre><code>active_flags: List[str]\n</code></pre> <p>See source code</p> <p>Flags that were set for this specific instance.</p>"},{"location":"reference/api/#django_components.BaseNode.allowed_flags","title":"allowed_flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allowed_flags: Optional[List[str]] = None\n</code></pre> <p>See source code</p> <p>The allowed flags for this tag.</p> <p>E.g. <code>[\"required\"]</code> will allow this tag to be used like <code>{% slot required %}</code>.</p>"},{"location":"reference/api/#django_components.BaseNode.end_tag","title":"end_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_tag: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The end tag name.</p> <p>E.g. <code>\"endcomponent\"</code> or <code>\"endslot\"</code> will make this class match template tags <code>{% endcomponent %}</code> or <code>{% endslot %}</code>.</p> <p>If not set, then this template tag has no end tag.</p> <p>So instead of <code>{% component %} ... {% endcomponent %}</code>, you'd use only <code>{% component %}</code>.</p>"},{"location":"reference/api/#django_components.BaseNode.flags","title":"flags  <code>instance-attribute</code>","text":"<pre><code>flags = flags or {flag: Falsefor flag in allowed_flags or []}\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.node_id","title":"node_id  <code>instance-attribute</code>","text":"<pre><code>node_id = node_id or gen_id()\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.nodelist","title":"nodelist  <code>instance-attribute</code>","text":"<pre><code>nodelist = nodelist or NodeList()\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params = params\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str\n</code></pre> <p>See source code</p> <p>The tag name.</p> <p>E.g. <code>\"component\"</code> or <code>\"slot\"</code> will make this class match template tags <code>{% component %}</code> or <code>{% slot %}</code>.</p>"},{"location":"reference/api/#django_components.BaseNode.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(parser: Parser, token: Token, **kwargs: Any) -&gt; BaseNode\n</code></pre> <p>See source code</p> <p>This function is what is passed to Django's <code>Library.tag()</code> when registering the tag.</p> <p>In other words, this method is called by Django's template parser when we encounter a tag that matches this node's tag, e.g. <code>{% component %}</code> or <code>{% slot %}</code>.</p> <p>To register the tag, you can use <code>BaseNode.register()</code>.</p>"},{"location":"reference/api/#django_components.BaseNode.register","title":"register  <code>classmethod</code>","text":"<pre><code>register(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>A convenience method for registering the tag with the given library.</p> <pre><code>class MyNode(BaseNode):\n    tag = \"mynode\"\n\nMyNode.register(library)\n</code></pre> <p>Allows you to then use the node in templates like so:</p> <pre><code>{% load mylibrary %}\n{% mynode %}\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.render","title":"render","text":"<pre><code>render(context: Context, *args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>See source code</p> <p>Render the node. This method is meant to be overridden by subclasses.</p> <p>The signature of this function decides what input the template tag accepts.</p> <p>The <code>render()</code> method MUST accept a <code>context</code> argument. Any arguments after that will be part of the tag's input parameters.</p> <p>So if you define a <code>render</code> method like this:</p> <pre><code>def render(self, context: Context, name: str, **kwargs: Any) -&gt; str:\n</code></pre> <p>Then the tag will require the <code>name</code> parameter, and accept any extra keyword arguments:</p> <pre><code>{% component name=\"John\" age=20 %}\n</code></pre>"},{"location":"reference/api/#django_components.BaseNode.unregister","title":"unregister  <code>classmethod</code>","text":"<pre><code>unregister(library: Library) -&gt; None\n</code></pre> <p>See source code</p> <p>Unregisters the node from the given library.</p>"},{"location":"reference/api/#django_components.CommandLiteralAction","title":"CommandLiteralAction  <code>module-attribute</code>","text":"<pre><code>CommandLiteralAction = Literal['append', 'append_const', 'count', 'extend', 'store', 'store_const', 'store_true', 'store_false', 'version']\n</code></pre> <p>See source code</p> <p>The basic type of action to be taken when this argument is encountered at the command line.</p> <p>This is a subset of the values for <code>action</code> in <code>ArgumentParser.add_argument()</code>.</p>"},{"location":"reference/api/#django_components.Component","title":"Component","text":"<pre><code>Component(registered_name: Optional[str] = None, outer_context: Optional[Context] = None, registry: Optional[ComponentRegistry] = None)\n</code></pre> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              </li> <li> <code>get_context_data</code>             \u2013              </li> <li> <code>get_css_data</code>             \u2013              </li> <li> <code>get_js_data</code>             \u2013              </li> <li> <code>get_template</code>             \u2013              </li> <li> <code>get_template_data</code>             \u2013              </li> <li> <code>get_template_name</code>             \u2013              </li> <li> <code>inject</code>             \u2013              </li> <li> <code>on_render_after</code>             \u2013              </li> <li> <code>on_render_before</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>render_to_response</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>Args</code>               (<code>Type</code>)           \u2013            </li> <li> <code>Cache</code>               (<code>Type[ComponentCache]</code>)           \u2013            </li> <li> <code>CssData</code>               (<code>Type</code>)           \u2013            </li> <li> <code>Defaults</code>               (<code>Type[ComponentDefaults]</code>)           \u2013            </li> <li> <code>JsData</code>               (<code>Type</code>)           \u2013            </li> <li> <code>Kwargs</code>               (<code>Type</code>)           \u2013            </li> <li> <code>Media</code>               (<code>Optional[Type[ComponentMediaInput]]</code>)           \u2013            </li> <li> <code>Slots</code>               (<code>Type</code>)           \u2013            </li> <li> <code>TemplateData</code>               (<code>Type</code>)           \u2013            </li> <li> <code>View</code>               (<code>Type[ComponentView]</code>)           \u2013            </li> <li> <code>cache</code>               (<code>ComponentCache</code>)           \u2013            </li> <li> <code>class_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>context_processors_data</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>css_file</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>defaults</code>               (<code>ComponentDefaults</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>input</code>               (<code>ComponentInput</code>)           \u2013            </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>js_file</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>media</code>               (<code>Optional[Media]</code>)           \u2013            </li> <li> <code>media_class</code>               (<code>Type[Media]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>outer_context</code>               (<code>Optional[Context]</code>)           \u2013            </li> <li> <code>registered_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>registry</code>           \u2013            </li> <li> <code>request</code>               (<code>Optional[HttpRequest]</code>)           \u2013            </li> <li> <code>response_class</code>           \u2013            </li> <li> <code>template</code>               (<code>Optional[Union[str, Template]]</code>)           \u2013            </li> <li> <code>template_file</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>view</code>               (<code>ComponentView</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.Component.Args","title":"Args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Args: Type = cast(Type, None)\n</code></pre> <p>See source code</p> <p>Optional typing for positional arguments passed to the component.</p> <p>If set and not <code>None</code>, then the <code>args</code> parameter of the data methods (<code>get_template_data()</code>, <code>get_js_data()</code>, <code>get_css_data()</code>) will be the instance of this class:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class Args(NamedTuple):\n        color: str\n        size: int\n\n    def get_template_data(self, args: Args, kwargs, slots, context):\n        assert isinstance(args, Table.Args)\n\n        return {\n            \"color\": args.color,\n            \"size\": args.size,\n        }\n</code></pre> <p>The constructor of this class MUST accept positional arguments:</p> <pre><code>Args(*args)\n</code></pre> <p>As such, a good starting point is to set this field to a subclass of <code>NamedTuple</code>.</p> <p>Use <code>Args</code> to:</p> <ul> <li>Validate the input at runtime.</li> <li>Set type hints for the positional arguments for data methods like   <code>get_template_data()</code>.</li> <li>Document the component inputs.</li> </ul> <p>You can also use <code>Args</code> to validate the positional arguments for <code>Component.render()</code>:</p> <pre><code>Table.render(\n    args=Table.Args(color=\"red\", size=10),\n)\n</code></pre> <p>Read more on Typing and validation.</p>"},{"location":"reference/api/#django_components.Component.Cache","title":"Cache  <code>instance-attribute</code>","text":"<pre><code>Cache: Type[ComponentCache]\n</code></pre> <p>See source code</p> <p>The fields of this class are used to configure the component caching.</p> <p>Read more about Component caching.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n        cache_name = \"my_cache\"\n</code></pre>"},{"location":"reference/api/#django_components.Component.CssData","title":"CssData  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CssData: Type = cast(Type, None)\n</code></pre> <p>See source code</p> <p>Optional typing for the data to be returned from <code>get_css_data()</code>.</p> <p>If set and not <code>None</code>, then this class will be instantiated with the dictionary returned from <code>get_css_data()</code> to validate the data.</p> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>CssData(**css_data)\n</code></pre> <p>You can also return an instance of <code>CssData</code> directly from <code>get_css_data()</code> to get type hints:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class CssData(NamedTuple):\n        color: str\n        size: int\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return Table.CssData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre> <p>A good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>CssData</code> to:</p> <ul> <li>Validate the data returned from   <code>get_css_data()</code> at runtime.</li> <li>Set type hints for this data.</li> <li>Document the component data.</li> </ul> <p>Read more on Typing and validation.</p> <p>Info</p> <p>If you use a custom class for <code>CssData</code>, this class needs to be convertable to a dictionary.</p> <p>You can implement either:</p> <ol> <li> <p><code>_asdict()</code> method     <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def _asdict(self):\n        return {'x': self.x, 'y': self.y}\n</code></pre></p> </li> <li> <p>Or make the class dict-like with <code>__iter__()</code> and <code>__getitem__()</code> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code></pre></p> </li> </ol>"},{"location":"reference/api/#django_components.Component.Defaults","title":"Defaults  <code>instance-attribute</code>","text":"<pre><code>Defaults: Type[ComponentDefaults]\n</code></pre> <p>See source code</p> <p>The fields of this class are used to set default values for the component's kwargs.</p> <p>Read more about Component defaults.</p> <p>Example:</p> <pre><code>from django_components import Component, Default\n\nclass MyComponent(Component):\n    class Defaults:\n        position = \"left\"\n        selected_items = Default(lambda: [1, 2, 3])\n</code></pre>"},{"location":"reference/api/#django_components.Component.JsData","title":"JsData  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JsData: Type = cast(Type, None)\n</code></pre> <p>See source code</p> <p>Optional typing for the data to be returned from <code>get_js_data()</code>.</p> <p>If set and not <code>None</code>, then this class will be instantiated with the dictionary returned from <code>get_js_data()</code> to validate the data.</p> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>JsData(**js_data)\n</code></pre> <p>You can also return an instance of <code>JsData</code> directly from <code>get_js_data()</code> to get type hints:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class JsData(NamedTuple):\n        color: str\n        size: int\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return Table.JsData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre> <p>A good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>JsData</code> to:</p> <ul> <li>Validate the data returned from   <code>get_js_data()</code> at runtime.</li> <li>Set type hints for this data.</li> <li>Document the component data.</li> </ul> <p>Read more on Typing and validation.</p> <p>Info</p> <p>If you use a custom class for <code>JsData</code>, this class needs to be convertable to a dictionary.</p> <p>You can implement either:</p> <ol> <li> <p><code>_asdict()</code> method     <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def _asdict(self):\n        return {'x': self.x, 'y': self.y}\n</code></pre></p> </li> <li> <p>Or make the class dict-like with <code>__iter__()</code> and <code>__getitem__()</code> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code></pre></p> </li> </ol>"},{"location":"reference/api/#django_components.Component.Kwargs","title":"Kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Kwargs: Type = cast(Type, None)\n</code></pre> <p>See source code</p> <p>Optional typing for keyword arguments passed to the component.</p> <p>If set and not <code>None</code>, then the <code>kwargs</code> parameter of the data methods (<code>get_template_data()</code>, <code>get_js_data()</code>, <code>get_css_data()</code>) will be the instance of this class:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class Kwargs(NamedTuple):\n        color: str\n        size: int\n\n    def get_template_data(self, args, kwargs: Kwargs, slots, context):\n        assert isinstance(kwargs, Table.Kwargs)\n\n        return {\n            \"color\": kwargs.color,\n            \"size\": kwargs.size,\n        }\n</code></pre> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>Kwargs(**kwargs)\n</code></pre> <p>As such, a good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>Kwargs</code> to:</p> <ul> <li>Validate the input at runtime.</li> <li>Set type hints for the keyword arguments for data methods like   <code>get_template_data()</code>.</li> <li>Document the component inputs.</li> </ul> <p>You can also use <code>Kwargs</code> to validate the keyword arguments for <code>Component.render()</code>:</p> <pre><code>Table.render(\n    kwargs=Table.Kwargs(color=\"red\", size=10),\n)\n</code></pre> <p>Read more on Typing and validation.</p>"},{"location":"reference/api/#django_components.Component.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media: Optional[Type[ComponentMediaInput]] = None\n</code></pre> <p>See source code</p> <p>Defines JS and CSS media files associated with this component.</p> <p>This <code>Media</code> class behaves similarly to Django's Media class:</p> <ul> <li>Paths are generally handled as static file paths, and resolved URLs are rendered to HTML with   <code>media_class.render_js()</code> or <code>media_class.render_css()</code>.</li> <li>A path that starts with <code>http</code>, <code>https</code>, or <code>/</code> is considered a URL, skipping the static file resolution.   This path is still rendered to HTML with <code>media_class.render_js()</code> or <code>media_class.render_css()</code>.</li> <li>A <code>SafeString</code> (with <code>__html__</code> method) is considered an already-formatted HTML tag, skipping both static file     resolution and rendering with <code>media_class.render_js()</code> or <code>media_class.render_css()</code>.</li> <li>You can set <code>extend</code> to configure   whether to inherit JS / CSS from parent components. See   Media inheritance.</li> </ul> <p>However, there's a few differences from Django's Media class:</p> <ol> <li>Our Media class accepts various formats for the JS and CSS files: either a single file, a list,    or (CSS-only) a dictionary (See <code>ComponentMediaInput</code>).</li> <li>Individual JS / CSS files can be any of <code>str</code>, <code>bytes</code>, <code>Path</code>,    <code>SafeString</code>, or a function    (See <code>ComponentMediaInputPath</code>).</li> </ol> <p>Example:</p> <pre><code>class MyTable(Component):\n    class Media:\n        js = [\n            \"path/to/script.js\",\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",  # AlpineJS\n        ]\n        css = {\n            \"all\": [\n                \"path/to/style.css\",\n                \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",  # TailwindCSS\n            ],\n            \"print\": [\"path/to/style2.css\"],\n        }\n</code></pre>"},{"location":"reference/api/#django_components.Component.Slots","title":"Slots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Slots: Type = cast(Type, None)\n</code></pre> <p>See source code</p> <p>Optional typing for slots passed to the component.</p> <p>If set and not <code>None</code>, then the <code>slots</code> parameter of the data methods (<code>get_template_data()</code>, <code>get_js_data()</code>, <code>get_css_data()</code>) will be the instance of this class:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component, Slot, SlotInput\n\nclass Table(Component):\n    class Slots(NamedTuple):\n        header: SlotInput\n        footer: Slot\n\n    def get_template_data(self, args, kwargs, slots: Slots, context):\n        assert isinstance(slots, Table.Slots)\n\n        return {\n            \"header\": slots.header,\n            \"footer\": slots.footer,\n        }\n</code></pre> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>Slots(**slots)\n</code></pre> <p>As such, a good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>Slots</code> to:</p> <ul> <li>Validate the input at runtime.</li> <li>Set type hints for the slots for data methods like   <code>get_template_data()</code>.</li> <li>Document the component inputs.</li> </ul> <p>You can also use <code>Slots</code> to validate the slots for <code>Component.render()</code>:</p> <pre><code>Table.render(\n    slots=Table.Slots(\n        header=\"HELLO IM HEADER\",\n        footer=Slot(lambda: ...),\n    ),\n)\n</code></pre> <p>Read more on Typing and validation.</p> <p>Info</p> <p>Components can receive slots as strings, functions, or instances of <code>Slot</code>.</p> <p>Internally these are all normalized to instances of <code>Slot</code>.</p> <p>Therefore, the <code>slots</code> dictionary available in data methods (like <code>get_template_data()</code>) will always be a dictionary of <code>Slot</code> instances.</p> <p>To correctly type this dictionary, you should set the fields of <code>Slots</code> to <code>Slot</code> or <code>SlotInput</code>:</p> <p><code>SlotInput</code> is a union of <code>Slot</code>, string, and function types.</p>"},{"location":"reference/api/#django_components.Component.TemplateData","title":"TemplateData  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TemplateData: Type = cast(Type, None)\n</code></pre> <p>See source code</p> <p>Optional typing for the data to be returned from <code>get_template_data()</code>.</p> <p>If set and not <code>None</code>, then this class will be instantiated with the dictionary returned from <code>get_template_data()</code> to validate the data.</p> <p>The constructor of this class MUST accept keyword arguments:</p> <pre><code>TemplateData(**template_data)\n</code></pre> <p>You can also return an instance of <code>TemplateData</code> directly from <code>get_template_data()</code> to get type hints:</p> <pre><code>from typing import NamedTuple\nfrom django_components import Component\n\nclass Table(Component):\n    class TemplateData(NamedTuple):\n        color: str\n        size: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return Table.TemplateData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre> <p>A good starting point is to set this field to a subclass of <code>NamedTuple</code> or a dataclass.</p> <p>Use <code>TemplateData</code> to:</p> <ul> <li>Validate the data returned from   <code>get_template_data()</code> at runtime.</li> <li>Set type hints for this data.</li> <li>Document the component data.</li> </ul> <p>Read more on Typing and validation.</p> <p>Info</p> <p>If you use a custom class for <code>TemplateData</code>, this class needs to be convertable to a dictionary.</p> <p>You can implement either:</p> <ol> <li> <p><code>_asdict()</code> method     <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def _asdict(self):\n        return {'x': self.x, 'y': self.y}\n</code></pre></p> </li> <li> <p>Or make the class dict-like with <code>__iter__()</code> and <code>__getitem__()</code> <pre><code>class MyClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 2\n\n    def __iter__(self):\n        return iter([('x', self.x), ('y', self.y)])\n\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code></pre></p> </li> </ol>"},{"location":"reference/api/#django_components.Component.View","title":"View  <code>instance-attribute</code>","text":"<pre><code>View: Type[ComponentView]\n</code></pre> <p>See source code</p> <p>The fields of this class are used to configure the component views and URLs.</p> <p>This class is a subclass of <code>django.views.View</code>. The <code>Component</code> instance is available via <code>self.component</code>.</p> <p>Override the methods of this class to define the behavior of the component.</p> <p>Read more about Component views and URLs.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class View:\n        def get(self, request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse:\n            return HttpResponse(\"Hello, world!\")\n</code></pre>"},{"location":"reference/api/#django_components.Component.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache: ComponentCache\n</code></pre> <p>See source code</p> <p>Instance of <code>ComponentCache</code> available at component render time.</p>"},{"location":"reference/api/#django_components.Component.class_id","title":"class_id  <code>class-attribute</code>","text":"<pre><code>class_id: str\n</code></pre> <p>See source code</p> <p>Unique ID of the component class, e.g. <code>MyComponent_ab01f2</code>.</p> <p>This is derived from the component class' module import path, e.g. <code>path.to.my.MyComponent</code>.</p>"},{"location":"reference/api/#django_components.Component.context_processors_data","title":"context_processors_data  <code>property</code>","text":"<pre><code>context_processors_data: Dict\n</code></pre> <p>See source code</p> <p>Retrieve data injected by <code>context_processors</code>.</p> <p>This data is also available from within the component's template, without having to return this data from <code>get_template_data()</code>.</p> <p>In regular Django templates, you need to use <code>RequestContext</code> to apply context processors.</p> <p>In Components, the context processors are applied to components either when:</p> <ul> <li>The component is rendered with     <code>RequestContext</code>     (Regular Django behavior)</li> <li>The component is rendered with a regular     <code>Context</code> (or none),     but the <code>request</code> kwarg of <code>Component.render()</code> is set.</li> <li>The component is nested in another component that matches any of these conditions.</li> </ul> <p>See <code>Component.request</code> on how the <code>request</code> (HTTPRequest) object is passed to and within the components.</p> <p>Raises <code>RuntimeError</code> if accessed outside of rendering execution.</p> <p>NOTE: This dictionary is generated dynamically, so any changes to it will not be persisted.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        user = self.context_processors_data['user']\n        return {\n            'is_logged_in': user.is_authenticated,\n        }\n</code></pre>"},{"location":"reference/api/#django_components.Component.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Main CSS associated with this component inlined as string.</p> <p>Only one of <code>css</code> or <code>css_file</code> must be defined.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    css = \"\"\"\n    .my-class {\n        color: red;\n    }\n    \"\"\"\n</code></pre>"},{"location":"reference/api/#django_components.Component.css_file","title":"css_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css_file: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Main CSS associated with this component as file path.</p> <p>The filepath must be either:</p> <ul> <li>Relative to the directory where the Component's Python file is defined.</li> <li>Relative to one of the component directories, as set by   <code>COMPONENTS.dirs</code>   or   <code>COMPONENTS.app_dirs</code>   (e.g. <code>&lt;root&gt;/components/</code>).</li> <li>Relative to the staticfiles directories, as set by Django's <code>STATICFILES_DIRS</code> setting (e.g. <code>&lt;root&gt;/static/</code>).</li> </ul> <p>When you create a Component class with <code>css_file</code>, these will happen:</p> <ol> <li>If the file path is relative to the directory where the component's Python file is,    the path is resolved.</li> <li>The file is read and its contents is set to <code>Component.css</code>.</li> </ol> <p>Only one of <code>css</code> or <code>css_file</code> must be defined.</p> <p>Example:</p> path/to/style.css<pre><code>.my-class {\n    color: red;\n}\n</code></pre> path/to/component.py<pre><code>class MyComponent(Component):\n    css_file = \"path/to/style.css\"\n\nprint(MyComponent.css)\n# Output:\n# .my-class {\n#     color: red;\n# };\n</code></pre>"},{"location":"reference/api/#django_components.Component.defaults","title":"defaults  <code>instance-attribute</code>","text":"<pre><code>defaults: ComponentDefaults\n</code></pre> <p>See source code</p> <p>Instance of <code>ComponentDefaults</code> available at component render time.</p>"},{"location":"reference/api/#django_components.Component.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>See source code</p> <p>This ID is unique for every time a <code>Component.render()</code> (or equivalent) is called (AKA \"render ID\").</p> <p>This is useful for logging or debugging.</p> <p>Raises <code>RuntimeError</code> if accessed outside of rendering execution.</p> <p>The ID is a 7-letter alphanumeric string in the format <code>cXXXXXX</code>, where <code>XXXXXX</code> is a random string of 6 alphanumeric characters (case-sensitive).</p> <p>E.g. <code>c1A2b3c</code>.</p> <p>A single render ID has a chance of collision 1 in 57 billion. However, due to birthday paradox, the chance of collision increases to 1% when approaching ~33K render IDs.</p> <p>Thus, there is currently a soft-cap of ~30K components rendered on a single page.</p> <p>If you need to expand this limit, please open an issue on GitHub.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        print(f\"Rendering '{self.id}'\")\n        return {}\n\nMyComponent.render()\n# Rendering 'ab3c4d'\n</code></pre>"},{"location":"reference/api/#django_components.Component.input","title":"input  <code>property</code>","text":"<pre><code>input: ComponentInput\n</code></pre> <p>See source code</p> <p>Input holds the data that were passed to the current component at render time.</p> <p>Raises <code>RuntimeError</code> if accessed outside of rendering execution.</p> <p>This includes:</p> <ul> <li><code>args</code> - List of positional arguments</li> <li><code>kwargs</code> - Dictionary of keyword arguments</li> <li><code>slots</code> - Dictionary of slots. Values are normalized to   <code>Slot</code> instances</li> <li><code>context</code> -   <code>Context</code>   object that should be used to render the component</li> <li>And other kwargs passed to <code>Component.render()</code>   like <code>deps_strategy</code></li> </ul> <p>Read more on Component inputs.</p> <p>Example:</p> <pre><code>class Table(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        # Access component's inputs, slots and context\n        assert self.input.args == [123, \"str\"]\n        assert self.input.kwargs == {\"variable\": \"test\", \"another\": 1}\n        footer_slot = self.input.slots[\"footer\"]\n        some_var = self.input.context[\"some_var\"]\n\n        return {}\n\nrendered = TestComponent.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"footer\": \"MY_SLOT\"},\n)\n</code></pre>"},{"location":"reference/api/#django_components.Component.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>See source code</p> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p> <p>Raises <code>RuntimeError</code> if accessed outside of rendering execution.</p>"},{"location":"reference/api/#django_components.Component.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Main JS associated with this component inlined as string.</p> <p>Only one of <code>js</code> or <code>js_file</code> must be defined.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    js = \"console.log('Hello, World!');\"\n</code></pre>"},{"location":"reference/api/#django_components.Component.js_file","title":"js_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js_file: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Main JS associated with this component as file path.</p> <p>The filepath must be either:</p> <ul> <li>Relative to the directory where the Component's Python file is defined.</li> <li>Relative to one of the component directories, as set by   <code>COMPONENTS.dirs</code>   or   <code>COMPONENTS.app_dirs</code>   (e.g. <code>&lt;root&gt;/components/</code>).</li> <li>Relative to the staticfiles directories, as set by Django's <code>STATICFILES_DIRS</code> setting (e.g. <code>&lt;root&gt;/static/</code>).</li> </ul> <p>When you create a Component class with <code>js_file</code>, these will happen:</p> <ol> <li>If the file path is relative to the directory where the component's Python file is,    the path is resolved.</li> <li>The file is read and its contents is set to <code>Component.js</code>.</li> </ol> <p>Only one of <code>js</code> or <code>js_file</code> must be defined.</p> <p>Example:</p> path/to/script.js<pre><code>console.log('Hello, World!');\n</code></pre> path/to/component.py<pre><code>class MyComponent(Component):\n    js_file = \"path/to/script.js\"\n\nprint(MyComponent.js)\n# Output: console.log('Hello, World!');\n</code></pre>"},{"location":"reference/api/#django_components.Component.media","title":"media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>media: Optional[Media] = None\n</code></pre> <p>See source code</p> <p>Normalized definition of JS and CSS media files associated with this component. <code>None</code> if <code>Component.Media</code> is not defined.</p> <p>This field is generated from <code>Component.media_class</code>.</p> <p>Read more on Accessing component's HTML / JS / CSS.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"path/to/script.js\"\n        css = \"path/to/style.css\"\n\nprint(MyComponent.media)\n# Output:\n# &lt;script src=\"/static/path/to/script.js\"&gt;&lt;/script&gt;\n# &lt;link href=\"/static/path/to/style.css\" media=\"all\" rel=\"stylesheet\"&gt;\n</code></pre>"},{"location":"reference/api/#django_components.Component.media_class","title":"media_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>media_class: Type[Media] = Media\n</code></pre> <p>See source code</p> <p>Set the Media class that will be instantiated with the JS and CSS media files from <code>Component.Media</code>.</p> <p>This is useful when you want to customize the behavior of the media files, like customizing how the JS or CSS files are rendered into <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> HTML tags.</p> <p>Read more in Defining HTML / JS / CSS files.</p> <p>Example:</p> <pre><code>class MyTable(Component):\n    class Media:\n        js = \"path/to/script.js\"\n        css = \"path/to/style.css\"\n\n    media_class = MyMediaClass\n</code></pre>"},{"location":"reference/api/#django_components.Component.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/api/#django_components.Component.outer_context","title":"outer_context  <code>instance-attribute</code>","text":"<pre><code>outer_context: Optional[Context] = outer_context\n</code></pre>"},{"location":"reference/api/#django_components.Component.registered_name","title":"registered_name  <code>instance-attribute</code>","text":"<pre><code>registered_name: Optional[str] = registered_name\n</code></pre>"},{"location":"reference/api/#django_components.Component.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry = registry or registry\n</code></pre>"},{"location":"reference/api/#django_components.Component.request","title":"request  <code>property</code>","text":"<pre><code>request: Optional[HttpRequest]\n</code></pre> <p>See source code</p> <p>HTTPRequest object passed to this component.</p> <p>In regular Django templates, you have to use <code>RequestContext</code> to pass the <code>HttpRequest</code> object to the template.</p> <p>But in Components, you can either use <code>RequestContext</code>, or pass the <code>request</code> object explicitly via <code>Component.render()</code> and <code>Component.render_to_response()</code>.</p> <p>When a component is nested in another, the child component uses parent's <code>request</code> object.</p> <p>Raises <code>RuntimeError</code> if accessed outside of rendering execution.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        user_id = self.request.GET['user_id']\n        return {\n            'user_id': user_id,\n        }\n</code></pre>"},{"location":"reference/api/#django_components.Component.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>See source code</p> <p>This attribute configures what class is used to generate response from <code>Component.render_to_response()</code>.</p> <p>The response class should accept a string as the first argument.</p> <p>Defaults to <code>django.http.HttpResponse</code>.</p> <p>Example:</p> <pre><code>from django.http import HttpResponse\nfrom django_components import Component\n\nclass MyHttpResponse(HttpResponse):\n    ...\n\nclass MyComponent(Component):\n    response_class = MyHttpResponse\n\nresponse = MyComponent.render_to_response()\nassert isinstance(response, MyHttpResponse)\n</code></pre>"},{"location":"reference/api/#django_components.Component.template","title":"template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template: Optional[Union[str, Template]] = None\n</code></pre> <p>See source code</p> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_file</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    template = \"Hello, {{ name }}!\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"name\": \"World\"}\n</code></pre>"},{"location":"reference/api/#django_components.Component.template_file","title":"template_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_file: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be either:</p> <ul> <li>Relative to the directory where the Component's Python file is defined.</li> <li>Relative to one of the component directories, as set by   <code>COMPONENTS.dirs</code>   or   <code>COMPONENTS.app_dirs</code>   (e.g. <code>&lt;root&gt;/components/</code>).</li> <li>Relative to the template directories, as set by Django's <code>TEMPLATES</code> setting (e.g. <code>&lt;root&gt;/templates/</code>).</li> </ul> <p>Only one of <code>template_file</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    template_file = \"path/to/template.html\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\"name\": \"World\"}\n</code></pre>"},{"location":"reference/api/#django_components.Component.template_name","title":"template_name  <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str]\n</code></pre> <p>See source code</p> <p>Alias for <code>template_file</code>.</p> <p>For historical reasons, django-components used <code>template_name</code> to align with Django's TemplateView.</p> <p><code>template_file</code> was introduced to align with <code>js/js_file</code> and <code>css/css_file</code>.</p> <p>Setting and accessing this attribute is proxied to <code>template_file</code>.</p>"},{"location":"reference/api/#django_components.Component.view","title":"view  <code>instance-attribute</code>","text":"<pre><code>view: ComponentView\n</code></pre> <p>See source code</p> <p>Instance of <code>ComponentView</code> available at component render time.</p>"},{"location":"reference/api/#django_components.Component.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>See source code</p> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> <p>Read more on Component views and URLs.</p>"},{"location":"reference/api/#django_components.Component.get_context_data","title":"get_context_data","text":"<pre><code>get_context_data(*args: Any, **kwargs: Any) -&gt; Optional[Mapping]\n</code></pre> <p>See source code</p> <p>DEPRECATED: Use <code>get_template_data()</code> instead. Will be removed in v2.</p> <p>Use this method to define variables that will be available in the template.</p> <p>Receives the args and kwargs as they were passed to the Component.</p> <p>This method has access to the Render API.</p> <p>Read more about Template variables.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_context_data(self, name, *args, **kwargs):\n        return {\n            \"name\": name,\n            \"id\": self.id,\n        }\n\n    template = \"Hello, {{ name }}!\"\n\nMyComponent.render(name=\"World\")\n</code></pre> <p>Warning</p> <p><code>get_context_data()</code> and <code>get_template_data()</code> are mutually exclusive.</p> <p>If both methods return non-empty dictionaries, an error will be raised.</p>"},{"location":"reference/api/#django_components.Component.get_css_data","title":"get_css_data","text":"<pre><code>get_css_data(args: Any, kwargs: Any, slots: Any, context: Context) -&gt; Optional[Mapping]\n</code></pre> <p>See source code</p> <p>Use this method to define variables that will be available from within the component's CSS code.</p> <p>This method has access to the Render API.</p> <p>The data returned from this method will be serialized to string.</p> <p>Read more about CSS variables.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs[\"color\"],\n        }\n\n    css = '''\n        .my-class {\n            color: var(--color);\n        }\n    '''\n\nMyComponent.render(color=\"red\")\n</code></pre> <p>Args:</p> <ul> <li><code>args</code>: Positional arguments passed to the component.</li> <li><code>kwargs</code>: Keyword arguments passed to the component.</li> <li><code>slots</code>: Slots passed to the component.</li> <li><code>context</code>: <code>Context</code>    used for rendering the component template.</li> </ul> <p>Pass-through kwargs:</p> <p>It's best practice to explicitly define what args and kwargs a component accepts.</p> <p>However, if you want a looser setup, you can easily write components that accept any number of kwargs, and pass them all to the CSS code.</p> <p>To do that, simply return the <code>kwargs</code> dictionary itself from <code>get_css_data()</code>:</p> <pre><code>class MyComponent(Component):\n    def get_css_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre> <p>Type hints:</p> <p>To get type hints for the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters, you can define the <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes on the component class, and then directly reference them in the function signature of <code>get_css_data()</code>.</p> <p>When you set these classes, the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as instances of these (<code>args</code> instance of <code>Args</code>, etc).</p> <p>When you omit these classes, or set them to <code>None</code>, then the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as plain lists / dictionaries, unmodified.</p> <p>Read more on Typing and validation.</p> <p>Example:</p> <pre><code>from typing import NamedTuple\nfrom django.template import Context\nfrom django_components import Component, SlotInput\n\nclass MyComponent(Component):\n    class Args(NamedTuple):\n        color: str\n\n    class Kwargs(NamedTuple):\n        size: int\n\n    class Slots(NamedTuple):\n        footer: SlotInput\n\n    def get_css_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        assert isinstance(args, MyComponent.Args)\n        assert isinstance(kwargs, MyComponent.Kwargs)\n        assert isinstance(slots, MyComponent.Slots)\n\n        return {\n            \"color\": args.color,\n            \"size\": kwargs.size,\n        }\n</code></pre> <p>You can also add typing to the data returned from <code>get_css_data()</code> by defining the <code>CssData</code> class on the component class.</p> <p>When you set this class, you can return either the data as a plain dictionary, or an instance of <code>CssData</code>.</p> <p>If you return plain dictionary, the data will be validated against the <code>CssData</code> class by instantiating it with the dictionary.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class CssData(NamedTuple):\n        color: str\n        size: int\n\n    def get_css_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs[\"color\"],\n            \"size\": kwargs[\"size\"],\n        }\n        # or\n        return MyComponent.CssData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre>"},{"location":"reference/api/#django_components.Component.get_js_data","title":"get_js_data","text":"<pre><code>get_js_data(args: Any, kwargs: Any, slots: Any, context: Context) -&gt; Optional[Mapping]\n</code></pre> <p>See source code</p> <p>Use this method to define variables that will be available from within the component's JavaScript code.</p> <p>This method has access to the Render API.</p> <p>The data returned from this method will be serialized to JSON.</p> <p>Read more about JavaScript variables.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"name\": kwargs[\"name\"],\n            \"id\": self.id,\n        }\n\n    js = '''\n        $onLoad(({ name, id }) =&gt; {\n            console.log(name, id);\n        });\n    '''\n\nMyComponent.render(name=\"World\")\n</code></pre> <p>Args:</p> <ul> <li><code>args</code>: Positional arguments passed to the component.</li> <li><code>kwargs</code>: Keyword arguments passed to the component.</li> <li><code>slots</code>: Slots passed to the component.</li> <li><code>context</code>: <code>Context</code>    used for rendering the component template.</li> </ul> <p>Pass-through kwargs:</p> <p>It's best practice to explicitly define what args and kwargs a component accepts.</p> <p>However, if you want a looser setup, you can easily write components that accept any number of kwargs, and pass them all to the JavaScript code.</p> <p>To do that, simply return the <code>kwargs</code> dictionary itself from <code>get_js_data()</code>:</p> <pre><code>class MyComponent(Component):\n    def get_js_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre> <p>Type hints:</p> <p>To get type hints for the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters, you can define the <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes on the component class, and then directly reference them in the function signature of <code>get_js_data()</code>.</p> <p>When you set these classes, the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as instances of these (<code>args</code> instance of <code>Args</code>, etc).</p> <p>When you omit these classes, or set them to <code>None</code>, then the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as plain lists / dictionaries, unmodified.</p> <p>Read more on Typing and validation.</p> <p>Example:</p> <pre><code>from typing import NamedTuple\nfrom django.template import Context\nfrom django_components import Component, SlotInput\n\nclass MyComponent(Component):\n    class Args(NamedTuple):\n        color: str\n\n    class Kwargs(NamedTuple):\n        size: int\n\n    class Slots(NamedTuple):\n        footer: SlotInput\n\n    def get_js_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        assert isinstance(args, MyComponent.Args)\n        assert isinstance(kwargs, MyComponent.Kwargs)\n        assert isinstance(slots, MyComponent.Slots)\n\n        return {\n            \"color\": args.color,\n            \"size\": kwargs.size,\n            \"id\": self.id,\n        }\n</code></pre> <p>You can also add typing to the data returned from <code>get_js_data()</code> by defining the <code>JsData</code> class on the component class.</p> <p>When you set this class, you can return either the data as a plain dictionary, or an instance of <code>JsData</code>.</p> <p>If you return plain dictionary, the data will be validated against the <code>JsData</code> class by instantiating it with the dictionary.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class JsData(NamedTuple):\n        color: str\n        size: int\n\n    def get_js_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs[\"color\"],\n            \"size\": kwargs[\"size\"],\n        }\n        # or\n        return MyComponent.JsData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre>"},{"location":"reference/api/#django_components.Component.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>See source code</p> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_file</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/api/#django_components.Component.get_template_data","title":"get_template_data","text":"<pre><code>get_template_data(args: Any, kwargs: Any, slots: Any, context: Context) -&gt; Optional[Mapping]\n</code></pre> <p>See source code</p> <p>Use this method to define variables that will be available in the template.</p> <p>This method has access to the Render API.</p> <p>Read more about Template variables.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"name\": kwargs[\"name\"],\n            \"id\": self.id,\n        }\n\n    template = \"Hello, {{ name }}!\"\n\nMyComponent.render(name=\"World\")\n</code></pre> <p>Args:</p> <ul> <li><code>args</code>: Positional arguments passed to the component.</li> <li><code>kwargs</code>: Keyword arguments passed to the component.</li> <li><code>slots</code>: Slots passed to the component.</li> <li><code>context</code>: <code>Context</code>    used for rendering the component template.</li> </ul> <p>Pass-through kwargs:</p> <p>It's best practice to explicitly define what args and kwargs a component accepts.</p> <p>However, if you want a looser setup, you can easily write components that accept any number of kwargs, and pass them all to the template (similar to django-cotton).</p> <p>To do that, simply return the <code>kwargs</code> dictionary itself from <code>get_template_data()</code>:</p> <pre><code>class MyComponent(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return kwargs\n</code></pre> <p>Type hints:</p> <p>To get type hints for the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters, you can define the <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes on the component class, and then directly reference them in the function signature of <code>get_template_data()</code>.</p> <p>When you set these classes, the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as instances of these (<code>args</code> instance of <code>Args</code>, etc).</p> <p>When you omit these classes, or set them to <code>None</code>, then the <code>args</code>, <code>kwargs</code>, and <code>slots</code> parameters will be given as plain lists / dictionaries, unmodified.</p> <p>Read more on Typing and validation.</p> <p>Example:</p> <pre><code>from typing import NamedTuple\nfrom django.template import Context\nfrom django_components import Component, SlotInput\n\nclass MyComponent(Component):\n    class Args(NamedTuple):\n        color: str\n\n    class Kwargs(NamedTuple):\n        size: int\n\n    class Slots(NamedTuple):\n        footer: SlotInput\n\n    def get_template_data(self, args: Args, kwargs: Kwargs, slots: Slots, context: Context):\n        assert isinstance(args, MyComponent.Args)\n        assert isinstance(kwargs, MyComponent.Kwargs)\n        assert isinstance(slots, MyComponent.Slots)\n\n        return {\n            \"color\": args.color,\n            \"size\": kwargs.size,\n            \"id\": self.id,\n        }\n</code></pre> <p>You can also add typing to the data returned from <code>get_template_data()</code> by defining the <code>TemplateData</code> class on the component class.</p> <p>When you set this class, you can return either the data as a plain dictionary, or an instance of <code>TemplateData</code>.</p> <p>If you return plain dictionary, the data will be validated against the <code>TemplateData</code> class by instantiating it with the dictionary.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class TemplateData(NamedTuple):\n        color: str\n        size: int\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"color\": kwargs[\"color\"],\n            \"size\": kwargs[\"size\"],\n        }\n        # or\n        return MyComponent.TemplateData(\n            color=kwargs[\"color\"],\n            size=kwargs[\"size\"],\n        )\n</code></pre> <p>Warning</p> <p><code>get_template_data()</code> and <code>get_context_data()</code> are mutually exclusive.</p> <p>If both methods return non-empty dictionaries, an error will be raised.</p>"},{"location":"reference/api/#django_components.Component.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_file</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/api/#django_components.Component.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>See source code</p> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>{% provide %}</code> tag with given key was NOT found.</p> <p>This method is part of the Render API, and raises an error if called from outside the rendering execution.</p> <p>Read more about Provide / Inject.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"my_provide\" message=\"hello\" %}\n    {% component \"my_comp\" / %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ message }}!\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        data = self.inject(\"my_provide\")\n        message = data.message\n        return {\"message\": message}\n</code></pre></p> <p>This renders into: <pre><code>hi hello!\n</code></pre></p> <p>As the <code>{{ message }}</code> is taken from the \"my_provide\" provider.</p>"},{"location":"reference/api/#django_components.Component.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>See source code</p> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p>"},{"location":"reference/api/#django_components.Component.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>See source code</p> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p>"},{"location":"reference/api/#django_components.Component.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[Any] = None,\n    kwargs: Optional[Any] = None,\n    slots: Optional[Any] = None,\n    escape_slots_content: bool = True,\n    deps_strategy: DependenciesStrategy = \"document\",\n    type: Optional[DependenciesStrategy] = None,\n    render_dependencies: bool = True,\n    request: Optional[HttpRequest] = None,\n) -&gt; str\n</code></pre> <p>See source code</p> <p>Render the component into a string. This is the equivalent of calling the <code>{% component %}</code> tag.</p> <pre><code>Button.render(\n    args=[\"John\"],\n    kwargs={\n        \"surname\": \"Doe\",\n        \"age\": 30,\n    },\n    slots={\n        \"footer\": \"i AM A SLOT\",\n    },\n)\n</code></pre> <p>Inputs:</p> <ul> <li> <p><code>args</code> - Optional. A list of positional args for the component. This is the same as calling the component   as:</p> <pre><code>{% component \"button\" arg1 arg2 ... %}\n</code></pre> </li> <li> <p><code>kwargs</code> - Optional. A dictionary of keyword arguments for the component. This is the same as calling   the component as:</p> <pre><code>{% component \"button\" key1=val1 key2=val2 ... %}\n</code></pre> </li> <li> <p><code>slots</code> - Optional. A dictionary of slot fills. This is the same as passing <code>{% fill %}</code>     tags to the component.</p> <pre><code>{% component \"button\" %}\n    {% fill \"content\" %}\n        Click me!\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Dictionary keys are the slot names. Dictionary values are the slot fills.</p> <p>Slot fills can be strings, render functions, or <code>Slot</code> instances:</p> <pre><code>Button.render(\n    slots={\n        \"content\": \"Click me!\"\n        \"content2\": lambda *a, **kwa: \"Click me!\",\n        \"content3\": Slot(lambda *a, **kwa: \"Click me!\"),\n    },\n)\n</code></pre> </li> <li> <p><code>context</code> - Optional. Plain dictionary or Django's     Context.     The context within which the component is rendered.</p> <p>When a component is rendered within a template with the <code>{% component %}</code> tag, this will be set to the Context instance that is used for rendering the template.</p> <p>When you call <code>Component.render()</code> directly from Python, you can ignore this input most of the time. Instead use <code>args</code>, <code>kwargs</code>, and <code>slots</code> to pass data to the component.</p> <p>You can pass <code>RequestContext</code> to the <code>context</code> argument, so that the component will gain access to the request object and will use context processors. Read more on Working with HTTP requests.</p> <pre><code>Button.render(\n    context=RequestContext(request),\n)\n</code></pre> <p>For advanced use cases, you can use <code>context</code> argument to \"pre-render\" the component in Python, and then pass the rendered output as plain string to the template. With this, the inner component is rendered as if it was within the template with <code>{% component %}</code>.</p> <pre><code>class Button(Component):\n    def render(self, context, template):\n        # Pass `context` to Icon component so it is rendered\n        # as if nested within Button.\n        icon = Icon.render(\n            context=context,\n            args=[\"icon-name\"],\n            render_dependencies=False,\n        )\n        # Update context with icon\n        with context.update({\"icon\": icon}):\n            return template.render(context)\n</code></pre> <p>Whether the variables defined in <code>context</code> are available to the template depends on the context behavior mode:</p> <ul> <li> <p>In <code>\"django\"</code> context behavior mode, the template will have access to the keys of this context.</p> </li> <li> <p>In <code>\"isolated\"</code> context behavior mode, the template will NOT have access to this context,     and data MUST be passed via component's args and kwargs.</p> </li> </ul> </li> <li> <p><code>deps_strategy</code> - Optional. Configure how to handle JS and CSS dependencies. Read more about     Dependencies rendering.</p> <p>There are five strategies:</p> <ul> <li><code>\"document\"</code> (default)<ul> <li>Smartly inserts JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>Inserts extra script to allow <code>fragment</code> types to work.</li> <li>Assumes the HTML will be rendered in a JS-enabled browser.</li> </ul> </li> <li><code>\"fragment\"</code><ul> <li>A lightweight HTML fragment to be inserted into a document with AJAX.</li> <li>No JS / CSS included.</li> </ul> </li> <li><code>\"simple\"</code><ul> <li>Smartly insert JS / CSS into placeholders or into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"prepend\"</code><ul> <li>Insert JS / CSS before the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> <li><code>\"append\"</code><ul> <li>Insert JS / CSS after the rendered HTML.</li> <li>No extra script loaded.</li> </ul> </li> </ul> </li> <li> <p><code>request</code> - Optional. HTTPRequest object. Pass a request object directly to the component to apply     context processors.</p> <p>Read more about Working with HTTP requests.</p> </li> <li> <p><code>escape_slots_content</code> - Optional. Whether the content from <code>slots</code> should be escaped with Django's     <code>escape</code>.     Defaults to <code>True</code>.</p> </li> <li> <p><code>render_dependencies</code> - Optional. Whether the output should be processed to finalize JS and CSS dependencies.     Defaults to <code>True</code>.</p> <p>Set this to <code>False</code> if you want to insert the resulting HTML into another component:</p> <pre><code>html = Button.render(\n    render_dependencies=False,\n)\n\n# Insert the resulting HTML into another component\nMyOtherComponent.render(\n    content=html,\n)\n</code></pre> </li> </ul> <p>Type hints:</p> <p><code>Component.render()</code> is NOT typed. To add type hints, you can wrap the inputs in component's <code>Args</code>, <code>Kwargs</code>, and <code>Slots</code> classes.</p> <p>Read more on Typing and validation.</p> <pre><code>from typing import NamedTuple, Optional\nfrom django_components import Component, Slot, SlotInput\n\n# Define the component with the types\nclass Button(Component):\n    class Args(NamedTuple):\n        name: str\n\n    class Kwargs(NamedTuple):\n        surname: str\n        age: int\n\n    class Slots(NamedTuple):\n        my_slot: Optional[SlotInput] = None\n        footer: SlotInput\n\n# Add type hints to the render call\nButton.render(\n    args=Button.Args(\n        name=\"John\",\n    ),\n    kwargs=Button.Kwargs(\n        surname=\"Doe\",\n        age=30,\n    ),\n    slots=Button.Slots(\n        footer=Slot(lambda *a, **kwa: \"Click me!\"),\n    ),\n)\n</code></pre>"},{"location":"reference/api/#django_components.Component.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[Any] = None,\n    kwargs: Optional[Any] = None,\n    slots: Optional[Any] = None,\n    escape_slots_content: bool = True,\n    deps_strategy: DependenciesStrategy = \"document\",\n    type: Optional[DependenciesStrategy] = None,\n    render_dependencies: bool = True,\n    request: Optional[HttpRequest] = None,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>See source code</p> <p>Render the component and wrap the content in an HTTP response class.</p> <p><code>render_to_response()</code> takes the same inputs as <code>Component.render()</code>. See that method for more information.</p> <p>After the component is rendered, the HTTP response class is instantiated with the rendered content.</p> <p>Any additional kwargs are passed to the response class.</p> <p>Example:</p> <pre><code>Button.render_to_response(\n    args=[\"John\"],\n    kwargs={\n        \"surname\": \"Doe\",\n        \"age\": 30,\n    },\n    slots={\n        \"footer\": \"i AM A SLOT\",\n    },\n    # HttpResponse kwargs\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre> <p>Custom response class:</p> <p>You can set a custom response class on the component via <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <pre><code>from django.http import HttpResponse\nfrom django_components import Component\n\nclass MyHttpResponse(HttpResponse):\n    ...\n\nclass MyComponent(Component):\n    response_class = MyHttpResponse\n\nresponse = MyComponent.render_to_response()\nassert isinstance(response, MyHttpResponse)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache","title":"ComponentCache","text":"<p>Bases: <code>django_components.extension.BaseExtensionClass</code></p> <p>See source code</p> <p>The interface for <code>Component.Cache</code>.</p> <p>The fields of this class are used to configure the component caching.</p> <p>Read more about Component caching.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class Cache:\n        enabled = True\n        ttl = 60 * 60 * 24  # 1 day\n        cache_name = \"my_cache\"\n</code></pre> <p>Methods:</p> <ul> <li> <code>get_cache</code>             \u2013              </li> <li> <code>get_cache_key</code>             \u2013              </li> <li> <code>get_entry</code>             \u2013              </li> <li> <code>hash</code>             \u2013              </li> <li> <code>set_entry</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cache_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>enabled</code>               (<code>bool</code>)           \u2013            </li> <li> <code>ttl</code>               (<code>Optional[int]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentCache.cache_name","title":"cache_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The name of the cache to use. If <code>None</code>, the default cache will be used.</p>"},{"location":"reference/api/#django_components.ComponentCache.enabled","title":"enabled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enabled: bool = False\n</code></pre> <p>See source code</p> <p>Whether this Component should be cached. Defaults to <code>False</code>.</p>"},{"location":"reference/api/#django_components.ComponentCache.ttl","title":"ttl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ttl: Optional[int] = None\n</code></pre> <p>See source code</p> <p>The time-to-live (TTL) in seconds, i.e. for how long should an entry be valid in the cache.</p> <ul> <li>If <code>&gt; 0</code>, the entries will be cached for the given number of seconds.</li> <li>If <code>-1</code>, the entries will be cached indefinitely.</li> <li>If <code>0</code>, the entries won't be cached.</li> <li>If <code>None</code>, the default TTL will be used.</li> </ul>"},{"location":"reference/api/#django_components.ComponentCache.get_cache","title":"get_cache","text":"<pre><code>get_cache() -&gt; BaseCache\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache.get_cache_key","title":"get_cache_key","text":"<pre><code>get_cache_key(*args: Any, **kwargs: Any) -&gt; str\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache.get_entry","title":"get_entry","text":"<pre><code>get_entry(cache_key: str) -&gt; Any\n</code></pre>"},{"location":"reference/api/#django_components.ComponentCache.hash","title":"hash","text":"<pre><code>hash(*args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>See source code</p> <p>Defines how the input (both args and kwargs) is hashed into a cache key.</p> <p>By default, <code>hash()</code> serializes the input into a string. As such, the default implementation might NOT be suitable if you need to hash complex objects.</p>"},{"location":"reference/api/#django_components.ComponentCache.set_entry","title":"set_entry","text":"<pre><code>set_entry(cache_key: str, value: Any) -&gt; None\n</code></pre>"},{"location":"reference/api/#django_components.ComponentDefaults","title":"ComponentDefaults","text":"<p>Bases: <code>django_components.extension.BaseExtensionClass</code></p> <p>See source code</p> <p>The interface for <code>Component.Defaults</code>.</p> <p>The fields of this class are used to set default values for the component's kwargs.</p> <p>Read more about Component defaults.</p> <p>Example:</p> <pre><code>from django_components import Component, Default\n\nclass MyComponent(Component):\n    class Defaults:\n        position = \"left\"\n        selected_items = Default(lambda: [1, 2, 3])\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension","title":"ComponentExtension","text":"<p>Bases: <code>object</code></p> <p>See source code</p> <p>Base class for all extensions.</p> <p>Read more on Extensions.</p> <p>Methods:</p> <ul> <li> <code>on_component_class_created</code>             \u2013              </li> <li> <code>on_component_class_deleted</code>             \u2013              </li> <li> <code>on_component_data</code>             \u2013              </li> <li> <code>on_component_input</code>             \u2013              </li> <li> <code>on_component_registered</code>             \u2013              </li> <li> <code>on_component_rendered</code>             \u2013              </li> <li> <code>on_component_unregistered</code>             \u2013              </li> <li> <code>on_registry_created</code>             \u2013              </li> <li> <code>on_registry_deleted</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>ExtensionClass</code>           \u2013            </li> <li> <code>class_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>commands</code>               (<code>List[Type[ComponentCommand]]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>urls</code>               (<code>List[URLRoute]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentExtension.ExtensionClass","title":"ExtensionClass  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ExtensionClass = BaseExtensionClass\n</code></pre> <p>See source code</p> <p>Base class that the \"extension class\" nested within a <code>Component</code> class will inherit from.</p> <p>This is where you can define new methods and attributes that will be available to the component instance.</p> <p>Background:</p> <p>The extension may add new features to the <code>Component</code> class by allowing users to define and access a nested class in the <code>Component</code> class. E.g.:</p> <pre><code>class MyComp(Component):\n    class MyExtension:\n        ...\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"my_extension\": self.my_extension.do_something(),\n        }\n</code></pre> <p>When rendering a component, the nested extension class will be set as a subclass of <code>ExtensionClass</code>. So it will be same as if the user had directly inherited from <code>ExtensionClass</code>. E.g.:</p> <pre><code>class MyComp(Component):\n    class MyExtension(ComponentExtension.ExtensionClass):\n        ...\n</code></pre> <p>This setting decides what the extension class will inherit from.</p>"},{"location":"reference/api/#django_components.ComponentExtension.class_name","title":"class_name  <code>instance-attribute</code>","text":"<pre><code>class_name: str\n</code></pre> <p>See source code</p> <p>Name of the extension class.</p> <p>By default, this is the same as <code>name</code>, but with snake_case converted to PascalCase.</p> <p>So if the extension name is <code>\"my_extension\"</code>, then the extension class name will be <code>\"MyExtension\"</code>.</p> <pre><code>class MyComp(Component):\n    class MyExtension:  # &lt;--- This is the extension class\n        ...\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.commands","title":"commands  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>commands: List[Type[ComponentCommand]] = []\n</code></pre> <p>See source code</p> <p>List of commands that can be run by the extension.</p> <p>These commands will be available to the user as <code>components ext run &lt;extension&gt; &lt;command&gt;</code>.</p> <p>Commands are defined as subclasses of <code>ComponentCommand</code>.</p> <p>Example:</p> <p>This example defines an extension with a command that prints \"Hello world\". To run the command, the user would run <code>components ext run hello_world hello</code>.</p> <pre><code>from django_components import ComponentCommand, ComponentExtension, CommandArg, CommandArgGroup\n\nclass HelloWorldCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Hello world command.\"\n\n    # Allow to pass flags `--foo`, `--bar` and `--baz`.\n    # Argument parsing is managed by `argparse`.\n    arguments = [\n        CommandArg(\n            name_or_flags=\"--foo\",\n            help=\"Foo description.\",\n        ),\n        # When printing the command help message, `bar` and `baz`\n        # will be grouped under \"group bar\".\n        CommandArgGroup(\n            title=\"group bar\",\n            description=\"Group description.\",\n            arguments=[\n                CommandArg(\n                    name_or_flags=\"--bar\",\n                    help=\"Bar description.\",\n                ),\n                CommandArg(\n                    name_or_flags=\"--baz\",\n                    help=\"Baz description.\",\n                ),\n            ],\n        ),\n    ]\n\n    # Callback that receives the parsed arguments and options.\n    def handle(self, *args, **kwargs):\n        print(f\"HelloWorldCommand.handle: args={args}, kwargs={kwargs}\")\n\n# Associate the command with the extension\nclass HelloWorldExtension(ComponentExtension):\n    name = \"hello_world\"\n\n    commands = [\n        HelloWorldCommand,\n    ]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>Name of the extension.</p> <p>Name must be lowercase, and must be a valid Python identifier (e.g. <code>\"my_extension\"</code>).</p> <p>The extension may add new features to the <code>Component</code> class by allowing users to define and access a nested class in the <code>Component</code> class.</p> <p>The extension name determines the name of the nested class in the <code>Component</code> class, and the attribute under which the extension will be accessible.</p> <p>E.g. if the extension name is <code>\"my_extension\"</code>, then the nested class in the <code>Component</code> class will be <code>MyExtension</code>, and the extension will be accessible as <code>MyComp.my_extension</code>.</p> <pre><code>class MyComp(Component):\n    class MyExtension:\n        ...\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"my_extension\": self.my_extension.do_something(),\n        }\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.urls","title":"urls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>urls: List[URLRoute] = []\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_class_created","title":"on_component_class_created","text":"<pre><code>on_component_class_created(ctx: OnComponentClassCreatedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a new <code>Component</code> class is created.</p> <p>This hook is called after the <code>Component</code> class is fully defined but before it's registered.</p> <p>Use this hook to perform any initialization or validation of the <code>Component</code> class.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentClassCreatedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext) -&gt; None:\n        # Add a new attribute to the Component class\n        ctx.component_cls.my_attr = \"my_value\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_class_deleted","title":"on_component_class_deleted","text":"<pre><code>on_component_class_deleted(ctx: OnComponentClassDeletedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is being deleted.</p> <p>This hook is called before the <code>Component</code> class is deleted from memory.</p> <p>Use this hook to perform any cleanup related to the <code>Component</code> class.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentClassDeletedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_class_deleted(self, ctx: OnComponentClassDeletedContext) -&gt; None:\n        # Remove Component class from the extension's cache on deletion\n        self.cache.pop(ctx.component_cls, None)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_data","title":"on_component_data","text":"<pre><code>on_component_data(ctx: OnComponentDataContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was triggered to render, after a component's context and data methods have been processed.</p> <p>This hook is called after <code>Component.get_template_data()</code>, <code>Component.get_js_data()</code> and <code>Component.get_css_data()</code>.</p> <p>This hook runs after <code>on_component_input</code>.</p> <p>Use this hook to modify or validate the component's data before rendering.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentDataContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_data(self, ctx: OnComponentDataContext) -&gt; None:\n        # Add extra template variable to all components when they are rendered\n        ctx.template_data[\"my_template_var\"] = \"my_value\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_input","title":"on_component_input","text":"<pre><code>on_component_input(ctx: OnComponentInputContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was triggered to render, but before a component's context and data methods are invoked.</p> <p>Use this hook to modify or validate component inputs before they're processed.</p> <p>This is the first hook that is called when rendering a component. As such this hook is called before <code>Component.get_template_data()</code>, <code>Component.get_js_data()</code>, and <code>Component.get_css_data()</code> methods, and the <code>on_component_data</code> hook.</p> <p>This hook also allows to skip the rendering of a component altogether. If the hook returns a non-null value, this value will be used instead of rendering the component.</p> <p>You can use this to implement a caching mechanism for components, or define components that will be rendered conditionally.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentInputContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_input(self, ctx: OnComponentInputContext) -&gt; None:\n        # Add extra kwarg to all components when they are rendered\n        ctx.kwargs[\"my_input\"] = \"my_value\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_registered","title":"on_component_registered","text":"<pre><code>on_component_registered(ctx: OnComponentRegisteredContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is registered with a <code>ComponentRegistry</code>.</p> <p>This hook is called after a <code>Component</code> class is successfully registered.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentRegisteredContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_registered(self, ctx: OnComponentRegisteredContext) -&gt; None:\n        print(f\"Component {ctx.component_cls} registered to {ctx.registry} as '{ctx.name}'\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_rendered","title":"on_component_rendered","text":"<pre><code>on_component_rendered(ctx: OnComponentRenderedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was rendered, including all its child components.</p> <p>Use this hook to access or post-process the component's rendered output.</p> <p>To modify the output, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_rendered(self, ctx: OnComponentRenderedContext) -&gt; Optional[str]:\n        # Append a comment to the component's rendered output\n        return ctx.result + \"&lt;!-- MyExtension comment --&gt;\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_component_unregistered","title":"on_component_unregistered","text":"<pre><code>on_component_unregistered(ctx: OnComponentUnregisteredContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is unregistered from a <code>ComponentRegistry</code>.</p> <p>This hook is called after a <code>Component</code> class is removed from the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentUnregisteredContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_unregistered(self, ctx: OnComponentUnregisteredContext) -&gt; None:\n        print(f\"Component {ctx.component_cls} unregistered from {ctx.registry} as '{ctx.name}'\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_registry_created","title":"on_registry_created","text":"<pre><code>on_registry_created(ctx: OnRegistryCreatedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a new <code>ComponentRegistry</code> is created.</p> <p>This hook is called after a new <code>ComponentRegistry</code> instance is initialized.</p> <p>Use this hook to perform any initialization needed for the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnRegistryCreatedContext\n\nclass MyExtension(ComponentExtension):\n    def on_registry_created(self, ctx: OnRegistryCreatedContext) -&gt; None:\n        # Add a new attribute to the registry\n        ctx.registry.my_attr = \"my_value\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentExtension.on_registry_deleted","title":"on_registry_deleted","text":"<pre><code>on_registry_deleted(ctx: OnRegistryDeletedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>ComponentRegistry</code> is being deleted.</p> <p>This hook is called before a <code>ComponentRegistry</code> instance is deleted.</p> <p>Use this hook to perform any cleanup related to the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnRegistryDeletedContext\n\nclass MyExtension(ComponentExtension):\n    def on_registry_deleted(self, ctx: OnRegistryDeletedContext) -&gt; None:\n        # Remove registry from the extension's cache on deletion\n        self.cache.pop(ctx.registry, None)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentFileEntry","title":"ComponentFileEntry","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Result returned by <code>get_component_files()</code>.</p> <p>Attributes:</p> <ul> <li> <code>dot_path</code>               (<code>str</code>)           \u2013            </li> <li> <code>filepath</code>               (<code>Path</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentFileEntry.dot_path","title":"dot_path  <code>instance-attribute</code>","text":"<pre><code>dot_path: str\n</code></pre> <p>See source code</p> <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p>"},{"location":"reference/api/#django_components.ComponentFileEntry.filepath","title":"filepath  <code>instance-attribute</code>","text":"<pre><code>filepath: Path\n</code></pre> <p>See source code</p> <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p>"},{"location":"reference/api/#django_components.ComponentInput","title":"ComponentInput  <code>dataclass</code>","text":"<pre><code>ComponentInput(\n    context: Context,\n    args: List,\n    kwargs: Dict,\n    slots: Dict[SlotName, Slot],\n    deps_strategy: DependenciesStrategy,\n    type: DependenciesStrategy,\n    render_dependencies: bool,\n)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Object holding the inputs that were passed to <code>Component.render()</code> or the <code>{% component %}</code> template tag.</p> <p>This object is available only during render under <code>Component.input</code>.</p> <p>Read more about the Render API.</p> <p>This class can be typed as:</p> <p>Attributes:</p> <ul> <li> <code>args</code>               (<code>List</code>)           \u2013            </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            </li> <li> <code>deps_strategy</code>               (<code>DependenciesStrategy</code>)           \u2013            </li> <li> <code>kwargs</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>render_dependencies</code>               (<code>bool</code>)           \u2013            </li> <li> <code>slots</code>               (<code>Dict[SlotName, Slot]</code>)           \u2013            </li> <li> <code>type</code>               (<code>DependenciesStrategy</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentInput.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: List\n</code></pre>"},{"location":"reference/api/#django_components.ComponentInput.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Context\n</code></pre>"},{"location":"reference/api/#django_components.ComponentInput.deps_strategy","title":"deps_strategy  <code>instance-attribute</code>","text":"<pre><code>deps_strategy: DependenciesStrategy\n</code></pre>"},{"location":"reference/api/#django_components.ComponentInput.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: Dict\n</code></pre>"},{"location":"reference/api/#django_components.ComponentInput.render_dependencies","title":"render_dependencies  <code>instance-attribute</code>","text":"<pre><code>render_dependencies: bool\n</code></pre>"},{"location":"reference/api/#django_components.ComponentInput.slots","title":"slots  <code>instance-attribute</code>","text":"<pre><code>slots: Dict[SlotName, Slot]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentInput.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: DependenciesStrategy\n</code></pre> <p>See source code</p> <p>Deprecated alias for <code>deps_strategy</code>.</p>"},{"location":"reference/api/#django_components.ComponentMediaInput","title":"ComponentMediaInput","text":"<p>Bases: <code>typing.Protocol</code></p> <p>See source code</p> <p>Defines JS and CSS media files associated with a <code>Component</code>.</p> <pre><code>class MyTable(Component):\n    class Media:\n        js = [\n            \"path/to/script.js\",\n            \"https://unpkg.com/alpinejs@3.14.7/dist/cdn.min.js\",  # AlpineJS\n        ]\n        css = {\n            \"all\": [\n                \"path/to/style.css\",\n                \"https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\",  # TailwindCSS\n            ],\n            \"print\": [\"path/to/style2.css\"],\n        }\n</code></pre> <p>Attributes:</p> <ul> <li> <code>css</code>               (<code>Optional[Union[ComponentMediaInputPath, List[ComponentMediaInputPath], Dict[str, ComponentMediaInputPath], Dict[str, List[ComponentMediaInputPath]]]]</code>)           \u2013            </li> <li> <code>extend</code>               (<code>Union[bool, List[Type[Component]]]</code>)           \u2013            </li> <li> <code>js</code>               (<code>Optional[Union[ComponentMediaInputPath, List[ComponentMediaInputPath]]]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentMediaInput.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[\n    Union[\n        ComponentMediaInputPath, List[ComponentMediaInputPath], Dict[str, ComponentMediaInputPath], Dict[str, List[ComponentMediaInputPath]]\n    ]\n] = None\n</code></pre> <p>See source code</p> <p>CSS files associated with a <code>Component</code>.</p> <ul> <li> <p>If a string, it's assumed to be a path to a CSS file.</p> </li> <li> <p>If a list, each entry is assumed to be a path to a CSS file.</p> </li> <li> <p>If a dict, the keys are media types (e.g. \"all\", \"print\", \"screen\", etc.), and the values are either:</p> <ul> <li>A string, assumed to be a path to a CSS file.</li> <li>A list, each entry is assumed to be a path to a CSS file.</li> </ul> </li> </ul> <p>Each entry can be a string, bytes, SafeString, PathLike, or a callable that returns one of the former (see <code>ComponentMediaInputPath</code>).</p> <p>Examples: <pre><code>class MyComponent(Component):\n    class Media:\n        css = \"path/to/style.css\"\n</code></pre></p> <pre><code>class MyComponent(Component):\n    class Media:\n        css = [\"path/to/style1.css\", \"path/to/style2.css\"]\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": \"path/to/style.css\",\n            \"print\": \"path/to/print.css\",\n        }\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": [\"path/to/style1.css\", \"path/to/style2.css\"],\n            \"print\": \"path/to/print.css\",\n        }\n</code></pre>"},{"location":"reference/api/#django_components.ComponentMediaInput.extend","title":"extend  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extend: Union[bool, List[Type[Component]]] = True\n</code></pre> <p>See source code</p> <p>Configures whether the component should inherit the media files from the parent component.</p> <ul> <li>If <code>True</code>, the component inherits the media files from the parent component.</li> <li>If <code>False</code>, the component does not inherit the media files from the parent component.</li> <li>If a list of components classes, the component inherits the media files ONLY from these specified components.</li> </ul> <p>Read more in Media inheritance section.</p> <p>Example:</p> <p>Disable media inheritance:</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        extend = False  # Don't inherit parent media\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"script.js\"]\n</code></pre> <p>Specify which components to inherit from. In this case, the media files are inherited ONLY from the specified components, and NOT from the original parent components:</p> <pre><code>class ParentComponent(Component):\n    class Media:\n        js = [\"parent.js\"]\n\nclass MyComponent(ParentComponent):\n    class Media:\n        # Only inherit from these, ignoring the files from the parent\n        extend = [OtherComponent1, OtherComponent2]\n\n        js = [\"script.js\"]\n\nprint(MyComponent.media._js)  # [\"script.js\", \"other1.js\", \"other2.js\"]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentMediaInput.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[Union[ComponentMediaInputPath, List[ComponentMediaInputPath]]] = None\n</code></pre> <p>See source code</p> <p>JS files associated with a <code>Component</code>.</p> <ul> <li> <p>If a string, it's assumed to be a path to a JS file.</p> </li> <li> <p>If a list, each entry is assumed to be a path to a JS file.</p> </li> </ul> <p>Each entry can be a string, bytes, SafeString, PathLike, or a callable that returns one of the former (see <code>ComponentMediaInputPath</code>).</p> <p>Examples: <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"path/to/script.js\"\n</code></pre></p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = [\"path/to/script1.js\", \"path/to/script2.js\"]\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        js = lambda: [\"path/to/script1.js\", \"path/to/script2.js\"]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentMediaInputPath","title":"ComponentMediaInputPath  <code>module-attribute</code>","text":"<pre><code>ComponentMediaInputPath = Union[str, bytes, SafeData, Path, PathLike, Callable[[], Union[str, bytes, SafeData, Path, PathLike]]]\n</code></pre> <p>See source code</p> <p>A type representing an entry in Media.js or Media.css.</p> <p>If an entry is a SafeString (or has <code>__html__</code> method), then entry is assumed to be a formatted HTML tag. Otherwise, it's assumed to be a path to a file.</p> <p>Example:</p> <pre><code>class MyComponent\n    class Media:\n        js = [\n            \"path/to/script.js\",\n            b\"script.js\",\n            SafeString(\"&lt;script src='path/to/script.js'&gt;&lt;/script&gt;\"),\n        ]\n        css = [\n            Path(\"path/to/style.css\"),\n            lambda: \"path/to/style.css\",\n            lambda: Path(\"path/to/style.css\"),\n        ]\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry","title":"ComponentRegistry","text":"<pre><code>ComponentRegistry(\n    library: Optional[Library] = None, settings: Optional[Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]] = None\n)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Manages components and makes them available in the template, by default as <code>{% component %}</code> tags.</p> <pre><code>{% component \"my_comp\" key=value %}\n{% endcomponent %}\n</code></pre> <p>To enable a component to be used in a template, the component must be registered with a component registry.</p> <p>When you register a component to a registry, behind the scenes the registry automatically adds the component's template tag (e.g. <code>{% component %}</code> to the <code>Library</code>. And the opposite happens when you unregister a component - the tag is removed.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>, default:                   <code>None</code> )           \u2013            <p>Django            <code>Library</code>            associated with this registry. If omitted, the default Library instance from django_components is used.</p> </li> <li> <code>settings</code>               (<code>Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]</code>, default:                   <code>None</code> )           \u2013            <p>Configure            how the components registered with this registry will behave when rendered.            See <code>RegistrySettings</code>. Can be either            a static value or a callable that returns the settings. If omitted, the settings from            <code>COMPONENTS</code> are used.</p> </li> </ul> <p>Notes:</p> <ul> <li>The default registry is available as <code>django_components.registry</code>.</li> <li>The default registry is used when registering components with <code>@register</code> decorator.</li> </ul> <p>Example:</p> <pre><code># Use with default Library\nregistry = ComponentRegistry()\n\n# Or a custom one\nmy_lib = Library()\nregistry = ComponentRegistry(library=my_lib)\n\n# Usage\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\nregistry.all()\nregistry.clear()\nregistry.get(\"button\")\nregistry.has(\"button\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry--using-registry-to-share-components","title":"Using registry to share components","text":"<p>You can use component registry for isolating or \"packaging\" components:</p> <ol> <li> <p>Create new instance of <code>ComponentRegistry</code> and Library:     <pre><code>my_comps = Library()\nmy_comps_reg = ComponentRegistry(library=my_comps)\n</code></pre></p> </li> <li> <p>Register components to the registry:     <pre><code>my_comps_reg.register(\"my_button\", ButtonComponent)\nmy_comps_reg.register(\"my_card\", CardComponent)\n</code></pre></p> </li> <li> <p>In your target project, load the Library associated with the registry:     <pre><code>{% load my_comps %}\n</code></pre></p> </li> <li> <p>Use the registered components in your templates:     <pre><code>{% component \"button\" %}\n{% endcomponent %}\n</code></pre></p> </li> </ol> <p>Methods:</p> <ul> <li> <code>all</code>             \u2013              </li> <li> <code>clear</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>has</code>             \u2013              </li> <li> <code>register</code>             \u2013              </li> <li> <code>unregister</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            </li> <li> <code>settings</code>               (<code>InternalRegistrySettings</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentRegistry.library","title":"library  <code>property</code>","text":"<pre><code>library: Library\n</code></pre> <p>See source code</p> <p>The template tag <code>Library</code> that is associated with the registry.</p>"},{"location":"reference/api/#django_components.ComponentRegistry.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: InternalRegistrySettings\n</code></pre> <p>See source code</p> <p>Registry settings configured for this registry.</p>"},{"location":"reference/api/#django_components.ComponentRegistry.all","title":"all","text":"<pre><code>all() -&gt; Dict[str, Type[Component]]\n</code></pre> <p>See source code</p> <p>Retrieve all registered <code>Component</code> classes.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Type[Component]]</code>           \u2013            <p>Dict[str, Type[Component]]: A dictionary of component names to component classes</p> </li> </ul> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then get all\nregistry.all()\n# &gt; {\n# &gt;   \"button\": ButtonComponent,\n# &gt;   \"card\": CardComponent,\n# &gt; }\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>See source code</p> <p>Clears the registry, unregistering all components.</p> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then clear\nregistry.clear()\n# Then get all\nregistry.all()\n# &gt; {}\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.get","title":"get","text":"<pre><code>get(name: str) -&gt; Type[Component]\n</code></pre> <p>See source code</p> <p>Retrieve a <code>Component</code> class registered under the given name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component was registered. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Component]</code>           \u2013            <p>Type[Component]: The component class registered under the given name.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code>   if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then get\nregistry.get(\"button\")\n# &gt; ButtonComponent\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.has","title":"has","text":"<pre><code>has(name: str) -&gt; bool\n</code></pre> <p>See source code</p> <p>Check if a <code>Component</code> class is registered under the given name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component was registered. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p><code>True</code> if the component is registered, <code>False</code> otherwise.</p> </li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then check\nregistry.has(\"button\")\n# &gt; True\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.register","title":"register","text":"<pre><code>register(name: str, component: Type[Component]) -&gt; None\n</code></pre> <p>See source code</p> <p>Register a <code>Component</code> class with this registry under the given name.</p> <p>A component MUST be registered before it can be used in a template such as: <pre><code>{% component \"my_comp\" %}\n{% endcomponent %}\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component will be registered. Required.</p> </li> <li> <code>component</code>               (<code>Type[Component]</code>)           \u2013            <p>The component class to register. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>AlreadyRegistered</code> if a different component was already registered under the same name.</li> </ul> <p>Example:</p> <pre><code>registry.register(\"button\", ButtonComponent)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentRegistry.unregister","title":"unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>See source code</p> <p>Unregister the <code>Component</code> class that was registered under the given name.</p> <p>Once a component is unregistered, it is no longer available in the templates.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component is registered. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code> if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then unregister\nregistry.unregister(\"button\")\n</code></pre>"},{"location":"reference/api/#django_components.ComponentVars","title":"ComponentVars","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Type for the variables available inside the component templates.</p> <p>All variables here are scoped under <code>component_vars.</code>, so e.g. attribute <code>is_filled</code> on this class is accessible inside the template as:</p> <pre><code>{{ component_vars.is_filled }}\n</code></pre> <p>Attributes:</p> <ul> <li> <code>is_filled</code>               (<code>Dict[str, bool]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentVars.is_filled","title":"is_filled  <code>instance-attribute</code>","text":"<pre><code>is_filled: Dict[str, bool]\n</code></pre> <p>See source code</p> <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> <p>New in version 0.70</p> <p>Use as <code>{{ component_vars.is_filled }}</code></p> <p>Example:</p> <pre><code>{# Render wrapping HTML only if the slot is defined #}\n{% if component_vars.is_filled.my_slot %}\n    &lt;div class=\"slot-wrapper\"&gt;\n        {% slot \"my_slot\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre> <p>This is equivalent to checking if a given key is among the slot fills:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"my_slot_filled\": \"my_slot\" in slots\n        }\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView","title":"ComponentView","text":"<pre><code>ComponentView(component: Component, **kwargs: Any)\n</code></pre> <p>Bases: <code>django_components.extension.BaseExtensionClass</code>, <code>django.views.generic.base.View</code></p> <p>See source code</p> <p>The interface for <code>Component.View</code>.</p> <p>The fields of this class are used to configure the component views and URLs.</p> <p>This class is a subclass of <code>django.views.View</code>. The <code>Component</code> instance is available via <code>self.component</code>.</p> <p>Override the methods of this class to define the behavior of the component.</p> <p>Read more about Component views and URLs.</p> <p>Example:</p> <pre><code>class MyComponent(Component):\n    class View:\n        def get(self, request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse:\n            return HttpResponse(\"Hello, world!\")\n</code></pre> <p>Component URL:</p> <p>If the <code>public</code> attribute is set to <code>True</code>, the component will have its own URL that will point to the Component's View.</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class View:\n        public = True\n\n        def get(self, request, *args, **kwargs):\n            return HttpResponse(\"Hello, world!\")\n</code></pre> <p>Will create a URL route like <code>/components/ext/view/components/a1b2c3/</code>.</p> <p>To get the URL for the component, use <code>get_component_url</code>:</p> <pre><code>url = get_component_url(MyComponent)\n</code></pre> <p>Methods:</p> <ul> <li> <code>delete</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>head</code>             \u2013              </li> <li> <code>options</code>             \u2013              </li> <li> <code>patch</code>             \u2013              </li> <li> <code>post</code>             \u2013              </li> <li> <code>put</code>             \u2013              </li> <li> <code>trace</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>component</code>           \u2013            </li> <li> <code>public</code>           \u2013            </li> <li> <code>url</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentView.component","title":"component  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>component = cast('Component', None)\n</code></pre> <p>See source code</p> <p>The component instance.</p> <p>This is a dummy instance created solely for the View methods.</p> <p>It is the same as if you instantiated the component class directly:</p> <pre><code>component = Calendar()\ncomponent.render_to_response(request=request)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.public","title":"public  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>public = False\n</code></pre> <p>See source code</p> <p>Whether the component should be available via a URL.</p> <p>Example:</p> <pre><code>from django_components import Component\n\nclass MyComponent(Component):\n    class View:\n        public = True\n</code></pre> <p>Will create a URL route like <code>/components/ext/view/components/a1b2c3/</code>.</p> <p>To get the URL for the component, use <code>get_component_url</code>:</p> <pre><code>url = get_component_url(MyComponent)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>See source code</p> <p>The URL for the component.</p> <p>Raises <code>RuntimeError</code> if the component is not public.</p>"},{"location":"reference/api/#django_components.ComponentView.delete","title":"delete","text":"<pre><code>delete(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.get","title":"get","text":"<pre><code>get(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.head","title":"head","text":"<pre><code>head(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.options","title":"options","text":"<pre><code>options(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.patch","title":"patch","text":"<pre><code>patch(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.post","title":"post","text":"<pre><code>post(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.put","title":"put","text":"<pre><code>put(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentView.trace","title":"trace","text":"<pre><code>trace(request: HttpRequest, *args: Any, **kwargs: Any) -&gt; HttpResponse\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings","title":"ComponentsSettings","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Settings available for django_components.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n    dirs = [BASE_DIR / \"components\"],\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>app_dirs</code>               (<code>Optional[Sequence[str]]</code>)           \u2013            </li> <li> <code>autodiscover</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>cache</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            </li> <li> <code>debug_highlight_components</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>debug_highlight_slots</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>dirs</code>               (<code>Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]]</code>)           \u2013            </li> <li> <code>dynamic_component_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>extensions</code>               (<code>Optional[Sequence[Union[Type[ComponentExtension], str]]]</code>)           \u2013            </li> <li> <code>forbidden_static_files</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            </li> <li> <code>libraries</code>               (<code>Optional[List[str]]</code>)           \u2013            </li> <li> <code>multiline_tags</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>reload_on_file_change</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>reload_on_template_change</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>static_files_allowed</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            </li> <li> <code>static_files_forbidden</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            </li> <li> <code>template_cache_size</code>               (<code>Optional[int]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ComponentsSettings.app_dirs","title":"app_dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_dirs: Optional[Sequence[str]] = None\n</code></pre> <p>See source code</p> <p>Specify the app-level directories that contain your components.</p> <p>Defaults to <code>[\"components\"]</code>. That is, for each Django app, we search <code>&lt;app&gt;/components/</code> for components.</p> <p>The paths must be relative to app, e.g.:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[\"my_comps\"],\n)\n</code></pre> <p>To search for <code>&lt;app&gt;/my_comps/</code>.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <p>Set to empty list to disable app-level components:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[],\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.autodiscover","title":"autodiscover  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autodiscover: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Toggle whether to run autodiscovery at the Django server startup.</p> <p>Defaults to <code>True</code></p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.cache","title":"cache  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cache: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the Django cache to be used for storing component's JS and CSS files.</p> <p>If <code>None</code>, a <code>LocMemCache</code> is used with default settings.</p> <p>Defaults to <code>None</code>.</p> <p>Read more about caching.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    cache=\"my_cache\",\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>See source code</p> <p>Configure whether, inside a component template, you can use variables from the outside (<code>\"django\"</code>) or not (<code>\"isolated\"</code>). This also affects what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Defaults to <code>\"django\"</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    context_behavior=\"isolated\",\n)\n</code></pre> <p>NOTE: <code>context_behavior</code> and <code>slot_context_behavior</code> options were merged in v0.70.</p> <p>If you are migrating from BEFORE v0.67, set <code>context_behavior</code> to <code>\"django\"</code>. From v0.67 to v0.78 (incl) the default value was <code>\"isolated\"</code>.</p> <p>For v0.79 and later, the default is again <code>\"django\"</code>. See the rationale for change here.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.debug_highlight_components","title":"debug_highlight_components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_highlight_components: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Enable / disable component highlighting. See Troubleshooting for more details.</p> <p>Defaults to <code>False</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_components=True,\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.debug_highlight_slots","title":"debug_highlight_slots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug_highlight_slots: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Enable / disable slot highlighting. See Troubleshooting for more details.</p> <p>Defaults to <code>False</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_slots=True,\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.dirs","title":"dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirs: Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]] = None\n</code></pre> <p>See source code</p> <p>Specify the directories that contain your components.</p> <p>Defaults to <code>[Path(settings.BASE_DIR) / \"components\"]</code>. That is, the root <code>components/</code> app.</p> <p>Directories must be full paths, same as with STATICFILES_DIRS.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[BASE_DIR / \"components\"],\n)\n</code></pre> <p>Set to empty list to disable global components directories:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[],\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.dynamic_component_name","title":"dynamic_component_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dynamic_component_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>.</p> <p>In case of a conflict, you can use this setting to change the component name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.extensions","title":"extensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extensions: Optional[Sequence[Union[Type[ComponentExtension], str]]] = None\n</code></pre> <p>See source code</p> <p>List of extensions to be loaded.</p> <p>The extensions can be specified as:</p> <ul> <li>Python import path, e.g. <code>\"path.to.my_extension.MyExtension\"</code>.</li> <li>Extension class, e.g. <code>my_extension.MyExtension</code>.</li> </ul> <pre><code>COMPONENTS = ComponentsSettings(\n    extensions=[\n        \"path.to.my_extension.MyExtension\",\n        StorybookExtension,\n    ],\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.forbidden_static_files","title":"forbidden_static_files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forbidden_static_files: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>COMPONENTS.static_files_forbidden</code> instead.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.libraries","title":"libraries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>libraries: Optional[List[str]] = None\n</code></pre> <p>See source code</p> <p>Configure extra python modules that should be loaded.</p> <p>This may be useful if you are not using the autodiscovery feature, or you need to load components from non-standard locations. Thus you can have a structure of components that is independent from your apps.</p> <p>Expects a list of python module paths. Defaults to empty list.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    libraries=[\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n)\n</code></pre> <p>This would be the equivalent of importing these modules from within Django's <code>AppConfig.ready()</code>:</p> <pre><code>class MyAppConfig(AppConfig):\n    def ready(self):\n        import \"mysite.components.forms\"\n        import \"mysite.components.buttons\"\n        import \"mysite.components.cards\"\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.libraries--manually-loading-libraries","title":"Manually loading libraries","text":"<p>In the rare case that you need to manually trigger the import of libraries, you can use the <code>import_libraries()</code> function:</p> <pre><code>from django_components import import_libraries\n\nimport_libraries()\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.multiline_tags","title":"multiline_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>multiline_tags: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Enable / disable multiline support for template tags. If <code>True</code>, template tags like <code>{% component %}</code> or <code>{{ my_var }}</code> can span multiple lines.</p> <p>Defaults to <code>True</code>.</p> <p>Disable this setting if you are making custom modifications to Django's regular expression for parsing templates at <code>django.template.base.tag_re</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    multiline_tags=False,\n)\n</code></pre>"},{"location":"reference/api/#django_components.ComponentsSettings.reload_on_file_change","title":"reload_on_file_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_file_change: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>This is relevant if you are using the project structure where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>Django's native live reload logic handles only Python files and HTML template files. It does NOT reload when other file types change or when template files are nested more than one level deep.</p> <p>The setting <code>reload_on_file_change</code> fixes this, reloading the dev server even when your component's HTML, JS, or CSS changes.</p> <p>If <code>True</code>, django_components configures Django to reload when files inside <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> change.</p> <p>See Reload dev server on component file changes.</p> <p>Defaults to <code>False</code>.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"reference/api/#django_components.ComponentsSettings.reload_on_template_change","title":"reload_on_template_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_template_change: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>COMPONENTS.reload_on_file_change</code> instead.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.static_files_allowed","title":"static_files_allowed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_allowed: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> are treated as static files.</p> <p>If a file is matched against any of the patterns, it's considered a static file. Such files are collected when running <code>collectstatic</code>, and can be accessed under the static file endpoint.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, JS, CSS, and common image and font file formats are considered static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\",  \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.static_files_forbidden","title":"static_files_forbidden  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_forbidden: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> will NEVER be treated as static files.</p> <p>If a file is matched against any of the patterns, it will never be considered a static file, even if the file matches a pattern in <code>static_files_allowed</code>.</p> <p>Use this setting together with <code>static_files_allowed</code> for a fine control over what file types will be exposed.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, any HTML and Python are considered NOT static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_forbidden=[\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/api/#django_components.ComponentsSettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>See source code</p> <p>Configure what syntax is used inside Django templates to render components. See the available tag formatters.</p> <p>Defaults to <code>\"django_components.component_formatter\"</code>.</p> <p>Learn more about Customizing component tags with TagFormatter.</p> <p>Can be set either as direct reference:</p> <pre><code>from django_components import component_formatter\n\nCOMPONENTS = ComponentsSettings(\n    \"tag_formatter\": component_formatter\n)\n</code></pre> <p>Or as an import string;</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>Examples:</p> <ul> <li> <p><code>\"django_components.component_formatter\"</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    Click me!\n{% endcomponent %}\n</code></pre> </li> <li> <p><code>django_components.component_shorthand_formatter</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"reference/api/#django_components.ComponentsSettings.template_cache_size","title":"template_cache_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_cache_size: Optional[int] = None\n</code></pre> <p>See source code</p> <p>Configure the maximum amount of Django templates to be cached.</p> <p>Defaults to <code>128</code>.</p> <p>Each time a Django template is rendered, it is cached to a global in-memory cache (using Python's <code>lru_cache</code> decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up.</p> <p>By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are overriding <code>Component.get_template()</code> to render many dynamic templates, you can increase this number.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=256,\n)\n</code></pre> <p>To remove the cache limit altogether and cache everything, set <code>template_cache_size</code> to <code>None</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=None,\n)\n</code></pre> <p>If you want to add templates to the cache yourself, you can use <code>cached_template()</code>:</p> <pre><code>from django_components import cached_template\n\ncached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ncached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/api/#django_components.ContextBehavior","title":"ContextBehavior","text":"<p>Bases: <code>str</code>, <code>enum.Enum</code></p> <p>See source code</p> <p>Configure how (and whether) the context is passed to the component fills and what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Options:</p> <ul> <li><code>django</code>: With this setting, component fills behave as usual Django tags.</li> <li><code>isolated</code>: This setting makes the component fills behave similar to Vue or React.</li> </ul> <p>Attributes:</p> <ul> <li> <code>DJANGO</code>           \u2013            </li> <li> <code>ISOLATED</code>           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.ContextBehavior.DJANGO","title":"DJANGO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DJANGO = 'django'\n</code></pre> <p>See source code</p> <p>With this setting, component fills behave as usual Django tags. That is, they enrich the context, and pass it along.</p> <ol> <li>Component fills use the context of the component they are within.</li> <li>Variables from <code>Component.get_template_data()</code> are available to the component fill.</li> </ol> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>Component.get_template_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>456   # my_var\nfeta  # cheese\n</code></pre></p> <p>Because \"my_comp\" overrides the variable \"my_var\", so <code>{{ my_var }}</code> equals <code>456</code>.</p> <p>And variable \"cheese\" will equal <code>feta</code>, because the fill CAN access the current context.</p>"},{"location":"reference/api/#django_components.ContextBehavior.ISOLATED","title":"ISOLATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ISOLATED = 'isolated'\n</code></pre> <p>See source code</p> <p>This setting makes the component fills behave similar to Vue or React, where the fills use EXCLUSIVELY the context variables defined in <code>Component.get_template_data()</code>.</p> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>get_template_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>123   # my_var\n      # cheese\n</code></pre></p> <p>Because both variables \"my_var\" and \"cheese\" are taken from the root context. Since \"cheese\" is not defined in root context, it's empty.</p>"},{"location":"reference/api/#django_components.Default","title":"Default  <code>dataclass</code>","text":"<pre><code>Default(value: Callable[[], Any])\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Use this class to mark a field on the <code>Component.Defaults</code> class as a factory.</p> <p>Read more about Component defaults.</p> <p>Example:</p> <pre><code>from django_components import Default\n\nclass MyComponent(Component):\n    class Defaults:\n        # Plain value doesn't need a factory\n        position = \"left\"\n        # Lists and dicts need to be wrapped in `Default`\n        # Otherwise all instances will share the same value\n        selected_items = Default(lambda: [1, 2, 3])\n</code></pre> <p>Attributes:</p> <ul> <li> <code>value</code>               (<code>Callable[[], Any]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.Default.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Callable[[], Any]\n</code></pre>"},{"location":"reference/api/#django_components.DependenciesStrategy","title":"DependenciesStrategy  <code>module-attribute</code>","text":"<pre><code>DependenciesStrategy = Literal['document', 'fragment', 'simple', 'prepend', 'append']\n</code></pre> <p>See source code</p> <p>Type for the available strategies for rendering JS and CSS dependencies.</p> <p>Read more about the dependencies strategies.</p>"},{"location":"reference/api/#django_components.Empty","title":"Empty","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Type for an object with no members.</p> <p>You can use this to define Component types that accept NO args, kwargs, slots, etc:</p> <pre><code>from django_components import Component, Empty\n\nclass Table(Component):\n    Args = Empty\n    Kwargs = Empty\n    ...\n</code></pre> <p>This class is a shorthand for:</p> <pre><code>class Empty(NamedTuple):\n    pass\n</code></pre> <p>Read more about Typing and validation.</p>"},{"location":"reference/api/#django_components.RegistrySettings","title":"RegistrySettings","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>Configuration for a <code>ComponentRegistry</code>.</p> <p>These settings define how the components registered with this registry will behave when rendered.</p> <pre><code>from django_components import ComponentRegistry, RegistrySettings\n\nregistry_settings = RegistrySettings(\n    context_behavior=\"django\",\n    tag_formatter=\"django_components.component_shorthand_formatter\",\n)\n\nregistry = ComponentRegistry(settings=registry_settings)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>CONTEXT_BEHAVIOR</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            </li> <li> <code>TAG_FORMATTER</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.RegistrySettings.CONTEXT_BEHAVIOR","title":"CONTEXT_BEHAVIOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTEXT_BEHAVIOR: Optional[ContextBehaviorType] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>context_behavior</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/api/#django_components.RegistrySettings.TAG_FORMATTER","title":"TAG_FORMATTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAG_FORMATTER: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>tag_formatter</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/api/#django_components.RegistrySettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>See source code</p> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/api/#django_components.RegistrySettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>See source code</p> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/api/#django_components.Slot","title":"Slot  <code>dataclass</code>","text":"<pre><code>Slot(\n    content_func: SlotFunc[TSlotData],\n    escaped: bool = False,\n    component_name: Optional[str] = None,\n    slot_name: Optional[str] = None,\n    nodelist: Optional[NodeList] = None,\n)\n</code></pre> <p>Bases: <code>typing.Generic</code></p> <p>See source code</p> <p>This class holds the slot content function along with related metadata.</p> <p>Attributes:</p> <ul> <li> <code>component_name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>content_func</code>               (<code>SlotFunc[TSlotData]</code>)           \u2013            </li> <li> <code>do_not_call_in_templates</code>               (<code>bool</code>)           \u2013            </li> <li> <code>escaped</code>               (<code>bool</code>)           \u2013            </li> <li> <code>nodelist</code>               (<code>Optional[NodeList]</code>)           \u2013            </li> <li> <code>slot_name</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.Slot.component_name","title":"component_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>component_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the component that originally defined or accepted this slot fill.</p>"},{"location":"reference/api/#django_components.Slot.content_func","title":"content_func  <code>instance-attribute</code>","text":"<pre><code>content_func: SlotFunc[TSlotData]\n</code></pre>"},{"location":"reference/api/#django_components.Slot.do_not_call_in_templates","title":"do_not_call_in_templates  <code>property</code>","text":"<pre><code>do_not_call_in_templates: bool\n</code></pre>"},{"location":"reference/api/#django_components.Slot.escaped","title":"escaped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>escaped: bool = False\n</code></pre> <p>See source code</p> <p>Whether the slot content has been escaped.</p>"},{"location":"reference/api/#django_components.Slot.nodelist","title":"nodelist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nodelist: Optional[NodeList] = None\n</code></pre> <p>See source code</p> <p>Nodelist of the slot content.</p>"},{"location":"reference/api/#django_components.Slot.slot_name","title":"slot_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slot_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the slot that originally defined or accepted this slot fill.</p>"},{"location":"reference/api/#django_components.SlotContent","title":"SlotContent  <code>module-attribute</code>","text":"<pre><code>SlotContent = SlotInput[TSlotData]\n</code></pre> <p>See source code</p> <p>DEPRECATED: Use <code>SlotInput</code> instead. Will be removed in v1.</p>"},{"location":"reference/api/#django_components.SlotFunc","title":"SlotFunc","text":""},{"location":"reference/api/#django_components.SlotInput","title":"SlotInput  <code>module-attribute</code>","text":"<pre><code>SlotInput = Union[SlotResult, SlotFunc[TSlotData], Slot[TSlotData]]\n</code></pre> <p>See source code</p> <p>When rendering a component with <code>Component.render()</code> or <code>Component.render_to_response()</code>, the slots may be given a strings, functions, or <code>Slot</code> instances. This type describes that union.</p> <p>Use this type when typing the slots in your component.</p> <p><code>SlotInput</code> accepts an optional type parameter to specify the data dictionary that will be passed to the slot content function.</p> <p>Example:</p> <pre><code>from typing import NamedTuple\nfrom typing_extensions import TypedDict\nfrom django_components import Component, SlotInput\n\nclass TableFooterSlotData(TypedDict):\n    page_number: int\n\nclass Table(Component):\n    class Slots(NamedTuple):\n        header: SlotInput\n        footer: SlotInput[TableFooterSlotData]\n\n    template = \"&lt;div&gt;{% slot 'footer' %}&lt;/div&gt;\"\n</code></pre>"},{"location":"reference/api/#django_components.SlotRef","title":"SlotRef","text":"<pre><code>SlotRef(slot: SlotNode, context: Context)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>SlotRef allows to treat a slot as a variable. The slot is rendered only once the instance is coerced to string.</p> <p>This is used to access slots as variables inside the templates. When a SlotRef is rendered in the template with <code>{{ my_lazy_slot }}</code>, it will output the contents of the slot.</p>"},{"location":"reference/api/#django_components.SlotResult","title":"SlotResult  <code>module-attribute</code>","text":"<pre><code>SlotResult = Union[str, SafeString]\n</code></pre>"},{"location":"reference/api/#django_components.TagFormatterABC","title":"TagFormatterABC","text":"<p>Bases: <code>abc.ABC</code></p> <p>See source code</p> <p>Abstract base class for defining custom tag formatters.</p> <p>Tag formatters define how the component tags are used in the template.</p> <p>Read more about Tag formatter.</p> <p>For example, with the default tag formatter (<code>ComponentFormatter</code>), components are written as:</p> <pre><code>{% component \"comp_name\" %}\n{% endcomponent %}\n</code></pre> <p>While with the shorthand tag formatter (<code>ShorthandComponentFormatter</code>), components are written as: <pre><code>{% comp_name %}\n{% endcomp_name %}\n</code></pre></p> <p>Example:</p> <p>Implementation for <code>ShorthandComponentFormatter</code>:</p> <pre><code>from djagno_components import TagFormatterABC, TagResult\n\nclass ShorthandComponentFormatter(TagFormatterABC):\n    def start_tag(self, name: str) -&gt; str:\n        return name\n\n    def end_tag(self, name: str) -&gt; str:\n        return f\"end{name}\"\n\n    def parse(self, tokens: List[str]) -&gt; TagResult:\n        tokens = [*tokens]\n        name = tokens.pop(0)\n        return TagResult(name, tokens)\n</code></pre> <p>Methods:</p> <ul> <li> <code>end_tag</code>             \u2013              </li> <li> <code>parse</code>             \u2013              </li> <li> <code>start_tag</code>             \u2013              </li> </ul>"},{"location":"reference/api/#django_components.TagFormatterABC.end_tag","title":"end_tag  <code>abstractmethod</code>","text":"<pre><code>end_tag(name: str) -&gt; str\n</code></pre> <p>See source code</p> <p>Formats the end tag of a block component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted end tag.</p> </li> </ul>"},{"location":"reference/api/#django_components.TagFormatterABC.parse","title":"parse  <code>abstractmethod</code>","text":"<pre><code>parse(tokens: List[str]) -&gt; TagResult\n</code></pre> <p>See source code</p> <p>Given the tokens (words) passed to a component start tag, this function extracts the component name from the tokens list, and returns <code>TagResult</code>, which is a tuple of <code>(component_name, remaining_tokens)</code>.</p> <p>Parameters:</p> <ul> <li> <code>tokens</code>               (<code>[List(str]</code>)           \u2013            <p>List of tokens passed to the component tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TagResult</code> (              <code>TagResult</code> )          \u2013            <p>Parsed component name and remaining tokens.</p> </li> </ul> <p>Example:</p> <p>Assuming we used a component in a template like this:</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n{% endcomponent %}\n</code></pre> <p>This function receives a list of tokens:</p> <pre><code>['component', '\"my_comp\"', 'key=val', 'key2=val2']\n</code></pre> <ul> <li><code>component</code> is the tag name, which we drop.</li> <li><code>\"my_comp\"</code> is the component name, but we must remove the extra quotes.</li> <li>The remaining tokens we pass unmodified, as that's the input to the component.</li> </ul> <p>So in the end, we return:</p> <pre><code>TagResult('my_comp', ['key=val', 'key2=val2'])\n</code></pre>"},{"location":"reference/api/#django_components.TagFormatterABC.start_tag","title":"start_tag  <code>abstractmethod</code>","text":"<pre><code>start_tag(name: str) -&gt; str\n</code></pre> <p>See source code</p> <p>Formats the start tag of a component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted start tag.</p> </li> </ul>"},{"location":"reference/api/#django_components.TagResult","title":"TagResult","text":"<p>Bases: <code>tuple</code></p> <p>See source code</p> <p>The return value from <code>TagFormatter.parse()</code>.</p> <p>Read more about Tag formatter.</p> <p>Attributes:</p> <ul> <li> <code>component_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>tokens</code>               (<code>List[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/api/#django_components.TagResult.component_name","title":"component_name  <code>instance-attribute</code>","text":"<pre><code>component_name: str\n</code></pre> <p>See source code</p> <p>Component name extracted from the template tag</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>component_name</code> would be <code>my_comp</code>.</p>"},{"location":"reference/api/#django_components.TagResult.tokens","title":"tokens  <code>instance-attribute</code>","text":"<pre><code>tokens: List[str]\n</code></pre> <p>See source code</p> <p>Remaining tokens (words) that were passed to the tag, with component name removed</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>tokens</code> would be <code>['key=val', 'key2=val2']</code>.</p>"},{"location":"reference/api/#django_components.all_components","title":"all_components","text":"<pre><code>all_components() -&gt; List[Type[Component]]\n</code></pre> <p>See source code</p> <p>Get a list of all created <code>Component</code> classes.</p>"},{"location":"reference/api/#django_components.all_registries","title":"all_registries","text":"<pre><code>all_registries() -&gt; List[ComponentRegistry]\n</code></pre> <p>See source code</p> <p>Get a list of all created <code>ComponentRegistry</code> instances.</p>"},{"location":"reference/api/#django_components.autodiscover","title":"autodiscover","text":"<pre><code>autodiscover(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>See source code</p> <p>Search for all python files in <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> and import them.</p> <p>See Autodiscovery.</p> <p>NOTE: Subdirectories and files starting with an underscore <code>_</code> (except for <code>__init__.py</code> are ignored.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>To get the same list of modules that <code>autodiscover()</code> would return, but without importing them, use <code>get_component_files()</code>:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre>"},{"location":"reference/api/#django_components.cached_template","title":"cached_template","text":"<pre><code>cached_template(\n    template_string: str,\n    template_cls: Optional[Type[Template]] = None,\n    origin: Optional[Origin] = None,\n    name: Optional[str] = None,\n    engine: Optional[Any] = None,\n) -&gt; Template\n</code></pre> <p>See source code</p> <p>Create a Template instance that will be cached as per the <code>COMPONENTS.template_cache_size</code> setting.</p> <p>Parameters:</p> <ul> <li> <code>template_string</code>               (<code>str</code>)           \u2013            <p>Template as a string, same as the first argument to Django's            <code>Template</code>. Required.</p> </li> <li> <code>template_cls</code>               (<code>Type[Template]</code>, default:                   <code>None</code> )           \u2013            <p>Specify the Template class that should be instantiated.            Defaults to Django's <code>Template</code> class.</p> </li> <li> <code>origin</code>               (<code>Type[Origin]</code>, default:                   <code>None</code> )           \u2013            <p>Sets             <code>Template.Origin</code>.</p> </li> <li> <code>name</code>               (<code>Type[str]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.name</code></p> </li> <li> <code>engine</code>               (<code>Type[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.engine</code></p> </li> </ul> <pre><code>from django_components import cached_template\n\ntemplate = cached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ntemplate = cached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/api/#django_components.format_attributes","title":"format_attributes","text":"<pre><code>format_attributes(attributes: Mapping[str, Any]) -&gt; str\n</code></pre> <p>See source code</p> <p>Format a dict of attributes into an HTML attributes string.</p> <p>Read more about HTML attributes.</p> <p>Example:</p> <pre><code>format_attributes({\"class\": \"my-class\", \"data-id\": \"123\"})\n</code></pre> <p>will return</p> <pre><code>'class=\"my-class\" data-id=\"123\"'\n</code></pre>"},{"location":"reference/api/#django_components.get_component_by_class_id","title":"get_component_by_class_id","text":"<pre><code>get_component_by_class_id(comp_cls_id: str) -&gt; Type[Component]\n</code></pre> <p>See source code</p> <p>Get a component class by its unique ID.</p> <p>Each component class is associated with a unique hash that's derived from its module import path.</p> <p>E.g. <code>path.to.my.secret.MyComponent</code> -&gt; <code>MyComponent_ab01f32</code></p> <p>This hash is available under <code>class_id</code> on the component class.</p> <p>Raises <code>KeyError</code> if the component class is not found.</p> <p>NOTE: This is mainly intended for extensions.</p>"},{"location":"reference/api/#django_components.get_component_dirs","title":"get_component_dirs","text":"<pre><code>get_component_dirs(include_apps: bool = True) -&gt; List[Path]\n</code></pre> <p>See source code</p> <p>Get directories that may contain component files.</p> <p>This is the heart of all features that deal with filesystem and file lookup. Autodiscovery, Django template resolution, static file resolution - They all use this.</p> <p>Parameters:</p> <ul> <li> <code>include_apps</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Include directories from installed Django apps.            Defaults to <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Path]</code>           \u2013            <p>List[Path]: A list of directories that may contain component files.</p> </li> </ul> <p><code>get_component_dirs()</code> searches for dirs set in <code>COMPONENTS.dirs</code> settings. If none set, defaults to searching for a <code>\"components\"</code> app.</p> <p>In addition to that, also all installed Django apps are checked whether they contain directories as set in <code>COMPONENTS.app_dirs</code> (e.g. <code>[app]/components</code>).</p> <p>Notes:</p> <ul> <li> <p>Paths that do not point to directories are ignored.</p> </li> <li> <p><code>BASE_DIR</code> setting is required.</p> </li> <li> <p>The paths in <code>COMPONENTS.dirs</code>     must be absolute paths.</p> </li> </ul>"},{"location":"reference/api/#django_components.get_component_files","title":"get_component_files","text":"<pre><code>get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]\n</code></pre> <p>See source code</p> <p>Search for files within the component directories (as defined in <code>get_component_dirs()</code>).</p> <p>Requires <code>BASE_DIR</code> setting to be set.</p> <p>Subdirectories and files starting with an underscore <code>_</code> (except <code>__init__.py</code>) are ignored.</p> <p>Parameters:</p> <ul> <li> <code>suffix</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The suffix to search for. E.g. <code>.py</code>, <code>.js</code>, <code>.css</code>.            Defaults to <code>None</code>, which will search for all files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ComponentFileEntry]</code>           \u2013            <p>List[ComponentFileEntry] A list of entries that contain both the filesystem path and             the python import path (dot path).</p> </li> </ul> <p>Example:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre>"},{"location":"reference/api/#django_components.get_component_url","title":"get_component_url","text":"<pre><code>get_component_url(component: Union[Type[Component], Component], query: Optional[Dict] = None, fragment: Optional[str] = None) -&gt; str\n</code></pre> <p>See source code</p> <p>Get the URL for a <code>Component</code>.</p> <p>Raises <code>RuntimeError</code> if the component is not public.</p> <p>Read more about Component views and URLs.</p> <p><code>get_component_url()</code> optionally accepts <code>query</code> and <code>fragment</code> arguments.</p> <p>Example:</p> <pre><code>from django_components import Component, get_component_url\n\nclass MyComponent(Component):\n    class View:\n        public = True\n\n# Get the URL for the component\nurl = get_component_url(\n    MyComponent,\n    query={\"foo\": \"bar\"},\n    fragment=\"baz\",\n)\n# /components/ext/view/components/c1ab2c3?foo=bar#baz\n</code></pre>"},{"location":"reference/api/#django_components.import_libraries","title":"import_libraries","text":"<pre><code>import_libraries(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>See source code</p> <p>Import modules set in <code>COMPONENTS.libraries</code> setting.</p> <p>See Autodiscovery.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>Examples:</p> <p>Normal usage - load libraries after Django has loaded <pre><code>from django_components import import_libraries\n\nclass MyAppConfig(AppConfig):\n    def ready(self):\n        import_libraries()\n</code></pre></p> <p>Potential usage in tests <pre><code>from django_components import import_libraries\n\nimport_libraries(lambda path: path.replace(\"tests.\", \"myapp.\"))\n</code></pre></p>"},{"location":"reference/api/#django_components.merge_attributes","title":"merge_attributes","text":"<pre><code>merge_attributes(*attrs: Dict) -&gt; Dict\n</code></pre> <p>See source code</p> <p>Merge a list of dictionaries into a single dictionary.</p> <p>The dictionaries are treated as HTML attributes and are merged accordingly:</p> <ul> <li>If a same key is present in multiple dictionaries, the values are joined with a space   character.</li> <li>The <code>class</code> and <code>style</code> keys are handled specially, similar to   how Vue does it.</li> </ul> <p>Read more about HTML attributes.</p> <p>Example:</p> <pre><code>merge_attributes(\n    {\"my-attr\": \"my-value\", \"class\": \"my-class\"},\n    {\"my-attr\": \"extra-value\", \"data-id\": \"123\"},\n)\n</code></pre> <p>will result in</p> <pre><code>{\n    \"my-attr\": \"my-value extra-value\",\n    \"class\": \"my-class\",\n    \"data-id\": \"123\",\n}\n</code></pre> <p>The <code>class</code> attribute</p> <p>The <code>class</code> attribute can be given as a string, or a dictionary.</p> <ul> <li>If given as a string, it is used as is.</li> <li>If given as a dictionary, only the keys with a truthy value are used.</li> </ul> <p>Example:</p> <pre><code>merge_attributes(\n    {\"class\": \"my-class extra-class\"},\n    {\"class\": {\"truthy\": True, \"falsy\": False}},\n)\n</code></pre> <p>will result in</p> <pre><code>{\n    \"class\": \"my-class extra-class truthy\",\n}\n</code></pre> <p>The <code>style</code> attribute</p> <p>The <code>style</code> attribute can be given as a string, a list, or a dictionary.</p> <ul> <li>If given as a string, it is used as is.</li> <li>If given as a dictionary, it is converted to a style attribute string.</li> </ul> <p>Example:</p> <pre><code>merge_attributes(\n    {\"style\": \"color: red; background-color: blue;\"},\n    {\"style\": {\"background-color\": \"green\", \"color\": False}},\n)\n</code></pre> <p>will result in</p> <pre><code>{\n    \"style\": \"color: red; background-color: blue; background-color: green;\",\n}\n</code></pre>"},{"location":"reference/api/#django_components.register","title":"register","text":"<pre><code>register(name: str, registry: Optional[ComponentRegistry] = None) -&gt; Callable[[Type[TComponent]], Type[TComponent]]\n</code></pre> <p>See source code</p> <p>Class decorator for registering a component to a component registry.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Registered name. This is the name by which the component will be accessed            from within a template when using the <code>{% component %}</code> tag. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to which to register this component. If omitted, component is registered to the default registry.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AlreadyRegistered</code>             \u2013            <p>If there is already a component registered under the same name.</p> </li> </ul> <p>Examples:</p> <pre><code>from django_components import Component, register\n\n@register(\"my_component\")\nclass MyComponent(Component):\n    ...\n</code></pre> <p>Specifing <code>ComponentRegistry</code> the component should be registered to by setting the <code>registry</code> kwarg:</p> <pre><code>from django.template import Library\nfrom django_components import Component, ComponentRegistry, register\n\nmy_lib = Library()\nmy_reg = ComponentRegistry(library=my_lib)\n\n@register(\"my_component\", registry=my_reg)\nclass MyComponent(Component):\n    ...\n</code></pre>"},{"location":"reference/api/#django_components.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry: ComponentRegistry = ComponentRegistry()\n</code></pre> <p>See source code</p> <p>The default and global component registry. Use this instance to directly register or remove components:</p> <p>See Registering components.</p> <pre><code># Register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n\n# Get single\nregistry.get(\"button\")\n\n# Get all\nregistry.all()\n\n# Check if component is registered\nregistry.has(\"button\")\n\n# Unregister single\nregistry.unregister(\"button\")\n\n# Unregister all\nregistry.clear()\n</code></pre>"},{"location":"reference/api/#django_components.render_dependencies","title":"render_dependencies","text":"<pre><code>render_dependencies(content: TContent, strategy: DependenciesStrategy = 'document') -&gt; TContent\n</code></pre> <p>See source code</p> <p>Given a string that contains parts that were rendered by components, this function inserts all used JS and CSS.</p> <p>By default, the string is parsed as an HTML and: - CSS is inserted at the end of <code>&lt;head&gt;</code> (if present) - JS is inserted at the end of <code>&lt;body&gt;</code> (if present)</p> <p>If you used <code>{% component_js_dependencies %}</code> or <code>{% component_css_dependencies %}</code>, then the JS and CSS will be inserted only at these locations.</p> <p>Example: <pre><code>def my_view(request):\n    template = Template('''\n        {% load components %}\n        &lt;!doctype html&gt;\n        &lt;html&gt;\n            &lt;head&gt;&lt;/head&gt;\n            &lt;body&gt;\n                &lt;h1&gt;{{ table_name }}&lt;/h1&gt;\n                {% component \"table\" name=table_name / %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    ''')\n\n    html = template.render(\n        Context({\n            \"table_name\": request.GET[\"name\"],\n        })\n    )\n\n    # This inserts components' JS and CSS\n    processed_html = render_dependencies(html)\n\n    return HttpResponse(processed_html)\n</code></pre></p>"},{"location":"reference/api/#django_components.template_tag","title":"template_tag","text":"<pre><code>template_tag(\n    library: Library, tag: str, end_tag: Optional[str] = None, allowed_flags: Optional[List[str]] = None\n) -&gt; Callable[[Callable], Callable]\n</code></pre> <p>See source code</p> <p>A simplified version of creating a template tag based on <code>BaseNode</code>.</p> <p>Instead of defining the whole class, you can just define the <code>render()</code> method.</p> <pre><code>from django.template import Context, Library\nfrom django_components import BaseNode, template_tag\n\nlibrary = Library()\n\n@template_tag(\n    library,\n    tag=\"mytag\",\n    end_tag=\"endmytag\",\n    allowed_flags=[\"required\"],\n)\ndef mytag(node: BaseNode, context: Context, name: str, **kwargs: Any) -&gt; str:\n    return f\"Hello, {name}!\"\n</code></pre> <p>This will allow the template tag <code>{% mytag %}</code> to be used like this:</p> <pre><code>{% mytag name=\"John\" %}\n{% mytag name=\"John\" required %} ... {% endmytag %}\n</code></pre> <p>The given function will be wrapped in a class that inherits from <code>BaseNode</code>.</p> <p>And this class will be registered with the given library.</p> <p>The function MUST accept at least two positional arguments: <code>node</code> and <code>context</code></p> <ul> <li><code>node</code> is the <code>BaseNode</code> instance.</li> <li><code>context</code> is the <code>Context</code>     of the template.</li> </ul> <p>Any extra parameters defined on this function will be part of the tag's input parameters.</p> <p>For more info, see <code>BaseNode.render()</code>.</p>"},{"location":"reference/commands/","title":"Commands","text":""},{"location":"reference/commands/#commands","title":"Commands","text":"<p>These are all the Django management commands that will be added by installing <code>django_components</code>:</p>"},{"location":"reference/commands/#components","title":"<code>components</code>","text":"<pre><code>usage: python manage.py  components [-h] {create,upgrade,ext,list} ...\n</code></pre> <p>See source code</p> <p>The entrypoint for the 'components' commands.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> </ul> <p>Subcommands:</p> <ul> <li><code>create</code><ul> <li>Create a new django component.</li> </ul> </li> <li><code>upgrade</code><ul> <li>Upgrade django components syntax from '{% component_block ... %}' to '{% component ... %}'.</li> </ul> </li> <li><code>ext</code><ul> <li>Run extension commands.</li> </ul> </li> <li><code>list</code><ul> <li>List all components created in this project.</li> </ul> </li> </ul> <p>The entrypoint for the \"components\" commands.</p> <pre><code>python manage.py components list\npython manage.py components create &lt;name&gt;\npython manage.py components upgrade\npython manage.py components ext list\npython manage.py components ext run &lt;extension&gt; &lt;command&gt;\n</code></pre>"},{"location":"reference/commands/#components-create","title":"<code>components create</code>","text":"<pre><code>usage: python manage.py components create [-h] [--path PATH] [--js JS] [--css CSS] [--template TEMPLATE]\n              [--force] [--verbose] [--dry-run]\n              name\n</code></pre> <p>See source code</p> <p>Create a new django component.</p> <p>Positional Arguments:</p> <ul> <li><code>name</code><ul> <li>The name of the component to create. This is a required argument.</li> </ul> </li> </ul> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--path PATH</code><ul> <li>The path to the component's directory. This is an optional argument. If not provided, the command will use the <code>COMPONENTS.dirs</code> setting from your Django settings.</li> </ul> </li> <li><code>--js JS</code><ul> <li>The name of the JavaScript file. This is an optional argument. The default value is <code>script.js</code>.</li> </ul> </li> <li><code>--css CSS</code><ul> <li>The name of the CSS file. This is an optional argument. The default value is <code>style.css</code>.</li> </ul> </li> <li><code>--template TEMPLATE</code><ul> <li>The name of the template file. This is an optional argument. The default value is <code>template.html</code>.</li> </ul> </li> <li><code>--force</code><ul> <li>This option allows you to overwrite existing files if they exist. This is an optional argument.</li> </ul> </li> <li><code>--verbose</code><ul> <li>This option allows the command to print additional information during component creation. This is an optional argument.</li> </ul> </li> <li><code>--dry-run</code><ul> <li>This option allows you to simulate component creation without actually creating any files. This is an optional argument. The default value is <code>False</code>.</li> </ul> </li> </ul>"},{"location":"reference/commands/#usage","title":"Usage","text":"<p>To use the command, run the following command in your terminal:</p> <pre><code>python manage.py components create &lt;name&gt; --path &lt;path&gt; --js &lt;js_filename&gt; --css &lt;css_filename&gt; --template &lt;template_filename&gt; --force --verbose --dry-run\n</code></pre> <p>Replace <code>&lt;name&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;js_filename&gt;</code>, <code>&lt;css_filename&gt;</code>, and <code>&lt;template_filename&gt;</code> with your desired values.</p>"},{"location":"reference/commands/#examples","title":"Examples","text":"<p>Here are some examples of how you can use the command:</p> <p>Creating a Component with Default Settings</p> <p>To create a component with the default settings, you only need to provide the name of the component:</p> <pre><code>python manage.py components create my_component\n</code></pre> <p>This will create a new component named <code>my_component</code> in the <code>components</code> directory of your Django project. The JavaScript, CSS, and template files will be named <code>script.js</code>, <code>style.css</code>, and <code>template.html</code>, respectively.</p> <p>Creating a Component with Custom Settings</p> <p>You can also create a component with custom settings by providing additional arguments:</p> <pre><code>python manage.py components create new_component --path my_components --js my_script.js --css my_style.css --template my_template.html\n</code></pre> <p>This will create a new component named <code>new_component</code> in the <code>my_components</code> directory. The JavaScript, CSS, and template files will be named <code>my_script.js</code>, <code>my_style.css</code>, and <code>my_template.html</code>, respectively.</p> <p>Overwriting an Existing Component</p> <p>If you want to overwrite an existing component, you can use the <code>--force</code> option:</p> <pre><code>python manage.py components create my_component --force\n</code></pre> <p>This will overwrite the existing <code>my_component</code> if it exists.</p> <p>Simulating Component Creation</p> <p>If you want to simulate the creation of a component without actually creating any files, you can use the <code>--dry-run</code> option:</p> <pre><code>python manage.py components create my_component --dry-run\n</code></pre> <p>This will simulate the creation of <code>my_component</code> without creating any files.</p>"},{"location":"reference/commands/#components-upgrade","title":"<code>components upgrade</code>","text":"<pre><code>usage: python manage.py components upgrade [-h] [--path PATH]\n</code></pre> <p>See source code</p> <p>Upgrade django components syntax from '{% component_block ... %}' to '{% component ... %}'.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--path PATH</code><ul> <li>Path to search for components</li> </ul> </li> </ul>"},{"location":"reference/commands/#components-ext","title":"<code>components ext</code>","text":"<pre><code>usage: python manage.py components ext [-h] {list,run} ...\n</code></pre> <p>See source code</p> <p>Run extension commands.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> </ul> <p>Subcommands:</p> <ul> <li><code>list</code><ul> <li>List all extensions.</li> </ul> </li> <li><code>run</code><ul> <li>Run a command added by an extension.</li> </ul> </li> </ul> <p>Run extension commands.</p> <pre><code>python manage.py components ext list\npython manage.py components ext run &lt;extension&gt; &lt;command&gt;\n</code></pre>"},{"location":"reference/commands/#components-ext-list","title":"<code>components ext list</code>","text":"<pre><code>usage: python manage.py components ext list [-h] [--all] [--columns COLUMNS] [-s]\n</code></pre> <p>See source code</p> <p>List all extensions.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--all</code><ul> <li>Show all columns. Same as <code>--columns name</code>.</li> </ul> </li> <li><code>--columns COLUMNS</code><ul> <li>Comma-separated list of columns to show. Available columns: name. Defaults to <code>--columns name</code>.</li> </ul> </li> <li><code>-s</code>, <code>--simple</code><ul> <li>Only show table data, without headers. Use this option for generating machine-readable output.</li> </ul> </li> </ul> <p>List all extensions.</p> <pre><code>python manage.py components ext list\n</code></pre> <p>Prints the list of installed extensions:</p> <pre><code>name\n==============\nview\nmy_extension\n</code></pre> <p>To specify which columns to show, use the <code>--columns</code> flag:</p> <pre><code>python manage.py components ext list --columns name\n</code></pre> <p>Which prints:</p> <pre><code>name\n==============\nview\nmy_extension\n</code></pre> <p>To print out all columns, use the <code>--all</code> flag:</p> <pre><code>python manage.py components ext list --all\n</code></pre> <p>If you need to omit the title in order to programmatically post-process the output, you can use the <code>--simple</code> (or <code>-s</code>) flag:</p> <pre><code>python manage.py components ext list --simple\n</code></pre> <p>Which prints just:</p> <pre><code>view\nmy_extension\n</code></pre>"},{"location":"reference/commands/#components-ext-run","title":"<code>components ext run</code>","text":"<pre><code>usage: python manage.py components ext run [-h]\n</code></pre> <p>See source code</p> <p>Run a command added by an extension.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> </ul> <p>Run a command added by an extension.</p> <p>Each extension can add its own commands, which will be available to run with this command.</p> <p>For example, if you define and install the following extension:</p> <pre><code>from django_components import ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n    def handle(self, *args, **kwargs):\n        print(\"Hello, world!\")\n\nclass MyExt(ComponentExtension):\n    name = \"my_ext\"\n    commands = [HelloCommand]\n</code></pre> <p>You can run the <code>hello</code> command with:</p> <pre><code>python manage.py components ext run my_ext hello\n</code></pre> <p>You can also define arguments for the command, which will be passed to the command's <code>handle</code> method.</p> <pre><code>from django_components import CommandArg, ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n    arguments = [\n        CommandArg(name=\"name\", help=\"The name to say hello to\"),\n        CommandArg(name=[\"--shout\", \"-s\"], action=\"store_true\"),\n    ]\n\n    def handle(self, name: str, *args, **kwargs):\n        shout = kwargs.get(\"shout\", False)\n        msg = f\"Hello, {name}!\"\n        if shout:\n            msg = msg.upper()\n        print(msg)\n</code></pre> <p>You can run the command with:</p> <pre><code>python manage.py components ext run my_ext hello --name John --shout\n</code></pre> <p>Note</p> <p>Command arguments and options are based on Python's <code>argparse</code> module.</p> <p>For more information, see the argparse documentation.</p>"},{"location":"reference/commands/#components-list","title":"<code>components list</code>","text":"<pre><code>usage: python manage.py components list [-h] [--all] [--columns COLUMNS] [-s]\n</code></pre> <p>See source code</p> <p>List all components created in this project.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--all</code><ul> <li>Show all columns. Same as <code>--columns name,full_name,path</code>.</li> </ul> </li> <li><code>--columns COLUMNS</code><ul> <li>Comma-separated list of columns to show. Available columns: name, full_name, path. Defaults to <code>--columns full_name,path</code>.</li> </ul> </li> <li><code>-s</code>, <code>--simple</code><ul> <li>Only show table data, without headers. Use this option for generating machine-readable output.</li> </ul> </li> </ul> <p>List all components.</p> <pre><code>python manage.py components list\n</code></pre> <p>Prints the list of available components:</p> <pre><code>full_name                                                     path\n==================================================================================================\nproject.pages.project.ProjectPage                             ./project/pages/project\nproject.components.dashboard.ProjectDashboard                 ./project/components/dashboard\nproject.components.dashboard_action.ProjectDashboardAction    ./project/components/dashboard_action\n</code></pre> <p>To specify which columns to show, use the <code>--columns</code> flag:</p> <pre><code>python manage.py components list --columns name,full_name,path\n</code></pre> <p>Which prints:</p> <pre><code>name                      full_name                                                     path\n==================================================================================================\nProjectPage               project.pages.project.ProjectPage                             ./project/pages/project\nProjectDashboard          project.components.dashboard.ProjectDashboard                 ./project/components/dashboard\nProjectDashboardAction    project.components.dashboard_action.ProjectDashboardAction    ./project/components/dashboard_action\n</code></pre> <p>To print out all columns, use the <code>--all</code> flag:</p> <pre><code>python manage.py components list --all\n</code></pre> <p>If you need to omit the title in order to programmatically post-process the output, you can use the <code>--simple</code> (or <code>-s</code>) flag:</p> <pre><code>python manage.py components list --simple\n</code></pre> <p>Which prints just:</p> <pre><code>ProjectPage               project.pages.project.ProjectPage                             ./project/pages/project\nProjectDashboard          project.components.dashboard.ProjectDashboard                 ./project/components/dashboard\nProjectDashboardAction    project.components.dashboard_action.ProjectDashboardAction    ./project/components/dashboard_action\n</code></pre>"},{"location":"reference/commands/#startcomponent","title":"<code>startcomponent</code>","text":"<pre><code>usage: startcomponent [-h] [--path PATH] [--js JS] [--css CSS]\n                      [--template TEMPLATE] [--force] [--verbose] [--dry-run]\n                      [--version] [-v {0,1,2,3}] [--settings SETTINGS]\n                      [--pythonpath PYTHONPATH] [--traceback] [--no-color]\n                      [--force-color] [--skip-checks]\n                      name\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>components create</code> instead.</p> <p>Positional Arguments:</p> <ul> <li><code>name</code><ul> <li>The name of the component to create. This is a required argument.</li> </ul> </li> </ul> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--path PATH</code><ul> <li>The path to the component's directory. This is an optional argument. If not provided, the command will use the <code>COMPONENTS.dirs</code> setting from your Django settings.</li> </ul> </li> <li><code>--js JS</code><ul> <li>The name of the JavaScript file. This is an optional argument. The default value is <code>script.js</code>.</li> </ul> </li> <li><code>--css CSS</code><ul> <li>The name of the CSS file. This is an optional argument. The default value is <code>style.css</code>.</li> </ul> </li> <li><code>--template TEMPLATE</code><ul> <li>The name of the template file. This is an optional argument. The default value is <code>template.html</code>.</li> </ul> </li> <li><code>--force</code><ul> <li>This option allows you to overwrite existing files if they exist. This is an optional argument.</li> </ul> </li> <li><code>--verbose</code><ul> <li>This option allows the command to print additional information during component creation. This is an optional argument.</li> </ul> </li> <li><code>--dry-run</code><ul> <li>This option allows you to simulate component creation without actually creating any files. This is an optional argument. The default value is <code>False</code>.</li> </ul> </li> <li><code>--version</code><ul> <li>Show program's version number and exit.</li> </ul> </li> <li><code>-v</code>, <code>--verbosity {0,1,2,3}</code><ul> <li>Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output</li> </ul> </li> <li><code>--settings SETTINGS</code><ul> <li>The Python path to a settings module, e.g. \"myproject.settings.main\". If this isn't provided, the DJANGO_SETTINGS_MODULE environment variable will be used.</li> </ul> </li> <li><code>--pythonpath PYTHONPATH</code><ul> <li>A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".</li> </ul> </li> <li><code>--traceback</code><ul> <li>Raise on CommandError exceptions.</li> </ul> </li> <li><code>--no-color</code><ul> <li>Don't colorize the command output.</li> </ul> </li> <li><code>--force-color</code><ul> <li>Force colorization of the command output.</li> </ul> </li> <li><code>--skip-checks</code><ul> <li>Skip system checks.</li> </ul> </li> </ul> <p>Deprecated. Use <code>components create</code> instead.</p>"},{"location":"reference/commands/#upgradecomponent","title":"<code>upgradecomponent</code>","text":"<pre><code>usage: upgradecomponent [-h] [--path PATH] [--version] [-v {0,1,2,3}]\n                        [--settings SETTINGS] [--pythonpath PYTHONPATH]\n                        [--traceback] [--no-color] [--force-color]\n                        [--skip-checks]\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>components upgrade</code> instead.</p> <p>Options:</p> <ul> <li><code>-h</code>, <code>--help</code><ul> <li>show this help message and exit</li> </ul> </li> <li><code>--path PATH</code><ul> <li>Path to search for components</li> </ul> </li> <li><code>--version</code><ul> <li>Show program's version number and exit.</li> </ul> </li> <li><code>-v</code>, <code>--verbosity {0,1,2,3}</code><ul> <li>Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output</li> </ul> </li> <li><code>--settings SETTINGS</code><ul> <li>The Python path to a settings module, e.g. \"myproject.settings.main\". If this isn't provided, the DJANGO_SETTINGS_MODULE environment variable will be used.</li> </ul> </li> <li><code>--pythonpath PYTHONPATH</code><ul> <li>A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".</li> </ul> </li> <li><code>--traceback</code><ul> <li>Raise on CommandError exceptions.</li> </ul> </li> <li><code>--no-color</code><ul> <li>Don't colorize the command output.</li> </ul> </li> <li><code>--force-color</code><ul> <li>Force colorization of the command output.</li> </ul> </li> <li><code>--skip-checks</code><ul> <li>Skip system checks.</li> </ul> </li> </ul> <p>Deprecated. Use <code>components upgrade</code> instead.</p>"},{"location":"reference/components/","title":"Components","text":""},{"location":"reference/components/#components","title":"Components","text":"<p>These are the components provided by django_components.</p>"},{"location":"reference/components/#django_components.components.dynamic.DynamicComponent","title":"<code>DynamicComponent</code>","text":"<p>Bases: <code>django_components.component.Component</code></p> <p>See source code</p> <p>This component is given a registered name or a reference to another component, and behaves as if the other component was in its place.</p> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>Parameters:</p> <ul> <li> <code>is</code>               (<code>str | Type[Component]</code>)           \u2013            <p>Component that should be rendered. Either a registered name of a component, or a Component class directly. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to search for the registered name. If omitted, all registries are searched until the first match.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional data passed to the component.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional data passed to the component.</p> </li> </ul> <p>Slots:</p> <ul> <li>Any slots, depending on the actual component.</li> </ul> <p>Examples:</p> <p>Django <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Or in case you use the <code>django_components.component_shorthand_formatter</code> tag formatter:</p> <pre><code>{% dynamic is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% enddynamic %}\n</code></pre> <p>Python <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            render_dependencies=False,\n        ),\n    },\n)\n</code></pre></p>"},{"location":"reference/components/#django_components.components.dynamic.DynamicComponent--use-cases","title":"Use cases","text":"<p>Dynamic components are suitable if you are writing something like a form component. You may design it such that users give you a list of input types, and you render components depending on the input types.</p> <p>While you could handle this with a series of if / else statements, that's not an extensible approach. Instead, you can use the dynamic component in place of normal components.</p>"},{"location":"reference/components/#django_components.components.dynamic.DynamicComponent--component-name","title":"Component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name: <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#exceptions","title":"Exceptions","text":""},{"location":"reference/exceptions/#django_components.AlreadyRegistered","title":"AlreadyRegistered","text":"<p>Bases: <code>Exception</code></p> <p>See source code</p> <p>Raised when you try to register a Component, but it's already registered with given ComponentRegistry.</p>"},{"location":"reference/exceptions/#django_components.NotRegistered","title":"NotRegistered","text":"<p>Bases: <code>Exception</code></p> <p>See source code</p> <p>Raised when you try to access a Component, but it's NOT registered with given ComponentRegistry.</p>"},{"location":"reference/exceptions/#django_components.TagProtectedError","title":"TagProtectedError","text":"<p>Bases: <code>Exception</code></p> <p>See source code</p> <p>The way the <code>TagFormatter</code> works is that, based on which start and end tags are used for rendering components, the <code>ComponentRegistry</code> behind the scenes un-/registers the template tags with the associated instance of Django's <code>Library</code>.</p> <p>In other words, if I have registered a component <code>\"table\"</code>, and I use the shorthand syntax:</p> <pre><code>{% table ... %}\n{% endtable %}\n</code></pre> <p>Then <code>ComponentRegistry</code> registers the tag <code>table</code> onto the Django's Library instance.</p> <p>However, that means that if we registered a component <code>\"slot\"</code>, then we would overwrite the <code>{% slot %}</code> tag from django_components.</p> <p>Thus, this exception is raised when a component is attempted to be registered under a forbidden name, such that it would overwrite one of django_component's own template tags.</p>"},{"location":"reference/extension_commands/","title":"Extension commands","text":""},{"location":"reference/extension_commands/#extension-commands","title":"Extension commands","text":"<p>Overview of all classes, functions, and other objects related to defining extension commands.</p> <p>Read more on Extensions.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg","title":"CommandArg  <code>dataclass</code>","text":"<pre><code>CommandArg(\n    name_or_flags: Union[str, Sequence[str]],\n    action: Optional[Union[CommandLiteralAction, Action]] = None,\n    nargs: Optional[Union[int, Literal[\"*\", \"+\", \"?\"]]] = None,\n    const: Any = None,\n    default: Any = None,\n    type: Optional[Union[Type, Callable[[str], Any]]] = None,\n    choices: Optional[Sequence[Any]] = None,\n    required: Optional[bool] = None,\n    help: Optional[str] = None,\n    metavar: Optional[str] = None,\n    dest: Optional[str] = None,\n    version: Optional[str] = None,\n    deprecated: Optional[bool] = None,\n)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Define a single positional argument or an option for a command.</p> <p>Fields on this class correspond to the arguments for <code>ArgumentParser.add_argument()</code></p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>action</code>               (<code>Optional[Union[CommandLiteralAction, Action]]</code>)           \u2013            </li> <li> <code>choices</code>               (<code>Optional[Sequence[Any]]</code>)           \u2013            </li> <li> <code>const</code>               (<code>Any</code>)           \u2013            </li> <li> <code>default</code>               (<code>Any</code>)           \u2013            </li> <li> <code>deprecated</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>dest</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>help</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>metavar</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>name_or_flags</code>               (<code>Union[str, Sequence[str]]</code>)           \u2013            </li> <li> <code>nargs</code>               (<code>Optional[Union[int, Literal['*', '+', '?']]]</code>)           \u2013            </li> <li> <code>required</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>type</code>               (<code>Optional[Union[Type, Callable[[str], Any]]]</code>)           \u2013            </li> <li> <code>version</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.CommandArg.action","title":"action  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>action: Optional[Union[CommandLiteralAction, Action]] = None\n</code></pre> <p>See source code</p> <p>The basic type of action to be taken when this argument is encountered at the command line.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.choices","title":"choices  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>choices: Optional[Sequence[Any]] = None\n</code></pre> <p>See source code</p> <p>A sequence of the allowable values for the argument.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.const","title":"const  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>const: Any = None\n</code></pre> <p>See source code</p> <p>A constant value required by some action and nargs selections.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.default","title":"default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default: Any = None\n</code></pre> <p>See source code</p> <p>The value produced if the argument is absent from the command line and if it is absent from the namespace object.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.deprecated","title":"deprecated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deprecated: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Whether or not use of the argument is deprecated.</p> <p>NOTE: This is supported only in Python 3.13+</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.dest","title":"dest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dest: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The name of the attribute to be added to the object returned by parse_args().</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.help","title":"help  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help: Optional[str] = None\n</code></pre> <p>See source code</p> <p>A brief description of what the argument does.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.metavar","title":"metavar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metavar: Optional[str] = None\n</code></pre> <p>See source code</p> <p>A name for the argument in usage messages.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.name_or_flags","title":"name_or_flags  <code>instance-attribute</code>","text":"<pre><code>name_or_flags: Union[str, Sequence[str]]\n</code></pre> <p>See source code</p> <p>Either a name or a list of option strings, e.g. 'foo' or '-f', '--foo'.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.nargs","title":"nargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nargs: Optional[Union[int, Literal['*', '+', '?']]] = None\n</code></pre> <p>See source code</p> <p>The number of command-line arguments that should be consumed.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Whether or not the command-line option may be omitted (optionals only).</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: Optional[Union[Type, Callable[[str], Any]]] = None\n</code></pre> <p>See source code</p> <p>The type to which the command-line argument should be converted.</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The version string to be added to the object returned by parse_args().</p> <p>MUST be used with <code>action='version'</code>.</p> <p>See https://docs.python.org/3/library/argparse.html#action</p>"},{"location":"reference/extension_commands/#django_components.CommandArg.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict\n</code></pre> <p>See source code</p> <p>Convert the dataclass to a dictionary, stripping out fields with <code>None</code> values</p>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup","title":"CommandArgGroup  <code>dataclass</code>","text":"<pre><code>CommandArgGroup(title: Optional[str] = None, description: Optional[str] = None, arguments: Sequence[CommandArg] = ())\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Define a group of arguments for a command.</p> <p>Fields on this class correspond to the arguments for <code>ArgumentParser.add_argument_group()</code></p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>arguments</code>               (<code>Sequence[CommandArg]</code>)           \u2013            </li> <li> <code>description</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>title</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Sequence[CommandArg] = ()\n</code></pre>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Description for the argument group in help output, by default None</p>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Title for the argument group in help output; by default \u201cpositional arguments\u201d if description is provided, otherwise uses title for positional arguments.</p>"},{"location":"reference/extension_commands/#django_components.CommandArgGroup.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict\n</code></pre> <p>See source code</p> <p>Convert the dataclass to a dictionary, stripping out fields with <code>None</code> values</p>"},{"location":"reference/extension_commands/#django_components.CommandHandler","title":"CommandHandler","text":""},{"location":"reference/extension_commands/#django_components.CommandParserInput","title":"CommandParserInput  <code>dataclass</code>","text":"<pre><code>CommandParserInput(\n    prog: Optional[str] = None,\n    usage: Optional[str] = None,\n    description: Optional[str] = None,\n    epilog: Optional[str] = None,\n    parents: Optional[Sequence[ArgumentParser]] = None,\n    formatter_class: Optional[Type[_FormatterClass]] = None,\n    prefix_chars: Optional[str] = None,\n    fromfile_prefix_chars: Optional[str] = None,\n    argument_default: Optional[Any] = None,\n    conflict_handler: Optional[str] = None,\n    add_help: Optional[bool] = None,\n    allow_abbrev: Optional[bool] = None,\n    exit_on_error: Optional[bool] = None,\n)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Typing for the input to the <code>ArgumentParser</code> constructor.</p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>add_help</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>allow_abbrev</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>argument_default</code>               (<code>Optional[Any]</code>)           \u2013            </li> <li> <code>conflict_handler</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>description</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>epilog</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>exit_on_error</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>formatter_class</code>               (<code>Optional[Type[_FormatterClass]]</code>)           \u2013            </li> <li> <code>fromfile_prefix_chars</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>parents</code>               (<code>Optional[Sequence[ArgumentParser]]</code>)           \u2013            </li> <li> <code>prefix_chars</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>prog</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>usage</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.add_help","title":"add_help  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>add_help: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Add a -h/--help option to the parser (default: <code>True</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.allow_abbrev","title":"allow_abbrev  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_abbrev: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Allows long options to be abbreviated if the abbreviation is unambiguous. (default: <code>True</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.argument_default","title":"argument_default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>argument_default: Optional[Any] = None\n</code></pre> <p>See source code</p> <p>The global default value for arguments (default: <code>None</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.conflict_handler","title":"conflict_handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conflict_handler: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The strategy for resolving conflicting optionals (usually unnecessary)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Text to display before the argument help (by default, no text)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.epilog","title":"epilog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>epilog: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Text to display after the argument help (by default, no text)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.exit_on_error","title":"exit_on_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_on_error: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Determines whether or not ArgumentParser exits with error info when an error occurs. (default: <code>True</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.formatter_class","title":"formatter_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>formatter_class: Optional[Type[_FormatterClass]] = None\n</code></pre> <p>See source code</p> <p>A class for customizing the help output</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.fromfile_prefix_chars","title":"fromfile_prefix_chars  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fromfile_prefix_chars: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The set of characters that prefix files from which additional arguments should be read (default: <code>None</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.parents","title":"parents  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parents: Optional[Sequence[ArgumentParser]] = None\n</code></pre> <p>See source code</p> <p>A list of ArgumentParser objects whose arguments should also be included</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.prefix_chars","title":"prefix_chars  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix_chars: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The set of characters that prefix optional arguments (default: \u2018-\u2018)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.prog","title":"prog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prog: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The name of the program (default: <code>os.path.basename(sys.argv[0])</code>)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.usage","title":"usage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>usage: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The string describing the program usage (default: generated from arguments added to parser)</p>"},{"location":"reference/extension_commands/#django_components.CommandParserInput.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict\n</code></pre> <p>See source code</p> <p>Convert the dataclass to a dictionary, stripping out fields with <code>None</code> values</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand","title":"CommandSubcommand  <code>dataclass</code>","text":"<pre><code>CommandSubcommand(\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    prog: Optional[str] = None,\n    parser_class: Optional[Type[ArgumentParser]] = None,\n    action: Optional[Union[CommandLiteralAction, Action]] = None,\n    dest: Optional[str] = None,\n    required: Optional[bool] = None,\n    help: Optional[str] = None,\n    metavar: Optional[str] = None,\n)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Define a subcommand for a command.</p> <p>Fields on this class correspond to the arguments for <code>ArgumentParser.add_subparsers.add_parser()</code></p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>action</code>               (<code>Optional[Union[CommandLiteralAction, Action]]</code>)           \u2013            </li> <li> <code>description</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>dest</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>help</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>metavar</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>parser_class</code>               (<code>Optional[Type[ArgumentParser]]</code>)           \u2013            </li> <li> <code>prog</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>required</code>               (<code>Optional[bool]</code>)           \u2013            </li> <li> <code>title</code>               (<code>Optional[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.action","title":"action  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>action: Optional[Union[CommandLiteralAction, Action]] = None\n</code></pre> <p>See source code</p> <p>The basic type of action to be taken when this argument is encountered at the command line.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Description for the sub-parser group in help output, by default <code>None</code>.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.dest","title":"dest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dest: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the attribute under which sub-command name will be stored; by default <code>None</code> and no value is stored.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.help","title":"help  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Help for sub-parser group in help output, by default <code>None</code>.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.metavar","title":"metavar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metavar: Optional[str] = None\n</code></pre> <p>See source code</p> <p>String presenting available subcommands in help; by default it is None and presents subcommands in form <code>{cmd1, cmd2, ..}</code>.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.parser_class","title":"parser_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_class: Optional[Type[ArgumentParser]] = None\n</code></pre> <p>See source code</p> <p>Class which will be used to create sub-parser instances, by default the class of the current parser (e.g. <code>ArgumentParser</code>).</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.prog","title":"prog  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prog: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Usage information that will be displayed with sub-command help, by default the name of the program and any positional arguments before the subparser argument.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.required","title":"required  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>required: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Whether or not a subcommand must be provided, by default <code>False</code> (added in 3.7)</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Title for the sub-parser group in help output; by default \u201csubcommands\u201d if description is provided, otherwise uses title for positional arguments.</p>"},{"location":"reference/extension_commands/#django_components.CommandSubcommand.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict\n</code></pre> <p>See source code</p> <p>Convert the dataclass to a dictionary, stripping out fields with <code>None</code> values</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand","title":"ComponentCommand","text":"<p>Bases: <code>object</code></p> <p>See source code</p> <p>Definition of a CLI command.</p> <p>This class is based on Python's <code>argparse</code> module and Django's <code>BaseCommand</code> class. <code>ComponentCommand</code> allows you to define:</p> <ul> <li>Command name, description, and help text</li> <li>Arguments and options (e.g. <code>--name John</code>)</li> <li>Group arguments (see argparse groups)</li> <li>Subcommands (e.g. <code>components ext run my_ext hello</code>)</li> <li>Handler behavior</li> </ul> <p>Each extension can add its own commands, which will be available to run with <code>components ext run</code>.</p> <p>Extensions use the <code>ComponentCommand</code> class to define their commands.</p> <p>For example, if you define and install the following extension:</p> <pre><code>from django_components ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n    def handle(self, *args, **kwargs):\n        print(\"Hello, world!\")\n\nclass MyExt(ComponentExtension):\n    name = \"my_ext\"\n    commands = [HelloCommand]\n</code></pre> <p>You can run the <code>hello</code> command with:</p> <pre><code>python manage.py components ext run my_ext hello\n</code></pre> <p>You can also define arguments for the command, which will be passed to the command's <code>handle</code> method.</p> <pre><code>from django_components import CommandArg, ComponentCommand, ComponentExtension\n\nclass HelloCommand(ComponentCommand):\n    name = \"hello\"\n    help = \"Say hello\"\n    arguments = [\n        CommandArg(name=\"name\", help=\"The name to say hello to\"),\n        CommandArg(name=[\"--shout\", \"-s\"], action=\"store_true\"),\n    ]\n\n    def handle(self, name: str, *args, **kwargs):\n        shout = kwargs.get(\"shout\", False)\n        msg = f\"Hello, {name}!\"\n        if shout:\n            msg = msg.upper()\n        print(msg)\n</code></pre> <p>You can run the command with:</p> <pre><code>python manage.py components ext run my_ext hello --name John --shout\n</code></pre> <p>Note</p> <p>Command arguments and options are based on Python's <code>argparse</code> module.</p> <p>For more information, see the argparse documentation.</p> <p>Attributes:</p> <ul> <li> <code>arguments</code>               (<code>Sequence[Union[CommandArg, CommandArgGroup]]</code>)           \u2013            </li> <li> <code>handle</code>               (<code>Optional[CommandHandler]</code>)           \u2013            </li> <li> <code>help</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>parser_input</code>               (<code>Optional[CommandParserInput]</code>)           \u2013            </li> <li> <code>subcommands</code>               (<code>Sequence[Type[ComponentCommand]]</code>)           \u2013            </li> <li> <code>subparser_input</code>               (<code>Optional[CommandSubcommand]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Sequence[Union[CommandArg, CommandArgGroup]] = ()\n</code></pre> <p>See source code</p> <p>argparse arguments for the command</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.handle","title":"handle  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>handle: Optional[CommandHandler] = None\n</code></pre> <p>See source code</p> <p>The function that is called when the command is run. If <code>None</code>, the command will print the help message.</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.help","title":"help  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>help: Optional[str] = None\n</code></pre> <p>See source code</p> <p>The help text for the command</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>The name of the command - this is what is used to call the command</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.parser_input","title":"parser_input  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parser_input: Optional[CommandParserInput] = None\n</code></pre> <p>See source code</p> <p>The input to use when creating the <code>ArgumentParser</code> for this command. If <code>None</code>, the default values will be used.</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.subcommands","title":"subcommands  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subcommands: Sequence[Type[ComponentCommand]] = ()\n</code></pre> <p>See source code</p> <p>Subcommands for the command</p>"},{"location":"reference/extension_commands/#django_components.ComponentCommand.subparser_input","title":"subparser_input  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subparser_input: Optional[CommandSubcommand] = None\n</code></pre> <p>See source code</p> <p>The input to use when this command is a subcommand installed with <code>add_subparser()</code>. If <code>None</code>, the default values will be used.</p>"},{"location":"reference/extension_hooks/","title":"Extension hooks","text":""},{"location":"reference/extension_hooks/#extension-hooks","title":"Extension hooks","text":"<p>Overview of all the extension hooks available in Django Components.</p> <p>Read more on Extensions.</p>"},{"location":"reference/extension_hooks/#hooks","title":"Hooks","text":"<p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The created Component class <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The to-be-deleted Component class <p>Available data:</p> name type description <code>component</code> <code>Component</code> The Component instance that is being rendered <code>component_cls</code> <code>Type[Component]</code> The Component class <code>component_id</code> <code>str</code> The unique identifier for this component instance <code>context_data</code> <code>Dict</code> Dictionary of context data from <code>Component.get_context_data()</code> <code>css_data</code> <code>Dict</code> Dictionary of CSS data from <code>Component.get_css_data()</code> <code>js_data</code> <code>Dict</code> Dictionary of JavaScript data from <code>Component.get_js_data()</code> <p>Available data:</p> name type description <code>args</code> <code>List</code> List of positional arguments passed to the component <code>component</code> <code>Component</code> The Component instance that received the input and is being rendered <code>component_cls</code> <code>Type[Component]</code> The Component class <code>component_id</code> <code>str</code> The unique identifier for this component instance <code>context</code> <code>Context</code> The Django template Context object <code>kwargs</code> <code>Dict</code> Dictionary of keyword arguments passed to the component <code>slots</code> <code>Dict</code> Dictionary of slot definitions <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The registered Component class <code>name</code> <code>str</code> The name the component was registered under <code>registry</code> <code>ComponentRegistry</code> The registry the component was registered to <p>Available data:</p> name type description <code>component</code> <code>Component</code> The Component instance that is being rendered <code>component_cls</code> <code>Type[Component]</code> The Component class <code>component_id</code> <code>str</code> The unique identifier for this component instance <code>result</code> <code>str</code> The rendered component <p>Available data:</p> name type description <code>component_cls</code> <code>Type[Component]</code> The unregistered Component class <code>name</code> <code>str</code> The name the component was registered under <code>registry</code> <code>ComponentRegistry</code> The registry the component was unregistered from <p>Available data:</p> name type description <code>registry</code> <code>ComponentRegistry</code> The created ComponentRegistry instance <p>Available data:</p> name type description <code>registry</code> <code>ComponentRegistry</code> The to-be-deleted ComponentRegistry instance"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_class_created","title":"on_component_class_created","text":"<pre><code>on_component_class_created(ctx: OnComponentClassCreatedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a new <code>Component</code> class is created.</p> <p>This hook is called after the <code>Component</code> class is fully defined but before it's registered.</p> <p>Use this hook to perform any initialization or validation of the <code>Component</code> class.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentClassCreatedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_class_created(self, ctx: OnComponentClassCreatedContext) -&gt; None:\n        # Add a new attribute to the Component class\n        ctx.component_cls.my_attr = \"my_value\"\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_class_deleted","title":"on_component_class_deleted","text":"<pre><code>on_component_class_deleted(ctx: OnComponentClassDeletedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is being deleted.</p> <p>This hook is called before the <code>Component</code> class is deleted from memory.</p> <p>Use this hook to perform any cleanup related to the <code>Component</code> class.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentClassDeletedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_class_deleted(self, ctx: OnComponentClassDeletedContext) -&gt; None:\n        # Remove Component class from the extension's cache on deletion\n        self.cache.pop(ctx.component_cls, None)\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_data","title":"on_component_data","text":"<pre><code>on_component_data(ctx: OnComponentDataContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was triggered to render, after a component's context and data methods have been processed.</p> <p>This hook is called after <code>Component.get_template_data()</code>, <code>Component.get_js_data()</code> and <code>Component.get_css_data()</code>.</p> <p>This hook runs after <code>on_component_input</code>.</p> <p>Use this hook to modify or validate the component's data before rendering.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentDataContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_data(self, ctx: OnComponentDataContext) -&gt; None:\n        # Add extra template variable to all components when they are rendered\n        ctx.template_data[\"my_template_var\"] = \"my_value\"\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_input","title":"on_component_input","text":"<pre><code>on_component_input(ctx: OnComponentInputContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was triggered to render, but before a component's context and data methods are invoked.</p> <p>Use this hook to modify or validate component inputs before they're processed.</p> <p>This is the first hook that is called when rendering a component. As such this hook is called before <code>Component.get_template_data()</code>, <code>Component.get_js_data()</code>, and <code>Component.get_css_data()</code> methods, and the <code>on_component_data</code> hook.</p> <p>This hook also allows to skip the rendering of a component altogether. If the hook returns a non-null value, this value will be used instead of rendering the component.</p> <p>You can use this to implement a caching mechanism for components, or define components that will be rendered conditionally.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentInputContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_input(self, ctx: OnComponentInputContext) -&gt; None:\n        # Add extra kwarg to all components when they are rendered\n        ctx.kwargs[\"my_input\"] = \"my_value\"\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_registered","title":"on_component_registered","text":"<pre><code>on_component_registered(ctx: OnComponentRegisteredContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is registered with a <code>ComponentRegistry</code>.</p> <p>This hook is called after a <code>Component</code> class is successfully registered.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentRegisteredContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_registered(self, ctx: OnComponentRegisteredContext) -&gt; None:\n        print(f\"Component {ctx.component_cls} registered to {ctx.registry} as '{ctx.name}'\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_rendered","title":"on_component_rendered","text":"<pre><code>on_component_rendered(ctx: OnComponentRenderedContext) -&gt; Optional[str]\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> was rendered, including all its child components.</p> <p>Use this hook to access or post-process the component's rendered output.</p> <p>To modify the output, return a new string from this hook.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentRenderedContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_rendered(self, ctx: OnComponentRenderedContext) -&gt; Optional[str]:\n        # Append a comment to the component's rendered output\n        return ctx.result + \"&lt;!-- MyExtension comment --&gt;\"\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_component_unregistered","title":"on_component_unregistered","text":"<pre><code>on_component_unregistered(ctx: OnComponentUnregisteredContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>Component</code> class is unregistered from a <code>ComponentRegistry</code>.</p> <p>This hook is called after a <code>Component</code> class is removed from the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnComponentUnregisteredContext\n\nclass MyExtension(ComponentExtension):\n    def on_component_unregistered(self, ctx: OnComponentUnregisteredContext) -&gt; None:\n        print(f\"Component {ctx.component_cls} unregistered from {ctx.registry} as '{ctx.name}'\")\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_registry_created","title":"on_registry_created","text":"<pre><code>on_registry_created(ctx: OnRegistryCreatedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a new <code>ComponentRegistry</code> is created.</p> <p>This hook is called after a new <code>ComponentRegistry</code> instance is initialized.</p> <p>Use this hook to perform any initialization needed for the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnRegistryCreatedContext\n\nclass MyExtension(ComponentExtension):\n    def on_registry_created(self, ctx: OnRegistryCreatedContext) -&gt; None:\n        # Add a new attribute to the registry\n        ctx.registry.my_attr = \"my_value\"\n</code></pre>"},{"location":"reference/extension_hooks/#django_components.extension.ComponentExtension.on_registry_deleted","title":"on_registry_deleted","text":"<pre><code>on_registry_deleted(ctx: OnRegistryDeletedContext) -&gt; None\n</code></pre> <p>See source code</p> <p>Called when a <code>ComponentRegistry</code> is being deleted.</p> <p>This hook is called before a <code>ComponentRegistry</code> instance is deleted.</p> <p>Use this hook to perform any cleanup related to the registry.</p> <p>Example:</p> <pre><code>from django_components import ComponentExtension, OnRegistryDeletedContext\n\nclass MyExtension(ComponentExtension):\n    def on_registry_deleted(self, ctx: OnRegistryDeletedContext) -&gt; None:\n        # Remove registry from the extension's cache on deletion\n        self.cache.pop(ctx.registry, None)\n</code></pre>"},{"location":"reference/extension_hooks/#objects","title":"Objects","text":""},{"location":"reference/extension_hooks/#django_components.extension.OnComponentClassCreatedContext","title":"OnComponentClassCreatedContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentClassCreatedContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The created Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentClassDeletedContext","title":"OnComponentClassDeletedContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentClassDeletedContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The to-be-deleted Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext","title":"OnComponentDataContext","text":"<p>Attributes:</p> <ul> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>context_data</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>css_data</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>js_data</code>               (<code>Dict</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.component","title":"component  <code>instance-attribute</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>The Component instance that is being rendered</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: str\n</code></pre> <p>See source code</p> <p>The unique identifier for this component instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.context_data","title":"context_data  <code>instance-attribute</code>","text":"<pre><code>context_data: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of context data from <code>Component.get_context_data()</code></p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.css_data","title":"css_data  <code>instance-attribute</code>","text":"<pre><code>css_data: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of CSS data from <code>Component.get_css_data()</code></p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentDataContext.js_data","title":"js_data  <code>instance-attribute</code>","text":"<pre><code>js_data: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of JavaScript data from <code>Component.get_js_data()</code></p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext","title":"OnComponentInputContext","text":"<p>Attributes:</p> <ul> <li> <code>args</code>               (<code>List</code>)           \u2013            </li> <li> <code>component</code>               (<code>Component</code>)           \u2013            </li> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>component_id</code>               (<code>str</code>)           \u2013            </li> <li> <code>context</code>               (<code>Context</code>)           \u2013            </li> <li> <code>kwargs</code>               (<code>Dict</code>)           \u2013            </li> <li> <code>slots</code>               (<code>Dict</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: List\n</code></pre> <p>See source code</p> <p>List of positional arguments passed to the component</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.component","title":"component  <code>instance-attribute</code>","text":"<pre><code>component: Component\n</code></pre> <p>See source code</p> <p>The Component instance that received the input and is being rendered</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.component_id","title":"component_id  <code>instance-attribute</code>","text":"<pre><code>component_id: str\n</code></pre> <p>See source code</p> <p>The unique identifier for this component instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Context\n</code></pre> <p>See source code</p> <p>The Django template Context object</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of keyword arguments passed to the component</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentInputContext.slots","title":"slots  <code>instance-attribute</code>","text":"<pre><code>slots: Dict\n</code></pre> <p>See source code</p> <p>Dictionary of slot definitions</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRegisteredContext","title":"OnComponentRegisteredContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRegisteredContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The registered Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRegisteredContext.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>The name the component was registered under</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentRegisteredContext.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The registry the component was registered to</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentUnregisteredContext","title":"OnComponentUnregisteredContext","text":"<p>Attributes:</p> <ul> <li> <code>component_cls</code>               (<code>Type[Component]</code>)           \u2013            </li> <li> <code>name</code>               (<code>str</code>)           \u2013            </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentUnregisteredContext.component_cls","title":"component_cls  <code>instance-attribute</code>","text":"<pre><code>component_cls: Type[Component]\n</code></pre> <p>See source code</p> <p>The unregistered Component class</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentUnregisteredContext.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>See source code</p> <p>The name the component was registered under</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnComponentUnregisteredContext.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The registry the component was unregistered from</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnRegistryCreatedContext","title":"OnRegistryCreatedContext","text":"<p>Attributes:</p> <ul> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnRegistryCreatedContext.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The created ComponentRegistry instance</p>"},{"location":"reference/extension_hooks/#django_components.extension.OnRegistryDeletedContext","title":"OnRegistryDeletedContext","text":"<p>Attributes:</p> <ul> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_hooks/#django_components.extension.OnRegistryDeletedContext.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry: ComponentRegistry\n</code></pre> <p>See source code</p> <p>The to-be-deleted ComponentRegistry instance</p>"},{"location":"reference/extension_urls/","title":"Extension URLs","text":""},{"location":"reference/extension_urls/#extension-urls","title":"Extension URLs","text":"<p>Overview of all classes, functions, and other objects related to defining extension URLs.</p> <p>Read more on Extensions.</p>"},{"location":"reference/extension_urls/#django_components.URLRoute","title":"URLRoute  <code>dataclass</code>","text":"<pre><code>URLRoute(\n    path: str,\n    handler: Optional[URLRouteHandler] = None,\n    children: Iterable[URLRoute] = list(),\n    name: Optional[str] = None,\n    extra: Dict[str, Any] = dict(),\n)\n</code></pre> <p>Bases: <code>object</code></p> <p>See source code</p> <p>Framework-agnostic route definition.</p> <p>This is similar to Django's <code>URLPattern</code> object created with <code>django.urls.path()</code>.</p> <p>The <code>URLRoute</code> must either define a <code>handler</code> function or have a list of child routes <code>children</code>. If both are defined, an error will be raised.</p> <p>Example:</p> <pre><code>URLRoute(\"/my/path\", handler=my_handler, name=\"my_name\", extra={\"kwargs\": {\"my_extra\": \"my_value\"}})\n</code></pre> <p>Is equivalent to:</p> <pre><code>django.urls.path(\"/my/path\", my_handler, name=\"my_name\", kwargs={\"my_extra\": \"my_value\"})\n</code></pre> <p>With children:</p> <pre><code>URLRoute(\n    \"/my/path\",\n    name=\"my_name\",\n    extra={\"kwargs\": {\"my_extra\": \"my_value\"}},\n    children=[\n        URLRoute(\n            \"/child/&lt;str:name&gt;/\",\n            handler=my_handler,\n            name=\"my_name\",\n            extra={\"kwargs\": {\"my_extra\": \"my_value\"}},\n        ),\n        URLRoute(\"/other/&lt;int:id&gt;/\", handler=other_handler),\n    ],\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>Iterable[URLRoute]</code>)           \u2013            </li> <li> <code>extra</code>               (<code>Dict[str, Any]</code>)           \u2013            </li> <li> <code>handler</code>               (<code>Optional[URLRouteHandler]</code>)           \u2013            </li> <li> <code>name</code>               (<code>Optional[str]</code>)           \u2013            </li> <li> <code>path</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/extension_urls/#django_components.URLRoute.children","title":"children  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>children: Iterable[URLRoute] = field(default_factory=list)\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRoute.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra: Dict[str, Any] = field(default_factory=dict)\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRoute.handler","title":"handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>handler: Optional[URLRouteHandler] = None\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRoute.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRoute.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre>"},{"location":"reference/extension_urls/#django_components.URLRouteHandler","title":"URLRouteHandler","text":"<p>Bases: <code>typing.Protocol</code></p> <p>See source code</p> <p>Framework-agnostic 'view' function for routes</p>"},{"location":"reference/middlewares/","title":"Middlewares","text":""},{"location":"reference/middlewares/#middlewares","title":"Middlewares","text":""},{"location":"reference/middlewares/#django_components.dependencies.ComponentDependencyMiddleware","title":"<code>ComponentDependencyMiddleware</code>","text":"<p>Bases: <code>object</code></p> <p>See source code</p> <p>Middleware that inserts CSS/JS dependencies for all rendered components at points marked with template tags.</p>"},{"location":"reference/settings/","title":"Settings","text":""},{"location":"reference/settings/#settings","title":"Settings","text":"<p>You can configure django_components with a global <code>COMPONENTS</code> variable in your Django settings file, e.g. <code>settings.py</code>. By default you don't need it set, there are resonable defaults.</p> <p>To configure the settings you can instantiate <code>ComponentsSettings</code> for validation and type hints. Or, for backwards compatibility, you can also use plain dictionary:</p> <pre><code># settings.py\nfrom django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    autodiscover=True,\n    ...\n)\n\n# or\n\nCOMPONENTS = {\n    \"autodiscover\": True,\n    ...\n}\n</code></pre>"},{"location":"reference/settings/#settings-defaults","title":"Settings defaults","text":"<p>Here's overview of all available settings and their defaults:</p> <pre><code>defaults = ComponentsSettings(\n    autodiscover=True,\n    cache=None,\n    context_behavior=ContextBehavior.DJANGO.value,  # \"django\" | \"isolated\"\n    # Root-level \"components\" dirs, e.g. `/path/to/proj/components/`\n    dirs=[Path(settings.BASE_DIR) / \"components\"],\n    # App-level \"components\" dirs, e.g. `[app]/components/`\n    app_dirs=[\"components\"],\n    debug_highlight_components=False,\n    debug_highlight_slots=False,\n    dynamic_component_name=\"dynamic\",\n    extensions=[],\n    libraries=[],  # E.g. [\"mysite.components.forms\", ...]\n    multiline_tags=True,\n    reload_on_file_change=False,\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\", \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n    static_files_forbidden=[\n        # See https://marketplace.visualstudio.com/items?itemName=junstyle.vscode-django-support\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n    tag_formatter=\"django_components.component_formatter\",\n    template_cache_size=128,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.app_dirs","title":"app_dirs","text":"<pre><code>app_dirs: Optional[Sequence[str]] = None\n</code></pre> <p>See source code</p> <p>Specify the app-level directories that contain your components.</p> <p>Defaults to <code>[\"components\"]</code>. That is, for each Django app, we search <code>&lt;app&gt;/components/</code> for components.</p> <p>The paths must be relative to app, e.g.:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[\"my_comps\"],\n)\n</code></pre> <p>To search for <code>&lt;app&gt;/my_comps/</code>.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <p>Set to empty list to disable app-level components:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[],\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.autodiscover","title":"autodiscover","text":"<pre><code>autodiscover: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Toggle whether to run autodiscovery at the Django server startup.</p> <p>Defaults to <code>True</code></p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.cache","title":"cache","text":"<pre><code>cache: Optional[str] = None\n</code></pre> <p>See source code</p> <p>Name of the Django cache to be used for storing component's JS and CSS files.</p> <p>If <code>None</code>, a <code>LocMemCache</code> is used with default settings.</p> <p>Defaults to <code>None</code>.</p> <p>Read more about caching.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    cache=\"my_cache\",\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.context_behavior","title":"context_behavior","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>See source code</p> <p>Configure whether, inside a component template, you can use variables from the outside (<code>\"django\"</code>) or not (<code>\"isolated\"</code>). This also affects what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Defaults to <code>\"django\"</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    context_behavior=\"isolated\",\n)\n</code></pre> <p>NOTE: <code>context_behavior</code> and <code>slot_context_behavior</code> options were merged in v0.70.</p> <p>If you are migrating from BEFORE v0.67, set <code>context_behavior</code> to <code>\"django\"</code>. From v0.67 to v0.78 (incl) the default value was <code>\"isolated\"</code>.</p> <p>For v0.79 and later, the default is again <code>\"django\"</code>. See the rationale for change here.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.debug_highlight_components","title":"debug_highlight_components","text":"<pre><code>debug_highlight_components: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Enable / disable component highlighting. See Troubleshooting for more details.</p> <p>Defaults to <code>False</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_components=True,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.debug_highlight_slots","title":"debug_highlight_slots","text":"<pre><code>debug_highlight_slots: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Enable / disable slot highlighting. See Troubleshooting for more details.</p> <p>Defaults to <code>False</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    debug_highlight_slots=True,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.dirs","title":"dirs","text":"<pre><code>dirs: Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]] = None\n</code></pre> <p>See source code</p> <p>Specify the directories that contain your components.</p> <p>Defaults to <code>[Path(settings.BASE_DIR) / \"components\"]</code>. That is, the root <code>components/</code> app.</p> <p>Directories must be full paths, same as with STATICFILES_DIRS.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[BASE_DIR / \"components\"],\n)\n</code></pre> <p>Set to empty list to disable global components directories:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[],\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.dynamic_component_name","title":"dynamic_component_name","text":"<pre><code>dynamic_component_name: Optional[str] = None\n</code></pre> <p>See source code</p> <p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>.</p> <p>In case of a conflict, you can use this setting to change the component name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.extensions","title":"extensions","text":"<pre><code>extensions: Optional[Sequence[Union[Type[ComponentExtension], str]]] = None\n</code></pre> <p>See source code</p> <p>List of extensions to be loaded.</p> <p>The extensions can be specified as:</p> <ul> <li>Python import path, e.g. <code>\"path.to.my_extension.MyExtension\"</code>.</li> <li>Extension class, e.g. <code>my_extension.MyExtension</code>.</li> </ul> <pre><code>COMPONENTS = ComponentsSettings(\n    extensions=[\n        \"path.to.my_extension.MyExtension\",\n        StorybookExtension,\n    ],\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.forbidden_static_files","title":"forbidden_static_files","text":"<pre><code>forbidden_static_files: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>COMPONENTS.static_files_forbidden</code> instead.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.libraries","title":"libraries","text":"<pre><code>libraries: Optional[List[str]] = None\n</code></pre> <p>See source code</p> <p>Configure extra python modules that should be loaded.</p> <p>This may be useful if you are not using the autodiscovery feature, or you need to load components from non-standard locations. Thus you can have a structure of components that is independent from your apps.</p> <p>Expects a list of python module paths. Defaults to empty list.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    libraries=[\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n)\n</code></pre> <p>This would be the equivalent of importing these modules from within Django's <code>AppConfig.ready()</code>:</p> <pre><code>class MyAppConfig(AppConfig):\n    def ready(self):\n        import \"mysite.components.forms\"\n        import \"mysite.components.buttons\"\n        import \"mysite.components.cards\"\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.libraries--manually-loading-libraries","title":"Manually loading libraries","text":"<p>In the rare case that you need to manually trigger the import of libraries, you can use the <code>import_libraries()</code> function:</p> <pre><code>from django_components import import_libraries\n\nimport_libraries()\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.multiline_tags","title":"multiline_tags","text":"<pre><code>multiline_tags: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Enable / disable multiline support for template tags. If <code>True</code>, template tags like <code>{% component %}</code> or <code>{{ my_var }}</code> can span multiple lines.</p> <p>Defaults to <code>True</code>.</p> <p>Disable this setting if you are making custom modifications to Django's regular expression for parsing templates at <code>django.template.base.tag_re</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    multiline_tags=False,\n)\n</code></pre>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.reload_on_file_change","title":"reload_on_file_change","text":"<pre><code>reload_on_file_change: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>This is relevant if you are using the project structure where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>Django's native live reload logic handles only Python files and HTML template files. It does NOT reload when other file types change or when template files are nested more than one level deep.</p> <p>The setting <code>reload_on_file_change</code> fixes this, reloading the dev server even when your component's HTML, JS, or CSS changes.</p> <p>If <code>True</code>, django_components configures Django to reload when files inside <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> change.</p> <p>See Reload dev server on component file changes.</p> <p>Defaults to <code>False</code>.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.reload_on_template_change","title":"reload_on_template_change","text":"<pre><code>reload_on_template_change: Optional[bool] = None\n</code></pre> <p>See source code</p> <p>Deprecated. Use <code>COMPONENTS.reload_on_file_change</code> instead.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.static_files_allowed","title":"static_files_allowed","text":"<pre><code>static_files_allowed: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> are treated as static files.</p> <p>If a file is matched against any of the patterns, it's considered a static file. Such files are collected when running <code>collectstatic</code>, and can be accessed under the static file endpoint.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, JS, CSS, and common image and font file formats are considered static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\",  \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.static_files_forbidden","title":"static_files_forbidden","text":"<pre><code>static_files_forbidden: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>See source code</p> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> will NEVER be treated as static files.</p> <p>If a file is matched against any of the patterns, it will never be considered a static file, even if the file matches a pattern in <code>static_files_allowed</code>.</p> <p>Use this setting together with <code>static_files_allowed</code> for a fine control over what file types will be exposed.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, any HTML and Python are considered NOT static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_forbidden=[\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.tag_formatter","title":"tag_formatter","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>See source code</p> <p>Configure what syntax is used inside Django templates to render components. See the available tag formatters.</p> <p>Defaults to <code>\"django_components.component_formatter\"</code>.</p> <p>Learn more about Customizing component tags with TagFormatter.</p> <p>Can be set either as direct reference:</p> <pre><code>from django_components import component_formatter\n\nCOMPONENTS = ComponentsSettings(\n    \"tag_formatter\": component_formatter\n)\n</code></pre> <p>Or as an import string;</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>Examples:</p> <ul> <li> <p><code>\"django_components.component_formatter\"</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    Click me!\n{% endcomponent %}\n</code></pre> </li> <li> <p><code>django_components.component_shorthand_formatter</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"reference/settings/#django_components.app_settings.ComponentsSettings.template_cache_size","title":"template_cache_size","text":"<pre><code>template_cache_size: Optional[int] = None\n</code></pre> <p>See source code</p> <p>Configure the maximum amount of Django templates to be cached.</p> <p>Defaults to <code>128</code>.</p> <p>Each time a Django template is rendered, it is cached to a global in-memory cache (using Python's <code>lru_cache</code> decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up.</p> <p>By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are overriding <code>Component.get_template()</code> to render many dynamic templates, you can increase this number.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=256,\n)\n</code></pre> <p>To remove the cache limit altogether and cache everything, set <code>template_cache_size</code> to <code>None</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=None,\n)\n</code></pre> <p>If you want to add templates to the cache yourself, you can use <code>cached_template()</code>:</p> <pre><code>from django_components import cached_template\n\ncached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ncached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/signals/","title":"Signals","text":""},{"location":"reference/signals/#signals","title":"Signals","text":"<p>Below are the signals that are sent by or during the use of django-components.</p>"},{"location":"reference/signals/#template_rendered","title":"template_rendered","text":"<p>Django's <code>template_rendered</code> signal. This signal is sent when a template is rendered.</p> <p>Django-components triggers this signal when a component is rendered. If there are nested components, the signal is triggered for each component.</p> <p>Import from django as <code>django.test.signals.template_rendered</code>.</p> <pre><code>from django.test.signals import template_rendered\n\n# Setup a callback function\ndef my_callback(sender, **kwargs):\n    ...\n\ntemplate_rendered.connect(my_callback)\n\nclass MyTable(Component):\n    template = \"\"\"\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;th&gt;Header&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;Cell&lt;/td&gt;\n        &lt;/tr&gt;\n    \"\"\"\n\n# This will trigger the signal\nMyTable().render()\n</code></pre>"},{"location":"reference/tag_formatters/","title":"Tag formatters","text":""},{"location":"reference/tag_formatters/#tag-formatters","title":"Tag Formatters","text":"<p>Tag formatters allow you to change the syntax for calling components from within the Django templates.</p> <p>Tag formatter are set via the tag_formatter setting.</p>"},{"location":"reference/tag_formatters/#available-tag-formatters","title":"Available tag formatters","text":"<ul> <li> <p><code>django_components.component_formatter</code> for ComponentFormatter</p> </li> <li> <p><code>django_components.component_shorthand_formatter</code> for ShorthandComponentFormatter </p> </li> </ul>"},{"location":"reference/tag_formatters/#django_components.tag_formatter.ComponentFormatter","title":"<code>ComponentFormatter</code>","text":"<p>Bases: <code>django_components.tag_formatter.TagFormatterABC</code></p> <p>See source code</p> <p>The original django_component's component tag formatter, it uses the <code>{% component %}</code> and <code>{% endcomponent %}</code> tags, and the component name is given as the first positional arg.</p> <p>Example as block: <pre><code>{% component \"mycomp\" abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% component \"mycomp\" abc=123 / %}\n</code></pre></p>"},{"location":"reference/tag_formatters/#django_components.tag_formatter.ShorthandComponentFormatter","title":"<code>ShorthandComponentFormatter</code>","text":"<p>Bases: <code>django_components.tag_formatter.TagFormatterABC</code></p> <p>See source code</p> <p>The component tag formatter that uses <code>{% &lt;name&gt; %}</code> / <code>{% end&lt;name&gt; %}</code> tags.</p> <p>This is similar to django-web-components and django-slippers syntax.</p> <p>Example as block: <pre><code>{% mycomp abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endmycomp %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% mycomp abc=123 / %}\n</code></pre></p>"},{"location":"reference/template_tags/","title":"Template tags","text":""},{"location":"reference/template_tags/#template-tags","title":"Template tags","text":"<p>All following template tags are defined in</p> <p><code>django_components.templatetags.component_tags</code></p> <p>Import as <pre><code>{% load component_tags %}\n</code></pre></p>"},{"location":"reference/template_tags/#component_css_dependencies","title":"component_css_dependencies","text":"<pre><code>{% component_css_dependencies  %}\n</code></pre> <p>See source code</p> <p>Marks location where CSS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted into the <code>&lt;head&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_css_dependencies %}</code> tags, CSS links are by default inserted into the <code>&lt;head&gt;</code> tag of the HTML. (See JS and CSS output locations)</p> <p>Note that there should be only one <code>{% component_css_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL CSS links will be duplicately inserted into ALL these places.</p>"},{"location":"reference/template_tags/#component_js_dependencies","title":"component_js_dependencies","text":"<pre><code>{% component_js_dependencies  %}\n</code></pre> <p>See source code</p> <p>Marks location where JS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_js_dependencies %}</code> tags, JS scripts are by default inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML. (See JS and CSS output locations)</p> <p>Note that there should be only one <code>{% component_js_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL JS scripts will be duplicately inserted into ALL these places.</p>"},{"location":"reference/template_tags/#component","title":"component","text":"<pre><code>{% component *args: Any, **kwargs: Any [only] %}\n{% endcomponent %}\n</code></pre> <p>See source code</p> <p>Renders one of the components that was previously registered with <code>@register()</code> decorator.</p> <p>The <code>{% component %}</code> tag takes:</p> <ul> <li>Component's registered name as the first positional argument,</li> <li>Followed by any number of positional and keyword arguments.</li> </ul> <pre><code>{% load component_tags %}\n&lt;div&gt;\n    {% component \"button\" name=\"John\" job=\"Developer\" / %}\n&lt;/div&gt;\n</code></pre> <p>The component name must be a string literal.</p>"},{"location":"reference/template_tags/#inserting-slot-fills","title":"Inserting slot fills","text":"<p>If the component defined any slots, you can \"fill\" these slots by placing the <code>{% fill %}</code> tags within the <code>{% component %}</code> tag:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>You can even nest <code>{% fill %}</code> tags within <code>{% if %}</code>, <code>{% for %}</code> and other tags:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers %}\n    {% if rows %}\n        {% fill \"pagination\" %}\n            &lt; 1 | 2 | 3 &gt;\n        {% endfill %}\n    {% endif %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#isolating-components","title":"Isolating components","text":"<p>By default, components behave similarly to Django's <code>{% include %}</code>, and the template inside the component has access to the variables defined in the outer template.</p> <p>You can selectively isolate a component, using the <code>only</code> flag, so that the inner template can access only the data that was explicitly passed to it:</p> <pre><code>{% component \"name\" positional_arg keyword_arg=value ... only %}\n</code></pre> <p>Alternatively, you can set all components to be isolated by default, by setting <code>context_behavior</code> to <code>\"isolated\"</code> in your settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"context_behavior\": \"isolated\",\n}\n</code></pre>"},{"location":"reference/template_tags/#omitting-the-component-keyword","title":"Omitting the <code>component</code> keyword","text":"<p>If you would like to omit the <code>component</code> keyword, and simply refer to your components by their registered names:</p> <pre><code>{% button name=\"John\" job=\"Developer\" / %}\n</code></pre> <p>You can do so by setting the \"shorthand\" Tag formatter in the settings:</p> <pre><code># settings.py\nCOMPONENTS = {\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\",\n}\n</code></pre>"},{"location":"reference/template_tags/#fill","title":"fill","text":"<pre><code>{% fill name: str, *, data: Optional[str] = None, default: Optional[str] = None %}\n{% endfill %}\n</code></pre> <p>See source code</p> <p>Use this tag to insert content into component's slots.</p> <p><code>{% fill %}</code> tag may be used only within a <code>{% component %}..{% endcomponent %}</code> block. Runtime checks should prohibit other usages.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Name of the slot to insert this content into. Use <code>\"default\"</code> for     the default slot.</li> <li><code>default</code> (str, optional): This argument allows you to access the original content of the slot     under the specified variable name. See     Accessing original content of slots</li> <li><code>data</code> (str, optional): This argument allows you to access the data passed to the slot     under the specified variable name. See Scoped slots</li> </ul> <p>Examples:</p> <p>Basic usage: <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre></p>"},{"location":"reference/template_tags/#accessing-slots-default-content-with-the-default-kwarg","title":"Accessing slot's default content with the <code>default</code> kwarg","text":"<pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" default=\"default_pag\" %}\n    &lt;div class=\"my-class\"&gt;\n      {{ default_pag }}\n    &lt;/div&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#accessing-slots-data-with-the-data-kwarg","title":"Accessing slot's data with the <code>data</code> kwarg","text":"<pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" pages=pages %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" data=\"slot_data\" %}\n    {% for page in slot_data.pages %}\n        &lt;a href=\"{{ page.link }}\"&gt;\n          {{ page.index }}\n        &lt;/a&gt;\n    {% endfor %}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#accessing-slot-data-and-default-content-on-the-default-slot","title":"Accessing slot data and default content on the default slot","text":"<p>To access slot data and the default slot content on the default slot, use <code>{% fill %}</code> with <code>name</code> set to <code>\"default\"</code>:</p> <pre><code>{% component \"button\" %}\n  {% fill name=\"default\" data=\"slot_data\" default=\"default_slot\" %}\n    You clicked me {{ slot_data.count }} times!\n    {{ default_slot }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/template_tags/#html_attrs","title":"html_attrs","text":"<pre><code>{% html_attrs attrs: Optional[Dict] = None, defaults: Optional[Dict] = None, **kwargs: Any %}\n</code></pre> <p>See source code</p> <p>Generate HTML attributes (<code>key=\"value\"</code>), combining data from multiple sources, whether its template variables or static text.</p> <p>It is designed to easily merge HTML attributes passed from outside with the internal. See how to in Passing HTML attributes to components.</p> <p>Args:</p> <ul> <li><code>attrs</code> (dict, optional): Optional dictionary that holds HTML attributes. On conflict, overrides     values in the <code>default</code> dictionary.</li> <li><code>default</code> (str, optional): Optional dictionary that holds HTML attributes. On conflict, is overriden     with values in the <code>attrs</code> dictionary.</li> <li>Any extra kwargs will be appended to the corresponding keys</li> </ul> <p>The attributes in <code>attrs</code> and <code>defaults</code> are merged and resulting dict is rendered as HTML attributes (<code>key=\"value\"</code>).</p> <p>Extra kwargs (<code>key=value</code>) are concatenated to existing keys. So if we have</p> <pre><code>attrs = {\"class\": \"my-class\"}\n</code></pre> <p>Then</p> <pre><code>{% html_attrs attrs class=\"extra-class\" %}\n</code></pre> <p>will result in <code>class=\"my-class extra-class\"</code>.</p> <p>Example: <pre><code>&lt;div {% html_attrs\n    attrs\n    defaults:class=\"default-class\"\n    class=\"extra-class\"\n    data-id=\"123\"\n%}&gt;\n</code></pre></p> <p>renders</p> <pre><code>&lt;div class=\"my-class extra-class\" data-id=\"123\"&gt;\n</code></pre> <p>See more usage examples in HTML attributes.</p>"},{"location":"reference/template_tags/#provide","title":"provide","text":"<pre><code>{% provide name: str, **kwargs: Any %}\n{% endprovide %}\n</code></pre> <p>See source code</p> <p>The \"provider\" part of the provide / inject feature. Pass kwargs to this tag to define the provider's data. Any components defined within the <code>{% provide %}..{% endprovide %}</code> tags will be able to access this data with <code>Component.inject()</code>.</p> <p>This is similar to React's <code>ContextProvider</code>, or Vue's <code>provide()</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Provider name. This is the name you will then use in     <code>Component.inject()</code>.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the provided data.</li> </ul> <p>Example:</p> <p>Provide the \"user_data\" in parent component:</p> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% provide \"user_data\" user=user %}\n          {% component \"child\" / %}\n        {% endprovide %}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"user\": kwargs[\"user\"],\n        }\n</code></pre> <p>Since the \"child\" component is used within the <code>{% provide %} / {% endprovide %}</code> tags, we can request the \"user_data\" using <code>Component.inject(\"user_data\")</code>:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        User is: {{ user }}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_template_data(self, args, kwargs, slots, context):\n        user = self.inject(\"user_data\").user\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Notice that the keys defined on the <code>{% provide %}</code> tag are then accessed as attributes when accessing them with <code>Component.inject()</code>.</p> <p>\u2705 Do this <pre><code>user = self.inject(\"user_data\").user\n</code></pre></p> <p>\u274c Don't do this <pre><code>user = self.inject(\"user_data\")[\"user\"]\n</code></pre></p>"},{"location":"reference/template_tags/#slot","title":"slot","text":"<pre><code>{% slot name: str, **kwargs: Any [default] [required] %}\n{% endslot %}\n</code></pre> <p>See source code</p> <p>Slot tag marks a place inside a component where content can be inserted from outside.</p> <p>Learn more about using slots.</p> <p>This is similar to slots as seen in Web components, Vue or React's <code>children</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li><code>default</code>: Optional flag. If there is a default slot, you can pass the component slot content     without using the <code>{% fill %}</code> tag. See     Default slot</li> <li><code>required</code>: Optional flag. Will raise an error if a slot is required but not given.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the slot data.</li> </ul> <p>Example:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" default %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n      &lt;aside&gt;\n        {% slot \"sidebar\" required / %}\n      &lt;/aside&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% fill \"content\" %}\n            \ud83d\uddde\ufe0f\ud83d\udcf0\n          {% endfill %}\n\n          {% fill \"sidebar\" %}\n            \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n          {% endfill %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/template_tags/#passing-data-to-slots","title":"Passing data to slots","text":"<p>Any extra kwargs will be considered as slot data, and will be accessible in the <code>{% fill %}</code> tag via fill's <code>data</code> kwarg:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {# Passing data to the slot #}\n        {% slot \"content\" user=user %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot data #}\n      {% component \"child\" %}\n        {% fill \"content\" data=\"data\" %}\n          &lt;div class=\"wrapper-class\"&gt;\n            {{ data.user }}\n          &lt;/div&gt;\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre>"},{"location":"reference/template_tags/#accessing-default-slot-content","title":"Accessing default slot content","text":"<p>The content between the <code>{% slot %}..{% endslot %}</code> tags is the default content that will be rendered if no fill is given for the slot.</p> <p>This default content can then be accessed from within the <code>{% fill %}</code> tag using the fill's <code>default</code> kwarg. This is useful if you need to wrap / prepend / append the original slot's content.</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" %}\n          This is default content!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot's default content #}\n      {% component \"child\" %}\n        {% fill \"content\" default=\"default\" %}\n          {{ default }}\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre>"},{"location":"reference/template_vars/","title":"Template vars","text":""},{"location":"reference/template_vars/#template-variables","title":"Template variables","text":"<p>Here is a list of all variables that are automatically available from inside the component's template and in <code>on_render_before</code> / <code>on_render_after</code> hooks.</p>"},{"location":"reference/template_vars/#django_components.component.ComponentVars.is_filled","title":"is_filled  <code>instance-attribute</code>","text":"<pre><code>is_filled: Dict[str, bool]\n</code></pre> <p>See source code</p> <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> <p>New in version 0.70</p> <p>Use as <code>{{ component_vars.is_filled }}</code></p> <p>Example:</p> <pre><code>{# Render wrapping HTML only if the slot is defined #}\n{% if component_vars.is_filled.my_slot %}\n    &lt;div class=\"slot-wrapper\"&gt;\n        {% slot \"my_slot\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre> <p>This is equivalent to checking if a given key is among the slot fills:</p> <pre><code>class MyTable(Component):\n    def get_template_data(self, args, kwargs, slots, context):\n        return {\n            \"my_slot_filled\": \"my_slot\" in slots\n        }\n</code></pre>"},{"location":"reference/testing_api/","title":"Testing API","text":""},{"location":"reference/testing_api/#testing-api","title":"Testing API","text":""},{"location":"reference/testing_api/#django_components.testing.djc_test","title":"djc_test","text":"<pre><code>djc_test(\n    django_settings: Union[Optional[Dict], Callable, Type] = None,\n    components_settings: Optional[Dict] = None,\n    parametrize: Optional[\n        Union[\n            Tuple[Sequence[str], Sequence[Sequence[Any]]],\n            Tuple[\n                Sequence[str],\n                Sequence[Sequence[Any]],\n                Optional[Union[Iterable[Union[None, str, float, int, bool]], Callable[[Any], Optional[object]]]],\n            ],\n        ]\n    ] = None,\n    gc_collect: bool = True,\n) -&gt; Callable\n</code></pre> <p>See source code</p> <p>Decorator for testing components from django-components.</p> <p><code>@djc_test</code> manages the global state of django-components, ensuring that each test is properly isolated and that components registered in one test do not affect other tests.</p> <p>This decorator can be applied to a function, method, or a class. If applied to a class, it will search for all methods that start with <code>test_</code>, and apply the decorator to them. This is applied recursively to nested classes as well.</p> <p>Examples:</p> <p>Applying to a function: <pre><code>from django_components.testing import djc_test\n\n@djc_test\ndef test_my_component():\n    @register(\"my_component\")\n    class MyComponent(Component):\n        template = \"...\"\n    ...\n</code></pre></p> <p>Applying to a class: <pre><code>from django_components.testing import djc_test\n\n@djc_test\nclass TestMyComponent:\n    def test_something(self):\n        ...\n\n    class Nested:\n        def test_something_else(self):\n            ...\n</code></pre></p> <p>Applying to a class is the same as applying the decorator to each <code>test_</code> method individually: <pre><code>from django_components.testing import djc_test\n\nclass TestMyComponent:\n    @djc_test\n    def test_something(self):\n        ...\n\n    class Nested:\n        @djc_test\n        def test_something_else(self):\n            ...\n</code></pre></p> <p>To use <code>@djc_test</code>, Django must be set up first:</p> <pre><code>import django\nfrom django_components.testing import djc_test\n\ndjango.setup()\n\n@djc_test\ndef test_my_component():\n    ...\n</code></pre> <p>Arguments:</p> <ul> <li> <p><code>django_settings</code>: Django settings, a dictionary passed to Django's   <code>@override_settings</code>.   The test runs within the context of these overridden settings.</p> <p>If <code>django_settings</code> contains django-components settings (<code>COMPONENTS</code> field), these are merged. Other Django settings are simply overridden.</p> </li> <li> <p><code>components_settings</code>: Instead of defining django-components settings under <code>django_settings[\"COMPONENTS\"]</code>,     you can simply set the Components settings here.</p> <p>These settings are merged with the django-components settings from <code>django_settings[\"COMPONENTS\"]</code>.</p> <p>Fields in <code>components_settings</code> override fields in <code>django_settings[\"COMPONENTS\"]</code>.</p> </li> <li> <p><code>parametrize</code>: Parametrize the test function with     <code>pytest.mark.parametrize</code>.     This requires pytest to be installed.</p> <p>The input is a tuple of:</p> <ul> <li><code>(param_names, param_values)</code> or</li> <li><code>(param_names, param_values, ids)</code></li> </ul> <p>Example:</p> <pre><code>from django_components.testing import djc_test\n\n@djc_test(\n    parametrize=(\n         [\"input\", \"expected\"],\n         [[1, \"&lt;div&gt;1&lt;/div&gt;\"], [2, \"&lt;div&gt;2&lt;/div&gt;\"]],\n         ids=[\"1\", \"2\"]\n     )\n)\ndef test_component(input, expected):\n    rendered = MyComponent(input=input).render()\n    assert rendered == expected\n</code></pre> <p>You can parametrize the Django or Components settings by setting up parameters called <code>django_settings</code> and <code>components_settings</code>. These will be merged with the respetive settings from the decorator.</p> <p>Example of parametrizing context_behavior: <pre><code>from django_components.testing import djc_test\n\n@djc_test(\n    components_settings={\n        # Settings shared by all tests\n        \"app_dirs\": [\"custom_dir\"],\n    },\n    parametrize=(\n        # Parametrized settings\n        [\"components_settings\"],\n        [\n            [{\"context_behavior\": \"django\"}],\n            [{\"context_behavior\": \"isolated\"}],\n        ],\n        [\"django\", \"isolated\"],\n    )\n)\ndef test_context_behavior(components_settings):\n    rendered = MyComponent().render()\n    ...\n</code></pre></p> </li> <li> <p><code>gc_collect</code>: By default <code>djc_test</code> runs garbage collection after each test to force the state cleanup.   Set this to <code>False</code> to skip this.</p> </li> </ul> <p>Settings resolution:</p> <p><code>@djc_test</code> accepts settings from different sources. The settings are resolved in the following order:</p> <ul> <li> <p>Django settings:</p> <ol> <li>The defaults are the Django settings that Django was set up with.</li> <li>Those are then overriden with fields in the <code>django_settings</code> kwarg.</li> <li>The parametrized <code>django_settings</code> override the fields on the <code>django_settings</code> kwarg.</li> </ol> <p>Priority: <code>django_settings</code> (parametrized) &gt; <code>django_settings</code> &gt; <code>django.conf.settings</code></p> </li> <li> <p>Components settings:</p> <ol> <li>Same as above, except that the <code>django_settings[\"COMPONENTS\"]</code> field is merged instead of overridden.</li> <li>The <code>components_settings</code> kwarg is then merged with the <code>django_settings[\"COMPONENTS\"]</code> field.</li> <li>The parametrized <code>components_settings</code> override the fields on the <code>components_settings</code> kwarg.</li> </ol> <p>Priority: <code>components_settings</code> (parametrized) &gt; <code>components_settings</code> &gt; <code>django_settings[\"COMPONENTS\"]</code> &gt; <code>django.conf.settings.COMPONENTS</code></p> </li> </ul>"},{"location":"reference/urls/","title":"URLs","text":""},{"location":"reference/urls/#urls","title":"URLs","text":"<p>Below are all the URL patterns that will be added by adding <code>django_components.urls</code>.</p> <p>See Installation on how to add these URLs to your Django project.</p> <p>Django components already prefixes all URLs with <code>components/</code>. So when you are adding the URLs to <code>urlpatterns</code>, you can use an empty string as the first argument:</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    ...\n    path(\"\", include(\"django_components.urls\")),\n]\n</code></pre>"},{"location":"reference/urls/#list-of-urls","title":"List of URLs","text":"<ul> <li> <p><code>components/cache/&lt;str:comp_cls_id&gt;.&lt;str:input_hash&gt;.&lt;str:script_type&gt;</code></p> </li> <li> <p><code>components/cache/&lt;str:comp_cls_id&gt;.&lt;str:script_type&gt;</code></p> </li> </ul>"}]}